[{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\ConfigReader.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar config_1 = require(\"stryker-api/config\");\r\nvar log4js = require(\"log4js\");\r\nvar _ = require(\"lodash\");\r\nvar VALID_COVERAGE_ANALYSIS_VALUES = ['perTest', 'all', 'off'];\r\nexports.CONFIG_SYNTAX_HELP = '  module.exports = function(config) {\\n' +\r\n    '    config.set({\\n' +\r\n    '      // your config\\n' +\r\n    '    });\\n' +\r\n    '  };';\r\nvar log = log4js.getLogger('ConfigReader');\r\nvar ConfigReader = (function () {\r\n    function ConfigReader(cliOptions) {\r\n        this.cliOptions = cliOptions;\r\n    }\r\n    ConfigReader.prototype.readConfig = function () {\r\n        var configModule = this.loadConfigModule();\r\n        var config = new config_1.Config();\r\n        try {\r\n            configModule(config);\r\n        }\r\n        catch (e) {\r\n            log.fatal('Error in config file!\\n', e);\r\n            process.exit(1);\r\n        }\r\n        // merge the config from config file and cliOptions (precedence)\r\n        config.set(this.cliOptions);\r\n        this.validate(config);\r\n        return config;\r\n    };\r\n    ConfigReader.prototype.loadConfigModule = function () {\r\n        // we start with a dummy configModule\r\n        var configModule = function () { };\r\n        if (this.cliOptions.configFile) {\r\n            log.debug('Loading config %s', this.cliOptions.configFile);\r\n            try {\r\n                configModule = require(process.cwd() + \"/\" + this.cliOptions.configFile);\r\n            }\r\n            catch (e) {\r\n                if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(this.cliOptions.configFile) !== -1) {\r\n                    log.fatal(\"File \" + process.cwd() + \"/\" + this.cliOptions.configFile + \" does not exist!\");\r\n                    log.fatal(e);\r\n                }\r\n                else {\r\n                    log.fatal('Invalid config file!\\n  ' + e.stack);\r\n                }\r\n                process.exit(1);\r\n            }\r\n            if (!_.isFunction(configModule)) {\r\n                log.fatal('Config file must export a function!\\n' + exports.CONFIG_SYNTAX_HELP);\r\n                process.exit(1);\r\n            }\r\n        }\r\n        else if (Object.keys(this.cliOptions).length === 0) {\r\n            log.info('Using stryker.conf.js in the current working directory.');\r\n            this.cliOptions.configFile = 'stryker.conf.js';\r\n            return this.loadConfigModule();\r\n        }\r\n        else {\r\n            log.info('No config file specified. Running with command line arguments');\r\n            // if no config file path is passed, we create and return a dummy config module.\r\n        }\r\n        return configModule;\r\n    };\r\n    ConfigReader.prototype.validate = function (options) {\r\n        if (VALID_COVERAGE_ANALYSIS_VALUES.indexOf(options.coverageAnalysis) < 0) {\r\n            log.fatal(\"Value \\\"\" + options.coverageAnalysis + \"\\\" is invalid for `coverageAnalysis`. Expected one of the folowing: \" + VALID_COVERAGE_ANALYSIS_VALUES.map(function (v) { return \"\\\"\" + v + \"\\\"\"; }).join(', '));\r\n            process.exit(1);\r\n        }\r\n        if (options.coverageAnalysis === 'perTest' && !options.testFramework) {\r\n            var validCoverageAnalysisSettingsExceptPerTest = VALID_COVERAGE_ANALYSIS_VALUES.filter(function (v) { return v !== 'perTest'; }).map(function (v) { return \"\\\"\" + v + \"\\\"\"; }).join(', ');\r\n            log.fatal(\"Configured coverage analysis 'perTest' requires a test framework to be configured. Either configure your test framework (for example testFramework: 'jasmine') or set coverageAnalysis setting to one of the following: \" + validCoverageAnalysisSettingsExceptPerTest);\r\n            process.exit(1);\r\n        }\r\n    };\r\n    return ConfigReader;\r\n}());\r\nexports.default = ConfigReader;\r\n//# sourceMappingURL=ConfigReader.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\coverage\\CoverageInstrumenter.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar log4js = require(\"log4js\");\r\nvar stream_1 = require(\"stream\");\r\nvar objectUtils_1 = require(\"../utils/objectUtils\");\r\nvar CoverageInstrumenterStream_1 = require(\"./CoverageInstrumenterStream\");\r\nvar log = log4js.getLogger('CoverageInstrumenter');\r\nvar COVERAGE_CURRENT_TEST_VARIABLE_NAME = '__strykerCoverageCurrentTest__';\r\n/**\r\n * Represents the CoverageInstrumenter\r\n * Responsible for managing the instrumentation of all files to be mutated.\r\n * In case of `perTest` coverageAnalysis it will hookin to the test framework to accomplish that.\r\n */\r\nvar CoverageInstrumenter = (function () {\r\n    function CoverageInstrumenter(coverageAnalysis, testFramework) {\r\n        this.coverageAnalysis = coverageAnalysis;\r\n        this.testFramework = testFramework;\r\n        this.coverageInstrumenterStreamPerFile = Object.create(null);\r\n    }\r\n    CoverageInstrumenter.prototype.instrumenterStreamForFile = function (file) {\r\n        if (file.mutated) {\r\n            /*\r\n            Coverage variable *must* have the name '__coverage__'. Only that variable\r\n            is reported back to the TestRunner process when using one of the karma\r\n            test framework adapters (karma-jasmine, karma-mocha, ...).\r\n      \r\n            However, when coverageAnalysis is 'perTest' we don't choose that variable name right away,\r\n            because we need that variable to hold all coverage results per test. Instead, we use __strykerCoverageCurrentTest__\r\n            and after each test copy over the value of that current test to the global coverage object __coverage__\r\n             */\r\n            switch (this.coverageAnalysis) {\r\n                case 'all':\r\n                    return this.createStreamForFile('__coverage__', file.path);\r\n                case 'perTest':\r\n                    return this.createStreamForFile(COVERAGE_CURRENT_TEST_VARIABLE_NAME, file.path);\r\n            }\r\n        }\r\n        // By default, do not instrument for code coverage\r\n        return new stream_1.PassThrough();\r\n    };\r\n    CoverageInstrumenter.prototype.hooksForTestRun = function () {\r\n        if (this.testFramework && this.coverageAnalysis === 'perTest') {\r\n            log.debug(\"Adding test hooks file for coverageAnalysis \\\"perTest\\\"\");\r\n            return objectUtils_1.wrapInClosure(\"\\n          var id = 0;\\n          window.__coverage__ = globalCoverage = { deviations: {} };\\n          \" + this.testFramework.beforeEach(beforeEachFragmentPerTest) + \"\\n          \" + this.testFramework.afterEach(afterEachFragmentPerTest) + \"\\n          \" + cloneFunctionFragment + \";\\n      \");\r\n        }\r\n        else {\r\n            return '';\r\n        }\r\n    };\r\n    CoverageInstrumenter.prototype.retrieveStatementMapsPerFile = function () {\r\n        var _this = this;\r\n        var statementMapsPerFile = Object.create(null);\r\n        Object.keys(this.coverageInstrumenterStreamPerFile)\r\n            .forEach(function (key) { return statementMapsPerFile[key] = _this.coverageInstrumenterStreamPerFile[key].statementMap; });\r\n        return statementMapsPerFile;\r\n    };\r\n    CoverageInstrumenter.prototype.createStreamForFile = function (coverageVariable, fileName) {\r\n        var stream = new CoverageInstrumenterStream_1.default(coverageVariable, fileName);\r\n        this.coverageInstrumenterStreamPerFile[fileName] = stream;\r\n        return stream;\r\n    };\r\n    return CoverageInstrumenter;\r\n}());\r\nexports.default = CoverageInstrumenter;\r\nvar cloneFunctionFragment = \"    \\n    function clone(source) {\\n        var result = source;\\n        if (Array.isArray(source)) {\\n            result = [];\\n            source.forEach(function (child, index) {\\n                result[index] = clone(child);\\n            });\\n        } else if (typeof source == \\\"object\\\") {\\n            result = {};\\n            for (var i in source) {\\n                result[i] = clone(source[i]);\\n            }\\n        }\\n        return result;\\n    }\";\r\nvar beforeEachFragmentPerTest = \"\\nif (!globalCoverage.baseline && window.\" + COVERAGE_CURRENT_TEST_VARIABLE_NAME + \") {\\n  globalCoverage.baseline = clone(window.\" + COVERAGE_CURRENT_TEST_VARIABLE_NAME + \");\\n}\";\r\nvar afterEachFragmentPerTest = \"\\n  globalCoverage.deviations[id] = coverageResult = {};\\n  id++;\\n  var coveragePerFile = window.\" + COVERAGE_CURRENT_TEST_VARIABLE_NAME + \";\\n  if(coveragePerFile) {\\n    Object.keys(coveragePerFile).forEach(function (file) {\\n        var coverage = coveragePerFile[file];\\n        var baseline = globalCoverage.baseline[file];\\n        var fileResult = { s: {} };\\n        var touchedFile = false;\\n        for(var i in coverage.s){\\n          if(coverage.s[i] !== baseline.s[i]){\\n            fileResult.s[i] = coverage.s[i];\\n            touchedFile = true;\\n          }\\n        }\\n        if(touchedFile){\\n          coverageResult[file] = fileResult;\\n        }\\n    });\\n  }\";\r\n//# sourceMappingURL=CoverageInstrumenter.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\coverage\\CoverageInstrumenterStream.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar stream_1 = require(\"stream\");\r\nvar istanbul_1 = require(\"istanbul\");\r\nvar log4js = require(\"log4js\");\r\nvar coverageObjRegex = /\\{.*\"path\".*\"fnMap\".*\"statementMap\".*\"branchMap\".*\\}/g;\r\nvar log = log4js.getLogger('CoverageInstrumenterStream');\r\n/**\r\n * Represents a stream responsible to add code coverage instrumentation and reporting back on the statement map\r\n */\r\nvar CoverageInstrumenterStream = (function (_super) {\r\n    tslib_1.__extends(CoverageInstrumenterStream, _super);\r\n    function CoverageInstrumenterStream(coverageVariable, filename, opts) {\r\n        var _this = _super.call(this, opts) || this;\r\n        _this.coverageVariable = coverageVariable;\r\n        _this.filename = filename;\r\n        _this.source = '';\r\n        return _this;\r\n    }\r\n    CoverageInstrumenterStream.prototype._transform = function (chunk, encoding, callback) {\r\n        if (typeof chunk === 'string') {\r\n            this.source += chunk;\r\n        }\r\n        else {\r\n            this.source += chunk.toString();\r\n        }\r\n        callback();\r\n    };\r\n    CoverageInstrumenterStream.prototype._flush = function (callback) {\r\n        try {\r\n            var instrumenter = new istanbul_1.Instrumenter({ coverageVariable: this.coverageVariable });\r\n            var instrumentedCode = instrumenter.instrumentSync(this.source, this.filename);\r\n            coverageObjRegex.lastIndex = 0;\r\n            var coverageObjectMatch = coverageObjRegex.exec(instrumentedCode) + '';\r\n            var coverageObj = JSON.parse(coverageObjectMatch);\r\n            this.statementMap = coverageObj.statementMap;\r\n            this.push(instrumentedCode);\r\n        }\r\n        catch (err) {\r\n            var error = \"Error while instrumenting file \\\"\" + this.filename + \"\\\", error was: \" + err.toString();\r\n            log.error(error);\r\n            this.push(this.source);\r\n        }\r\n        callback();\r\n    };\r\n    return CoverageInstrumenterStream;\r\n}(stream_1.Transform));\r\nexports.default = CoverageInstrumenterStream;\r\n//# sourceMappingURL=CoverageInstrumenterStream.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\FileStatements.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n//# sourceMappingURL=FileStatements.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\initializer\\NpmClient.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar RestClient_1 = require(\"typed-rest-client/RestClient\");\r\nvar log4js = require(\"log4js\");\r\nvar objectUtils_1 = require(\"../utils/objectUtils\");\r\nvar log = log4js.getLogger('NpmClient');\r\nvar BASE_NPM_SEARCH = 'https://api.npms.io';\r\nvar BASE_NPM_PACKAGE = 'https://registry.npmjs.org';\r\nvar getName = function (packageName) {\r\n    return packageName.split('-')[1];\r\n};\r\nvar mapSearchResultToPromptOption = function (searchResults) { return searchResults.results.map(function (result) { return ({\r\n    name: getName(result.package.name),\r\n    npm: result.package.name\r\n}); }); };\r\nvar handleResult = function (from) { return function (response) {\r\n    if (response.statusCode === 200) {\r\n        return response.result;\r\n    }\r\n    else {\r\n        throw new Error(\"Query \" + from + \" resulted in http status code: \" + response.statusCode + \".\");\r\n    }\r\n}; };\r\nvar NpmClient = (function () {\r\n    function NpmClient(searchClient, packageClient) {\r\n        if (searchClient === void 0) { searchClient = new RestClient_1.RestClient('npmSearch', BASE_NPM_SEARCH); }\r\n        if (packageClient === void 0) { packageClient = new RestClient_1.RestClient('npm', BASE_NPM_PACKAGE); }\r\n        this.searchClient = searchClient;\r\n        this.packageClient = packageClient;\r\n    }\r\n    NpmClient.prototype.getTestRunnerOptions = function () {\r\n        return this.search('/v2/search?q=keywords:stryker-test-runner')\r\n            .then(mapSearchResultToPromptOption);\r\n    };\r\n    NpmClient.prototype.getTestFrameworkOptions = function (testRunnerFilter) {\r\n        return this.search('/v2/search?q=keywords:stryker-test-framework')\r\n            .then(function (searchResult) {\r\n            if (testRunnerFilter) {\r\n                searchResult.results = searchResult.results.filter(function (framework) { return framework.package.keywords.indexOf(testRunnerFilter) >= 0; });\r\n            }\r\n            return searchResult;\r\n        })\r\n            .then(mapSearchResultToPromptOption);\r\n    };\r\n    NpmClient.prototype.getTestReporterOptions = function () {\r\n        return this.search(\"/v2/search?q=keywords:stryker-reporter\")\r\n            .then(mapSearchResultToPromptOption);\r\n    };\r\n    NpmClient.prototype.getAdditionalConfig = function (packageName) {\r\n        return this.packageClient.get(\"/\" + packageName + \"/latest\")\r\n            .then(handleResult(BASE_NPM_PACKAGE + \"/\" + packageName))\r\n            .then(function (pkg) { return pkg.initStrykerConfig || {}; })\r\n            .catch(function (err) {\r\n            log.warn(\"Could not fetch additional initialization config for dependency \" + packageName + \". You might need to configure it manually\", err);\r\n            return {};\r\n        });\r\n    };\r\n    NpmClient.prototype.search = function (query) {\r\n        var call = BASE_NPM_SEARCH + query;\r\n        log.debug(\"Searching: \" + call);\r\n        return this.searchClient.get(query)\r\n            .then(handleResult(call))\r\n            .catch(function (err) {\r\n            log.error(\"Unable to reach \" + BASE_NPM_SEARCH + \" (for query \" + query + \"). Please check your internet connection.\", objectUtils_1.errorToString(err));\r\n            var result = {\r\n                total: 0,\r\n                results: []\r\n            };\r\n            return result;\r\n        });\r\n    };\r\n    return NpmClient;\r\n}());\r\nexports.default = NpmClient;\r\n//# sourceMappingURL=NpmClient.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\initializer\\PromptOption.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n//# sourceMappingURL=PromptOption.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\initializer\\StrykerConfigWriter.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar fs = require(\"mz/fs\");\r\nvar _ = require(\"lodash\");\r\nvar log4js_1 = require(\"log4js\");\r\nvar STRYKER_CONFIG_FILE = 'stryker.conf.js';\r\nvar log = log4js_1.getLogger('StrykerConfigWriter');\r\nvar StrykerConfigWriter = (function () {\r\n    function StrykerConfigWriter(out, selectedTestRunner, selectedTestFramework, selectedReporters, additionalPiecesOfConfig) {\r\n        this.out = out;\r\n        this.selectedTestFramework = selectedTestFramework;\r\n        this.additionalPiecesOfConfig = additionalPiecesOfConfig;\r\n        this.configObject = {\r\n            files: [\r\n                { pattern: 'src/**/*.js', mutated: true, included: false },\r\n                'test/**/*.js'\r\n            ],\r\n            testRunner: (selectedTestRunner ? selectedTestRunner.name : ''),\r\n            reporter: selectedReporters.map(function (rep) { return rep.name; })\r\n        };\r\n    }\r\n    StrykerConfigWriter.guardForExistingConfig = function () {\r\n        if (fs.existsSync(STRYKER_CONFIG_FILE)) {\r\n            var msg = 'Stryker config file \"stryker.conf.js\" already exists in the current directory. Please remove it and try again.';\r\n            log.error(msg);\r\n            throw new Error(msg);\r\n        }\r\n    };\r\n    /**\r\n    * Create stryker.conf.js based on the chosen framework and test runner\r\n    * @function\r\n    */\r\n    StrykerConfigWriter.prototype.write = function () {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            return tslib_1.__generator(this, function (_a) {\r\n                this.configureTestFramework();\r\n                _.assign.apply(_, [this.configObject].concat(this.additionalPiecesOfConfig));\r\n                return [2 /*return*/, this.writeStrykerConfig(this.configObject)];\r\n            });\r\n        });\r\n    };\r\n    StrykerConfigWriter.prototype.configureTestFramework = function () {\r\n        if (this.selectedTestFramework) {\r\n            this.configObject.testFramework = this.selectedTestFramework.name;\r\n            this.configObject.coverageAnalysis = 'perTest';\r\n        }\r\n        else {\r\n            this.configObject.coverageAnalysis = 'all';\r\n        }\r\n    };\r\n    StrykerConfigWriter.prototype.writeStrykerConfig = function (configObject) {\r\n        this.out('Writing stryker.conf.js...');\r\n        return fs.writeFile(STRYKER_CONFIG_FILE, this.wrapInModule());\r\n    };\r\n    StrykerConfigWriter.prototype.wrapInModule = function () {\r\n        return \"\\n  module.exports = function(config){\\n    config.set(\\n      \" + JSON.stringify(this.configObject, null, 2) + \"\\n    );\\n  }\";\r\n    };\r\n    return StrykerConfigWriter;\r\n}());\r\nexports.default = StrykerConfigWriter;\r\n//# sourceMappingURL=StrykerConfigWriter.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\initializer\\StrykerInitializer.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar child = require(\"child_process\");\r\nvar StrykerInquirer_1 = require(\"./StrykerInquirer\");\r\nvar NpmClient_1 = require(\"./NpmClient\");\r\nvar log4js = require(\"log4js\");\r\nvar objectUtils_1 = require(\"../utils/objectUtils\");\r\nvar StrykerConfigWriter_1 = require(\"./StrykerConfigWriter\");\r\nvar log = log4js.getLogger('StrykerInitializer');\r\nvar StrykerInitializer = (function () {\r\n    function StrykerInitializer(out, client) {\r\n        if (out === void 0) { out = console.log; }\r\n        if (client === void 0) { client = new NpmClient_1.default(); }\r\n        this.out = out;\r\n        this.client = client;\r\n        this.inquirer = new StrykerInquirer_1.StrykerInquirer();\r\n    }\r\n    /**\r\n     * Runs the initializer will prompt the user for questions about his setup. After that, install plugins and configure Stryker.\r\n     * @function\r\n     */\r\n    StrykerInitializer.prototype.initialize = function () {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var selectedTestRunner, selectedTestFramework, _a, selectedReporters, npmDependencies, _b, _c;\r\n            return tslib_1.__generator(this, function (_d) {\r\n                switch (_d.label) {\r\n                    case 0:\r\n                        StrykerConfigWriter_1.default.guardForExistingConfig();\r\n                        this.patchProxies();\r\n                        return [4 /*yield*/, this.selectTestRunner()];\r\n                    case 1:\r\n                        selectedTestRunner = _d.sent();\r\n                        if (!selectedTestRunner) return [3 /*break*/, 3];\r\n                        return [4 /*yield*/, this.selectTestFramework(selectedTestRunner)];\r\n                    case 2:\r\n                        _a = _d.sent();\r\n                        return [3 /*break*/, 4];\r\n                    case 3:\r\n                        _a = null;\r\n                        _d.label = 4;\r\n                    case 4:\r\n                        selectedTestFramework = _a;\r\n                        return [4 /*yield*/, this.selectReporters()];\r\n                    case 5:\r\n                        selectedReporters = _d.sent();\r\n                        npmDependencies = this.getSelectedNpmDependencies([selectedTestRunner, selectedTestFramework].concat(selectedReporters));\r\n                        this.installNpmDependencies(npmDependencies);\r\n                        _b = StrykerConfigWriter_1.default.bind;\r\n                        _c = [void 0, this.out,\r\n                            selectedTestRunner,\r\n                            selectedTestFramework,\r\n                            selectedReporters];\r\n                        return [4 /*yield*/, this.fetchAdditionalConfig(npmDependencies)];\r\n                    case 6: return [4 /*yield*/, new (_b.apply(StrykerConfigWriter_1.default, _c.concat([_d.sent()])))().write()];\r\n                    case 7:\r\n                        _d.sent();\r\n                        this.out('Done configuring stryker. Please review `stryker.conf.js`, you might need to configure your files and test runner correctly.');\r\n                        this.out('Let\\'s kill some mutants with this command: `stryker run`');\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n    * The typed rest client works only with the specific HTTP_PROXY and HTTPS_PROXY env settings.\r\n    * Let's make sure they are available.\r\n    */\r\n    StrykerInitializer.prototype.patchProxies = function () {\r\n        var copyEnvVariable = function (from, to) {\r\n            if (process.env[from] && !process.env[to]) {\r\n                process.env[to] = process.env[from];\r\n            }\r\n        };\r\n        copyEnvVariable('http_proxy', 'HTTP_PROXY');\r\n        copyEnvVariable('https_proxy', 'HTTPS_PROXY');\r\n    };\r\n    StrykerInitializer.prototype.selectTestRunner = function () {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var testRunnerOptions;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.client.getTestRunnerOptions()];\r\n                    case 1:\r\n                        testRunnerOptions = _a.sent();\r\n                        if (!testRunnerOptions.length) return [3 /*break*/, 3];\r\n                        log.debug(\"Found test runners: \" + JSON.stringify(testRunnerOptions));\r\n                        return [4 /*yield*/, this.inquirer.promptTestRunners(testRunnerOptions)];\r\n                    case 2: return [2 /*return*/, _a.sent()];\r\n                    case 3:\r\n                        this.out('Unable to select a test runner. You will need to configure it manually.');\r\n                        return [2 /*return*/, null];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    StrykerInitializer.prototype.selectReporters = function () {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var reporterOptions;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.client.getTestReporterOptions()];\r\n                    case 1:\r\n                        reporterOptions = _a.sent();\r\n                        reporterOptions.push({\r\n                            name: 'clear-text',\r\n                            npm: null\r\n                        }, {\r\n                            name: 'progress',\r\n                            npm: null\r\n                        });\r\n                        return [2 /*return*/, this.inquirer.promptReporters(reporterOptions)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    StrykerInitializer.prototype.selectTestFramework = function (testRunnerOption) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var selectedTestFramework, testFrameworkOptions, none;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        selectedTestFramework = null;\r\n                        return [4 /*yield*/, this.client.getTestFrameworkOptions(testRunnerOption.npm)];\r\n                    case 1:\r\n                        testFrameworkOptions = _a.sent();\r\n                        if (!testFrameworkOptions.length) return [3 /*break*/, 3];\r\n                        log.debug(\"Found test frameworks for \" + testRunnerOption.name + \": \" + JSON.stringify(testFrameworkOptions));\r\n                        none = {\r\n                            name: 'None/other',\r\n                            npm: null\r\n                        };\r\n                        testFrameworkOptions.push(none);\r\n                        return [4 /*yield*/, this.inquirer.promptTestFrameworks(testFrameworkOptions)];\r\n                    case 2:\r\n                        selectedTestFramework = _a.sent();\r\n                        if (selectedTestFramework === none) {\r\n                            selectedTestFramework = null;\r\n                            this.out('OK, downgrading coverageAnalysis to \"all\"');\r\n                        }\r\n                        return [3 /*break*/, 4];\r\n                    case 3:\r\n                        this.out(\"No stryker test framework plugin found that is compatible with \" + testRunnerOption.name + \", downgrading coverageAnalysis to \\\"all\\\"\");\r\n                        _a.label = 4;\r\n                    case 4: return [2 /*return*/, selectedTestFramework];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    StrykerInitializer.prototype.getSelectedNpmDependencies = function (selectedOptions) {\r\n        return objectUtils_1.filterEmpty(objectUtils_1.filterEmpty(selectedOptions)\r\n            .map(function (option) { return option.npm; }));\r\n    };\r\n    /**\r\n    * Install the npm packages\r\n    * @function\r\n    */\r\n    StrykerInitializer.prototype.installNpmDependencies = function (dependencies) {\r\n        if (dependencies.length > 0) {\r\n            this.out('Installing NPM dependencies...');\r\n            var cmd = \"npm i --save-dev stryker-api \" + dependencies.join(' ');\r\n            this.out(cmd);\r\n            try {\r\n                child.execSync(cmd, { stdio: [0, 1, 2] });\r\n            }\r\n            catch (_) {\r\n                this.out(\"An error occurred during installation, please try it yourself: \\\"\" + cmd + \"\\\"\");\r\n            }\r\n        }\r\n    };\r\n    StrykerInitializer.prototype.fetchAdditionalConfig = function (dependencies) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var _this = this;\r\n            var _a;\r\n            return tslib_1.__generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        _a = objectUtils_1.filterEmpty;\r\n                        return [4 /*yield*/, Promise.all(dependencies.map(function (dep) {\r\n                                return _this.client.getAdditionalConfig(dep);\r\n                            }))];\r\n                    case 1: return [2 /*return*/, _a.apply(void 0, [_b.sent()])];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    return StrykerInitializer;\r\n}());\r\nexports.default = StrykerInitializer;\r\n//# sourceMappingURL=StrykerInitializer.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\initializer\\StrykerInquirer.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar inquirer = require(\"inquirer\");\r\nvar StrykerInquirer = (function () {\r\n    function StrykerInquirer() {\r\n    }\r\n    StrykerInquirer.prototype.promptTestRunners = function (options) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var answers;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, inquirer.prompt({\r\n                            type: 'list',\r\n                            name: 'testRunner',\r\n                            message: 'Which test runner do you want to use?',\r\n                            choices: options.map(function (_) { return _.name; }),\r\n                            default: 'Mocha'\r\n                        })];\r\n                    case 1:\r\n                        answers = _a.sent();\r\n                        return [2 /*return*/, options.filter(function (_) { return _.name === answers['testRunner']; })[0] || { name: 'mocha', npm: 'stryker-mocha-runner' }];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    StrykerInquirer.prototype.promptTestFrameworks = function (options) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var answers;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, inquirer.prompt({\r\n                            type: 'list',\r\n                            name: 'testFramework',\r\n                            message: 'Which test framework do you want to use?',\r\n                            choices: options.map(function (_) { return _.name; }),\r\n                        })];\r\n                    case 1:\r\n                        answers = _a.sent();\r\n                        return [2 /*return*/, options.filter(function (_) { return _.name === answers['testFramework']; })[0]];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    StrykerInquirer.prototype.promptReporters = function (options) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var answers;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, inquirer.prompt({\r\n                            type: 'checkbox',\r\n                            name: 'reporters',\r\n                            message: 'Which reporter(s) do you want to use?',\r\n                            choices: options.map(function (_) { return _.name; }),\r\n                            default: ['clear-text', 'progress']\r\n                        })];\r\n                    case 1:\r\n                        answers = _a.sent();\r\n                        return [2 /*return*/, options.filter(function (option) { return answers['reporters'].some(function (reporterName) { return option.name === reporterName; }); })];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    return StrykerInquirer;\r\n}());\r\nexports.StrykerInquirer = StrykerInquirer;\r\n//# sourceMappingURL=StrykerInquirer.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\InputFileResolver.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar fileUtils_1 = require(\"./utils/fileUtils\");\r\nvar _ = require(\"lodash\");\r\nvar log4js = require(\"log4js\");\r\nvar path = require(\"path\");\r\nvar log = log4js.getLogger('InputFileResolver');\r\nvar DEFAULT_INPUT_FILE_PROPERTIES = { mutated: false, included: true };\r\nvar InputFileResolver = (function () {\r\n    function InputFileResolver(mutate, allFileExpressions) {\r\n        this.validateFileDescriptor(allFileExpressions);\r\n        this.validateMutationArray(mutate);\r\n        this.mutateResolver = PatternResolver.parse(mutate || []);\r\n        this.inputFileResolver = PatternResolver.parse(allFileExpressions);\r\n    }\r\n    InputFileResolver.prototype.resolve = function () {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var results, inputFiles, mutateFiles;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, Promise.all([this.inputFileResolver.resolve(), this.mutateResolver.resolve()])];\r\n                    case 1:\r\n                        results = _a.sent();\r\n                        inputFiles = results[0];\r\n                        mutateFiles = results[1];\r\n                        this.markAdditionalFilesToMutate(inputFiles, mutateFiles.map(function (m) { return m.path; }));\r\n                        this.logFilesToMutate(inputFiles);\r\n                        return [2 /*return*/, inputFiles];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    InputFileResolver.prototype.validateFileDescriptor = function (maybeInputFileDescriptors) {\r\n        maybeInputFileDescriptors.forEach(function (maybeInputFileDescriptor) {\r\n            if (_.isObject(maybeInputFileDescriptor)) {\r\n                if (Object.keys(maybeInputFileDescriptor).indexOf('pattern') === -1) {\r\n                    throw Error(\"File descriptor \" + JSON.stringify(maybeInputFileDescriptor) + \" is missing mandatory property 'pattern'.\");\r\n                }\r\n                else {\r\n                    maybeInputFileDescriptor = maybeInputFileDescriptor;\r\n                    if (fileUtils_1.isOnlineFile(maybeInputFileDescriptor.pattern) && maybeInputFileDescriptor.mutated) {\r\n                        throw new Error(\"Cannot mutate web url \\\"\" + maybeInputFileDescriptor.pattern + \"\\\".\");\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    };\r\n    InputFileResolver.prototype.validateMutationArray = function (mutationArray) {\r\n        if (mutationArray) {\r\n            mutationArray.forEach(function (mutation) {\r\n                if (fileUtils_1.isOnlineFile(mutation)) {\r\n                    throw new Error(\"Cannot mutate web url \\\"\" + mutation + \"\\\".\");\r\n                }\r\n            });\r\n        }\r\n    };\r\n    InputFileResolver.prototype.markAdditionalFilesToMutate = function (allInputFiles, additionalMutateFiles) {\r\n        var errors = [];\r\n        additionalMutateFiles.forEach(function (mutateFile) {\r\n            if (!allInputFiles.filter(function (inputFile) { return inputFile.path === mutateFile; }).length) {\r\n                errors.push(\"Could not find mutate file \\\"\" + mutateFile + \"\\\" in list of files.\");\r\n            }\r\n        });\r\n        if (errors.length > 0) {\r\n            throw new Error(errors.join(' '));\r\n        }\r\n        allInputFiles.forEach(function (file) { return file.mutated = additionalMutateFiles.some(function (mutateFile) { return mutateFile === file.path; }) || file.mutated; });\r\n    };\r\n    InputFileResolver.prototype.logFilesToMutate = function (allInputFiles) {\r\n        var mutateFiles = allInputFiles.filter(function (file) { return file.mutated; });\r\n        if (mutateFiles.length) {\r\n            log.info(\"Found \" + mutateFiles.length + \" of \" + allInputFiles.length + \" file(s) to be mutated.\");\r\n        }\r\n        else {\r\n            log.warn(\"No files marked to be mutated, stryker will perform a dry-run without actually mutating anything.\");\r\n        }\r\n        if (log.isDebugEnabled) {\r\n            log.debug('All input files in order:%s', allInputFiles.map(function (file) { return '\\n\\t' + JSON.stringify(file); }));\r\n        }\r\n    };\r\n    return InputFileResolver;\r\n}());\r\nexports.default = InputFileResolver;\r\nvar PatternResolver = (function () {\r\n    function PatternResolver(descriptor, previous) {\r\n        this.previous = previous;\r\n        this.ignore = false;\r\n        if (typeof descriptor === 'string') {\r\n            this.descriptor = _.assign({ pattern: descriptor }, DEFAULT_INPUT_FILE_PROPERTIES);\r\n            this.ignore = descriptor.indexOf('!') === 0;\r\n            if (this.ignore) {\r\n                this.descriptor.pattern = descriptor.substring(1);\r\n            }\r\n        }\r\n        else {\r\n            this.descriptor = descriptor;\r\n        }\r\n    }\r\n    PatternResolver.prototype.resolve = function () {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var _this = this;\r\n            var globbingTask, results, previousFiles_1, currentFiles_1;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        if (!(this.ignore && !this.previous)) return [3 /*break*/, 1];\r\n                        return [2 /*return*/, Promise.resolve([])];\r\n                    case 1:\r\n                        globbingTask = this.resolveGlobbingExpression(this.descriptor.pattern)\r\n                            .then(function (filePaths) { return filePaths.map(function (filePath) { return _this.createInputFile(filePath); }); });\r\n                        if (!this.previous) return [3 /*break*/, 3];\r\n                        return [4 /*yield*/, Promise.all([this.previous.resolve(), globbingTask])];\r\n                    case 2:\r\n                        results = _a.sent();\r\n                        previousFiles_1 = results[0];\r\n                        currentFiles_1 = results[1];\r\n                        // If this expression started with a '!', exclude current files\r\n                        if (this.ignore) {\r\n                            return [2 /*return*/, previousFiles_1.filter(function (previousFile) { return currentFiles_1.every(function (currentFile) { return previousFile.path !== currentFile.path; }); })];\r\n                        }\r\n                        else {\r\n                            // Only add files which were not already added\r\n                            return [2 /*return*/, previousFiles_1.concat(currentFiles_1.filter(function (currentFile) { return !previousFiles_1.some(function (file) { return file.path === currentFile.path; }); }))];\r\n                        }\r\n                        return [3 /*break*/, 4];\r\n                    case 3: return [2 /*return*/, globbingTask];\r\n                    case 4: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    PatternResolver.empty = function () {\r\n        var emptyResolver = new PatternResolver('');\r\n        emptyResolver.ignore = true;\r\n        return emptyResolver;\r\n    };\r\n    PatternResolver.parse = function (inputFileExpressions) {\r\n        var expressions = inputFileExpressions.map(function (i) { return i; }); // work on a copy as we're changing the array state\r\n        var current = PatternResolver.empty();\r\n        var expression = expressions.shift();\r\n        while (expression) {\r\n            current = new PatternResolver(expression, current);\r\n            expression = expressions.shift();\r\n        }\r\n        return current;\r\n    };\r\n    PatternResolver.prototype.resolveGlobbingExpression = function (pattern) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var files;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        if (!fileUtils_1.isOnlineFile(pattern)) return [3 /*break*/, 1];\r\n                        return [2 /*return*/, Promise.resolve([pattern])];\r\n                    case 1: return [4 /*yield*/, fileUtils_1.glob(pattern)];\r\n                    case 2:\r\n                        files = _a.sent();\r\n                        if (files.length === 0) {\r\n                            this.reportEmptyGlobbingExpression(pattern);\r\n                        }\r\n                        return [2 /*return*/, files.map(function (f) { return path.resolve(path.normalize(f)); })];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    PatternResolver.prototype.reportEmptyGlobbingExpression = function (expression) {\r\n        log.warn(\"Globbing expression \\\"\" + expression + \"\\\" did not result in any files.\");\r\n    };\r\n    PatternResolver.prototype.createInputFile = function (path) {\r\n        var inputFile = _.assign({ path: path }, DEFAULT_INPUT_FILE_PROPERTIES, this.descriptor);\r\n        delete inputFile['pattern'];\r\n        return inputFile;\r\n    };\r\n    return PatternResolver;\r\n}());\r\n//# sourceMappingURL=InputFileResolver.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\isolated-runner\\IsolatedRunnerOptions.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n//# sourceMappingURL=IsolatedRunnerOptions.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\isolated-runner\\IsolatedTestRunnerAdapter.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar events_1 = require(\"events\");\r\nvar log4js = require(\"log4js\");\r\nvar _ = require(\"lodash\");\r\nvar child_process_1 = require(\"child_process\");\r\nvar objectUtils_1 = require(\"../utils/objectUtils\");\r\nvar Task_1 = require(\"../utils/Task\");\r\nvar MAX_WAIT_FOR_DISPOSE = 2000;\r\nvar log = log4js.getLogger('IsolatedTestRunnerAdapter');\r\nvar InitTask = (function (_super) {\r\n    tslib_1.__extends(InitTask, _super);\r\n    function InitTask() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = 'init';\r\n        return _this;\r\n    }\r\n    return InitTask;\r\n}(Task_1.default));\r\nvar DisposeTask = (function (_super) {\r\n    tslib_1.__extends(DisposeTask, _super);\r\n    function DisposeTask() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = 'dispose';\r\n        return _this;\r\n    }\r\n    return DisposeTask;\r\n}(Task_1.default));\r\nvar RunTask = (function (_super) {\r\n    tslib_1.__extends(RunTask, _super);\r\n    function RunTask() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = 'run';\r\n        return _this;\r\n    }\r\n    return RunTask;\r\n}(Task_1.default));\r\n/**\r\n * Runs the given test runner in a child process and forwards reports about test results\r\n * Also implements timeout-mechanism (on timeout, restart the child runner and report timeout)\r\n */\r\nvar TestRunnerChildProcessAdapter = (function (_super) {\r\n    tslib_1.__extends(TestRunnerChildProcessAdapter, _super);\r\n    function TestRunnerChildProcessAdapter(realTestRunnerName, options) {\r\n        var _this = _super.call(this) || this;\r\n        _this.realTestRunnerName = realTestRunnerName;\r\n        _this.options = options;\r\n        _this.lastMessagesQueue = [];\r\n        _this.startWorker();\r\n        return _this;\r\n    }\r\n    TestRunnerChildProcessAdapter.prototype.startWorker = function () {\r\n        // Remove --debug-brk from process arguments. \r\n        // When debugging, it will try to reuse the same debug port, which will be taken by the main process.\r\n        var execArgv = _.clone(process.execArgv);\r\n        _.remove(execArgv, function (arg) { return arg.substr(0, 11) === '--debug-brk'; });\r\n        this.workerProcess = child_process_1.fork(__dirname + \"/IsolatedTestRunnerAdapterWorker\", [], { silent: true, execArgv: execArgv });\r\n        this.sendStartCommand();\r\n        this.listenToWorkerProcess();\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.listenToWorkerProcess = function () {\r\n        var _this = this;\r\n        if (this.workerProcess.stdout) {\r\n            var traceEnabled_1 = log.isTraceEnabled();\r\n            this.workerProcess.stdout.on('data', function (data) {\r\n                var msg = data.toString();\r\n                _this.lastMessagesQueue.push(msg);\r\n                if (_this.lastMessagesQueue.length > 10) {\r\n                    _this.lastMessagesQueue.shift();\r\n                }\r\n                if (traceEnabled_1) {\r\n                    log.trace(msg);\r\n                }\r\n            });\r\n        }\r\n        if (this.workerProcess.stderr) {\r\n            this.workerProcess.stderr.on('data', function (data) {\r\n                log.error(data.toString());\r\n            });\r\n        }\r\n        this.workerProcess.on('message', function (message) {\r\n            switch (message.kind) {\r\n                case 'result':\r\n                    if (_this.currentTask.kind === 'run') {\r\n                        _this.currentTask.resolve(message.result);\r\n                    }\r\n                    else {\r\n                        _this.logReceivedUnexpectedMessageWarning(message);\r\n                    }\r\n                    break;\r\n                case 'initDone':\r\n                    if (_this.currentTask.kind === 'init') {\r\n                        _this.currentTask.resolve(undefined);\r\n                    }\r\n                    else {\r\n                        _this.logReceivedUnexpectedMessageWarning(message);\r\n                    }\r\n                    break;\r\n                case 'disposeDone':\r\n                    if (_this.currentTask.kind === 'dispose') {\r\n                        _this.currentTask.resolve(undefined);\r\n                    }\r\n                    else {\r\n                        _this.logReceivedUnexpectedMessageWarning(message);\r\n                    }\r\n                    break;\r\n                default:\r\n                    _this.logReceivedMessageWarning(message);\r\n                    break;\r\n            }\r\n        });\r\n        this.workerProcess.on('exit', function (code, signal) {\r\n            if (code !== 0 && code !== null) {\r\n                log.error(\"Child process exited with non-zero exit code \" + code + \". Last 10 message from the child process were: \\r\\n\" + _this.lastMessagesQueue.map(function (msg) { return \"\\t\" + msg; }).join('\\r\\n'));\r\n                if (_this.currentTask) {\r\n                    _this.currentTask.reject(\"Test runner child process exited with non-zero exit code \" + code);\r\n                }\r\n            }\r\n        });\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.logReceivedUnexpectedMessageWarning = function (message) {\r\n        log.warn(\"Received unexpected message from test runner worker process: \\\"\" + message.kind + \"\\\" while current task is \" + this.currentTask.kind + \". Ignoring this message.\");\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.logReceivedMessageWarning = function (message) {\r\n        log.error(\"Retrieved unrecognized message from child process: \" + JSON.stringify(message));\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.init = function () {\r\n        this.currentTask = new InitTask();\r\n        this.sendInitCommand();\r\n        return this.currentTask.promise;\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.run = function (options) {\r\n        this.currentTask = new RunTask();\r\n        this.sendRunCommand(options);\r\n        return this.currentTask.promise;\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.dispose = function () {\r\n        var _this = this;\r\n        this.currentTask = new DisposeTask(MAX_WAIT_FOR_DISPOSE);\r\n        this.sendDisposeCommand();\r\n        return this.currentTask.promise\r\n            .then(function () { return _this.workerProcess.kill(); });\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.sendRunCommand = function (options) {\r\n        this.send({\r\n            kind: 'run',\r\n            runOptions: options\r\n        });\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.send = function (message) {\r\n        try {\r\n            // Serialize message before sending to preserve all javascript, including regex's and functions\r\n            // See https://github.com/stryker-mutator/stryker/issues/143\r\n            this.workerProcess.send(objectUtils_1.serialize(message));\r\n        }\r\n        catch (error) {\r\n            this.currentTask.reject(error);\r\n        }\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.sendStartCommand = function () {\r\n        this.send({\r\n            kind: 'start',\r\n            runnerName: this.realTestRunnerName,\r\n            runnerOptions: this.options\r\n        });\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.sendInitCommand = function () {\r\n        this.send({ kind: 'init' });\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.sendDisposeCommand = function () {\r\n        this.send({ kind: 'dispose' });\r\n    };\r\n    return TestRunnerChildProcessAdapter;\r\n}(events_1.EventEmitter));\r\nexports.default = TestRunnerChildProcessAdapter;\r\n//# sourceMappingURL=IsolatedTestRunnerAdapter.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\isolated-runner\\IsolatedTestRunnerAdapterFactory.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar IsolatedTestRunnerAdapter_1 = require(\"./IsolatedTestRunnerAdapter\");\r\nexports.default = {\r\n    create: function (settings) {\r\n        return new IsolatedTestRunnerAdapter_1.default(settings.strykerOptions.testRunner || '', settings);\r\n    }\r\n};\r\n//# sourceMappingURL=IsolatedTestRunnerAdapterFactory.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\isolated-runner\\IsolatedTestRunnerAdapterWorker.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar test_runner_1 = require(\"stryker-api/test_runner\");\r\nvar PluginLoader_1 = require(\"../PluginLoader\");\r\nvar log4js = require(\"log4js\");\r\nvar objectUtils_1 = require(\"../utils/objectUtils\");\r\nvar log = log4js.getLogger('IsolatedTestRunnerAdapterWorker');\r\nvar IsolatedTestRunnerAdapterWorker = (function () {\r\n    function IsolatedTestRunnerAdapterWorker() {\r\n        this.listenToMessages();\r\n    }\r\n    IsolatedTestRunnerAdapterWorker.prototype.listenToMessages = function () {\r\n        var _this = this;\r\n        process.on('message', function (serializedMessage) {\r\n            var message = objectUtils_1.deserialize(serializedMessage);\r\n            switch (message.kind) {\r\n                case 'start':\r\n                    _this.start(message);\r\n                    break;\r\n                case 'run':\r\n                    _this.run(message);\r\n                    break;\r\n                case 'init':\r\n                    _this.init();\r\n                    break;\r\n                case 'dispose':\r\n                    _this.dispose();\r\n                    break;\r\n                default:\r\n                    _this.logReceivedMessageWarning(message);\r\n            }\r\n        });\r\n    };\r\n    IsolatedTestRunnerAdapterWorker.prototype.logReceivedMessageWarning = function (message) {\r\n        log.warn('Received unsupported message: {}', JSON.stringify(message));\r\n    };\r\n    IsolatedTestRunnerAdapterWorker.prototype.start = function (message) {\r\n        this.loadPlugins(message.runnerOptions.strykerOptions.plugins || []);\r\n        log.debug(\"Changing current working directory for this process to \" + message.runnerOptions.sandboxWorkingFolder);\r\n        process.chdir(message.runnerOptions.sandboxWorkingFolder);\r\n        this.underlyingTestRunner = test_runner_1.TestRunnerFactory.instance().create(message.runnerName, message.runnerOptions);\r\n    };\r\n    IsolatedTestRunnerAdapterWorker.prototype.init = function () {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        if (!this.underlyingTestRunner.init) return [3 /*break*/, 2];\r\n                        return [4 /*yield*/, this.underlyingTestRunner.init()];\r\n                    case 1:\r\n                        _a.sent();\r\n                        _a.label = 2;\r\n                    case 2:\r\n                        this.sendInitDone();\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    IsolatedTestRunnerAdapterWorker.prototype.sendInitDone = function () {\r\n        var message = { kind: 'initDone' };\r\n        if (process.send) {\r\n            process.send(message);\r\n        }\r\n    };\r\n    IsolatedTestRunnerAdapterWorker.prototype.dispose = function () {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        if (!this.underlyingTestRunner.dispose) return [3 /*break*/, 2];\r\n                        return [4 /*yield*/, this.underlyingTestRunner.dispose()];\r\n                    case 1:\r\n                        _a.sent();\r\n                        _a.label = 2;\r\n                    case 2:\r\n                        this.sendDisposeDone();\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    IsolatedTestRunnerAdapterWorker.prototype.sendDisposeDone = function () {\r\n        this.send({ kind: 'disposeDone' });\r\n    };\r\n    IsolatedTestRunnerAdapterWorker.prototype.run = function (body) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var res, error_1;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        _a.trys.push([0, 2, , 3]);\r\n                        return [4 /*yield*/, this.underlyingTestRunner.run(body.runOptions)];\r\n                    case 1:\r\n                        res = _a.sent();\r\n                        this.reportResult(res);\r\n                        return [3 /*break*/, 3];\r\n                    case 2:\r\n                        error_1 = _a.sent();\r\n                        this.reportErrorResult(error_1);\r\n                        return [3 /*break*/, 3];\r\n                    case 3: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    IsolatedTestRunnerAdapterWorker.prototype.send = function (message) {\r\n        if (process.send) {\r\n            process.send(message);\r\n        }\r\n    };\r\n    IsolatedTestRunnerAdapterWorker.prototype.loadPlugins = function (plugins) {\r\n        new PluginLoader_1.default(plugins).load();\r\n    };\r\n    IsolatedTestRunnerAdapterWorker.prototype.reportResult = function (result) {\r\n        // If the test runner didn't report on coverage, let's try to do it ourselves.\r\n        if (!result.coverage) {\r\n            result.coverage = (Function('return this'))().__coverage__;\r\n        }\r\n        if (result.errorMessages) {\r\n            // errorMessages should be a string[]\r\n            // Just in case the test runner implementer forgot to convert `Error`s to string, we will do it here\r\n            // https://github.com/stryker-mutator/stryker/issues/141\r\n            result.errorMessages = result.errorMessages.map(objectUtils_1.errorToString);\r\n        }\r\n        this.send({\r\n            kind: 'result',\r\n            result: result\r\n        });\r\n    };\r\n    IsolatedTestRunnerAdapterWorker.prototype.reportErrorResult = function (error) {\r\n        var runResult = {\r\n            tests: [],\r\n            status: test_runner_1.RunStatus.Error,\r\n        };\r\n        if (error) {\r\n            if (Array.isArray(error)) {\r\n                runResult.errorMessages = error.map(function (e) { return e; });\r\n            }\r\n            else {\r\n                runResult.errorMessages = [error];\r\n            }\r\n        }\r\n        this.reportResult(runResult);\r\n    };\r\n    return IsolatedTestRunnerAdapterWorker;\r\n}());\r\nnew IsolatedTestRunnerAdapterWorker();\r\n//# sourceMappingURL=IsolatedTestRunnerAdapterWorker.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\isolated-runner\\MessageProtocol.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n//# sourceMappingURL=MessageProtocol.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\isolated-runner\\ResilientTestRunnerFactory.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar IsolatedTestRunnerAdapter_1 = require(\"./IsolatedTestRunnerAdapter\");\r\nvar TimeoutDecorator_1 = require(\"./TimeoutDecorator\");\r\nvar RetryDecorator_1 = require(\"./RetryDecorator\");\r\nexports.default = {\r\n    create: function (testRunnerName, settings) {\r\n        return new RetryDecorator_1.default(function () {\r\n            return new TimeoutDecorator_1.default(function () { return new IsolatedTestRunnerAdapter_1.default(testRunnerName, settings); });\r\n        });\r\n    }\r\n};\r\n//# sourceMappingURL=ResilientTestRunnerFactory.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\isolated-runner\\RetryDecorator.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar test_runner_1 = require(\"stryker-api/test_runner\");\r\nvar objectUtils_1 = require(\"../utils/objectUtils\");\r\nvar TestRunnerDecorator_1 = require(\"./TestRunnerDecorator\");\r\nvar Task_1 = require(\"../utils/Task\");\r\nvar BROKEN_PIPE_ERROR_CODE = 'EPIPE';\r\nvar ERROR_MESSAGE = 'Test runner crashed. Tried twice to restart it without any luck. Last time the error message was: ';\r\n/**\r\n * Wraps a test runner and implements the retry functionality.\r\n */\r\nvar RetryDecorator = (function (_super) {\r\n    tslib_1.__extends(RetryDecorator, _super);\r\n    function RetryDecorator() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    RetryDecorator.prototype.run = function (options) {\r\n        this.currentRunTask = new Task_1.default();\r\n        this.tryRun(options);\r\n        return this.currentRunTask.promise;\r\n    };\r\n    RetryDecorator.prototype.dispose = function () {\r\n        var _this = this;\r\n        return _super.prototype.dispose.call(this).catch(function (err) {\r\n            if (_this.innerProcessIsCrashed(err)) {\r\n                return null;\r\n            }\r\n            else {\r\n                // Oops, not intended to catch this one. Pass through\r\n                throw err;\r\n            }\r\n        });\r\n    };\r\n    RetryDecorator.prototype.innerProcessIsCrashed = function (error) {\r\n        return objectUtils_1.isErrnoException(error) && error.code === BROKEN_PIPE_ERROR_CODE;\r\n    };\r\n    RetryDecorator.prototype.tryRun = function (options, retriesLeft, lastError) {\r\n        var _this = this;\r\n        if (retriesLeft === void 0) { retriesLeft = 2; }\r\n        if (retriesLeft > 0) {\r\n            this.innerRunner.run(options).then(function (result) {\r\n                return _this.currentRunTask.resolve(result);\r\n            }, function (rejectReason) {\r\n                if (_this.innerProcessIsCrashed(rejectReason)) {\r\n                    _this.recover().then(function () { return _this.tryRun(options, retriesLeft - 1, rejectReason); }, function (reason) { return _this.currentRunTask.reject(reason); });\r\n                }\r\n                else {\r\n                    // Oops... not intended to catch this one\r\n                    _this.currentRunTask.reject(rejectReason);\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            this.recover().then(function () { return _this.currentRunTask.resolve({ status: test_runner_1.RunStatus.Error, errorMessages: [ERROR_MESSAGE + objectUtils_1.errorToString(lastError)], tests: [] }); }, function (reason) { return _this.currentRunTask.reject(reason); });\r\n        }\r\n    };\r\n    RetryDecorator.prototype.recover = function () {\r\n        this.createInnerRunner();\r\n        return this.init();\r\n    };\r\n    return RetryDecorator;\r\n}(TestRunnerDecorator_1.default));\r\nexports.default = RetryDecorator;\r\n//# sourceMappingURL=RetryDecorator.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\isolated-runner\\TestRunnerDecorator.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar events_1 = require(\"events\");\r\nvar TestRunnerDecorator = (function (_super) {\r\n    tslib_1.__extends(TestRunnerDecorator, _super);\r\n    function TestRunnerDecorator(testRunnerProducer) {\r\n        var _this = _super.call(this) || this;\r\n        _this.testRunnerProducer = testRunnerProducer;\r\n        _this.createInnerRunner();\r\n        return _this;\r\n    }\r\n    TestRunnerDecorator.prototype.init = function () {\r\n        if (this.innerRunner.init) {\r\n            return this.innerRunner.init() || Promise.resolve();\r\n        }\r\n        else {\r\n            return Promise.resolve();\r\n        }\r\n    };\r\n    TestRunnerDecorator.prototype.createInnerRunner = function () {\r\n        this.innerRunner = this.testRunnerProducer();\r\n    };\r\n    TestRunnerDecorator.prototype.run = function (options) {\r\n        return this.innerRunner.run(options);\r\n    };\r\n    TestRunnerDecorator.prototype.dispose = function () {\r\n        if (this.innerRunner.dispose) {\r\n            return this.innerRunner.dispose() || Promise.resolve();\r\n        }\r\n        else {\r\n            return Promise.resolve();\r\n        }\r\n    };\r\n    return TestRunnerDecorator;\r\n}(events_1.EventEmitter));\r\nexports.default = TestRunnerDecorator;\r\n//# sourceMappingURL=TestRunnerDecorator.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\isolated-runner\\TimeoutDecorator.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar test_runner_1 = require(\"stryker-api/test_runner\");\r\nvar objectUtils_1 = require(\"../utils/objectUtils\");\r\nvar Task_1 = require(\"../utils/Task\");\r\nvar TestRunnerDecorator_1 = require(\"./TestRunnerDecorator\");\r\nvar MAX_WAIT_FOR_DISPOSE = 2500;\r\n/**\r\n * Wraps a test runner and implements the timeout functionality.\r\n */\r\nvar TimeoutDecorator = (function (_super) {\r\n    tslib_1.__extends(TimeoutDecorator, _super);\r\n    function TimeoutDecorator() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    TimeoutDecorator.prototype.run = function (options) {\r\n        var _this = this;\r\n        var runTask = new Task_1.default(options.timeout, function () { return _this.handleTimeout(); });\r\n        runTask.chainTo(_super.prototype.run.call(this, options));\r\n        return runTask.promise;\r\n    };\r\n    TimeoutDecorator.prototype.dispose = function () {\r\n        var _this = this;\r\n        return this.proxy(function () { return _super.prototype.dispose.call(_this); }, MAX_WAIT_FOR_DISPOSE);\r\n    };\r\n    TimeoutDecorator.prototype.proxy = function (action, timeoutMs) {\r\n        if (action) {\r\n            var maybePromise = action();\r\n            if (objectUtils_1.isPromise(maybePromise)) {\r\n                var task = new Task_1.default(timeoutMs);\r\n                task.chainTo(maybePromise);\r\n                return task.promise;\r\n            }\r\n        }\r\n        return Promise.resolve();\r\n    };\r\n    TimeoutDecorator.prototype.handleTimeout = function () {\r\n        var _this = this;\r\n        return this.dispose()\r\n            .then(function () { return _this.createInnerRunner(); })\r\n            .then(function () { return _this.init(); })\r\n            .then(function () { return ({ status: test_runner_1.RunStatus.Timeout, tests: [] }); });\r\n    };\r\n    return TimeoutDecorator;\r\n}(TestRunnerDecorator_1.default));\r\nexports.default = TimeoutDecorator;\r\n//# sourceMappingURL=TimeoutDecorator.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\Mutant.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar StrykerTempFolder_1 = require(\"./utils/StrykerTempFolder\");\r\n/**\r\n * Represents a mutation which has been applied to a file.\r\n */\r\nvar Mutant = (function () {\r\n    /**\r\n     * @param mutatorName - The name of the Mutator which created this mutant.\r\n     * @param filename - The name of the file which was mutated, including the path.\r\n     * @param originalCode - The original content of the file which has not been mutated.\r\n     * @param replacement - The mutated code which will replace a part of the originalCode.\r\n     * @param location - The location of the code to be mutated - line and column based\r\n     * @param range - The location of the code to be mutated - index based\r\n     */\r\n    function Mutant(mutatorName, filename, originalCode, replacement, location, range) {\r\n        this.mutatorName = mutatorName;\r\n        this.filename = filename;\r\n        this.originalCode = originalCode;\r\n        this.replacement = replacement;\r\n        this.location = location;\r\n        this.range = range;\r\n        this._scopedTestIds = [];\r\n        this.specsRan = [];\r\n        this._timeSpentScopedTests = 0;\r\n    }\r\n    Object.defineProperty(Mutant.prototype, \"scopedTestIds\", {\r\n        get: function () {\r\n            return this._scopedTestIds;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Mutant.prototype, \"timeSpentScopedTests\", {\r\n        get: function () {\r\n            return this._timeSpentScopedTests;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Mutant.prototype.addAllTestResults = function (runResult) {\r\n        var _this = this;\r\n        runResult.tests.forEach(function (testResult, id) { return _this.addTestResult(id, testResult); });\r\n    };\r\n    Mutant.prototype.addTestResult = function (index, testResult) {\r\n        this._scopedTestIds.push(index);\r\n        this._timeSpentScopedTests += testResult.timeSpentMs;\r\n    };\r\n    Mutant.prototype.isNewLine = function (index) {\r\n        var char = this.originalCode[index];\r\n        return char === '\\n' || char === '\\r';\r\n    };\r\n    Mutant.prototype.getMutationLineIndexes = function () {\r\n        var startIndexLines = this.range[0], endIndexLines = this.range[1];\r\n        while (startIndexLines > 0 && !this.isNewLine(startIndexLines - 1)) {\r\n            startIndexLines--;\r\n        }\r\n        while (endIndexLines < this.originalCode.length && !this.isNewLine(endIndexLines)) {\r\n            endIndexLines++;\r\n        }\r\n        return [startIndexLines, endIndexLines];\r\n    };\r\n    Object.defineProperty(Mutant.prototype, \"originalLines\", {\r\n        get: function () {\r\n            var _a = this.getMutationLineIndexes(), startIndex = _a[0], endIndex = _a[1];\r\n            return this.originalCode.substring(startIndex, endIndex);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Mutant.prototype, \"mutatedLines\", {\r\n        get: function () {\r\n            var _a = this.getMutationLineIndexes(), startIndex = _a[0], endIndex = _a[1];\r\n            return this.originalCode.substring(startIndex, this.range[0]) + this.replacement + this.originalCode.substring(this.range[1], endIndex);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Mutant.prototype, \"mutatedCode\", {\r\n        get: function () {\r\n            return this.originalCode.substr(0, this.range[0]) + this.replacement + this.originalCode.substr(this.range[1]);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Saves the mutated code in a mutated file.\r\n     * @function\r\n     */\r\n    Mutant.prototype.save = function (filename) {\r\n        return StrykerTempFolder_1.default.writeFile(filename, this.mutatedCode);\r\n    };\r\n    /**\r\n     * Removes the mutated file.\r\n     * @function\r\n     */\r\n    Mutant.prototype.reset = function (filename) {\r\n        return StrykerTempFolder_1.default.writeFile(filename, this.originalCode);\r\n    };\r\n    Mutant.prototype.toString = function () {\r\n        return this.mutatorName + \" (\" + this.filename + \"@\" + this.location.start.line + \":\" + this.location.start.column + \")\";\r\n    };\r\n    return Mutant;\r\n}());\r\nexports.default = Mutant;\r\n//# sourceMappingURL=Mutant.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\MutantTestMatcher.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar log4js = require(\"log4js\");\r\nvar _ = require(\"lodash\");\r\nvar log = log4js.getLogger('MutantTestMatcher');\r\nvar MutantTestMatcher = (function () {\r\n    function MutantTestMatcher(mutants, initialRunResult, statementMaps, options, reporter) {\r\n        this.mutants = mutants;\r\n        this.initialRunResult = initialRunResult;\r\n        this.statementMaps = statementMaps;\r\n        this.options = options;\r\n        this.reporter = reporter;\r\n    }\r\n    Object.defineProperty(MutantTestMatcher.prototype, \"baseline\", {\r\n        get: function () {\r\n            if (this.isCoveragePerTestResult(this.initialRunResult.coverage)) {\r\n                return this.initialRunResult.coverage.baseline;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    MutantTestMatcher.prototype.matchWithMutants = function () {\r\n        var _this = this;\r\n        if (this.options.coverageAnalysis === 'off') {\r\n            this.mutants.forEach(function (mutant) { return mutant.addAllTestResults(_this.initialRunResult); });\r\n        }\r\n        else if (!this.initialRunResult.coverage) {\r\n            log.warn('No coverage result found, even though coverageAnalysis is \"%s\". Assuming that all tests cover each mutant. This might have a big impact on the performance.', this.options.coverageAnalysis);\r\n            this.mutants.forEach(function (mutant) { return mutant.addAllTestResults(_this.initialRunResult); });\r\n        }\r\n        else\r\n            this.mutants.forEach(function (mutant) {\r\n                var statementMap = _this.statementMaps[mutant.filename];\r\n                var smallestStatement = _this.findSmallestCoveringStatement(mutant, statementMap);\r\n                if (smallestStatement) {\r\n                    if (_this.isCoveredByBaseline(mutant.filename, smallestStatement)) {\r\n                        mutant.addAllTestResults(_this.initialRunResult);\r\n                    }\r\n                    else {\r\n                        _this.initialRunResult.tests.forEach(function (testResult, id) {\r\n                            if (_this.isCoveredByTest(id, mutant.filename, smallestStatement)) {\r\n                                mutant.addTestResult(id, testResult);\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n                else {\r\n                    log.warn('Cannot find statement for mutant %s in statement map for file. Assuming that all tests cover this mutant. This might have a big impact on the performance.', mutant.toString());\r\n                    mutant.addAllTestResults(_this.initialRunResult);\r\n                }\r\n            });\r\n        this.reporter.onAllMutantsMatchedWithTests(Object.freeze(this.mutants.map(this.mapMutantOnMatchedMutant)));\r\n    };\r\n    MutantTestMatcher.prototype.isCoveredByBaseline = function (filename, statementId) {\r\n        if (this.baseline) {\r\n            var coverageCollection = this.baseline[filename];\r\n            return coverageCollection && coverageCollection.s[statementId] > 0;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    };\r\n    MutantTestMatcher.prototype.isCoveredByTest = function (testId, filename, statementId) {\r\n        var coverageCollection = this.findCoverageCollectionForTest(testId);\r\n        var coveredFile = coverageCollection && coverageCollection[filename];\r\n        return coveredFile && coveredFile.s[statementId] > 0;\r\n    };\r\n    /**\r\n     * Map the Mutant object on the MatchMutant Object.\r\n     * @param mutant The mutant.\r\n     * @returns The MatchedMutant\r\n     */\r\n    MutantTestMatcher.prototype.mapMutantOnMatchedMutant = function (mutant) {\r\n        var matchedMutant = _.cloneDeep({\r\n            mutatorName: mutant.mutatorName,\r\n            scopedTestIds: mutant.scopedTestIds,\r\n            timeSpentScopedTests: mutant.timeSpentScopedTests,\r\n            filename: mutant.filename,\r\n            replacement: mutant.replacement\r\n        });\r\n        return Object.freeze(matchedMutant);\r\n    };\r\n    /**\r\n     * Finds the smallest statement that covers a mutant.\r\n     * @param mutant The mutant.\r\n     * @param statementMap of the covering file.\r\n     * @returns The index of the coveredFile which contains the smallest statement surrounding the mutant.\r\n     */\r\n    MutantTestMatcher.prototype.findSmallestCoveringStatement = function (mutant, statementMap) {\r\n        var _this = this;\r\n        var smallestStatement = null;\r\n        if (statementMap) {\r\n            Object.keys(statementMap).forEach(function (statementId) {\r\n                var location = statementMap[statementId];\r\n                if (_this.statementCoversMutant(mutant.location, location) && (!smallestStatement || _this.isNewSmallestStatement(statementMap[smallestStatement], location))) {\r\n                    smallestStatement = statementId;\r\n                }\r\n            });\r\n        }\r\n        return smallestStatement;\r\n    };\r\n    /**\r\n     * Indicates whether a statement is the smallest statement of the two statements provided.\r\n     * @param originalLocation The area which may cover a bigger area than the newLocation.\r\n     * @param newLocation The area which may cover a smaller area than the originalLocation.\r\n     * @returns true if the newLocation covers a smaller area than the originalLocation, making it the smaller statement.\r\n     */\r\n    MutantTestMatcher.prototype.isNewSmallestStatement = function (originalLocation, newLocation) {\r\n        var statementIsSmallestStatement = false;\r\n        if (!originalLocation) {\r\n            statementIsSmallestStatement = true;\r\n        }\r\n        else {\r\n            var lineDifference = (originalLocation.end.line - originalLocation.start.line) - (newLocation.end.line - newLocation.start.line);\r\n            var coversLessLines = lineDifference > 0;\r\n            var coversLessColumns = lineDifference === 0 && (newLocation.start.column - originalLocation.start.column) + (originalLocation.end.column - newLocation.end.column) > 0;\r\n            if (coversLessLines || coversLessColumns) {\r\n                statementIsSmallestStatement = true;\r\n            }\r\n        }\r\n        return statementIsSmallestStatement;\r\n    };\r\n    /**\r\n     * Indicates whether a statement covers a mutant.\r\n     * @param mutantLocation The location of the mutant.\r\n     * @param statementLocation The location of the statement.\r\n     * @returns true if the statment covers the mutant.\r\n     */\r\n    MutantTestMatcher.prototype.statementCoversMutant = function (mutantLocation, statementLocation) {\r\n        var mutantIsAfterStart = mutantLocation.start.line > statementLocation.start.line ||\r\n            (mutantLocation.start.line === statementLocation.start.line && mutantLocation.start.column >= statementLocation.start.column);\r\n        var mutantIsBeforeEnd = mutantLocation.end.line < statementLocation.end.line ||\r\n            (mutantLocation.end.line === statementLocation.end.line && mutantLocation.end.column <= statementLocation.end.column);\r\n        return mutantIsAfterStart && mutantIsBeforeEnd;\r\n    };\r\n    MutantTestMatcher.prototype.findCoverageCollectionForTest = function (testId) {\r\n        if (this.initialRunResult.coverage) {\r\n            if (this.isCoveragePerTestResult(this.initialRunResult.coverage)) {\r\n                return this.initialRunResult.coverage.deviations[testId];\r\n            }\r\n            else {\r\n                return this.initialRunResult.coverage;\r\n            }\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    };\r\n    MutantTestMatcher.prototype.isCoveragePerTestResult = function (coverage) {\r\n        return this.options.coverageAnalysis === 'perTest';\r\n    };\r\n    return MutantTestMatcher;\r\n}());\r\nexports.default = MutantTestMatcher;\r\n//# sourceMappingURL=MutantTestMatcher.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\MutatorOrchestrator.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar BinaryOperatorMutator_1 = require(\"./mutators/BinaryOperatorMutator\");\r\nvar BlockStatementMutator_1 = require(\"./mutators/BlockStatementMutator\");\r\nvar LogicalOperatorMutator_1 = require(\"./mutators/LogicalOperatorMutator\");\r\nvar RemoveConditionalsMutator_1 = require(\"./mutators/RemoveConditionalsMutator\");\r\nvar UnaryOperatorMutator_1 = require(\"./mutators/UnaryOperatorMutator\");\r\nvar UpdateOperatorMutator_1 = require(\"./mutators/UpdateOperatorMutator\");\r\nvar ArrayDeclaratorMutator_1 = require(\"./mutators/ArrayDeclaratorMutator\");\r\nvar BooleanSubstitutionMutator_1 = require(\"./mutators/BooleanSubstitutionMutator\");\r\nvar mutant_1 = require(\"stryker-api/mutant\");\r\nvar Mutant_1 = require(\"./Mutant\");\r\nvar parserUtils = require(\"./utils/parserUtils\");\r\nvar log4js = require(\"log4js\");\r\nvar fs = require(\"mz/fs\");\r\nvar objectUtils_1 = require(\"./utils/objectUtils\");\r\nvar log = log4js.getLogger('Mutator');\r\n/**\r\n * Class capable of finding spots to mutate in files.\r\n */\r\nvar MutatorOrchestrator = (function () {\r\n    /**\r\n     * @param reporter - The reporter to report read input files to\r\n     */\r\n    function MutatorOrchestrator(reporter) {\r\n        var _this = this;\r\n        this.reporter = reporter;\r\n        this.mutators = [];\r\n        this.registerDefaultMutators();\r\n        var mutatorFactory = mutant_1.MutatorFactory.instance();\r\n        mutatorFactory.knownNames().forEach(function (name) { return _this.mutators.push(mutatorFactory.create(name, undefined)); });\r\n    }\r\n    /**\r\n     * Mutates source files. Mutated code is not writen to disk.\r\n     * @function\r\n     * @param sourceFiles - The list of files which should be mutated.\r\n     * @returns {Mutant[]} The generated Mutants.\r\n     */\r\n    MutatorOrchestrator.prototype.generateMutants = function (sourceFiles) {\r\n        var _this = this;\r\n        var mutants = [];\r\n        this.sourceFiles = [];\r\n        sourceFiles.forEach(function (sourceFile) {\r\n            try {\r\n                var fileContent = fs.readFileSync(sourceFile, 'utf8');\r\n                _this.reportFileRead(sourceFile, fileContent);\r\n                var abstractSyntaxTree = parserUtils.parse(fileContent);\r\n                var nodes = new parserUtils.NodeIdentifier().identifyAndFreeze(abstractSyntaxTree);\r\n                var newMutants = _this.findMutants(sourceFile, fileContent, abstractSyntaxTree, nodes);\r\n                mutants = mutants.concat(newMutants);\r\n            }\r\n            catch (err) {\r\n                switch (err.code) {\r\n                    case 'ENOENT':\r\n                        log.info(\"Skipping file \" + err.path + \" because it does not exist\");\r\n                        break;\r\n                    default:\r\n                        console.log(err);\r\n                        throw err;\r\n                }\r\n            }\r\n        });\r\n        this.reportAllFilesRead();\r\n        return mutants;\r\n    };\r\n    MutatorOrchestrator.prototype.reportFileRead = function (path, content) {\r\n        var fileToReport = { path: path, content: content };\r\n        objectUtils_1.freezeRecursively(fileToReport);\r\n        this.sourceFiles.push(fileToReport);\r\n        this.reporter.onSourceFileRead(fileToReport);\r\n    };\r\n    MutatorOrchestrator.prototype.reportAllFilesRead = function () {\r\n        objectUtils_1.freezeRecursively(this.sourceFiles);\r\n        this.reporter.onAllSourceFilesRead(this.sourceFiles);\r\n    };\r\n    MutatorOrchestrator.prototype.registerDefaultMutators = function () {\r\n        var mutatorFactory = mutant_1.MutatorFactory.instance();\r\n        mutatorFactory.register('BinaryOperator', BinaryOperatorMutator_1.default);\r\n        mutatorFactory.register('BlockStatement', BlockStatementMutator_1.default);\r\n        mutatorFactory.register('LogicalOperator', LogicalOperatorMutator_1.default);\r\n        mutatorFactory.register('RemoveConditionals', RemoveConditionalsMutator_1.default);\r\n        mutatorFactory.register('UnaryOperator', UnaryOperatorMutator_1.default);\r\n        mutatorFactory.register('UpdateOperator', UpdateOperatorMutator_1.default);\r\n        mutatorFactory.register('ArrayDeclarator', ArrayDeclaratorMutator_1.default);\r\n        mutatorFactory.register('BooleanSubstitution', BooleanSubstitutionMutator_1.default);\r\n    };\r\n    /**\r\n     * Finds all mutants for a given set of nodes.\r\n     * @function\r\n     * @param {String} sourceFile - The name source file.\r\n     * @param {String} originalCode - The original content of the file which has not been mutated.\r\n     * @param {Object} ast - The original abstract syntax tree which is used for reference when generating code.\r\n     * @param {AbstractSyntaxTreeNode[]} nodes - The nodes which could be used by mutations to generate mutants.\r\n     * @returns {Mutant[]} All possible Mutants for the given set of nodes.\r\n     */\r\n    MutatorOrchestrator.prototype.findMutants = function (sourceFile, originalCode, ast, nodes) {\r\n        var _this = this;\r\n        var mutants = [];\r\n        nodes.forEach(function (astnode) {\r\n            if (astnode.type) {\r\n                Object.freeze(astnode);\r\n                _this.mutators.forEach(function (mutator) {\r\n                    try {\r\n                        var mutatedNodes = mutator.applyMutations(astnode, objectUtils_1.copy);\r\n                        if (mutatedNodes) {\r\n                            if (!Array.isArray(mutatedNodes)) {\r\n                                mutatedNodes = [mutatedNodes];\r\n                            }\r\n                            if (mutatedNodes.length > 0) {\r\n                                log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);\r\n                            }\r\n                            mutatedNodes.forEach(function (mutatedNode) {\r\n                                var mutatedCode = parserUtils.generate(mutatedNode);\r\n                                var originalNode = nodes[mutatedNode.nodeID];\r\n                                mutants.push(new Mutant_1.default(mutator.name, sourceFile, originalCode, mutatedCode, originalNode.loc, originalNode.range));\r\n                            });\r\n                        }\r\n                    }\r\n                    catch (error) {\r\n                        throw new Error(\"The mutator named '\" + mutator.name + \"' caused an error: \" + error);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n        return mutants;\r\n    };\r\n    return MutatorOrchestrator;\r\n}());\r\nexports.default = MutatorOrchestrator;\r\n//# sourceMappingURL=MutatorOrchestrator.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\mutators\\ArrayDeclaratorMutator.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar esprima_1 = require(\"esprima\");\r\n/**\r\n * Represents a mutator which can remove the content of an array's elements.\r\n */\r\nvar ArrayDeclaratorMutator = (function () {\r\n    function ArrayDeclaratorMutator() {\r\n        this.name = 'ArrayDeclarator';\r\n    }\r\n    ArrayDeclaratorMutator.prototype.applyMutations = function (node, copy) {\r\n        if ((node.type === esprima_1.Syntax.CallExpression || node.type === esprima_1.Syntax.NewExpression) && node.callee.type === esprima_1.Syntax.Identifier && node.callee.name === 'Array' && node.arguments.length > 0) {\r\n            var mutatedNode = copy(node);\r\n            mutatedNode.arguments = [];\r\n            return mutatedNode;\r\n        }\r\n        if (node.type === esprima_1.Syntax.ArrayExpression && node.elements.length > 0) {\r\n            var mutatedNode = copy(node);\r\n            mutatedNode.elements = [];\r\n            return mutatedNode;\r\n        }\r\n    };\r\n    return ArrayDeclaratorMutator;\r\n}());\r\nexports.default = ArrayDeclaratorMutator;\r\n//# sourceMappingURL=ArrayDeclaratorMutator.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\mutators\\BinaryOperatorMutator.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar esprima_1 = require(\"esprima\");\r\nvar BinaryOperatorMutator = (function () {\r\n    function BinaryOperatorMutator() {\r\n        this.name = 'BinaryOperator';\r\n        this.type = esprima_1.Syntax.BinaryExpression;\r\n        this.operators = {\r\n            '+': '-',\r\n            '-': '+',\r\n            '*': '/',\r\n            '/': '*',\r\n            '%': '*',\r\n            '<': ['<=', '>='],\r\n            '<=': ['<', '>'],\r\n            '>': ['>=', '<='],\r\n            '>=': ['>', '<'],\r\n            '==': '!=',\r\n            '!=': '==',\r\n            '===': '!==',\r\n            '!==': '==='\r\n        };\r\n    }\r\n    BinaryOperatorMutator.prototype.applyMutations = function (node, copy) {\r\n        var nodes = [];\r\n        if (node.type === this.type && this.operators[node.operator]) {\r\n            var binaryNode_1 = node;\r\n            var mutatedOperators = this.operators[node.operator];\r\n            if (typeof mutatedOperators === 'string') {\r\n                mutatedOperators = [mutatedOperators];\r\n            }\r\n            mutatedOperators.forEach(function (operator) {\r\n                var mutatedNode = copy(binaryNode_1);\r\n                mutatedNode.operator = operator;\r\n                nodes.push(mutatedNode);\r\n            });\r\n        }\r\n        return nodes;\r\n    };\r\n    return BinaryOperatorMutator;\r\n}());\r\nexports.default = BinaryOperatorMutator;\r\n//# sourceMappingURL=BinaryOperatorMutator.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\mutators\\BlockStatementMutator.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar esprima_1 = require(\"esprima\");\r\n/**\r\n * Represents a mutator which can remove the content of a BlockStatement.\r\n */\r\nvar BlockStatementMutator = (function () {\r\n    function BlockStatementMutator() {\r\n        this.name = 'BlockStatement';\r\n        this.type = esprima_1.Syntax.BlockStatement;\r\n    }\r\n    BlockStatementMutator.prototype.applyMutations = function (node, copy) {\r\n        if (node.type === this.type && node.body.length > 0) {\r\n            var mutatedNode = copy(node);\r\n            mutatedNode.body = [];\r\n            return mutatedNode;\r\n        }\r\n    };\r\n    return BlockStatementMutator;\r\n}());\r\nexports.default = BlockStatementMutator;\r\n//# sourceMappingURL=BlockStatementMutator.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\mutators\\BooleanSubstitutionMutator.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar esprima_1 = require(\"esprima\");\r\nvar BooleanSubstitutionMutator = (function () {\r\n    function BooleanSubstitutionMutator() {\r\n        this.name = 'BooleanSubstitution';\r\n    }\r\n    BooleanSubstitutionMutator.prototype.applyMutations = function (node, copy) {\r\n        var nodes = [];\r\n        // !a -> a\r\n        if (node.type === esprima_1.Syntax.UnaryExpression && node.operator === '!') {\r\n            var mutatedNode = copy(node.argument);\r\n            mutatedNode.nodeID = node.nodeID;\r\n            nodes.push(mutatedNode);\r\n        }\r\n        // true -> false or false -> true\r\n        if (node.type === esprima_1.Syntax.Literal && typeof node.value === 'boolean') {\r\n            var mutatedNode = copy(node);\r\n            mutatedNode.value = !mutatedNode.value;\r\n            nodes.push(mutatedNode);\r\n        }\r\n        return nodes;\r\n    };\r\n    return BooleanSubstitutionMutator;\r\n}());\r\nexports.default = BooleanSubstitutionMutator;\r\n//# sourceMappingURL=BooleanSubstitutionMutator.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\mutators\\LogicalOperatorMutator.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar esprima_1 = require(\"esprima\");\r\nvar LogicalOperatorMutator = (function () {\r\n    function LogicalOperatorMutator() {\r\n        this.name = 'LogicalOperator';\r\n        this.type = esprima_1.Syntax.LogicalExpression;\r\n        this.operators = {\r\n            '&&': '||',\r\n            '||': '&&'\r\n        };\r\n    }\r\n    LogicalOperatorMutator.prototype.applyMutations = function (node, copy) {\r\n        var nodes = [];\r\n        if (node.type === this.type && this.operators[node.operator]) {\r\n            var mutatedNode = copy(node);\r\n            mutatedNode.operator = this.operators[node.operator];\r\n            nodes.push(mutatedNode);\r\n        }\r\n        return nodes;\r\n    };\r\n    return LogicalOperatorMutator;\r\n}());\r\nexports.default = LogicalOperatorMutator;\r\n//# sourceMappingURL=LogicalOperatorMutator.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\mutators\\RemoveConditionalsMutator.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar esprima_1 = require(\"esprima\");\r\n/**\r\n * Represents a mutator which can remove the conditional clause from statements.\r\n */\r\nvar RemoveConditionalsMutator = (function () {\r\n    function RemoveConditionalsMutator() {\r\n        this.name = 'RemoveConditionals';\r\n        this.types = [esprima_1.Syntax.DoWhileStatement, esprima_1.Syntax.IfStatement, esprima_1.Syntax.ForStatement, esprima_1.Syntax.WhileStatement, esprima_1.Syntax.ConditionalExpression];\r\n    }\r\n    RemoveConditionalsMutator.prototype.applyMutations = function (node, copy) {\r\n        if (this.canMutate(node)) {\r\n            var nodes = [];\r\n            if (node.test) {\r\n                nodes.push(this.booleanLiteralNode(node.test.nodeID, false));\r\n            }\r\n            else {\r\n                var mutatedNode = copy(node);\r\n                mutatedNode.test = this.booleanLiteralNode(-1, false);\r\n                nodes.push(mutatedNode);\r\n            }\r\n            if (node.type === esprima_1.Syntax.IfStatement || node.type === esprima_1.Syntax.ConditionalExpression) {\r\n                nodes.push(this.booleanLiteralNode(node.test.nodeID, true));\r\n            }\r\n            return nodes;\r\n        }\r\n    };\r\n    RemoveConditionalsMutator.prototype.booleanLiteralNode = function (nodeID, value) {\r\n        return {\r\n            nodeID: nodeID,\r\n            type: esprima_1.Syntax.Literal,\r\n            value: value,\r\n            raw: value.toString()\r\n        };\r\n    };\r\n    RemoveConditionalsMutator.prototype.canMutate = function (node) {\r\n        return this.types.indexOf(node.type) >= 0;\r\n    };\r\n    return RemoveConditionalsMutator;\r\n}());\r\nexports.default = RemoveConditionalsMutator;\r\n//# sourceMappingURL=RemoveConditionalsMutator.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\mutators\\UnaryOperatorMutator.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar esprima_1 = require(\"esprima\");\r\nvar UnaryOperatorMutator = (function () {\r\n    function UnaryOperatorMutator() {\r\n        this.name = 'UnaryOperator';\r\n        this.type = esprima_1.Syntax.UnaryExpression;\r\n        this.operators = {\r\n            '+': '-',\r\n            '-': '+'\r\n        };\r\n    }\r\n    UnaryOperatorMutator.prototype.applyMutations = function (node, copy) {\r\n        var nodes = [];\r\n        if (node.type === this.type && this.operators[node.operator]) {\r\n            var mutatedNode = copy(node);\r\n            mutatedNode.operator = this.operators[node.operator];\r\n            nodes.push(mutatedNode);\r\n        }\r\n        return nodes;\r\n    };\r\n    return UnaryOperatorMutator;\r\n}());\r\nexports.default = UnaryOperatorMutator;\r\n//# sourceMappingURL=UnaryOperatorMutator.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\mutators\\UpdateOperatorMutator.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar esprima_1 = require(\"esprima\");\r\nvar UpdateOperatorMutator = (function () {\r\n    function UpdateOperatorMutator() {\r\n        this.name = 'UpdateOperator';\r\n        this.type = esprima_1.Syntax.UpdateExpression;\r\n        this.operators = {\r\n            '++': '--',\r\n            '--': '++'\r\n        };\r\n    }\r\n    UpdateOperatorMutator.prototype.applyMutations = function (node, copy) {\r\n        if (node.type === this.type && this.operators[node.operator]) {\r\n            var mutatedNode = copy(node);\r\n            mutatedNode.operator = this.operators[node.operator];\r\n            return mutatedNode;\r\n        }\r\n    };\r\n    return UpdateOperatorMutator;\r\n}());\r\nexports.default = UpdateOperatorMutator;\r\n//# sourceMappingURL=UpdateOperatorMutator.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\PluginLoader.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar fs = require(\"mz/fs\");\r\nvar path = require(\"path\");\r\nvar log4js = require(\"log4js\");\r\nvar _ = require(\"lodash\");\r\nvar fileUtils_1 = require(\"./utils/fileUtils\");\r\nvar log = log4js.getLogger('PluginLoader');\r\nvar IGNORED_PACKAGES = ['stryker-cli', 'stryker-api'];\r\nvar PluginLoader = (function () {\r\n    function PluginLoader(plugins) {\r\n        this.plugins = plugins;\r\n    }\r\n    PluginLoader.prototype.load = function () {\r\n        this.getModules().forEach(this.requirePlugin);\r\n    };\r\n    PluginLoader.prototype.getModules = function () {\r\n        var modules = [];\r\n        this.plugins.forEach(function (pluginExpression) {\r\n            if (_.isString(pluginExpression)) {\r\n                if (pluginExpression.indexOf('*') !== -1) {\r\n                    // Plugin directory is the node_modules folder of the module that installed stryker\r\n                    // So if current __dirname is './stryker/src' than the plugin directory should be 2 directories above\r\n                    var pluginDirectory_1 = path.normalize(__dirname + '/../..');\r\n                    var regexp_1 = new RegExp('^' + pluginExpression.replace('*', '.*'));\r\n                    log.debug('Loading %s from %s', pluginExpression, pluginDirectory_1);\r\n                    var plugins = fs.readdirSync(pluginDirectory_1)\r\n                        .filter(function (pluginName) { return IGNORED_PACKAGES.indexOf(pluginName) === -1 && regexp_1.test(pluginName); })\r\n                        .map(function (pluginName) { return pluginDirectory_1 + '/' + pluginName; });\r\n                    if (plugins.length === 0) {\r\n                        log.debug('Expression %s not resulted in plugins to load', pluginExpression);\r\n                    }\r\n                    plugins\r\n                        .map(function (plugin) { return path.basename(plugin); })\r\n                        .map(function (plugin) {\r\n                        log.debug('Loading plugins %s (matched with expression %s)', plugin, pluginExpression);\r\n                        return plugin;\r\n                    })\r\n                        .forEach(function (p) { return modules.push(p); });\r\n                }\r\n                else {\r\n                    modules.push(pluginExpression);\r\n                }\r\n            }\r\n            else {\r\n                log.warn('Ignoring plugin %s, as its not a string type', pluginExpression);\r\n            }\r\n        });\r\n        return modules;\r\n    };\r\n    PluginLoader.prototype.requirePlugin = function (name) {\r\n        log.debug(\"Loading plugins \" + name);\r\n        try {\r\n            fileUtils_1.importModule(name);\r\n        }\r\n        catch (e) {\r\n            if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(name) !== -1) {\r\n                log.warn('Cannot find plugin \"%s\".\\n  Did you forget to install it ?\\n' +\r\n                    '  npm install %s --save-dev', name, name);\r\n            }\r\n            else {\r\n                log.warn('Error during loading \"%s\" plugin:\\n  %s', name, e.message);\r\n            }\r\n        }\r\n    };\r\n    return PluginLoader;\r\n}());\r\nexports.default = PluginLoader;\r\n//# sourceMappingURL=PluginLoader.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\ReporterOrchestrator.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar report_1 = require(\"stryker-api/report\");\r\nvar ClearTextReporter_1 = require(\"./reporters/ClearTextReporter\");\r\nvar ProgressReporter_1 = require(\"./reporters/ProgressReporter\");\r\nvar ProgressAppendOnlyReporter_1 = require(\"./reporters/ProgressAppendOnlyReporter\");\r\nvar DotsReporter_1 = require(\"./reporters/DotsReporter\");\r\nvar EventRecorderReporter_1 = require(\"./reporters/EventRecorderReporter\");\r\nvar BroadcastReporter_1 = require(\"./reporters/BroadcastReporter\");\r\nvar log4js = require(\"log4js\");\r\nvar log = log4js.getLogger('ReporterOrchestrator');\r\nfunction registerDefaultReporters() {\r\n    report_1.ReporterFactory.instance().register('progress-append-only', ProgressAppendOnlyReporter_1.default);\r\n    report_1.ReporterFactory.instance().register('progress', ProgressReporter_1.default);\r\n    report_1.ReporterFactory.instance().register('dots', DotsReporter_1.default);\r\n    report_1.ReporterFactory.instance().register('clear-text', ClearTextReporter_1.default);\r\n    report_1.ReporterFactory.instance().register('event-recorder', EventRecorderReporter_1.default);\r\n}\r\nregisterDefaultReporters();\r\nvar ReporterOrchestrator = (function () {\r\n    function ReporterOrchestrator(options) {\r\n        this.options = options;\r\n    }\r\n    ReporterOrchestrator.prototype.createBroadcastReporter = function () {\r\n        var _this = this;\r\n        var reporters = [];\r\n        var reporterOption = this.options.reporter;\r\n        if (reporterOption) {\r\n            if (Array.isArray(reporterOption)) {\r\n                reporterOption.forEach(function (reporterName) { return reporters.push(_this.createReporter(reporterName)); });\r\n            }\r\n            else {\r\n                reporters.push(this.createReporter(reporterOption));\r\n            }\r\n        }\r\n        else {\r\n            log.warn(\"No reporter configured. Please configure one or more reporters in the (for example: reporter: 'progress')\");\r\n            this.logPossibleReporters();\r\n        }\r\n        return new BroadcastReporter_1.default(reporters);\r\n    };\r\n    ReporterOrchestrator.prototype.createReporter = function (name) {\r\n        if (name === 'progress' && !process.stdout['isTTY']) {\r\n            log.info('Detected that current console does not support the \"progress\" reporter, downgrading to \"progress-append-only\" reporter');\r\n            return { name: 'progress-append-only', reporter: report_1.ReporterFactory.instance().create('progress-append-only', this.options) };\r\n        }\r\n        else {\r\n            return { name: name, reporter: report_1.ReporterFactory.instance().create(name, this.options) };\r\n        }\r\n    };\r\n    ReporterOrchestrator.prototype.logPossibleReporters = function () {\r\n        var possibleReportersCsv = '';\r\n        report_1.ReporterFactory.instance().knownNames().forEach(function (name) {\r\n            if (possibleReportersCsv.length) {\r\n                possibleReportersCsv += ', ';\r\n            }\r\n            possibleReportersCsv += name;\r\n        });\r\n        log.warn(\"Possible reporters: \" + possibleReportersCsv);\r\n    };\r\n    return ReporterOrchestrator;\r\n}());\r\nexports.default = ReporterOrchestrator;\r\n//# sourceMappingURL=ReporterOrchestrator.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\reporters\\BroadcastReporter.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar log4js = require(\"log4js\");\r\nvar objectUtils_1 = require(\"../utils/objectUtils\");\r\nvar log = log4js.getLogger('BroadcastReporter');\r\nvar BroadcastReporter = (function () {\r\n    function BroadcastReporter(reporters) {\r\n        this.reporters = reporters;\r\n    }\r\n    BroadcastReporter.prototype.broadcast = function (methodName, eventArgs) {\r\n        var _this = this;\r\n        if (eventArgs === void 0) { eventArgs = undefined; }\r\n        var allPromises = [];\r\n        this.reporters.forEach(function (namedReporter) {\r\n            if (typeof namedReporter.reporter[methodName] === 'function') {\r\n                try {\r\n                    var maybePromise = namedReporter.reporter[methodName](eventArgs);\r\n                    if (objectUtils_1.isPromise(maybePromise)) {\r\n                        allPromises.push(maybePromise.catch(function (error) {\r\n                            _this.handleError(error, methodName, namedReporter.name);\r\n                        }));\r\n                    }\r\n                }\r\n                catch (error) {\r\n                    _this.handleError(error, methodName, namedReporter.name);\r\n                }\r\n            }\r\n        });\r\n        if (allPromises.length) {\r\n            return Promise.all(allPromises);\r\n        }\r\n    };\r\n    BroadcastReporter.prototype.onSourceFileRead = function (file) {\r\n        this.broadcast('onSourceFileRead', file);\r\n    };\r\n    BroadcastReporter.prototype.onAllSourceFilesRead = function (files) {\r\n        this.broadcast('onAllSourceFilesRead', files);\r\n    };\r\n    BroadcastReporter.prototype.onAllMutantsMatchedWithTests = function (results) {\r\n        this.broadcast('onAllMutantsMatchedWithTests', results);\r\n    };\r\n    BroadcastReporter.prototype.onMutantTested = function (result) {\r\n        this.broadcast('onMutantTested', result);\r\n    };\r\n    BroadcastReporter.prototype.onAllMutantsTested = function (results) {\r\n        this.broadcast('onAllMutantsTested', results);\r\n    };\r\n    BroadcastReporter.prototype.onScoreCalculated = function (score) {\r\n        this.broadcast('onScoreCalculated', score);\r\n    };\r\n    BroadcastReporter.prototype.wrapUp = function () {\r\n        return this.broadcast('wrapUp');\r\n    };\r\n    BroadcastReporter.prototype.handleError = function (error, methodName, reporterName) {\r\n        log.error(\"An error occurred during '\" + methodName + \"' on reporter '\" + reporterName + \"'. Error is: \" + error);\r\n    };\r\n    return BroadcastReporter;\r\n}());\r\nexports.default = BroadcastReporter;\r\n//# sourceMappingURL=BroadcastReporter.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\reporters\\ClearTextReporter.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar chalk = require(\"chalk\");\r\nvar log4js = require(\"log4js\");\r\nvar report_1 = require(\"stryker-api/report\");\r\nvar ClearTextScoreTable_1 = require(\"./ClearTextScoreTable\");\r\nvar os = require(\"os\");\r\nvar log = log4js.getLogger('ClearTextReporter');\r\nvar ClearTextReporter = (function () {\r\n    function ClearTextReporter(options) {\r\n        this.options = options;\r\n        this.out = process.stdout;\r\n    }\r\n    ClearTextReporter.prototype.writeLine = function (output) {\r\n        this.out.write(\"\" + (output || '') + os.EOL);\r\n    };\r\n    ClearTextReporter.prototype.onAllMutantsTested = function (mutantResults) {\r\n        var _this = this;\r\n        this.writeLine();\r\n        var totalTests = 0;\r\n        // use these fn's in order to preserve the 'this` pointer\r\n        var logDebugFn = function (input) { return log.debug(input); };\r\n        var writeLineFn = function (input) { return _this.writeLine(input); };\r\n        mutantResults.forEach(function (result) {\r\n            if (result.testsRan) {\r\n                totalTests += result.testsRan.length;\r\n            }\r\n            switch (result.status) {\r\n                case report_1.MutantStatus.Killed:\r\n                    log.debug(chalk.bold.green('Mutant killed!'));\r\n                    _this.logMutantResult(result, logDebugFn);\r\n                    break;\r\n                case report_1.MutantStatus.TimedOut:\r\n                    log.debug(chalk.bold.yellow('Mutant timed out!'));\r\n                    _this.logMutantResult(result, logDebugFn);\r\n                    break;\r\n                case report_1.MutantStatus.Error:\r\n                    log.debug(chalk.bold.yellow('Mutant caused an error!'));\r\n                    _this.logMutantResult(result, logDebugFn);\r\n                    break;\r\n                case report_1.MutantStatus.Survived:\r\n                    _this.writeLine(chalk.bold.red('Mutant survived!'));\r\n                    _this.logMutantResult(result, writeLineFn);\r\n                    break;\r\n                case report_1.MutantStatus.NoCoverage:\r\n                    _this.writeLine(chalk.bold.yellow('Mutant survived! (no coverage)'));\r\n                    _this.logMutantResult(result, writeLineFn);\r\n                    break;\r\n            }\r\n        });\r\n        this.writeLine(\"Ran \" + (totalTests / mutantResults.length).toFixed(2) + \" tests per mutant on average.\");\r\n    };\r\n    ClearTextReporter.prototype.logMutantResult = function (result, logImplementation) {\r\n        logImplementation(result.sourceFilePath + ': line ' + result.location.start.line + ':' + result.location.start.column);\r\n        logImplementation('Mutator: ' + result.mutatorName);\r\n        result.originalLines.split('\\n').forEach(function (line) {\r\n            logImplementation(chalk.red('-   ' + line));\r\n        });\r\n        result.mutatedLines.split('\\n').forEach(function (line) {\r\n            logImplementation(chalk.green('+   ' + line));\r\n        });\r\n        logImplementation('');\r\n        if (this.options.coverageAnalysis === 'perTest') {\r\n            this.logExecutedTests(result, logImplementation);\r\n        }\r\n        else if (result.testsRan && result.testsRan.length > 0) {\r\n            logImplementation('Ran all tests for this mutant.');\r\n        }\r\n    };\r\n    ClearTextReporter.prototype.logExecutedTests = function (result, logImplementation) {\r\n        var clearTextReporterConfig = this.options['clearTextReporter'];\r\n        if (result.testsRan && result.testsRan.length > 0) {\r\n            var testsToLog = 3;\r\n            if (clearTextReporterConfig && typeof clearTextReporterConfig.maxTestsToLog === 'number') {\r\n                testsToLog = clearTextReporterConfig.maxTestsToLog;\r\n            }\r\n            if (testsToLog > 0) {\r\n                logImplementation('Tests ran: ');\r\n                for (var i = 0; i < testsToLog; i++) {\r\n                    if (i > result.testsRan.length - 1) {\r\n                        break;\r\n                    }\r\n                    logImplementation('    ' + result.testsRan[i]);\r\n                }\r\n                if (testsToLog < result.testsRan.length) {\r\n                    logImplementation(\"  and \" + (result.testsRan.length - testsToLog) + \" more tests!\");\r\n                }\r\n                logImplementation('');\r\n            }\r\n        }\r\n    };\r\n    ClearTextReporter.prototype.onScoreCalculated = function (score) {\r\n        this.writeLine(new ClearTextScoreTable_1.default(score).draw());\r\n    };\r\n    return ClearTextReporter;\r\n}());\r\nexports.default = ClearTextReporter;\r\n//# sourceMappingURL=ClearTextReporter.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\reporters\\ClearTextScoreTable.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar os = require(\"os\");\r\nvar _ = require(\"lodash\");\r\nvar chalk = require(\"chalk\");\r\nvar FILES_ROOT_NAME = 'All files';\r\nvar repeat = function (char, nTimes) { return new Array(nTimes > -1 ? nTimes + 1 : 0).join(char); };\r\nvar spaces = function (n) { return repeat(' ', n); };\r\nvar dots = function (n) { return repeat('.', n); };\r\n/**\r\n * Represents a column in the clear text table\r\n */\r\nvar Column = (function () {\r\n    function Column(header, valueFactory, rows) {\r\n        this.header = header;\r\n        this.valueFactory = valueFactory;\r\n        this.rows = rows;\r\n        var maxContentSize = this.determineValueSize();\r\n        this.width = this.pad(dots(maxContentSize)).length;\r\n    }\r\n    Column.prototype.determineValueSize = function (row, ancestorCount) {\r\n        var _this = this;\r\n        if (row === void 0) { row = this.rows; }\r\n        if (ancestorCount === void 0) { ancestorCount = 0; }\r\n        var valueWidths = row.childResults.map(function (child) { return _this.determineValueSize(child, ancestorCount + 1); });\r\n        valueWidths.push(this.header.length);\r\n        valueWidths.push(this.valueFactory(row, ancestorCount).length);\r\n        return Math.max.apply(Math, valueWidths);\r\n    };\r\n    /**\r\n     * Adds padding (spaces) to the front and end of a value\r\n     * @param input The string input\r\n     */\r\n    Column.prototype.pad = function (input) {\r\n        return spaces(this.width - input.length - 2) + \" \" + input + \" \";\r\n    };\r\n    Column.prototype.drawLine = function () {\r\n        return repeat('-', this.width);\r\n    };\r\n    Column.prototype.drawTableCell = function (score, ancestorCount) {\r\n        return this.color(score)(this.pad(this.valueFactory(score, ancestorCount)));\r\n    };\r\n    Column.prototype.drawHeader = function () {\r\n        return this.pad(this.header);\r\n    };\r\n    Column.prototype.color = function (score) {\r\n        return function (input) { return input; };\r\n    };\r\n    return Column;\r\n}());\r\nvar MutationScoreColumn = (function (_super) {\r\n    tslib_1.__extends(MutationScoreColumn, _super);\r\n    function MutationScoreColumn(rows) {\r\n        return _super.call(this, '% score', function (row) { return row.mutationScore.toFixed(2); }, rows) || this;\r\n    }\r\n    MutationScoreColumn.prototype.color = function (score) {\r\n        if (score.mutationScore >= 80) {\r\n            return chalk.green;\r\n        }\r\n        else if (score.mutationScore >= 60) {\r\n            return chalk.yellow;\r\n        }\r\n        else {\r\n            return chalk.red;\r\n        }\r\n    };\r\n    return MutationScoreColumn;\r\n}(Column));\r\nvar FileColumn = (function (_super) {\r\n    tslib_1.__extends(FileColumn, _super);\r\n    function FileColumn(rows) {\r\n        return _super.call(this, 'File', function (row, ancestorCount) { return spaces(ancestorCount) + (ancestorCount === 0 ? FILES_ROOT_NAME : row.name); }, rows) || this;\r\n    }\r\n    FileColumn.prototype.pad = function (input) {\r\n        return input + \" \" + spaces(this.width - input.length - 1);\r\n    };\r\n    return FileColumn;\r\n}(Column));\r\n/**\r\n * Represents a clear text table for mutation score\r\n */\r\nvar ClearTextScoreTable = (function () {\r\n    function ClearTextScoreTable(score) {\r\n        this.score = score;\r\n        this.columns = [\r\n            new FileColumn(score),\r\n            new MutationScoreColumn(score),\r\n            new Column('# killed', function (row) { return row.killed.toString(); }, score),\r\n            new Column('# timeout', function (row) { return row.timedOut.toString(); }, score),\r\n            new Column('# survived', function (row) { return row.survived.toString(); }, score),\r\n            new Column('# no cov', function (row) { return row.noCoverage.toString(); }, score),\r\n            new Column('# error', function (row) { return row.errors.toString(); }, score)\r\n        ];\r\n    }\r\n    ClearTextScoreTable.prototype.drawBorder = function () {\r\n        return this.drawRow(function (column) { return column.drawLine(); });\r\n    };\r\n    ClearTextScoreTable.prototype.drawHeader = function () {\r\n        return this.drawRow(function (c) { return c.drawHeader(); });\r\n    };\r\n    ClearTextScoreTable.prototype.drawRow = function (toDraw) {\r\n        return this.columns.map(toDraw).join('|') + '|';\r\n    };\r\n    ClearTextScoreTable.prototype.drawValues = function (current, ancestorCount) {\r\n        var _this = this;\r\n        if (current === void 0) { current = this.score; }\r\n        if (ancestorCount === void 0) { ancestorCount = 0; }\r\n        return [this.drawRow(function (c) { return c.drawTableCell(current, ancestorCount); })]\r\n            .concat(_.flatMap(current.childResults, function (child) { return _this.drawValues(child, ancestorCount + 1); }));\r\n    };\r\n    /**\r\n     * Returns a string with the score results drawn in a table.\r\n     */\r\n    ClearTextScoreTable.prototype.draw = function () {\r\n        return [\r\n            this.drawBorder(),\r\n            this.drawHeader(),\r\n            this.drawBorder(),\r\n            this.drawValues().join(os.EOL),\r\n            this.drawBorder()\r\n        ].join(os.EOL);\r\n    };\r\n    return ClearTextScoreTable;\r\n}());\r\nexports.default = ClearTextScoreTable;\r\n//# sourceMappingURL=ClearTextScoreTable.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\reporters\\DotsReporter.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar report_1 = require(\"stryker-api/report\");\r\nvar chalk = require(\"chalk\");\r\nvar os = require(\"os\");\r\nvar DotsReporter = (function () {\r\n    function DotsReporter() {\r\n    }\r\n    DotsReporter.prototype.onMutantTested = function (result) {\r\n        var toLog;\r\n        switch (result.status) {\r\n            case report_1.MutantStatus.Killed:\r\n                toLog = '.';\r\n                break;\r\n            case report_1.MutantStatus.TimedOut:\r\n                toLog = chalk.yellow('T');\r\n                break;\r\n            case report_1.MutantStatus.Survived:\r\n                toLog = chalk.bold.red('S');\r\n                break;\r\n            case report_1.MutantStatus.Error:\r\n                toLog = chalk.yellow('E');\r\n                break;\r\n            default:\r\n                toLog = '';\r\n                break;\r\n        }\r\n        process.stdout.write(toLog);\r\n    };\r\n    DotsReporter.prototype.onAllMutantsTested = function () {\r\n        process.stdout.write(os.EOL);\r\n    };\r\n    return DotsReporter;\r\n}());\r\nexports.default = DotsReporter;\r\n//# sourceMappingURL=DotsReporter.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\reporters\\EventRecorderReporter.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar log4js = require(\"log4js\");\r\nvar path = require(\"path\");\r\nvar fs = require(\"mz/fs\");\r\nvar fileUtils_1 = require(\"../utils/fileUtils\");\r\nvar log = log4js.getLogger('EventRecorderReporter');\r\nvar DEFAULT_BASE_FOLDER = 'reports/mutation/events';\r\nvar EventRecorderReporter = (function () {\r\n    function EventRecorderReporter(options) {\r\n        this.options = options;\r\n        this.allWork = [];\r\n        this.index = 0;\r\n        this.createBaseFolderTask = fileUtils_1.cleanFolder(this.baseFolder);\r\n    }\r\n    Object.defineProperty(EventRecorderReporter.prototype, \"baseFolder\", {\r\n        get: function () {\r\n            if (!this._baseFolder) {\r\n                if (this.options['eventReporter'] && this.options['eventReporter']['baseDir']) {\r\n                    this._baseFolder = this.options['eventReporter']['baseDir'];\r\n                    log.debug(\"Using configured output folder \" + this._baseFolder);\r\n                }\r\n                else {\r\n                    log.debug(\"No base folder configuration found (using configuration: eventReporter: { baseDir: 'output/folder' }), using default \" + DEFAULT_BASE_FOLDER);\r\n                    this._baseFolder = DEFAULT_BASE_FOLDER;\r\n                }\r\n            }\r\n            return this._baseFolder;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    EventRecorderReporter.prototype.writeToFile = function (methodName, data) {\r\n        var filename = path.join(this.baseFolder, this.format(this.index++) + \"-\" + methodName + \".json\");\r\n        log.debug(\"Writing event \" + methodName + \" to file \" + filename);\r\n        return fs.writeFile(filename, JSON.stringify(data), { encoding: 'utf8' });\r\n    };\r\n    EventRecorderReporter.prototype.format = function (input) {\r\n        var str = input.toString();\r\n        for (var i = 10000; i > 1; i = i / 10) {\r\n            if (i > input) {\r\n                str = '0' + str;\r\n            }\r\n        }\r\n        return str;\r\n    };\r\n    EventRecorderReporter.prototype.work = function (eventName, data) {\r\n        var _this = this;\r\n        this.allWork.push(this.createBaseFolderTask.then(function () { return _this.writeToFile(eventName, data); }));\r\n    };\r\n    EventRecorderReporter.prototype.onSourceFileRead = function (file) {\r\n        this.work('onSourceFileRead', file);\r\n    };\r\n    EventRecorderReporter.prototype.onAllSourceFilesRead = function (files) {\r\n        this.work('onAllSourceFilesRead', files);\r\n    };\r\n    EventRecorderReporter.prototype.onAllMutantsMatchedWithTests = function (results) {\r\n        this.work('onAllMutantsMatchedWithTests', results);\r\n    };\r\n    EventRecorderReporter.prototype.onMutantTested = function (result) {\r\n        this.work('onMutantTested', result);\r\n    };\r\n    EventRecorderReporter.prototype.onScoreCalculated = function (score) {\r\n        this.work('onScoreCalculated', score);\r\n    };\r\n    EventRecorderReporter.prototype.onAllMutantsTested = function (results) {\r\n        this.work('onAllMutantsTested', results);\r\n    };\r\n    EventRecorderReporter.prototype.wrapUp = function () {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.createBaseFolderTask];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2 /*return*/, Promise.all(this.allWork)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    return EventRecorderReporter;\r\n}());\r\nexports.default = EventRecorderReporter;\r\n//# sourceMappingURL=EventRecorderReporter.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\reporters\\ProgressAppendOnlyReporter.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar os = require(\"os\");\r\nvar ProgressKeeper_1 = require(\"./ProgressKeeper\");\r\nvar Timer_1 = require(\"../utils/Timer\");\r\nvar ProgressAppendOnlyReporter = (function (_super) {\r\n    tslib_1.__extends(ProgressAppendOnlyReporter, _super);\r\n    function ProgressAppendOnlyReporter() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ProgressAppendOnlyReporter.prototype.onAllMutantsMatchedWithTests = function (matchedMutants) {\r\n        var _this = this;\r\n        _super.prototype.onAllMutantsMatchedWithTests.call(this, matchedMutants);\r\n        this.timer = new Timer_1.default();\r\n        this.intervalReference = setInterval(function () { return _this.render(); }, 10000);\r\n    };\r\n    ProgressAppendOnlyReporter.prototype.onAllMutantsTested = function () {\r\n        clearInterval(this.intervalReference);\r\n    };\r\n    ProgressAppendOnlyReporter.prototype.render = function () {\r\n        process.stdout.write(\"Mutation testing \" + this.procent() + \" (ETC \" + this.etc() + \") \" +\r\n            (\"[\" + this.progress.killed + \" \" + this.progress.killedLabel + \"] \") +\r\n            (\"[\" + this.progress.survived + \" \" + this.progress.survivedLabel + \"] \") +\r\n            (\"[\" + this.progress.noCoverage + \" \" + this.progress.noCoverageLabel + \"] \") +\r\n            (\"[\" + this.progress.timeout + \" \" + this.progress.timeoutLabel + \"] \") +\r\n            (\"[\" + this.progress.error + \" \" + this.progress.errorLabel + \"]\") +\r\n            os.EOL);\r\n    };\r\n    ProgressAppendOnlyReporter.prototype.procent = function () {\r\n        return Math.floor(this.progress.testedCount / this.progress.totalCount * 100) + '%';\r\n    };\r\n    ProgressAppendOnlyReporter.prototype.etc = function () {\r\n        var etcSeconds = Math.floor(this.timer.elapsedSeconds() / this.progress.testedCount * (this.progress.totalCount - this.progress.testedCount));\r\n        if (isFinite(etcSeconds)) {\r\n            return etcSeconds + 's';\r\n        }\r\n        else {\r\n            return 'n/a';\r\n        }\r\n    };\r\n    return ProgressAppendOnlyReporter;\r\n}(ProgressKeeper_1.default));\r\nexports.default = ProgressAppendOnlyReporter;\r\n//# sourceMappingURL=ProgressAppendOnlyReporter.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\reporters\\ProgressBar.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ProgressBar = require(\"progress\");\r\nexports.default = ProgressBar;\r\n//# sourceMappingURL=ProgressBar.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\reporters\\ProgressKeeper.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar chalk = require(\"chalk\");\r\nvar report_1 = require(\"stryker-api/report\");\r\nvar ProgressKeeper = (function () {\r\n    function ProgressKeeper() {\r\n        // progress contains Labels, because on initation of the ProgressBar the width is determined based on the amount of characters of the progressBarContent inclusive ASCII-codes for colors\r\n        this.progress = {\r\n            error: 0,\r\n            survived: 0,\r\n            killed: 0,\r\n            timeout: 0,\r\n            noCoverage: 0,\r\n            testedCount: 0,\r\n            totalCount: 0,\r\n            killedLabel: chalk.green.bold('killed'),\r\n            survivedLabel: chalk.red.bold('survived'),\r\n            noCoverageLabel: chalk.red.bold('no coverage'),\r\n            timeoutLabel: chalk.yellow.bold('timeout'),\r\n            errorLabel: chalk.yellow.bold('error')\r\n        };\r\n    }\r\n    ProgressKeeper.prototype.onAllMutantsMatchedWithTests = function (matchedMutants) {\r\n        this.progress.totalCount = matchedMutants.filter(function (m) { return m.scopedTestIds.length > 0; }).length;\r\n    };\r\n    ProgressKeeper.prototype.onMutantTested = function (result) {\r\n        this.progress.testedCount++;\r\n        switch (result.status) {\r\n            case report_1.MutantStatus.NoCoverage:\r\n                this.progress.testedCount--; // correct for not tested, because no coverage\r\n                this.progress.noCoverage++;\r\n                break;\r\n            case report_1.MutantStatus.Killed:\r\n                this.progress.killed++;\r\n                break;\r\n            case report_1.MutantStatus.Survived:\r\n                this.progress.survived++;\r\n                break;\r\n            case report_1.MutantStatus.TimedOut:\r\n                this.progress.timeout++;\r\n                break;\r\n            case report_1.MutantStatus.Error:\r\n                this.progress.error++;\r\n                break;\r\n        }\r\n    };\r\n    return ProgressKeeper;\r\n}());\r\nexports.default = ProgressKeeper;\r\n//# sourceMappingURL=ProgressKeeper.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\reporters\\ProgressReporter.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar ProgressKeeper_1 = require(\"./ProgressKeeper\");\r\nvar ProgressBar_1 = require(\"./ProgressBar\");\r\nvar ProgressBarReporter = (function (_super) {\r\n    tslib_1.__extends(ProgressBarReporter, _super);\r\n    function ProgressBarReporter() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ProgressBarReporter.prototype.onAllMutantsMatchedWithTests = function (matchedMutants) {\r\n        _super.prototype.onAllMutantsMatchedWithTests.call(this, matchedMutants);\r\n        var progressBarContent = \"Mutation testing  [:bar] :percent (ETC :etas)\" +\r\n            \"[:killed :killedLabel] \" +\r\n            \"[:survived :survivedLabel] \" +\r\n            \"[:noCoverage :noCoverageLabel] \" +\r\n            \"[:timeout :timeoutLabel] \" +\r\n            \"[:error :errorLabel]\";\r\n        this.progressBar = new ProgressBar_1.default(progressBarContent, {\r\n            width: 50,\r\n            complete: '=',\r\n            incomplete: ' ',\r\n            stream: process.stdout,\r\n            total: this.progress.totalCount\r\n        });\r\n    };\r\n    ProgressBarReporter.prototype.onMutantTested = function (result) {\r\n        var ticksBefore = this.progress.testedCount;\r\n        _super.prototype.onMutantTested.call(this, result);\r\n        if (ticksBefore < this.progress.testedCount) {\r\n            this.tick();\r\n        }\r\n        else {\r\n            this.render();\r\n        }\r\n    };\r\n    ProgressBarReporter.prototype.tick = function () {\r\n        this.progressBar.tick(this.progress);\r\n    };\r\n    ProgressBarReporter.prototype.render = function () {\r\n        this.progressBar.render(this.progress);\r\n    };\r\n    return ProgressBarReporter;\r\n}(ProgressKeeper_1.default));\r\nexports.default = ProgressBarReporter;\r\n//# sourceMappingURL=ProgressReporter.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\reporters\\StrictReporter.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n//# sourceMappingURL=StrictReporter.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\Sandbox.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar path = require(\"path\");\r\nvar log4js = require(\"log4js\");\r\nvar _ = require(\"lodash\");\r\nvar mkdirp = require(\"mkdirp\");\r\nvar objectUtils_1 = require(\"./utils/objectUtils\");\r\nvar fileUtils_1 = require(\"./utils/fileUtils\");\r\nvar ResilientTestRunnerFactory_1 = require(\"./isolated-runner/ResilientTestRunnerFactory\");\r\nvar StrykerTempFolder_1 = require(\"./utils/StrykerTempFolder\");\r\nvar log = log4js.getLogger('Sandbox');\r\nvar Sandbox = (function () {\r\n    function Sandbox(options, index, files, testFramework, coverageInstrumenter) {\r\n        this.options = options;\r\n        this.index = index;\r\n        this.files = files;\r\n        this.testFramework = testFramework;\r\n        this.coverageInstrumenter = coverageInstrumenter;\r\n        this.workingFolder = StrykerTempFolder_1.default.createRandomFolder('sandbox');\r\n        log.debug('Creating a sandbox for files in %s', this.workingFolder);\r\n        this.testHooksFile = path.join(this.workingFolder, '___testHooksForStryker.js');\r\n    }\r\n    Sandbox.prototype.initialize = function () {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.fillSandbox()];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2 /*return*/, this.initializeTestRunner()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Sandbox.prototype.run = function (timeout) {\r\n        return this.testRunner.run({ timeout: timeout });\r\n    };\r\n    Sandbox.prototype.dispose = function () {\r\n        return this.testRunner.dispose() || Promise.resolve();\r\n    };\r\n    Sandbox.prototype.runMutant = function (mutant) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var targetedFile, runResult;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        targetedFile = this.fileMap[mutant.filename];\r\n                        return [4 /*yield*/, Promise.all([mutant.save(targetedFile), this.filterTests(mutant)])];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [4 /*yield*/, this.run(this.calculateTimeout(mutant))];\r\n                    case 2:\r\n                        runResult = _a.sent();\r\n                        return [4 /*yield*/, mutant.reset(targetedFile)];\r\n                    case 3:\r\n                        _a.sent();\r\n                        return [2 /*return*/, runResult];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Sandbox.prototype.fillSandbox = function () {\r\n        var _this = this;\r\n        this.fileMap = Object.create(null);\r\n        var copyPromises = this.files\r\n            .map(function (file) { return _this.copyFile(file); });\r\n        if (this.coverageInstrumenter) {\r\n            copyPromises.push(StrykerTempFolder_1.default.writeFile(this.testHooksFile, this.coverageInstrumenter.hooksForTestRun()));\r\n        }\r\n        else {\r\n            copyPromises.push(StrykerTempFolder_1.default.writeFile(this.testHooksFile, ''));\r\n        }\r\n        return Promise.all(copyPromises);\r\n    };\r\n    Sandbox.prototype.copyFile = function (file) {\r\n        if (fileUtils_1.isOnlineFile(file.path)) {\r\n            this.fileMap[file.path] = file.path;\r\n            return Promise.resolve();\r\n        }\r\n        else {\r\n            var cwd = process.cwd();\r\n            var relativePath = file.path.substr(cwd.length);\r\n            var folderName = this.workingFolder + path.dirname(relativePath);\r\n            mkdirp.sync(folderName);\r\n            var targetFile = path.join(folderName, path.basename(relativePath));\r\n            this.fileMap[file.path] = targetFile;\r\n            var instrumentingStream = this.coverageInstrumenter ?\r\n                this.coverageInstrumenter.instrumenterStreamForFile(file) : null;\r\n            return StrykerTempFolder_1.default.copyFile(file.path, targetFile, instrumentingStream);\r\n        }\r\n    };\r\n    Sandbox.prototype.initializeTestRunner = function () {\r\n        var _this = this;\r\n        var files = this.files.map(function (originalFile) { return _.assign(_.cloneDeep(originalFile), { path: _this.fileMap[originalFile.path] }); });\r\n        files.unshift({ path: this.testHooksFile, mutated: false, included: true });\r\n        var settings = {\r\n            files: files,\r\n            strykerOptions: this.options,\r\n            port: this.options.port + this.index,\r\n            sandboxWorkingFolder: this.workingFolder\r\n        };\r\n        log.debug(\"Creating test runner %s using settings {port: %s}\", this.index, settings.port);\r\n        this.testRunner = ResilientTestRunnerFactory_1.default.create(settings.strykerOptions.testRunner || '', settings);\r\n        return this.testRunner.init();\r\n    };\r\n    Sandbox.prototype.calculateTimeout = function (mutant) {\r\n        var baseTimeout = mutant.timeSpentScopedTests;\r\n        return (this.options.timeoutFactor * baseTimeout) + this.options.timeoutMs;\r\n    };\r\n    Sandbox.prototype.filterTests = function (mutant) {\r\n        if (this.testFramework) {\r\n            var fileContent = objectUtils_1.wrapInClosure(this.testFramework.filter(mutant.scopedTestIds));\r\n            return StrykerTempFolder_1.default.writeFile(this.testHooksFile, fileContent);\r\n        }\r\n        else {\r\n            return Promise.resolve(void 0);\r\n        }\r\n    };\r\n    return Sandbox;\r\n}());\r\nexports.default = Sandbox;\r\n//# sourceMappingURL=Sandbox.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\SandboxCoordinator.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar log4js = require(\"log4js\");\r\nvar os = require(\"os\");\r\nvar _ = require(\"lodash\");\r\nvar test_runner_1 = require(\"stryker-api/test_runner\");\r\nvar report_1 = require(\"stryker-api/report\");\r\nvar objectUtils_1 = require(\"./utils/objectUtils\");\r\nvar Sandbox_1 = require(\"./Sandbox\");\r\nvar PromisePool = require('es6-promise-pool');\r\nvar log = log4js.getLogger('SandboxCoordinator');\r\n// The initial run might take a while.\r\n// For example: angular-bootstrap takes up to 45 seconds.\r\n// Lets take 5 minutes just to be sure\r\nvar INITIAL_RUN_TIMEOUT = 60 * 1000 * 5;\r\nvar SandboxCoordinator = (function () {\r\n    function SandboxCoordinator(options, files, testFramework, reporter) {\r\n        this.options = options;\r\n        this.files = files;\r\n        this.testFramework = testFramework;\r\n        this.reporter = reporter;\r\n    }\r\n    SandboxCoordinator.prototype.initialRun = function (coverageInstrumenter) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            return tslib_1.__generator(this, function (_a) {\r\n                if (this.files.length > 0) {\r\n                    log.info(\"Starting initial test run. This may take a while.\");\r\n                    return [2 /*return*/, this.startTestRun(coverageInstrumenter)];\r\n                }\r\n                else {\r\n                    log.info(\"No files have been found. Aborting initial test run.\");\r\n                    return [2 /*return*/, this.createDryRunResult()];\r\n                }\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    SandboxCoordinator.prototype.runMutants = function (mutants) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var _this = this;\r\n            var results, sandboxes, promiseProducer;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        mutants = _.clone(mutants); // work with a copy because we're changing state (pop'ing values)\r\n                        results = [];\r\n                        return [4 /*yield*/, this.createSandboxes()];\r\n                    case 1:\r\n                        sandboxes = _a.sent();\r\n                        promiseProducer = function () {\r\n                            var mutant = mutants.shift();\r\n                            if (!mutant) {\r\n                                return null; // we're done\r\n                            }\r\n                            else {\r\n                                if (mutant.scopedTestIds.length > 0) {\r\n                                    var sandbox_1 = sandboxes.shift();\r\n                                    if (sandbox_1) {\r\n                                        return sandbox_1.runMutant(mutant)\r\n                                            .then(function (runResult) {\r\n                                            _this.reportMutantTested(mutant, runResult, results);\r\n                                            sandboxes.push(sandbox_1); // mark the sandbox as available again\r\n                                        });\r\n                                    }\r\n                                    else {\r\n                                        return null;\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    _this.reportMutantTested(mutant, null, results);\r\n                                    return Promise.resolve();\r\n                                }\r\n                            }\r\n                        };\r\n                        return [4 /*yield*/, new PromisePool(promiseProducer, sandboxes.length).start()];\r\n                    case 2:\r\n                        _a.sent();\r\n                        return [4 /*yield*/, this.reportAllMutantsTested(results)];\r\n                    case 3:\r\n                        _a.sent();\r\n                        return [4 /*yield*/, Promise.all(sandboxes.map(function (sandbox) { return sandbox.dispose(); }))];\r\n                    case 4:\r\n                        _a.sent();\r\n                        return [2 /*return*/, results];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    SandboxCoordinator.prototype.createSandboxes = function () {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var numConcurrentRunners, numConcurrentRunnersSource, sandboxes, i;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        numConcurrentRunners = os.cpus().length;\r\n                        numConcurrentRunnersSource = 'CPU count';\r\n                        if (numConcurrentRunners > this.options.maxConcurrentTestRunners && this.options.maxConcurrentTestRunners > 0) {\r\n                            numConcurrentRunners = this.options.maxConcurrentTestRunners;\r\n                            numConcurrentRunnersSource = 'maxConcurrentTestRunners config';\r\n                        }\r\n                        sandboxes = [];\r\n                        for (i = 0; i < numConcurrentRunners; i++) {\r\n                            sandboxes.push(new Sandbox_1.default(this.options, i, this.files, this.testFramework, null));\r\n                        }\r\n                        log.info(\"Creating \" + numConcurrentRunners + \" test runners (based on \" + numConcurrentRunnersSource + \")\");\r\n                        return [4 /*yield*/, Promise.all(sandboxes.map(function (s) { return s.initialize(); }))];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2 /*return*/, sandboxes];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    SandboxCoordinator.prototype.startTestRun = function (coverageInstrumenter) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var sandbox, runResult;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        sandbox = new Sandbox_1.default(this.options, 0, this.files, this.testFramework, coverageInstrumenter);\r\n                        return [4 /*yield*/, sandbox.initialize()];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [4 /*yield*/, sandbox.run(INITIAL_RUN_TIMEOUT)];\r\n                    case 2:\r\n                        runResult = _a.sent();\r\n                        return [4 /*yield*/, sandbox.dispose()];\r\n                    case 3:\r\n                        _a.sent();\r\n                        return [2 /*return*/, runResult];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    SandboxCoordinator.prototype.createDryRunResult = function () {\r\n        return {\r\n            status: test_runner_1.RunStatus.Complete,\r\n            tests: [],\r\n            errorMessages: []\r\n        };\r\n    };\r\n    SandboxCoordinator.prototype.reportMutantTested = function (mutant, runResult, results) {\r\n        var result = this.collectFrozenMutantResult(mutant, runResult);\r\n        results.push(result);\r\n        this.reporter.onMutantTested(result);\r\n    };\r\n    SandboxCoordinator.prototype.collectFrozenMutantResult = function (mutant, runResult) {\r\n        var status = report_1.MutantStatus.NoCoverage;\r\n        var testNames;\r\n        if (runResult) {\r\n            switch (runResult.status) {\r\n                case test_runner_1.RunStatus.Timeout:\r\n                    status = report_1.MutantStatus.TimedOut;\r\n                    break;\r\n                case test_runner_1.RunStatus.Error:\r\n                    status = report_1.MutantStatus.Error;\r\n                    break;\r\n                case test_runner_1.RunStatus.Complete:\r\n                    if (runResult.tests.some(function (t) { return t.status === test_runner_1.TestStatus.Failed; })) {\r\n                        status = report_1.MutantStatus.Killed;\r\n                    }\r\n                    else {\r\n                        status = report_1.MutantStatus.Survived;\r\n                    }\r\n                    break;\r\n            }\r\n            testNames = runResult.tests\r\n                .filter(function (t) { return t.status !== test_runner_1.TestStatus.Skipped; })\r\n                .map(function (t) { return t.name; });\r\n        }\r\n        else {\r\n            testNames = [];\r\n        }\r\n        var result = {\r\n            sourceFilePath: mutant.filename,\r\n            mutatorName: mutant.mutatorName,\r\n            status: status,\r\n            replacement: mutant.replacement,\r\n            location: mutant.location,\r\n            range: mutant.range,\r\n            testsRan: testNames,\r\n            originalLines: mutant.originalLines,\r\n            mutatedLines: mutant.mutatedLines,\r\n        };\r\n        objectUtils_1.freezeRecursively(result);\r\n        return result;\r\n    };\r\n    SandboxCoordinator.prototype.reportAllMutantsTested = function (results) {\r\n        objectUtils_1.freezeRecursively(results);\r\n        this.reporter.onAllMutantsTested(results);\r\n    };\r\n    return SandboxCoordinator;\r\n}());\r\nexports.default = SandboxCoordinator;\r\n//# sourceMappingURL=SandboxCoordinator.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\ScoreResultCalculator.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar report_1 = require(\"stryker-api/report\");\r\nvar objectUtils_1 = require(\"./utils/objectUtils\");\r\nvar _ = require(\"lodash\");\r\nvar path = require(\"path\");\r\nvar ScoreResultCalculator = (function () {\r\n    function ScoreResultCalculator() {\r\n    }\r\n    ScoreResultCalculator.calculate = function (results) {\r\n        return this.calculateScoreResult(results, '');\r\n    };\r\n    ScoreResultCalculator.calculateScoreResult = function (results, basePath) {\r\n        var numbers = this.countNumbers(results);\r\n        var facts = this.determineFacts(basePath, results);\r\n        return objectUtils_1.freezeRecursively(_.assign(numbers, facts));\r\n    };\r\n    ScoreResultCalculator.determineFacts = function (basePath, results) {\r\n        var name = this.determineCommonBasePath(results, basePath);\r\n        var childResults = this.calculateChildScores(results, name, basePath);\r\n        return {\r\n            name: name,\r\n            path: path.join(basePath, name),\r\n            childResults: childResults,\r\n            representsFile: childResults.length === 0\r\n        };\r\n    };\r\n    ScoreResultCalculator.compareScoreResults = function (a, b) {\r\n        var sortValue = function (scoreResult) {\r\n            // Directories first\r\n            if (scoreResult.representsFile) {\r\n                return \"1\" + scoreResult.name;\r\n            }\r\n            else {\r\n                return \"0\" + scoreResult.name;\r\n            }\r\n        };\r\n        return sortValue(a).localeCompare(sortValue(b));\r\n    };\r\n    ScoreResultCalculator.calculateChildScores = function (results, parentName, basePath) {\r\n        var _this = this;\r\n        var childrenBasePath = parentName.length ? path.join(basePath, parentName) + path.sep : '';\r\n        var resultsGroupedByFiles = _.groupBy(results, function (result) { return result.sourceFilePath.substr(childrenBasePath.length); });\r\n        var uniqueFiles = Object.keys(resultsGroupedByFiles);\r\n        if (uniqueFiles.length > 1) {\r\n            var filesGroupedByDirectory_1 = _.groupBy(uniqueFiles, function (file) { return file.split(path.sep)[0]; });\r\n            return Object.keys(filesGroupedByDirectory_1)\r\n                .map(function (directory) { return _this.calculateScoreResult(_.flatMap(filesGroupedByDirectory_1[directory], function (file) { return resultsGroupedByFiles[file]; }), childrenBasePath); })\r\n                .sort(this.compareScoreResults);\r\n        }\r\n        else {\r\n            return [];\r\n        }\r\n    };\r\n    ScoreResultCalculator.determineCommonBasePath = function (results, basePath) {\r\n        var uniqueFiles = _.uniq(results.map(function (result) { return result.sourceFilePath; }));\r\n        var uniqueFileDirectories = uniqueFiles.map(function (file) { return file.substr(basePath.length).split(path.sep); });\r\n        if (uniqueFileDirectories.length) {\r\n            return uniqueFileDirectories\r\n                .reduce(function (previousDirectories, currentDirectories) { return previousDirectories.filter(function (token, index) { return currentDirectories[index] === token; }); })\r\n                .join(path.sep);\r\n        }\r\n        else {\r\n            return '';\r\n        }\r\n    };\r\n    ScoreResultCalculator.countNumbers = function (mutantResults) {\r\n        var count = function (mutantResult) { return mutantResults.filter(function (_) { return _.status === mutantResult; }).length; };\r\n        var killed = count(report_1.MutantStatus.Killed);\r\n        var timedOut = count(report_1.MutantStatus.TimedOut);\r\n        var survived = count(report_1.MutantStatus.Survived);\r\n        var noCoverage = count(report_1.MutantStatus.NoCoverage);\r\n        var errors = count(report_1.MutantStatus.Error);\r\n        var totalDetected = timedOut + killed;\r\n        var totalUndetected = survived + noCoverage;\r\n        var totalMutants = totalDetected + totalUndetected;\r\n        var totalCovered = totalDetected + survived;\r\n        return {\r\n            killed: killed,\r\n            survived: survived,\r\n            noCoverage: noCoverage,\r\n            errors: errors,\r\n            timedOut: timedOut,\r\n            totalDetected: totalDetected,\r\n            totalUndetected: totalUndetected,\r\n            totalMutants: totalMutants,\r\n            totalCovered: totalCovered,\r\n            mutationScore: totalDetected / totalMutants * 100 || 0,\r\n            mutationScoreBasedOnCoveredCode: totalDetected / totalCovered * 100 || 0\r\n        };\r\n    };\r\n    return ScoreResultCalculator;\r\n}());\r\nexports.default = ScoreResultCalculator;\r\n//# sourceMappingURL=ScoreResultCalculator.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\stryker-cli.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar program = require(\"commander\");\r\nvar ConfigReader_1 = require(\"./ConfigReader\");\r\nvar Stryker_1 = require(\"./Stryker\");\r\nvar StrykerInitializer_1 = require(\"./initializer/StrykerInitializer\");\r\nvar log4js = require(\"log4js\");\r\nvar log = log4js.getLogger('stryker-cli');\r\nvar command = '', strykerConfig = null;\r\nfunction list(val) {\r\n    return val.split(',');\r\n}\r\nprogram\r\n    .version(require('../package.json').version)\r\n    .usage('<command> [options] [stryker.conf.js]')\r\n    .description(\"Possible commands: \\n    run: Run mutation testing\\n    init: Initalize Stryker for your project\\n\\nOptional location to the stryker.conf.js file as last argument. That file should export a function which accepts a \\\"config\\\" object\\n\" + ConfigReader_1.CONFIG_SYNTAX_HELP)\r\n    .arguments('<command> [stryker.conf.js]')\r\n    .action(function (cmd, config) {\r\n    command = cmd;\r\n    strykerConfig = config;\r\n})\r\n    .option('-f, --files <allFiles>', \"A comma seperated list of globbing expression used for selecting all files needed to run the tests. For a more detailed way of selecting inputfiles, please use a configFile.\\n  Example: node_modules/a-lib/**/*.js,src/**/*.js,!src/index.js,a.js,test/**/*.js\", list)\r\n    .option('-m, --mutate <filesToMutate>', \"A comma seperated list of globbing expression used for selecting the files that should be mutated.\\n  Example: src/**/*.js,a.js\", list)\r\n    .option('--coverageAnalysis <perTest|all|off>', \"The coverage analysis strategy you want to use. Default value: \\\"perTest\\\"\")\r\n    .option('--testFramework <name>', \"The name of the test framework you want to use.\")\r\n    .option('--testRunner <name>', \"The name of the test runner you want to use\")\r\n    .option('--reporter <name>', 'A comma separated list of the names of the reporter(s) you want to use', list)\r\n    .option('--plugins <listOfPlugins>', 'A list of plugins you want stryker to load (`require`).', list)\r\n    .option('--port <n>', 'A free port for the test runner to use (if it needs to). Any additional test runners will be spawned using n+1, n+2, etc', parseInt)\r\n    .option('--timeoutMs <number>', 'Tweak the absolute timeout used to wait for a test runner to complete', parseInt)\r\n    .option('--timeoutFactor <number>', 'Tweak the standard deviation relative to the normal test run of a mutated test', parseFloat)\r\n    .option('--maxConcurrentTestRunners <n>', 'Set the number of max concurrent test runner to spawn (default: cpuCount)', parseInt)\r\n    .option('--logLevel <level>', 'Set the log4js loglevel. Possible values: fatal, error, warn, info, debug, trace, all and off. Default is \"info\"')\r\n    .parse(process.argv);\r\nlog4js.setGlobalLogLevel(program['logLevel'] || 'info');\r\n// Cleanup commander state\r\ndelete program['options'];\r\ndelete program['rawArgs'];\r\ndelete program.args;\r\ndelete program.Command;\r\ndelete program.Option;\r\ndelete program['commands'];\r\nfor (var i in program) {\r\n    if (i.charAt(0) === '_') {\r\n        delete program[i];\r\n    }\r\n}\r\nif (strykerConfig) {\r\n    program['configFile'] = strykerConfig;\r\n}\r\nif (program['logLevel']) {\r\n    log4js.setGlobalLogLevel(program['logLevel']);\r\n}\r\nvar commands = {\r\n    init: function () { return new StrykerInitializer_1.default().initialize(); },\r\n    run: function () { return new Stryker_1.default(program).runMutationTest(); }\r\n};\r\nif (Object.keys(commands).indexOf(command) >= 0) {\r\n    commands[command]().catch(function (err) {\r\n        log.error(\"an error occurred\", err);\r\n        process.exitCode = 1;\r\n        process.kill(process.pid, 'SIGINT');\r\n    });\r\n}\r\nelse {\r\n    log.error('Unknown command: \"%s\", supported commands: [%s], or use `stryker --help`.', command, Object.keys(commands));\r\n}\r\n//# sourceMappingURL=stryker-cli.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\Stryker.js","content":"'use strict';\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar MutatorOrchestrator_1 = require(\"./MutatorOrchestrator\");\r\nvar config_1 = require(\"stryker-api/config\");\r\nvar SandboxCoordinator_1 = require(\"./SandboxCoordinator\");\r\nvar ReporterOrchestrator_1 = require(\"./ReporterOrchestrator\");\r\nvar test_runner_1 = require(\"stryker-api/test_runner\");\r\nvar TestFrameworkOrchestrator_1 = require(\"./TestFrameworkOrchestrator\");\r\nvar MutantTestMatcher_1 = require(\"./MutantTestMatcher\");\r\nvar InputFileResolver_1 = require(\"./InputFileResolver\");\r\nvar ConfigReader_1 = require(\"./ConfigReader\");\r\nvar PluginLoader_1 = require(\"./PluginLoader\");\r\nvar ScoreResultCalculator_1 = require(\"./ScoreResultCalculator\");\r\nvar CoverageInstrumenter_1 = require(\"./coverage/CoverageInstrumenter\");\r\nvar objectUtils_1 = require(\"./utils/objectUtils\");\r\nvar StrykerTempFolder_1 = require(\"./utils/StrykerTempFolder\");\r\nvar log4js = require(\"log4js\");\r\nvar Timer_1 = require(\"./utils/Timer\");\r\nvar log = log4js.getLogger('Stryker');\r\nvar humanReadableTestState = function (testState) {\r\n    switch (testState) {\r\n        case test_runner_1.TestStatus.Success:\r\n            return 'SUCCESS';\r\n        case test_runner_1.TestStatus.Failed:\r\n            return 'FAILED';\r\n        case test_runner_1.TestStatus.Skipped:\r\n            return 'SKIPPED';\r\n    }\r\n};\r\nvar Stryker = (function () {\r\n    /**\r\n     * The Stryker mutation tester.\r\n     * @constructor\r\n     * @param {String[]} mutateFilePatterns - A comma seperated list of globbing expression used for selecting the files that should be mutated\r\n     * @param {String[]} allFilePatterns - A comma seperated list of globbing expression used for selecting all files needed to run the tests. These include library files, test files and files to mutate, but should NOT include test framework files (for example jasmine)\r\n     * @param {Object} [options] - Optional options.\r\n     */\r\n    function Stryker(options) {\r\n        this.timer = new Timer_1.default();\r\n        var configReader = new ConfigReader_1.default(options);\r\n        this.config = configReader.readConfig();\r\n        this.setGlobalLogLevel(); // loglevel could be changed\r\n        this.loadPlugins();\r\n        this.applyConfigWriters();\r\n        this.setGlobalLogLevel(); // loglevel could be changed\r\n        this.freezeConfig();\r\n        this.reporter = new ReporterOrchestrator_1.default(this.config).createBroadcastReporter();\r\n        this.testFramework = new TestFrameworkOrchestrator_1.default(this.config).determineTestFramework();\r\n        this.coverageInstrumenter = new CoverageInstrumenter_1.default(this.config.coverageAnalysis, this.testFramework);\r\n        this.verify();\r\n    }\r\n    /**\r\n     * Runs mutation testing. This may take a while.\r\n     * @function\r\n     */\r\n    Stryker.prototype.runMutationTest = function () {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var inputFiles, _a, runResult, sandboxCoordinator, mutantResults;\r\n            return tslib_1.__generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        this.timer.reset();\r\n                        return [4 /*yield*/, new InputFileResolver_1.default(this.config.mutate, this.config.files).resolve()];\r\n                    case 1:\r\n                        inputFiles = _b.sent();\r\n                        return [4 /*yield*/, this.initialTestRun(inputFiles)];\r\n                    case 2:\r\n                        _a = _b.sent(), runResult = _a.runResult, sandboxCoordinator = _a.sandboxCoordinator;\r\n                        if (!(runResult && inputFiles && sandboxCoordinator)) return [3 /*break*/, 7];\r\n                        return [4 /*yield*/, this.generateAndRunMutations(inputFiles, runResult, sandboxCoordinator)];\r\n                    case 3:\r\n                        mutantResults = _b.sent();\r\n                        this.reporter.onScoreCalculated(ScoreResultCalculator_1.default.calculate(mutantResults));\r\n                        return [4 /*yield*/, this.wrapUpReporter()];\r\n                    case 4:\r\n                        _b.sent();\r\n                        return [4 /*yield*/, StrykerTempFolder_1.default.clean()];\r\n                    case 5:\r\n                        _b.sent();\r\n                        return [4 /*yield*/, this.logDone()];\r\n                    case 6:\r\n                        _b.sent();\r\n                        return [2 /*return*/, mutantResults];\r\n                    case 7: throw new Error('Resulting object did not contain runResult, inputFiles or sandboxCoordinator');\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Stryker.prototype.filterOutFailedTests = function (runResult) {\r\n        return runResult.tests.filter(function (testResult) { return testResult.status === test_runner_1.TestStatus.Failed; });\r\n    };\r\n    Stryker.prototype.loadPlugins = function () {\r\n        if (this.config.plugins) {\r\n            new PluginLoader_1.default(this.config.plugins).load();\r\n        }\r\n    };\r\n    Stryker.prototype.verify = function () {\r\n        if (this.config.coverageAnalysis === 'perTest' && !this.testFramework) {\r\n            log.fatal('Configured coverage analysis \"perTest\" requires there to be a testFramework configured. Either configure a testFramework or set coverageAnalysis to \"all\" or \"off\".');\r\n            process.exit(1);\r\n        }\r\n    };\r\n    Stryker.prototype.initialTestRun = function (inputFiles) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var sandboxCoordinator, runResult, failedTests;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        sandboxCoordinator = new SandboxCoordinator_1.default(this.config, inputFiles, this.testFramework, this.reporter);\r\n                        return [4 /*yield*/, sandboxCoordinator.initialRun(this.coverageInstrumenter)];\r\n                    case 1:\r\n                        runResult = _a.sent();\r\n                        switch (runResult.status) {\r\n                            case test_runner_1.RunStatus.Complete:\r\n                                failedTests = this.filterOutFailedTests(runResult);\r\n                                if (failedTests.length) {\r\n                                    this.logFailedTestsInInitialRun(failedTests);\r\n                                    throw new Error('There were failed tests in the initial test run:');\r\n                                }\r\n                                else {\r\n                                    this.logInitialTestRunSucceeded(runResult.tests);\r\n                                    return [2 /*return*/, { runResult: runResult, sandboxCoordinator: sandboxCoordinator }];\r\n                                }\r\n                            case test_runner_1.RunStatus.Error:\r\n                                this.logErrorredInitialRun(runResult);\r\n                                break;\r\n                            case test_runner_1.RunStatus.Timeout:\r\n                                this.logTimeoutInitialRun(runResult);\r\n                                break;\r\n                        }\r\n                        throw new Error('Something went wrong in the initial test run');\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Stryker.prototype.generateAndRunMutations = function (inputFiles, initialRunResult, sandboxCoordinator) {\r\n        var mutants = this.generateMutants(inputFiles, initialRunResult);\r\n        if (mutants.length) {\r\n            return sandboxCoordinator.runMutants(mutants);\r\n        }\r\n        else {\r\n            log.info('It\\'s a mutant-free world, nothing to test.');\r\n            return Promise.resolve([]);\r\n        }\r\n    };\r\n    Stryker.prototype.generateMutants = function (inputFiles, runResult) {\r\n        var mutatorOrchestrator = new MutatorOrchestrator_1.default(this.reporter);\r\n        var mutants = mutatorOrchestrator.generateMutants(inputFiles\r\n            .filter(function (inputFile) { return inputFile.mutated; })\r\n            .map(function (file) { return file.path; }));\r\n        log.info(mutants.length + \" Mutant(s) generated\");\r\n        var mutantRunResultMatcher = new MutantTestMatcher_1.default(mutants, runResult, this.coverageInstrumenter.retrieveStatementMapsPerFile(), this.config, this.reporter);\r\n        mutantRunResultMatcher.matchWithMutants();\r\n        return mutants;\r\n    };\r\n    Stryker.prototype.wrapUpReporter = function () {\r\n        var maybePromise = this.reporter.wrapUp();\r\n        if (objectUtils_1.isPromise(maybePromise)) {\r\n            return maybePromise;\r\n        }\r\n        else {\r\n            return Promise.resolve();\r\n        }\r\n    };\r\n    Stryker.prototype.applyConfigWriters = function () {\r\n        var _this = this;\r\n        config_1.ConfigWriterFactory.instance().knownNames().forEach(function (configWriterName) {\r\n            config_1.ConfigWriterFactory.instance().create(configWriterName, undefined).write(_this.config);\r\n        });\r\n    };\r\n    Stryker.prototype.freezeConfig = function () {\r\n        objectUtils_1.freezeRecursively(this.config);\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(\"Using config: \" + JSON.stringify(this.config));\r\n        }\r\n    };\r\n    Stryker.prototype.logInitialTestRunSucceeded = function (tests) {\r\n        log.info('Initial test run succeeded. Ran %s tests in %s.', tests.length, this.timer.humanReadableElapsed());\r\n    };\r\n    Stryker.prototype.logDone = function () {\r\n        log.info('Done in %s.', this.timer.humanReadableElapsed());\r\n    };\r\n    Stryker.prototype.setGlobalLogLevel = function () {\r\n        log4js.setGlobalLogLevel(this.config.logLevel);\r\n    };\r\n    Stryker.prototype.logFailedTestsInInitialRun = function (failedTests) {\r\n        var message = 'One or more tests failed in the initial test run:';\r\n        failedTests.forEach(function (test) {\r\n            message += \"\\n\\t\" + test.name;\r\n            if (test.failureMessages && test.failureMessages.length) {\r\n                message += \"\\n\\t\" + test.failureMessages.join('\\n\\t');\r\n            }\r\n        });\r\n        log.error(message);\r\n    };\r\n    Stryker.prototype.logErrorredInitialRun = function (runResult) {\r\n        var message = 'One or more tests errored in the initial test run:';\r\n        if (runResult.errorMessages && runResult.errorMessages.length) {\r\n            runResult.errorMessages.forEach(function (error) { return message += \"\\n\\t\" + error; });\r\n        }\r\n        log.error(message);\r\n    };\r\n    Stryker.prototype.logTimeoutInitialRun = function (runResult) {\r\n        var message = 'Initial test run timed out! Ran following tests before timeout:';\r\n        runResult.tests.forEach(function (test) { return \"\\n\\t\" + test.name + \" \" + humanReadableTestState(test.status); });\r\n        log.error(message);\r\n    };\r\n    return Stryker;\r\n}());\r\nexports.default = Stryker;\r\n//# sourceMappingURL=Stryker.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\TestFrameworkOrchestrator.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar test_framework_1 = require(\"stryker-api/test_framework\");\r\nvar log4js = require(\"log4js\");\r\nvar log = log4js.getLogger('TestFrameworkOrchestrator');\r\nvar TestFrameworkOrchestrator = (function () {\r\n    function TestFrameworkOrchestrator(options) {\r\n        this.options = options;\r\n    }\r\n    TestFrameworkOrchestrator.prototype.determineTestFramework = function () {\r\n        if (this.options.coverageAnalysis !== 'perTest') {\r\n            log.debug('The `coverageAnalysis` setting is \"%s\", not hooking into the test framework to achieve performance benefits.', this.options.coverageAnalysis);\r\n            return null;\r\n        }\r\n        else {\r\n            return this.determineFrameworkWithCoverageAnalysis();\r\n        }\r\n    };\r\n    TestFrameworkOrchestrator.prototype.determineFrameworkWithCoverageAnalysis = function () {\r\n        var testFramework = null;\r\n        if (this.options.testFramework) {\r\n            if (this.testFrameworkExists(this.options.testFramework)) {\r\n                log.debug(\"Using testFramework \" + this.options.testFramework + \" based on `testFramework` setting\");\r\n                testFramework = this.createTestFramework(this.options.testFramework);\r\n            }\r\n            else {\r\n                log.warn(\"Could not find test framework `\" + this.options.testFramework + \"`. \" + this.informAboutKnownTestFrameworks());\r\n            }\r\n        }\r\n        else {\r\n            log.warn('Missing config settings `testFramework`. Set `coverageAnalysis` option explicitly to \"off\" to ignore this warning.');\r\n        }\r\n        return testFramework;\r\n    };\r\n    TestFrameworkOrchestrator.prototype.informAboutKnownTestFrameworks = function () {\r\n        return \"Did you forget to load a plugin? Known test frameworks: \" + JSON.stringify(test_framework_1.TestFrameworkFactory.instance().knownNames()) + \".\";\r\n    };\r\n    TestFrameworkOrchestrator.prototype.createTestFramework = function (name) {\r\n        return test_framework_1.TestFrameworkFactory.instance().create(name, { options: this.options });\r\n    };\r\n    TestFrameworkOrchestrator.prototype.testFrameworkExists = function (maybeFramework) {\r\n        return test_framework_1.TestFrameworkFactory.instance().knownNames().indexOf(maybeFramework) > -1;\r\n    };\r\n    return TestFrameworkOrchestrator;\r\n}());\r\nexports.default = TestFrameworkOrchestrator;\r\n//# sourceMappingURL=TestFrameworkOrchestrator.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\utils\\fileUtils.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar fs = require(\"mz/fs\");\r\nvar nodeGlob = require(\"glob\");\r\nvar mkdirp = require(\"mkdirp\");\r\nvar rimraf = require(\"rimraf\");\r\nfunction glob(expression) {\r\n    return new Promise(function (resolve, reject) {\r\n        nodeGlob(expression, { nodir: true }, function (error, matches) { error ? reject(error) : resolve(matches); });\r\n    });\r\n}\r\nexports.glob = glob;\r\nfunction deleteDir(dirToDelete) {\r\n    return new Promise(function (resolve, reject) {\r\n        rimraf(dirToDelete, function (error) { error ? reject(error) : resolve(); });\r\n    });\r\n}\r\nexports.deleteDir = deleteDir;\r\nfunction cleanFolder(folderName) {\r\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n        var e_1;\r\n        return tslib_1.__generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    _a.trys.push([0, 3, , 4]);\r\n                    return [4 /*yield*/, fs.lstat(folderName)];\r\n                case 1:\r\n                    _a.sent();\r\n                    return [4 /*yield*/, deleteDir(folderName)];\r\n                case 2:\r\n                    _a.sent();\r\n                    return [2 /*return*/, mkdirp.sync(folderName)];\r\n                case 3:\r\n                    e_1 = _a.sent();\r\n                    return [2 /*return*/, mkdirp.sync(folderName)];\r\n                case 4: return [2 /*return*/];\r\n            }\r\n        });\r\n    });\r\n}\r\nexports.cleanFolder = cleanFolder;\r\n/**\r\n * Wrapper around the 'require' function (for testability)\r\n */\r\nfunction importModule(moduleName) {\r\n    require(moduleName);\r\n}\r\nexports.importModule = importModule;\r\nfunction isOnlineFile(path) {\r\n    return path.indexOf('http://') === 0 || path.indexOf('https://') === 0;\r\n}\r\nexports.isOnlineFile = isOnlineFile;\r\n//# sourceMappingURL=fileUtils.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\utils\\objectUtils.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar _ = require(\"lodash\");\r\n// Don't use JSON.parse, as it does not allow for regexes or functions, etc\r\nexports.serialize = require('serialize-javascript');\r\nfunction freezeRecursively(target) {\r\n    Object.freeze(target);\r\n    Object.keys(target).forEach(function (key) {\r\n        if (_.isObject(target[key])) {\r\n            freezeRecursively(target[key]);\r\n        }\r\n    });\r\n    return target;\r\n}\r\nexports.freezeRecursively = freezeRecursively;\r\nfunction isPromise(input) {\r\n    return input && typeof input['then'] === 'function';\r\n}\r\nexports.isPromise = isPromise;\r\nfunction filterEmpty(input) {\r\n    return input.filter(function (item) { return item !== undefined && item !== null; });\r\n}\r\nexports.filterEmpty = filterEmpty;\r\nfunction deserialize(serializedJavascript) {\r\n    // Don't use JSON.parse, as it does not allow for regexes or functions, etc\r\n    // tslint:disable\r\n    return eval(\"(\" + serializedJavascript + \")\");\r\n    // tslint:enable\r\n}\r\nexports.deserialize = deserialize;\r\nfunction isErrnoException(error) {\r\n    return typeof error.code === 'string';\r\n}\r\nexports.isErrnoException = isErrnoException;\r\nfunction errorToString(error) {\r\n    if (!error) {\r\n        return '';\r\n    }\r\n    else if (isErrnoException(error)) {\r\n        return error.name + \": \" + error.code + \" (\" + error.syscall + \") \" + error.stack;\r\n    }\r\n    else if (error instanceof Error) {\r\n        var message = error.name + \": \" + error.message;\r\n        if (error.stack) {\r\n            return message + \"\\n\" + error.stack.toString();\r\n        }\r\n        else {\r\n            return message;\r\n        }\r\n    }\r\n    else {\r\n        return error.toString();\r\n    }\r\n}\r\nexports.errorToString = errorToString;\r\nfunction copy(obj, deep) {\r\n    if (deep) {\r\n        return _.cloneDeep(obj);\r\n    }\r\n    else {\r\n        return _.clone(obj);\r\n    }\r\n}\r\nexports.copy = copy;\r\nfunction wrapInClosure(codeFragment) {\r\n    return \"\\n    (function (window) {\\n      \" + codeFragment + \"\\n    })((Function('return this'))());\";\r\n}\r\nexports.wrapInClosure = wrapInClosure;\r\n//# sourceMappingURL=objectUtils.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\utils\\parserUtils.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar _ = require(\"lodash\");\r\nvar esprima = require(\"esprima\");\r\nvar escodegen = require('escodegen');\r\n/**\r\n * Utility class for parsing and generating code.\r\n * @constructor\r\n */\r\nvar esprimaOptions = {\r\n    comment: true,\r\n    loc: true,\r\n    range: true,\r\n    tokens: true,\r\n};\r\n/**\r\n * Parses code to generate an Abstract Syntax Tree.\r\n * @function\r\n * @param code - The code which has to be parsed.\r\n * @returns {Object} The generated Abstract Syntax Tree.\r\n */\r\nfunction parse(code) {\r\n    if (code === undefined) {\r\n        throw new Error('Code parameter cannot be undefined');\r\n    }\r\n    var abstractSyntaxTree = esprima.parse(code, esprimaOptions);\r\n    return abstractSyntaxTree;\r\n}\r\nexports.parse = parse;\r\n/**\r\n   * Parses a Node to generate code.\r\n   * @param The Node which has to be transformed into code.\r\n   * @returns The generated code.\r\n   */\r\nfunction generate(node) {\r\n    return escodegen.generate(node);\r\n}\r\nexports.generate = generate;\r\n/**\r\n * Returns n as T & Identified, purely syntactic.\r\n * @param n The estree node which is identified\r\n */\r\nfunction identified(n) {\r\n    return n;\r\n}\r\nexports.identified = identified;\r\n/**\r\n * Represents an object responsible to identify estree nodes (estree.Node).\r\n * Labels all nodes with a `nodeID` recursively.\r\n */\r\nvar NodeIdentifier = (function () {\r\n    function NodeIdentifier() {\r\n        this.identifiedNodes = [];\r\n    }\r\n    NodeIdentifier.prototype.identifyAndFreeze = function (program) {\r\n        this.identifiedNodes = [];\r\n        this.identifyAndFreezeRecursively(program);\r\n        return this.identifiedNodes;\r\n    };\r\n    NodeIdentifier.prototype.identifyAndFreezeRecursively = function (maybeNode) {\r\n        var _this = this;\r\n        if (this.isNode(maybeNode)) {\r\n            if (!this.isIdentified(maybeNode)) {\r\n                this.identify(maybeNode);\r\n            }\r\n            Object.freeze(maybeNode);\r\n            _.forOwn(maybeNode, function (childNode) {\r\n                _this.identifyAndFreezeRecursively(childNode);\r\n            });\r\n        }\r\n        else if (Array.isArray(maybeNode)) {\r\n            maybeNode.forEach(function (grandChild) {\r\n                _this.identifyAndFreezeRecursively(grandChild);\r\n            });\r\n        }\r\n    };\r\n    NodeIdentifier.prototype.isNode = function (maybeNode) {\r\n        return !_.isArray(maybeNode) && _.isObject(maybeNode) && maybeNode.type;\r\n    };\r\n    NodeIdentifier.prototype.isIdentified = function (node) {\r\n        var n = node;\r\n        return _.isNumber(n.nodeID);\r\n    };\r\n    NodeIdentifier.prototype.identify = function (node) {\r\n        var n = node;\r\n        n.nodeID = this.identifiedNodes.length;\r\n        this.identifiedNodes.push(n);\r\n    };\r\n    return NodeIdentifier;\r\n}());\r\nexports.NodeIdentifier = NodeIdentifier;\r\n//# sourceMappingURL=parserUtils.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\utils\\StrykerTempFolder.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar fs = require(\"mz/fs\");\r\nvar path = require(\"path\");\r\nvar mkdirp = require(\"mkdirp\");\r\nvar log4js = require(\"log4js\");\r\nvar fileUtils_1 = require(\"./fileUtils\");\r\nvar log = log4js.getLogger('StrykerTempFolder');\r\nvar baseTempFolder = path.join(process.cwd(), '.stryker-tmp');\r\nvar tempFolder = path.join(baseTempFolder, random().toString());\r\nmkdirp.sync(baseTempFolder);\r\nmkdirp.sync(tempFolder);\r\n/**\r\n * Creates a new random folder with the specified prefix.\r\n * @param prefix The prefix.\r\n * @returns The path to the folder.\r\n */\r\nfunction createRandomFolder(prefix) {\r\n    var dir = tempFolder + path.sep + prefix + random();\r\n    mkdirp.sync(dir);\r\n    return dir;\r\n}\r\n/**\r\n * Creates a random integer number.\r\n * @returns A random integer.\r\n */\r\nfunction random() {\r\n    return Math.ceil(Math.random() * 10000000);\r\n}\r\n/**\r\n * Writes data to a specified file.\r\n * @param filename The path to the file.\r\n * @param data The content of the file.\r\n * @returns A promise to eventually save the file.\r\n */\r\nfunction writeFile(filename, data) {\r\n    return fs.writeFile(filename, data, { encoding: 'utf8' });\r\n}\r\n/**\r\n * Copies a file.\r\n * @param fromFilename The path to the existing file.\r\n * @param toFilename The path to copy the file to.\r\n * @param instrumenter An optional additional instrumenter to stream the file through\r\n * @returns A promise to eventually copy the file.\r\n */\r\nfunction copyFile(fromFilename, toFilename, instrumenter) {\r\n    return new Promise(function (resolve, reject) {\r\n        var readStream = fs.createReadStream(fromFilename, { encoding: 'utf8' });\r\n        var writeStream = fs.createWriteStream(toFilename);\r\n        readStream.on('error', reject);\r\n        writeStream.on('error', reject);\r\n        if (instrumenter) {\r\n            readStream = readStream.pipe(instrumenter);\r\n        }\r\n        readStream.pipe(writeStream);\r\n        readStream.on('end', function () { return resolve(); });\r\n    });\r\n}\r\n/**\r\n * Deletes the Stryker-temp folder\r\n */\r\nfunction clean() {\r\n    log.debug(\"Cleaning stryker temp folder \" + baseTempFolder);\r\n    return fileUtils_1.deleteDir(baseTempFolder)\r\n        .catch(function () { return log.info(\"Failed to clean stryker temp folder \" + baseTempFolder); });\r\n}\r\nexports.default = {\r\n    createRandomFolder: createRandomFolder,\r\n    writeFile: writeFile,\r\n    copyFile: copyFile,\r\n    clean: clean\r\n};\r\n//# sourceMappingURL=StrykerTempFolder.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\utils\\Task.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Wraps a promise in a Task api for convenience.\r\n */\r\nvar Task = (function () {\r\n    function Task(timeoutMs, timeoutHandler) {\r\n        var _this = this;\r\n        this.timeoutHandler = timeoutHandler;\r\n        this._isResolved = false;\r\n        this._promise = new Promise(function (resolve, reject) {\r\n            _this.resolveFn = resolve;\r\n            _this.rejectFn = reject;\r\n        });\r\n        if (timeoutMs) {\r\n            this.timeout = setTimeout(function () { return _this.handleTimeout(); }, timeoutMs);\r\n        }\r\n    }\r\n    Object.defineProperty(Task.prototype, \"isResolved\", {\r\n        get: function () {\r\n            return this._isResolved;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Task.prototype, \"promise\", {\r\n        get: function () {\r\n            return this._promise;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Task.prototype.handleTimeout = function () {\r\n        var _this = this;\r\n        if (this.timeoutHandler) {\r\n            this.timeoutHandler().then(function (val) { return _this.resolve(val); });\r\n        }\r\n        else {\r\n            this.resolve(undefined);\r\n        }\r\n    };\r\n    Task.prototype.chainTo = function (promise) {\r\n        var _this = this;\r\n        promise.then(function (value) { return _this.resolve(value); }, function (reason) { return _this.reject(reason); });\r\n    };\r\n    Task.prototype.resolve = function (result) {\r\n        this.resolveTimeout();\r\n        this.resolveFn(result);\r\n    };\r\n    Task.prototype.reject = function (reason) {\r\n        this.resolveTimeout();\r\n        this.rejectFn(reason);\r\n    };\r\n    Task.prototype.resolveTimeout = function () {\r\n        if (this.timeout) {\r\n            clearTimeout(this.timeout);\r\n        }\r\n        this._isResolved = true;\r\n    };\r\n    return Task;\r\n}());\r\nexports.default = Task;\r\n//# sourceMappingURL=Task.js.map"},{"path":"c:\\z\\github\\stryker-mutator\\stryker\\packages\\stryker\\src\\utils\\Timer.js","content":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Timer = (function () {\r\n    function Timer() {\r\n        this.reset();\r\n    }\r\n    Timer.prototype.reset = function () {\r\n        this.start = new Date();\r\n    };\r\n    Timer.prototype.humanReadableElapsed = function () {\r\n        var elapsedSeconds = this.elapsedSeconds();\r\n        return Timer.humanReadableElapsedMinutes(elapsedSeconds) + Timer.humanReadableElapsedSeconds(elapsedSeconds);\r\n    };\r\n    Timer.prototype.elapsedSeconds = function () {\r\n        var elapsedMs = new Date().getTime() - this.start.getTime();\r\n        return Math.floor(elapsedMs / 1000);\r\n    };\r\n    Timer.humanReadableElapsedSeconds = function (elapsedSeconds) {\r\n        var restSeconds = elapsedSeconds % 60;\r\n        if (restSeconds === 1) {\r\n            return restSeconds + \" second\";\r\n        }\r\n        else {\r\n            return restSeconds + \" seconds\";\r\n        }\r\n    };\r\n    Timer.humanReadableElapsedMinutes = function (elapsedSeconds) {\r\n        var elapsedMinutes = Math.floor(elapsedSeconds / 60);\r\n        if (elapsedMinutes > 1) {\r\n            return elapsedMinutes + \" minutes \";\r\n        }\r\n        else if (elapsedMinutes > 0) {\r\n            return elapsedMinutes + \" minute \";\r\n        }\r\n        else {\r\n            return '';\r\n        }\r\n    };\r\n    return Timer;\r\n}());\r\nexports.default = Timer;\r\n//# sourceMappingURL=Timer.js.map"}]