{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":13,"column":42},"end":{"line":231,"column":1}},"range":[602,11373],"testsRan":[" Uncaught error outside test suite","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should resolve the promise in a Timeout","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing \"before each\" hook for \"should result in a rejection\"","TestRunnerOrchestrator without test selector \"before each\" hook for \"should run all tests without selecting specific ones and report one runResult\"","TestRunnerOrchestrator with test selector \"before each\" hook for \"should have created an isolated test runner\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"var TestRunnerOrchestrator = (function () {\r\n    function TestRunnerOrchestrator(options, files, testSelector, reporter) {\r\n        this.options = options;\r\n        this.files = files;\r\n        this.testSelector = testSelector;\r\n        this.reporter = reporter;\r\n    }\r\n    TestRunnerOrchestrator.prototype.initialRun = function () {\r\n        if (this.testSelector) {\r\n            return this.initialRunWithTestSelector();\r\n        }\r\n        else {\r\n            return this.initalRunWithoutTestSelector();\r\n        }\r\n    };\r\n    TestRunnerOrchestrator.prototype.initalRunWithoutTestSelector = function () {\r\n        var testRunner = this.createTestRunner(this.files, true);\r\n        return testRunner.run({ timeout: 10000 }).then(function (testResults) {\r\n            testRunner.dispose();\r\n            return [testResults];\r\n        });\r\n    };\r\n    TestRunnerOrchestrator.prototype.initialRunWithTestSelector = function () {\r\n        var testSelectionFilePath = this.createTestSelectorFileName(this.createTempFolder());\r\n        var runnerAdapter = this.createTestRunner(this.files, true, testSelectionFilePath);\r\n        var sandbox = {\r\n            runnerAdapter: runnerAdapter,\r\n            fileMap: null,\r\n            testSelectionFilePath: testSelectionFilePath,\r\n            index: 0\r\n        };\r\n        return this.runSingleTestsRecursive(sandbox, [], 0).then(function (testResults) {\r\n            runnerAdapter.dispose();\r\n            return testResults;\r\n        });\r\n    };\r\n    TestRunnerOrchestrator.prototype.runMutations = function (mutants) {\r\n        var _this = this;\r\n        mutants = _.clone(mutants); // work with a copy because we're changing state (pop'ing values)\r\n        var results = [];\r\n        return this.createTestRunnerSandboxes().then(function (sandboxes) {\r\n            var promiseProducer = function () {\r\n                if (mutants.length === 0) {\r\n                    return null; // we're done\r\n                }\r\n                else {\r\n                    var mutant = mutants.pop();\r\n                    if (mutant.scopedTestIds.length > 0) {\r\n                        var sandbox_1 = sandboxes.pop();\r\n                        var sourceFileCopy_1 = sandbox_1.fileMap[mutant.filename];\r\n                        return Promise.all([mutant.save(sourceFileCopy_1), _this.selectTestsIfPossible(sandbox_1, mutant.scopedTestIds)])\r\n                            .then(function () { return sandbox_1.runnerAdapter.run({ timeout: _this.calculateTimeout(mutant.timeSpentScopedTests) }); })\r\n                            .then(function (runResult) {\r\n                            var result = _this.collectFrozenMutantResult(mutant, runResult);\r\n                            results.push(result);\r\n                            _this.reporter.onMutantTested(result);\r\n                            return mutant.reset(sourceFileCopy_1);\r\n                        })\r\n                            .then(function () { return sandboxes.push(sandbox_1); }); // mark the runner as available again\r\n                    }\r\n                    else {\r\n                        var result = _this.collectFrozenMutantResult(mutant);\r\n                        results.push(result);\r\n                        return Promise.resolve(_this.reporter.onMutantTested(result));\r\n                    }\r\n                }\r\n            };\r\n            return new PromisePool(promiseProducer, sandboxes.length)\r\n                .start()\r\n                .then(function () { return sandboxes.forEach(function (testRunner) { return testRunner.runnerAdapter.dispose(); }); })\r\n                .then(function () { return _this.reportAllMutantsTested(results); })\r\n                .then(function () { return results; });\r\n        });\r\n    };\r\n    TestRunnerOrchestrator.prototype.reportAllMutantsTested = function (results) {\r\n        objectUtils_1.freezeRecursively(results);\r\n        this.reporter.onAllMutantsTested(results);\r\n    };\r\n    TestRunnerOrchestrator.prototype.calculateTimeout = function (baseTimeout) {\r\n        return (this.options.timeoutFactor * baseTimeout) + this.options.timeoutMs;\r\n    };\r\n    TestRunnerOrchestrator.prototype.collectFrozenMutantResult = function (mutant, runResult) {\r\n        var status;\r\n        var testNames;\r\n        if (runResult) {\r\n            switch (runResult.result) {\r\n                case test_runner_1.TestResult.Timeout:\r\n                    status = report_1.MutantStatus.TIMEDOUT;\r\n                    break;\r\n                case test_runner_1.TestResult.Error:\r\n                    log.debug('Converting a test result `error` to mutant status `killed`.');\r\n                    status = report_1.MutantStatus.KILLED;\r\n                    break;\r\n                case test_runner_1.TestResult.Complete:\r\n                    if (runResult.failed > 0) {\r\n                        status = report_1.MutantStatus.KILLED;\r\n                    }\r\n                    else {\r\n                        status = report_1.MutantStatus.SURVIVED;\r\n                    }\r\n                    break;\r\n            }\r\n            testNames = runResult.testNames;\r\n        }\r\n        else {\r\n            testNames = [];\r\n            status = report_1.MutantStatus.UNTESTED;\r\n        }\r\n        var result = {\r\n            sourceFilePath: mutant.filename,\r\n            mutatorName: mutant.mutatorName,\r\n            status: status,\r\n            replacement: mutant.replacement,\r\n            location: mutant.location,\r\n            range: mutant.range,\r\n            testsRan: testNames,\r\n            originalLines: mutant.originalLines,\r\n            mutatedLines: mutant.mutatedLines,\r\n        };\r\n        objectUtils_1.freezeRecursively(result);\r\n        return result;\r\n    };\r\n    TestRunnerOrchestrator.prototype.runSingleTestsRecursive = function (sandbox, runResults, currentTestIndex) {\r\n        var _this = this;\r\n        return new Promise(function (resolve) {\r\n            _this.selectTestsIfPossible(sandbox, [currentTestIndex])\r\n                .then(function () { return sandbox.runnerAdapter.run({ timeout: 10000 }); })\r\n                .then(function (runResult) {\r\n                if (runResult.result === test_runner_1.TestResult.Complete && runResult.succeeded > 0 || runResult.failed > 0) {\r\n                    runResults[currentTestIndex] = runResult;\r\n                    resolve(_this.runSingleTestsRecursive(sandbox, runResults, currentTestIndex + 1));\r\n                }\r\n                else {\r\n                    if (runResult.result !== test_runner_1.TestResult.Complete) {\r\n                        // If this was iteration n+1 (n = number of tests), the runResult.result will be Complete, so we don't record it\r\n                        runResults[currentTestIndex] = runResult;\r\n                    }\r\n                    sandbox.runnerAdapter.dispose();\r\n                    resolve(runResults);\r\n                }\r\n            });\r\n        });\r\n    };\r\n    TestRunnerOrchestrator.prototype.createTestRunnerSandboxes = function () {\r\n        var cpuCount = os.cpus().length;\r\n        var testRunnerSandboxes = [];\r\n        var allPromises = [];\r\n        log.info(\"Creating \" + cpuCount + \" test runners (based on cpu count)\");\r\n        for (var i = 0; i < cpuCount; i++) {\r\n            allPromises.push(this.createSandbox(i).then(function (sandbox) { return testRunnerSandboxes.push(sandbox); }));\r\n        }\r\n        return Promise.all(allPromises).then(function () { return testRunnerSandboxes; });\r\n    };\r\n    TestRunnerOrchestrator.prototype.selectTestsIfPossible = function (sandbox, ids) {\r\n        if (this.testSelector) {\r\n            var fileContent = this.testSelector.select(ids);\r\n            return StrykerTempFolder_1.default.writeFile(sandbox.testSelectionFilePath, fileContent);\r\n        }\r\n        else {\r\n            return Promise.resolve(void 0);\r\n        }\r\n    };\r\n    TestRunnerOrchestrator.prototype.createSandbox = function (index) {\r\n        var _this = this;\r\n        var tempFolder = this.createTempFolder();\r\n        return this.copyAllFilesToFolder(tempFolder).then(function (fileMap) {\r\n            var runnerFiles = [];\r\n            var testSelectionFilePath = null;\r\n            if (_this.testSelector) {\r\n                testSelectionFilePath = _this.createTestSelectorFileName(tempFolder);\r\n            }\r\n            _this.files.forEach(function (originalFile) { return runnerFiles.push({ path: fileMap[originalFile.path], shouldMutate: originalFile.shouldMutate }); });\r\n            return {\r\n                index: index,\r\n                fileMap: fileMap,\r\n                runnerAdapter: _this.createTestRunner(runnerFiles, false, testSelectionFilePath, index),\r\n                testSelectionFilePath: testSelectionFilePath\r\n            };\r\n        });\r\n    };\r\n    TestRunnerOrchestrator.prototype.createTempFolder = function () {\r\n        var tempFolder = StrykerTempFolder_1.default.createRandomFolder('test-runner-files');\r\n        log.debug('Creating a sandbox for files in %s', tempFolder);\r\n        return tempFolder;\r\n    };\r\n    TestRunnerOrchestrator.prototype.createTestSelectorFileName = function (folder) {\r\n        return path.join(folder, '___testSelection.js');\r\n    };\r\n    TestRunnerOrchestrator.prototype.copyAllFilesToFolder = function (folder) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            var fileMap = Object.create(null);\r\n            var cwd = process.cwd();\r\n            var copyPromises = _this.files.map(function (file) {\r\n                var relativePath = file.path.substr(cwd.length);\r\n                var folderName = StrykerTempFolder_1.default.ensureFolderExists(folder + path.dirname(relativePath));\r\n                var targetFile = path.join(folderName, path.basename(relativePath));\r\n                fileMap[file.path] = targetFile;\r\n                return StrykerTempFolder_1.default.copyFile(file.path, targetFile);\r\n            });\r\n            Promise.all(copyPromises).then(function () { resolve(fileMap); }, reject);\r\n        });\r\n    };\r\n    TestRunnerOrchestrator.prototype.createTestRunner = function (files, coverageEnabled, testSelectionFilePath, index) {\r\n        if (index === void 0) { index = 0; }\r\n        if (testSelectionFilePath) {\r\n            files = [{ path: testSelectionFilePath, shouldMutate: false }].concat(files);\r\n        }\r\n        var settings = {\r\n            coverageEnabled: coverageEnabled,\r\n            files: files,\r\n            strykerOptions: this.options,\r\n            port: this.options.port + index\r\n        };\r\n        log.debug(\"Creating test runner %s using settings {port: %s, coverageEnabled: %s}\", index, settings.port, settings.coverageEnabled);\r\n        return IsolatedTestRunnerAdapterFactory_1.default.create(settings);\r\n    };\r\n    return TestRunnerOrchestrator;\r\n}());","mutatedLines":"var TestRunnerOrchestrator = (function () {\n}());"}