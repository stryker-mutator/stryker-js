{"sourceFilePath":"c:\\z\\github\\stryker-mutator\\stryker\\src\\utils\\fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":70,"column":23},"end":{"line":72,"column":13}},"range":[1825,1873],"testsRan":[" Uncaught error outside test suite","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should resolve the promise in a Timeout","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 4 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 4 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 4 mutants should have ran mutant 2 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 4 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 4 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 4 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"            if (error) {\r\n                reject(error);\r\n            }","mutatedLines":"            if (error) {\n}"}