[{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":55,"column":17},"end":{"line":58,"column":1}},"range":[1725,1843],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"function clean() {\r\n    log.info(\"Cleaning stryker temp folder \" + baseTempFolder);\r\n    return fileUtils.deleteDir(baseTempFolder);\r\n}","mutatedLines":"function clean() {\n}"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"Math","status":2,"replacement":"'Cleaning stryker temp folder ' - baseTempFolder","location":{"start":{"line":56,"column":13},"end":{"line":56,"column":61}},"range":[1741,1789],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"    log.info(\"Cleaning stryker temp folder \" + baseTempFolder);","mutatedLines":"    log.info('Cleaning stryker temp folder ' - baseTempFolder);"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":52,"column":41},"end":{"line":52,"column":62}},"range":[1671,1692],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"        readStream.on('end', function () { return resolve(); });","mutatedLines":"        readStream.on('end', function () {\n});"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":36,"column":16},"end":{"line":36,"column":21}},"range":[1097,1102],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"            if (error) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":36,"column":23},"end":{"line":38,"column":13}},"range":[1104,1152],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"            if (error) {\r\n                reject(error);\r\n            }","mutatedLines":"            if (error) {\n}"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":45,"column":44},"end":{"line":54,"column":1}},"range":[1286,1706],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"function copyFile(fromFilename, toFilename) {\r\n    return new Promise(function (resolve, reject) {\r\n        var readStream = fs.createReadStream(fromFilename, { encoding: 'utf8' });\r\n        var writeStream = fs.createWriteStream(toFilename, { encoding: 'utf8' });\r\n        readStream.on('error', reject);\r\n        writeStream.on('error', reject);\r\n        readStream.pipe(writeStream);\r\n        readStream.on('end', function () { return resolve(); });\r\n    });\r\n}","mutatedLines":"function copyFile(fromFilename, toFilename) {\n}"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":39,"column":17},"end":{"line":41,"column":13}},"range":[1171,1215],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"            else {\r\n                resolve();\r\n            }","mutatedLines":"            else {\n}"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":46,"column":50},"end":{"line":53,"column":5}},"range":[1339,1701],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"    return new Promise(function (resolve, reject) {\r\n        var readStream = fs.createReadStream(fromFilename, { encoding: 'utf8' });\r\n        var writeStream = fs.createWriteStream(toFilename, { encoding: 'utf8' });\r\n        readStream.on('error', reject);\r\n        writeStream.on('error', reject);\r\n        readStream.pipe(writeStream);\r\n        readStream.on('end', function () { return resolve(); });\r\n    });","mutatedLines":"    return new Promise(function (resolve, reject) {\n});"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"RemoveConditionals","status":2,"replacement":"false","location":{"start":{"line":36,"column":16},"end":{"line":36,"column":21}},"range":[1097,1102],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"            if (error) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":34,"column":50},"end":{"line":43,"column":5}},"range":[999,1235],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"    return new Promise(function (resolve, reject) {\r\n        fs.writeFile(filename, data, { encoding: 'utf8' }, function (error) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve();\r\n            }\r\n        });\r\n    });","mutatedLines":"    return new Promise(function (resolve, reject) {\n});"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":35,"column":76},"end":{"line":42,"column":9}},"range":[1078,1226],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"        fs.writeFile(filename, data, { encoding: 'utf8' }, function (error) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve();\r\n            }\r\n        });","mutatedLines":"        fs.writeFile(filename, data, { encoding: 'utf8' }, function (error) {\n});"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":33,"column":35},"end":{"line":44,"column":1}},"range":[946,1240],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"function writeFile(filename, data) {\r\n    return new Promise(function (resolve, reject) {\r\n        fs.writeFile(filename, data, { encoding: 'utf8' }, function (error) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve();\r\n            }\r\n        });\r\n    });\r\n}","mutatedLines":"function writeFile(filename, data) {\n}"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":25,"column":8},"end":{"line":28,"column":5}},"range":[784,855],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"    try {\r\n        var stats = fs.lstatSync(path);\r\n        return true;\r\n    }","mutatedLines":"    try {\n}"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":29,"column":18},"end":{"line":31,"column":5}},"range":[875,906],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"    catch (error) {\r\n        return false;\r\n    }","mutatedLines":"    catch (error) {\n}"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":15,"column":18},"end":{"line":17,"column":1}},"range":[553,606],"originalLines":"function random() {\r\n    return Math.ceil(Math.random() * 10000000);\r\n}","mutatedLines":"function random() {\n}"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":19,"column":35},"end":{"line":21,"column":5}},"range":[680,716],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"    if (!fileOrFolderExists(path)) {\r\n        mkdirp.sync(path);\r\n    }","mutatedLines":"    if (!fileOrFolderExists(path)) {\n}"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"Math","status":1,"replacement":"tempFolder + path.sep - prefix","location":{"start":{"line":13,"column":30},"end":{"line":13,"column":60}},"range":[487,517],"originalLines":"    return ensureFolderExists(tempFolder + path.sep + prefix + random());","mutatedLines":"    return ensureFolderExists(tempFolder + path.sep - prefix + random());"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":24,"column":34},"end":{"line":32,"column":1}},"range":[773,909],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"function fileOrFolderExists(path) {\r\n    try {\r\n        var stats = fs.lstatSync(path);\r\n        return true;\r\n    }\r\n    catch (error) {\r\n        return false;\r\n    }\r\n}","mutatedLines":"function fileOrFolderExists(path) {\n}"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":12,"column":36},"end":{"line":14,"column":1}},"range":[454,533],"originalLines":"function createRandomFolder(prefix) {\r\n    return ensureFolderExists(tempFolder + path.sep + prefix + random());\r\n}","mutatedLines":"function createRandomFolder(prefix) {\n}"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":36,"column":84},"end":{"line":38,"column":17}},"range":[1284,1364],"originalLines":"                if (arrayChild instanceof Object && !(arrayChild instanceof Array)) {\r\n                    collectFrozenNodes(arrayChild, nodes);\r\n                }","mutatedLines":"                if (arrayChild instanceof Object && !(arrayChild instanceof Array)) {\n}"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"ReverseConditional","status":1,"replacement":"arrayChild instanceof Object || !(arrayChild instanceof Array)","location":{"start":{"line":36,"column":20},"end":{"line":36,"column":82}},"range":[1220,1282],"originalLines":"                if (arrayChild instanceof Object && !(arrayChild instanceof Array)) {","mutatedLines":"                if (arrayChild instanceof Object || !(arrayChild instanceof Array)) {"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":36,"column":20},"end":{"line":36,"column":82}},"range":[1220,1282],"originalLines":"                if (arrayChild instanceof Object && !(arrayChild instanceof Array)) {","mutatedLines":"                if (true) {"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":36,"column":20},"end":{"line":36,"column":82}},"range":[1220,1282],"originalLines":"                if (arrayChild instanceof Object && !(arrayChild instanceof Array)) {","mutatedLines":"                if (false) {"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":35,"column":55},"end":{"line":39,"column":13}},"range":[1197,1379],"originalLines":"            _.forEach(childNode, function (arrayChild) {\r\n                if (arrayChild instanceof Object && !(arrayChild instanceof Array)) {\r\n                    collectFrozenNodes(arrayChild, nodes);\r\n                }\r\n            });","mutatedLines":"            _.forEach(childNode, function (arrayChild) {\n});"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":34,"column":45},"end":{"line":40,"column":9}},"range":[1139,1392],"originalLines":"        else if (childNode instanceof Array) {\r\n            _.forEach(childNode, function (arrayChild) {\r\n                if (arrayChild instanceof Object && !(arrayChild instanceof Array)) {\r\n                    collectFrozenNodes(arrayChild, nodes);\r\n                }\r\n            });\r\n        }","mutatedLines":"        else if (childNode instanceof Array) {\n}"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":34,"column":17},"end":{"line":34,"column":43}},"range":[1111,1137],"originalLines":"        else if (childNode instanceof Array) {","mutatedLines":"        else if (true) {"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":34,"column":17},"end":{"line":34,"column":43}},"range":[1111,1137],"originalLines":"        else if (childNode instanceof Array) {","mutatedLines":"        else if (false) {"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":31,"column":74},"end":{"line":33,"column":9}},"range":[1029,1092],"originalLines":"        if (childNode instanceof Object && !(childNode instanceof Array)) {\r\n            collectFrozenNodes(childNode, nodes);\r\n        }","mutatedLines":"        if (childNode instanceof Object && !(childNode instanceof Array)) {\n}"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"ReverseConditional","status":1,"replacement":"childNode instanceof Object || !(childNode instanceof Array)","location":{"start":{"line":31,"column":12},"end":{"line":31,"column":72}},"range":[967,1027],"originalLines":"        if (childNode instanceof Object && !(childNode instanceof Array)) {","mutatedLines":"        if (childNode instanceof Object || !(childNode instanceof Array)) {"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":31,"column":12},"end":{"line":31,"column":72}},"range":[967,1027],"originalLines":"        if (childNode instanceof Object && !(childNode instanceof Array)) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":31,"column":12},"end":{"line":31,"column":72}},"range":[967,1027],"originalLines":"        if (childNode instanceof Object && !(childNode instanceof Array)) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":30,"column":57},"end":{"line":41,"column":5}},"range":[952,1399],"originalLines":"    _.forOwn(abstractSyntaxTree, function (childNode, i) {\r\n        if (childNode instanceof Object && !(childNode instanceof Array)) {\r\n            collectFrozenNodes(childNode, nodes);\r\n        }\r\n        else if (childNode instanceof Array) {\r\n            _.forEach(childNode, function (arrayChild) {\r\n                if (arrayChild instanceof Object && !(arrayChild instanceof Array)) {\r\n                    collectFrozenNodes(arrayChild, nodes);\r\n                }\r\n            });\r\n        }\r\n    });","mutatedLines":"    _.forOwn(abstractSyntaxTree, function (childNode, i) {\n});"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":25,"column":145},"end":{"line":28,"column":5}},"range":[753,853],"originalLines":"    if (!_.isArray(abstractSyntaxTree) && _.isObject(abstractSyntaxTree) && abstractSyntaxTree.type && _.isUndefined(abstractSyntaxTree.nodeID)) {\r\n        abstractSyntaxTree.nodeID = nodes.length;\r\n        nodes.push(abstractSyntaxTree);\r\n    }","mutatedLines":"    if (!_.isArray(abstractSyntaxTree) && _.isObject(abstractSyntaxTree) && abstractSyntaxTree.type && _.isUndefined(abstractSyntaxTree.nodeID)) {\n}"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"ReverseConditional","status":1,"replacement":"!_.isArray(abstractSyntaxTree) || _.isObject(abstractSyntaxTree)","location":{"start":{"line":25,"column":8},"end":{"line":25,"column":72}},"range":[616,680],"originalLines":"    if (!_.isArray(abstractSyntaxTree) && _.isObject(abstractSyntaxTree) && abstractSyntaxTree.type && _.isUndefined(abstractSyntaxTree.nodeID)) {","mutatedLines":"    if (!_.isArray(abstractSyntaxTree) || _.isObject(abstractSyntaxTree) && abstractSyntaxTree.type && _.isUndefined(abstractSyntaxTree.nodeID)) {"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"ReverseConditional","status":1,"replacement":"!_.isArray(abstractSyntaxTree) && _.isObject(abstractSyntaxTree) || abstractSyntaxTree.type","location":{"start":{"line":25,"column":8},"end":{"line":25,"column":99}},"range":[616,707],"originalLines":"    if (!_.isArray(abstractSyntaxTree) && _.isObject(abstractSyntaxTree) && abstractSyntaxTree.type && _.isUndefined(abstractSyntaxTree.nodeID)) {","mutatedLines":"    if (!_.isArray(abstractSyntaxTree) && _.isObject(abstractSyntaxTree) || abstractSyntaxTree.type && _.isUndefined(abstractSyntaxTree.nodeID)) {"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"ReverseConditional","status":1,"replacement":"!_.isArray(abstractSyntaxTree) && _.isObject(abstractSyntaxTree) && abstractSyntaxTree.type || _.isUndefined(abstractSyntaxTree.nodeID)","location":{"start":{"line":25,"column":8},"end":{"line":25,"column":143}},"range":[616,751],"originalLines":"    if (!_.isArray(abstractSyntaxTree) && _.isObject(abstractSyntaxTree) && abstractSyntaxTree.type && _.isUndefined(abstractSyntaxTree.nodeID)) {","mutatedLines":"    if (!_.isArray(abstractSyntaxTree) && _.isObject(abstractSyntaxTree) && abstractSyntaxTree.type || _.isUndefined(abstractSyntaxTree.nodeID)) {"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":25,"column":8},"end":{"line":25,"column":143}},"range":[616,751],"originalLines":"    if (!_.isArray(abstractSyntaxTree) && _.isObject(abstractSyntaxTree) && abstractSyntaxTree.type && _.isUndefined(abstractSyntaxTree.nodeID)) {","mutatedLines":"    if (true) {"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":25,"column":8},"end":{"line":25,"column":143}},"range":[616,751],"originalLines":"    if (!_.isArray(abstractSyntaxTree) && _.isObject(abstractSyntaxTree) && abstractSyntaxTree.type && _.isUndefined(abstractSyntaxTree.nodeID)) {","mutatedLines":"    if (false) {"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"ReverseConditional","status":1,"replacement":"nodes && []","location":{"start":{"line":24,"column":12},"end":{"line":24,"column":23}},"range":[594,605],"originalLines":"    nodes = nodes || [];","mutatedLines":"    nodes = nodes && [];"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":23,"column":55},"end":{"line":43,"column":1}},"range":[579,1423],"originalLines":"function collectFrozenNodes(abstractSyntaxTree, nodes) {\r\n    nodes = nodes || [];\r\n    if (!_.isArray(abstractSyntaxTree) && _.isObject(abstractSyntaxTree) && abstractSyntaxTree.type && _.isUndefined(abstractSyntaxTree.nodeID)) {\r\n        abstractSyntaxTree.nodeID = nodes.length;\r\n        nodes.push(abstractSyntaxTree);\r\n    }\r\n    Object.freeze(abstractSyntaxTree);\r\n    _.forOwn(abstractSyntaxTree, function (childNode, i) {\r\n        if (childNode instanceof Object && !(childNode instanceof Array)) {\r\n            collectFrozenNodes(childNode, nodes);\r\n        }\r\n        else if (childNode instanceof Array) {\r\n            _.forEach(childNode, function (arrayChild) {\r\n                if (arrayChild instanceof Object && !(arrayChild instanceof Array)) {\r\n                    collectFrozenNodes(arrayChild, nodes);\r\n                }\r\n            });\r\n        }\r\n    });\r\n    return nodes;\r\n}","mutatedLines":"function collectFrozenNodes(abstractSyntaxTree, nodes) {\n}"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":15,"column":21},"end":{"line":17,"column":5}},"range":[365,393],"originalLines":"    if (code === '') {\r\n        return {};\r\n    }","mutatedLines":"    if (code === '') {\n}"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"ReverseConditional","status":1,"replacement":"code !== ''","location":{"start":{"line":15,"column":8},"end":{"line":15,"column":19}},"range":[352,363],"originalLines":"    if (code === '') {","mutatedLines":"    if (code !== '') {"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":15,"column":8},"end":{"line":15,"column":19}},"range":[352,363],"originalLines":"    if (code === '') {","mutatedLines":"    if (true) {"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":15,"column":8},"end":{"line":15,"column":19}},"range":[352,363],"originalLines":"    if (code === '') {","mutatedLines":"    if (false) {"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":12,"column":28},"end":{"line":14,"column":5}},"range":[270,342],"originalLines":"    if (code === undefined) {\r\n        throw new Error('Code parameter cannot be undefined');\r\n    }","mutatedLines":"    if (code === undefined) {\n}"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"ReverseConditional","status":1,"replacement":"code !== undefined","location":{"start":{"line":12,"column":8},"end":{"line":12,"column":26}},"range":[250,268],"originalLines":"    if (code === undefined) {","mutatedLines":"    if (code !== undefined) {"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":12,"column":8},"end":{"line":12,"column":26}},"range":[250,268],"originalLines":"    if (code === undefined) {","mutatedLines":"    if (true) {"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":12,"column":8},"end":{"line":12,"column":26}},"range":[250,268],"originalLines":"    if (code === undefined) {","mutatedLines":"    if (false) {"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":11,"column":21},"end":{"line":20,"column":1}},"range":[239,495],"originalLines":"function parse(code) {\r\n    if (code === undefined) {\r\n        throw new Error('Code parameter cannot be undefined');\r\n    }\r\n    if (code === '') {\r\n        return {};\r\n    }\r\n    var abstractSyntaxTree = esprima.parse(code, esprimaOptions);\r\n    return abstractSyntaxTree;\r\n}","mutatedLines":"function parse(code) {\n}"},{"sourceFilePath":"/stryker/src/utils/objectUtils.js","mutatorName":"ReverseConditional","status":1,"replacement":"typeof input['then'] !== 'function'","location":{"start":{"line":13,"column":20},"end":{"line":13,"column":55}},"range":[364,399],"originalLines":"    return input && typeof input['then'] === 'function';","mutatedLines":"    return input && typeof input['then'] !== 'function';"},{"sourceFilePath":"/stryker/src/utils/objectUtils.js","mutatorName":"ReverseConditional","status":1,"replacement":"input || typeof input['then'] === 'function'","location":{"start":{"line":13,"column":11},"end":{"line":13,"column":55}},"range":[355,399],"originalLines":"    return input && typeof input['then'] === 'function';","mutatedLines":"    return input || typeof input['then'] === 'function';"},{"sourceFilePath":"/stryker/src/utils/objectUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":12,"column":26},"end":{"line":14,"column":1}},"range":[341,403],"originalLines":"function isPromise(input) {\r\n    return input && typeof input['then'] === 'function';\r\n}","mutatedLines":"function isPromise(input) {\n}"},{"sourceFilePath":"/stryker/src/utils/objectUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":6,"column":37},"end":{"line":8,"column":9}},"range":[196,253],"originalLines":"        if (_.isObject(target[key])) {\r\n            freezeRecursively(target[key]);\r\n        }","mutatedLines":"        if (_.isObject(target[key])) {\n}"},{"sourceFilePath":"/stryker/src/utils/objectUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":6,"column":12},"end":{"line":6,"column":35}},"range":[171,194],"originalLines":"        if (_.isObject(target[key])) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/utils/objectUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":6,"column":12},"end":{"line":6,"column":35}},"range":[171,194],"originalLines":"        if (_.isObject(target[key])) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/utils/objectUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":5,"column":47},"end":{"line":9,"column":5}},"range":[156,260],"originalLines":"    Object.keys(target).forEach(function (key) {\r\n        if (_.isObject(target[key])) {\r\n            freezeRecursively(target[key]);\r\n        }\r\n    });","mutatedLines":"    Object.keys(target).forEach(function (key) {\n});"},{"sourceFilePath":"/stryker/src/utils/objectUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":3,"column":35},"end":{"line":10,"column":1}},"range":[78,265],"originalLines":"function freezeRecursively(target) {\r\n    Object.freeze(target);\r\n    Object.keys(target).forEach(function (key) {\r\n        if (_.isObject(target[key])) {\r\n            freezeRecursively(target[key]);\r\n        }\r\n    });\r\n}","mutatedLines":"function freezeRecursively(target) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":153,"column":34},"end":{"line":155,"column":1}},"range":[4272,4302],"originalLines":"function importModule(moduleName) {\r\n    require(moduleName);\r\n}","mutatedLines":"function importModule(moduleName) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":148,"column":45},"end":{"line":150,"column":5}},"range":[4149,4191],"originalLines":"    if (!fileOrFolderExistsSync(folderName)) {\r\n        mkdirp.sync(folderName);\r\n    }","mutatedLines":"    if (!fileOrFolderExistsSync(folderName)) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":148,"column":8},"end":{"line":148,"column":43}},"range":[4112,4147],"originalLines":"    if (!fileOrFolderExistsSync(folderName)) {","mutatedLines":"    if (true) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":148,"column":8},"end":{"line":148,"column":43}},"range":[4112,4147],"originalLines":"    if (!fileOrFolderExistsSync(folderName)) {","mutatedLines":"    if (false) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":147,"column":36},"end":{"line":151,"column":1}},"range":[4101,4194],"originalLines":"function mkdirRecursive(folderName) {\r\n    if (!fileOrFolderExistsSync(folderName)) {\r\n        mkdirp.sync(folderName);\r\n    }\r\n}","mutatedLines":"function mkdirRecursive(folderName) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":140,"column":17},"end":{"line":142,"column":13}},"range":[3962,4006],"originalLines":"            else {\r\n                resolve();\r\n            }","mutatedLines":"            else {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":137,"column":21},"end":{"line":139,"column":13}},"range":[3897,3943],"originalLines":"            if (err) {\r\n                reject(err);\r\n            }","mutatedLines":"            if (err) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":137,"column":16},"end":{"line":137,"column":19}},"range":[3892,3895],"originalLines":"            if (err) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":137,"column":16},"end":{"line":137,"column":19}},"range":[3892,3895],"originalLines":"            if (err) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":136,"column":55},"end":{"line":143,"column":9}},"range":[3873,4017],"originalLines":"        fs.writeFile(fileName, content, function (err) {\r\n            if (err) {\r\n                reject(err);\r\n            }\r\n            else {\r\n                resolve();\r\n            }\r\n        });","mutatedLines":"        fs.writeFile(fileName, content, function (err) {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":135,"column":50},"end":{"line":144,"column":5}},"range":[3815,4026],"originalLines":"    return new Promise(function (resolve, reject) {\r\n        fs.writeFile(fileName, content, function (err) {\r\n            if (err) {\r\n                reject(err);\r\n            }\r\n            else {\r\n                resolve();\r\n            }\r\n        });\r\n    });","mutatedLines":"    return new Promise(function (resolve, reject) {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":134,"column":38},"end":{"line":145,"column":1}},"range":[3762,4031],"originalLines":"function writeFile(fileName, content) {\r\n    return new Promise(function (resolve, reject) {\r\n        fs.writeFile(fileName, content, function (err) {\r\n            if (err) {\r\n                reject(err);\r\n            }\r\n            else {\r\n                resolve();\r\n            }\r\n        });\r\n    });\r\n}","mutatedLines":"function writeFile(fileName, content) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":128,"column":13},"end":{"line":130,"column":9}},"range":[3614,3674],"originalLines":"        else {\r\n            return mkdirRecursive(folderName);\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":126,"column":34},"end":{"line":126,"column":72}},"range":[3548,3586],"originalLines":"                .then(function () { return mkdirRecursive(folderName); });","mutatedLines":"                .then(function () {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":124,"column":20},"end":{"line":127,"column":9}},"range":[3469,3599],"originalLines":"        if (exists) {\r\n            return deleteDir(folderName)\r\n                .then(function () { return mkdirRecursive(folderName); });\r\n        }","mutatedLines":"        if (exists) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":124,"column":12},"end":{"line":124,"column":18}},"range":[3461,3467],"originalLines":"        if (exists) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":124,"column":12},"end":{"line":124,"column":18}},"range":[3461,3467],"originalLines":"        if (exists) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":123,"column":32},"end":{"line":131,"column":5}},"range":[3446,3681],"originalLines":"        .then(function (exists) {\r\n        if (exists) {\r\n            return deleteDir(folderName)\r\n                .then(function () { return mkdirRecursive(folderName); });\r\n        }\r\n        else {\r\n            return mkdirRecursive(folderName);\r\n        }\r\n    });","mutatedLines":"        .then(function (exists) {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":121,"column":33},"end":{"line":132,"column":1}},"range":[3368,3686],"originalLines":"function cleanFolder(folderName) {\r\n    return fileOrFolderExists(folderName)\r\n        .then(function (exists) {\r\n        if (exists) {\r\n            return deleteDir(folderName)\r\n                .then(function () { return mkdirRecursive(folderName); });\r\n        }\r\n        else {\r\n            return mkdirRecursive(folderName);\r\n        }\r\n    });\r\n}","mutatedLines":"function cleanFolder(folderName) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":115,"column":63},"end":{"line":115,"column":93}},"range":[3229,3259],"originalLines":"                return Promise.all(promisses).then(function () { return rmdir(dirToDelete); });","mutatedLines":"                return Promise.all(promisses).then(function () {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":110,"column":29},"end":{"line":112,"column":25}},"range":[3033,3118],"originalLines":"                        else {\r\n                            return rmFile(currentPath);\r\n                        }","mutatedLines":"                        else {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":107,"column":49},"end":{"line":109,"column":25}},"range":[2914,3002],"originalLines":"                        if (stats.isDirectory()) {\r\n                            return deleteDir(currentPath);\r\n                        }","mutatedLines":"                        if (stats.isDirectory()) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":107,"column":28},"end":{"line":107,"column":47}},"range":[2893,2912],"originalLines":"                        if (stats.isDirectory()) {","mutatedLines":"                        if (true) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":107,"column":28},"end":{"line":107,"column":47}},"range":[2893,2912],"originalLines":"                        if (stats.isDirectory()) {","mutatedLines":"                        if (false) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":106,"column":68},"end":{"line":113,"column":21}},"range":[2862,3141],"originalLines":"                    return stats(currentPath).then(function (stats) {\r\n                        if (stats.isDirectory()) {\r\n                            return deleteDir(currentPath);\r\n                        }\r\n                        else {\r\n                            return rmFile(currentPath);\r\n                        }\r\n                    });","mutatedLines":"                    return stats(currentPath).then(function (stats) {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":104,"column":58},"end":{"line":114,"column":17}},"range":[2722,3162],"originalLines":"                var promisses = files.map(function (file) {\r\n                    var currentPath = path.join(dirToDelete, file);\r\n                    return stats(currentPath).then(function (stats) {\r\n                        if (stats.isDirectory()) {\r\n                            return deleteDir(currentPath);\r\n                        }\r\n                        else {\r\n                            return rmFile(currentPath);\r\n                        }\r\n                    });\r\n                });","mutatedLines":"                var promisses = files.map(function (file) {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":103,"column":62},"end":{"line":116,"column":13}},"range":[2661,3276],"originalLines":"            return readdir(dirToDelete).then(function (files) {\r\n                var promisses = files.map(function (file) {\r\n                    var currentPath = path.join(dirToDelete, file);\r\n                    return stats(currentPath).then(function (stats) {\r\n                        if (stats.isDirectory()) {\r\n                            return deleteDir(currentPath);\r\n                        }\r\n                        else {\r\n                            return rmFile(currentPath);\r\n                        }\r\n                    });\r\n                });\r\n                return Promise.all(promisses).then(function () { return rmdir(dirToDelete); });\r\n            });","mutatedLines":"            return readdir(dirToDelete).then(function (files) {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":102,"column":20},"end":{"line":117,"column":9}},"range":[2596,3289],"originalLines":"        if (exists) {\r\n            return readdir(dirToDelete).then(function (files) {\r\n                var promisses = files.map(function (file) {\r\n                    var currentPath = path.join(dirToDelete, file);\r\n                    return stats(currentPath).then(function (stats) {\r\n                        if (stats.isDirectory()) {\r\n                            return deleteDir(currentPath);\r\n                        }\r\n                        else {\r\n                            return rmFile(currentPath);\r\n                        }\r\n                    });\r\n                });\r\n                return Promise.all(promisses).then(function () { return rmdir(dirToDelete); });\r\n            });\r\n        }","mutatedLines":"        if (exists) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":102,"column":12},"end":{"line":102,"column":18}},"range":[2588,2594],"originalLines":"        if (exists) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":102,"column":12},"end":{"line":102,"column":18}},"range":[2588,2594],"originalLines":"        if (exists) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":101,"column":66},"end":{"line":118,"column":5}},"range":[2573,3296],"originalLines":"    return fileOrFolderExists(dirToDelete).then(function (exists) {\r\n        if (exists) {\r\n            return readdir(dirToDelete).then(function (files) {\r\n                var promisses = files.map(function (file) {\r\n                    var currentPath = path.join(dirToDelete, file);\r\n                    return stats(currentPath).then(function (stats) {\r\n                        if (stats.isDirectory()) {\r\n                            return deleteDir(currentPath);\r\n                        }\r\n                        else {\r\n                            return rmFile(currentPath);\r\n                        }\r\n                    });\r\n                });\r\n                return Promise.all(promisses).then(function () { return rmdir(dirToDelete); });\r\n            });\r\n        }\r\n    });","mutatedLines":"    return fileOrFolderExists(dirToDelete).then(function (exists) {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":100,"column":32},"end":{"line":119,"column":1}},"range":[2504,3301],"originalLines":"function deleteDir(dirToDelete) {\r\n    return fileOrFolderExists(dirToDelete).then(function (exists) {\r\n        if (exists) {\r\n            return readdir(dirToDelete).then(function (files) {\r\n                var promisses = files.map(function (file) {\r\n                    var currentPath = path.join(dirToDelete, file);\r\n                    return stats(currentPath).then(function (stats) {\r\n                        if (stats.isDirectory()) {\r\n                            return deleteDir(currentPath);\r\n                        }\r\n                        else {\r\n                            return rmFile(currentPath);\r\n                        }\r\n                    });\r\n                });\r\n                return Promise.all(promisses).then(function () { return rmdir(dirToDelete); });\r\n            });\r\n        }\r\n    });\r\n}","mutatedLines":"function deleteDir(dirToDelete) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":94,"column":17},"end":{"line":96,"column":13}},"range":[2401,2445],"originalLines":"            else {\r\n                resolve();\r\n            }","mutatedLines":"            else {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":91,"column":23},"end":{"line":93,"column":13}},"range":[2334,2382],"originalLines":"            if (error) {\r\n                reject(error);\r\n            }","mutatedLines":"            if (error) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":91,"column":16},"end":{"line":91,"column":21}},"range":[2327,2332],"originalLines":"            if (error) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":91,"column":16},"end":{"line":91,"column":21}},"range":[2327,2332],"originalLines":"            if (error) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":19,"column":8},"end":{"line":19,"column":33}},"range":[653,678],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"    if (!fileOrFolderExists(path)) {","mutatedLines":"    if (true) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":90,"column":47},"end":{"line":97,"column":9}},"range":[2308,2456],"originalLines":"        fs.rmdir(dirToDelete, function (error) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve();\r\n            }\r\n        });","mutatedLines":"        fs.rmdir(dirToDelete, function (error) {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":88,"column":28},"end":{"line":99,"column":1}},"range":[2205,2470],"originalLines":"function rmdir(dirToDelete) {\r\n    return new Promise(function (resolve, reject) {\r\n        fs.rmdir(dirToDelete, function (error) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve();\r\n            }\r\n        });\r\n    });\r\n}","mutatedLines":"function rmdir(dirToDelete) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":82,"column":17},"end":{"line":84,"column":13}},"range":[2102,2150],"originalLines":"            else {\r\n                fileResolve();\r\n            }","mutatedLines":"            else {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":79,"column":23},"end":{"line":81,"column":13}},"range":[2031,2083],"originalLines":"            if (error) {\r\n                fileReject(error);\r\n            }","mutatedLines":"            if (error) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":79,"column":16},"end":{"line":79,"column":21}},"range":[2024,2029],"originalLines":"            if (error) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":79,"column":16},"end":{"line":79,"column":21}},"range":[2024,2029],"originalLines":"            if (error) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":78,"column":41},"end":{"line":85,"column":9}},"range":[2005,2161],"originalLines":"        fs.unlink(path, function (error) {\r\n            if (error) {\r\n                fileReject(error);\r\n            }\r\n            else {\r\n                fileResolve();\r\n            }\r\n        });","mutatedLines":"        fs.unlink(path, function (error) {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":77,"column":58},"end":{"line":86,"column":5}},"range":[1961,2170],"originalLines":"    return new Promise(function (fileResolve, fileReject) {\r\n        fs.unlink(path, function (error) {\r\n            if (error) {\r\n                fileReject(error);\r\n            }\r\n            else {\r\n                fileResolve();\r\n            }\r\n        });\r\n    });","mutatedLines":"    return new Promise(function (fileResolve, fileReject) {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":76,"column":22},"end":{"line":87,"column":1}},"range":[1900,2175],"originalLines":"function rmFile(path) {\r\n    return new Promise(function (fileResolve, fileReject) {\r\n        fs.unlink(path, function (error) {\r\n            if (error) {\r\n                fileReject(error);\r\n            }\r\n            else {\r\n                fileResolve();\r\n            }\r\n        });\r\n    });\r\n}","mutatedLines":"function rmFile(path) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":70,"column":17},"end":{"line":72,"column":13}},"range":[1802,1851],"originalLines":"            else {\r\n                resolve(stats);\r\n            }","mutatedLines":"            else {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":67,"column":23},"end":{"line":69,"column":13}},"range":[1735,1783],"originalLines":"            if (error) {\r\n                reject(error);\r\n            }","mutatedLines":"            if (error) {\n}"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"RemoveConditionals","status":2,"replacement":"false","location":{"start":{"line":19,"column":8},"end":{"line":19,"column":33}},"range":[653,678],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"    if (!fileOrFolderExists(path)) {","mutatedLines":"    if (false) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":67,"column":16},"end":{"line":67,"column":21}},"range":[1728,1733],"originalLines":"            if (error) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":18,"column":34},"end":{"line":23,"column":1}},"range":[642,737],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"function ensureFolderExists(path) {\r\n    if (!fileOrFolderExists(path)) {\r\n        mkdirp.sync(path);\r\n    }\r\n    return path;\r\n}","mutatedLines":"function ensureFolderExists(path) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":66,"column":46},"end":{"line":73,"column":9}},"range":[1709,1862],"originalLines":"        fs.stat(path, function (error, stats) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve(stats);\r\n            }\r\n        });","mutatedLines":"        fs.stat(path, function (error, stats) {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":64,"column":21},"end":{"line":75,"column":1}},"range":[1607,1876],"originalLines":"function stats(path) {\r\n    return new Promise(function (resolve, reject) {\r\n        fs.stat(path, function (error, stats) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve(stats);\r\n            }\r\n        });\r\n    });\r\n}","mutatedLines":"function stats(path) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":57,"column":17},"end":{"line":59,"column":13}},"range":[1482,1531],"originalLines":"            else {\r\n                resolve(files);\r\n            }","mutatedLines":"            else {\n}"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"Math","status":2,"replacement":"tempFolder - path.sep","location":{"start":{"line":13,"column":30},"end":{"line":13,"column":51}},"range":[487,508],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"    return ensureFolderExists(tempFolder + path.sep + prefix + random());","mutatedLines":"    return ensureFolderExists(tempFolder - path.sep + prefix + random());"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":54,"column":23},"end":{"line":56,"column":13}},"range":[1415,1463],"originalLines":"            if (error) {\r\n                reject(error);\r\n            }","mutatedLines":"            if (error) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":54,"column":16},"end":{"line":54,"column":21}},"range":[1408,1413],"originalLines":"            if (error) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"Math","status":2,"replacement":"Math.random() / 10000000","location":{"start":{"line":16,"column":21},"end":{"line":16,"column":45}},"range":[577,601],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"    return Math.ceil(Math.random() * 10000000);","mutatedLines":"    return Math.ceil(Math.random() / 10000000);"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":53,"column":49},"end":{"line":60,"column":9}},"range":[1389,1542],"originalLines":"        fs.readdir(path, function (error, files) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve(files);\r\n            }\r\n        });","mutatedLines":"        fs.readdir(path, function (error, files) {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":51,"column":23},"end":{"line":62,"column":1}},"range":[1284,1556],"originalLines":"function readdir(path) {\r\n    return new Promise(function (resolve, reject) {\r\n        fs.readdir(path, function (error, files) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve(files);\r\n            }\r\n        });\r\n    });\r\n}","mutatedLines":"function readdir(path) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":44,"column":17},"end":{"line":46,"column":13}},"range":[1161,1212],"originalLines":"            else {\r\n                resolve(matches);\r\n            }","mutatedLines":"            else {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":41,"column":23},"end":{"line":43,"column":13}},"range":[1094,1142],"originalLines":"            if (error) {\r\n                reject(error);\r\n            }","mutatedLines":"            if (error) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":41,"column":16},"end":{"line":41,"column":21}},"range":[1087,1092],"originalLines":"            if (error) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":46,"column":24},"end":{"line":48,"column":1}},"range":[1502,1544],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"function generate(node) {\r\n    return escodegen.generate(node);\r\n}","mutatedLines":"function generate(node) {\n}"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"Math","status":2,"replacement":"tempFolder + path.sep + prefix - random()","location":{"start":{"line":13,"column":30},"end":{"line":13,"column":71}},"range":[487,528],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"    return ensureFolderExists(tempFolder + path.sep + prefix + random());","mutatedLines":"    return ensureFolderExists(tempFolder + path.sep + prefix - random());"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":41,"column":16},"end":{"line":41,"column":21}},"range":[1087,1092],"originalLines":"            if (error) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":38,"column":26},"end":{"line":49,"column":1}},"range":[957,1237],"originalLines":"function glob(expression) {\r\n    return new Promise(function (resolve, reject) {\r\n        nodeGlob(expression, function (error, matches) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve(matches);\r\n            }\r\n        });\r\n    });\r\n}","mutatedLines":"function glob(expression) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":32,"column":42},"end":{"line":34,"column":5}},"range":[823,889],"originalLines":"    _.forEach(files, function (file, key) {\r\n        files[key] = path.resolve(path.normalize(file));\r\n    });","mutatedLines":"    _.forEach(files, function (file, key) {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":31,"column":26},"end":{"line":35,"column":1}},"range":[778,894],"originalLines":"function normalize(files) {\r\n    _.forEach(files, function (file, key) {\r\n        files[key] = path.resolve(path.normalize(file));\r\n    });\r\n}","mutatedLines":"function normalize(files) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":26,"column":28},"end":{"line":28,"column":1}},"range":[666,717],"originalLines":"function readFile(filename) {\r\n    return fs.readFileSync(filename, 'utf8');\r\n}","mutatedLines":"function readFile(filename) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":20,"column":47},"end":{"line":22,"column":9}},"range":[530,572],"originalLines":"        fs.lstat(path, function (error, stats) {\r\n            resolve(!error);\r\n        });","mutatedLines":"        fs.lstat(path, function (error, stats) {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":19,"column":42},"end":{"line":23,"column":5}},"range":[480,581],"originalLines":"    return new Promise(function (resolve) {\r\n        fs.lstat(path, function (error, stats) {\r\n            resolve(!error);\r\n        });\r\n    });","mutatedLines":"    return new Promise(function (resolve) {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":18,"column":34},"end":{"line":24,"column":1}},"range":[435,586],"originalLines":"function fileOrFolderExists(path) {\r\n    return new Promise(function (resolve) {\r\n        fs.lstat(path, function (error, stats) {\r\n            resolve(!error);\r\n        });\r\n    });\r\n}","mutatedLines":"function fileOrFolderExists(path) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":12,"column":19},"end":{"line":14,"column":5}},"range":[304,335],"originalLines":"    catch (errror) {\r\n        return false;\r\n    }","mutatedLines":"    catch (errror) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":8,"column":8},"end":{"line":11,"column":5}},"range":[212,283],"originalLines":"    try {\r\n        var stats = fs.lstatSync(path);\r\n        return true;\r\n    }","mutatedLines":"    try {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":7,"column":38},"end":{"line":15,"column":1}},"range":[201,338],"originalLines":"function fileOrFolderExistsSync(path) {\r\n    try {\r\n        var stats = fs.lstatSync(path);\r\n        return true;\r\n    }\r\n    catch (errror) {\r\n        return false;\r\n    }\r\n}","mutatedLines":"function fileOrFolderExistsSync(path) {\n}"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":58,"column":68},"end":{"line":60,"column":5}},"range":[3416,3467],"originalLines":"    TestSelectorOrchestrator.prototype.createSettings = function () {\r\n        return { options: this.options };\r\n    };","mutatedLines":"    TestSelectorOrchestrator.prototype.createSettings = function () {\n};"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"UnaryOperator","status":1,"replacement":"+1","location":{"start":{"line":56,"column":100},"end":{"line":56,"column":102}},"range":[3335,3337],"originalLines":"        return test_selector_1.TestSelectorFactory.instance().knownNames().indexOf(maybeSelector) > -1;","mutatedLines":"        return test_selector_1.TestSelectorFactory.instance().knownNames().indexOf(maybeSelector) > +1;"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"ReverseConditional","status":1,"replacement":"test_selector_1.TestSelectorFactory.instance().knownNames().indexOf(maybeSelector) <= -1","location":{"start":{"line":56,"column":15},"end":{"line":56,"column":102}},"range":[3250,3337],"originalLines":"        return test_selector_1.TestSelectorFactory.instance().knownNames().indexOf(maybeSelector) > -1;","mutatedLines":"        return test_selector_1.TestSelectorFactory.instance().knownNames().indexOf(maybeSelector) <= -1;"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"ConditionalBoundary","status":1,"replacement":"test_selector_1.TestSelectorFactory.instance().knownNames().indexOf(maybeSelector) >= -1","location":{"start":{"line":56,"column":15},"end":{"line":56,"column":102}},"range":[3250,3337],"originalLines":"        return test_selector_1.TestSelectorFactory.instance().knownNames().indexOf(maybeSelector) > -1;","mutatedLines":"        return test_selector_1.TestSelectorFactory.instance().knownNames().indexOf(maybeSelector) >= -1;"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":55,"column":85},"end":{"line":57,"column":5}},"range":[3232,3345],"originalLines":"    TestSelectorOrchestrator.prototype.testSelectorExists = function (maybeSelector) {\r\n        return test_selector_1.TestSelectorFactory.instance().knownNames().indexOf(maybeSelector) > -1;\r\n    };","mutatedLines":"    TestSelectorOrchestrator.prototype.testSelectorExists = function (maybeSelector) {\n};"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":52,"column":76},"end":{"line":54,"column":5}},"range":[3036,3144],"originalLines":"    TestSelectorOrchestrator.prototype.createTestSelector = function (name) {\r\n        return test_selector_1.TestSelectorFactory.instance().create(name, this.createSettings());\r\n    };","mutatedLines":"    TestSelectorOrchestrator.prototype.createTestSelector = function (name) {\n};"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'Did you forget to load a plugin? Known test selectors: ' - JSON.stringify(test_selector_1.TestSelectorFactory.instance().knownNames())","location":{"start":{"line":50,"column":15},"end":{"line":50,"column":150}},"range":[2808,2943],"originalLines":"        return \"Did you forget to load a plugin? Known test selectors: \" + JSON.stringify(test_selector_1.TestSelectorFactory.instance().knownNames()) + \".\";","mutatedLines":"        return 'Did you forget to load a plugin? Known test selectors: ' - JSON.stringify(test_selector_1.TestSelectorFactory.instance().knownNames()) + \".\";"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'Did you forget to load a plugin? Known test selectors: ' + JSON.stringify(test_selector_1.TestSelectorFactory.instance().knownNames()) - '.'","location":{"start":{"line":50,"column":15},"end":{"line":50,"column":156}},"range":[2808,2949],"originalLines":"        return \"Did you forget to load a plugin? Known test selectors: \" + JSON.stringify(test_selector_1.TestSelectorFactory.instance().knownNames()) + \".\";","mutatedLines":"        return 'Did you forget to load a plugin? Known test selectors: ' + JSON.stringify(test_selector_1.TestSelectorFactory.instance().knownNames()) - '.';"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":49,"column":83},"end":{"line":51,"column":5}},"range":[2790,2957],"originalLines":"    TestSelectorOrchestrator.prototype.informAboutKnownTestSelectors = function () {\r\n        return \"Did you forget to load a plugin? Known test selectors: \" + JSON.stringify(test_selector_1.TestSelectorFactory.instance().knownNames()) + \".\";\r\n    };","mutatedLines":"    TestSelectorOrchestrator.prototype.informAboutKnownTestSelectors = function () {\n};"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'Could not find test selector `' - this.options.testFramework","location":{"start":{"line":45,"column":21},"end":{"line":45,"column":82}},"range":[2446,2507],"originalLines":"            log.warn(\"Could not find test selector `\" + this.options.testFramework + \"` (based on the configured testFramework). \" + WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + IGNORE_WARNING + \" \" + this.informAboutKnownTestSelectors());","mutatedLines":"            log.warn('Could not find test selector `' - this.options.testFramework + \"` (based on the configured testFramework). \" + WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + IGNORE_WARNING + \" \" + this.informAboutKnownTestSelectors());"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'Could not find test selector `' + this.options.testFramework - '` (based on the configured testFramework). '","location":{"start":{"line":45,"column":21},"end":{"line":45,"column":130}},"range":[2446,2555],"originalLines":"            log.warn(\"Could not find test selector `\" + this.options.testFramework + \"` (based on the configured testFramework). \" + WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + IGNORE_WARNING + \" \" + this.informAboutKnownTestSelectors());","mutatedLines":"            log.warn('Could not find test selector `' + this.options.testFramework - '` (based on the configured testFramework). ' + WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + IGNORE_WARNING + \" \" + this.informAboutKnownTestSelectors());"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'Could not find test selector `' + this.options.testFramework + '` (based on the configured testFramework). ' - WARNING_RUNNING_WITHOUT_SELECTOR","location":{"start":{"line":45,"column":21},"end":{"line":45,"column":165}},"range":[2446,2590],"originalLines":"            log.warn(\"Could not find test selector `\" + this.options.testFramework + \"` (based on the configured testFramework). \" + WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + IGNORE_WARNING + \" \" + this.informAboutKnownTestSelectors());","mutatedLines":"            log.warn('Could not find test selector `' + this.options.testFramework + '` (based on the configured testFramework). ' - WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + IGNORE_WARNING + \" \" + this.informAboutKnownTestSelectors());"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'Could not find test selector `' + this.options.testFramework + '` (based on the configured testFramework). ' + WARNING_RUNNING_WITHOUT_SELECTOR - ' '","location":{"start":{"line":45,"column":21},"end":{"line":45,"column":171}},"range":[2446,2596],"originalLines":"            log.warn(\"Could not find test selector `\" + this.options.testFramework + \"` (based on the configured testFramework). \" + WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + IGNORE_WARNING + \" \" + this.informAboutKnownTestSelectors());","mutatedLines":"            log.warn('Could not find test selector `' + this.options.testFramework + '` (based on the configured testFramework). ' + WARNING_RUNNING_WITHOUT_SELECTOR - ' ' + IGNORE_WARNING + \" \" + this.informAboutKnownTestSelectors());"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'Could not find test selector `' + this.options.testFramework + '` (based on the configured testFramework). ' + WARNING_RUNNING_WITHOUT_SELECTOR + ' ' - IGNORE_WARNING","location":{"start":{"line":45,"column":21},"end":{"line":45,"column":188}},"range":[2446,2613],"originalLines":"            log.warn(\"Could not find test selector `\" + this.options.testFramework + \"` (based on the configured testFramework). \" + WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + IGNORE_WARNING + \" \" + this.informAboutKnownTestSelectors());","mutatedLines":"            log.warn('Could not find test selector `' + this.options.testFramework + '` (based on the configured testFramework). ' + WARNING_RUNNING_WITHOUT_SELECTOR + ' ' - IGNORE_WARNING + \" \" + this.informAboutKnownTestSelectors());"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'Could not find test selector `' + this.options.testFramework + '` (based on the configured testFramework). ' + WARNING_RUNNING_WITHOUT_SELECTOR + ' ' + IGNORE_WARNING - ' '","location":{"start":{"line":45,"column":21},"end":{"line":45,"column":194}},"range":[2446,2619],"originalLines":"            log.warn(\"Could not find test selector `\" + this.options.testFramework + \"` (based on the configured testFramework). \" + WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + IGNORE_WARNING + \" \" + this.informAboutKnownTestSelectors());","mutatedLines":"            log.warn('Could not find test selector `' + this.options.testFramework + '` (based on the configured testFramework). ' + WARNING_RUNNING_WITHOUT_SELECTOR + ' ' + IGNORE_WARNING - ' ' + this.informAboutKnownTestSelectors());"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'Could not find test selector `' + this.options.testFramework + '` (based on the configured testFramework). ' + WARNING_RUNNING_WITHOUT_SELECTOR + ' ' + IGNORE_WARNING + ' ' - this.informAboutKnownTestSelectors()","location":{"start":{"line":45,"column":21},"end":{"line":45,"column":233}},"range":[2446,2658],"originalLines":"            log.warn(\"Could not find test selector `\" + this.options.testFramework + \"` (based on the configured testFramework). \" + WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + IGNORE_WARNING + \" \" + this.informAboutKnownTestSelectors());","mutatedLines":"            log.warn('Could not find test selector `' + this.options.testFramework + '` (based on the configured testFramework). ' + WARNING_RUNNING_WITHOUT_SELECTOR + ' ' + IGNORE_WARNING + ' ' - this.informAboutKnownTestSelectors());"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":44,"column":13},"end":{"line":47,"column":9}},"range":[2422,2697],"originalLines":"        else {\r\n            log.warn(\"Could not find test selector `\" + this.options.testFramework + \"` (based on the configured testFramework). \" + WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + IGNORE_WARNING + \" \" + this.informAboutKnownTestSelectors());\r\n            return null;\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'Using testSelector ' - this.options.testFramework","location":{"start":{"line":41,"column":22},"end":{"line":41,"column":72}},"range":[2233,2283],"originalLines":"            log.debug(\"Using testSelector \" + this.options.testFramework + \" based on `testFramework` setting\");","mutatedLines":"            log.debug('Using testSelector ' - this.options.testFramework + \" based on `testFramework` setting\");"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'Using testSelector ' + this.options.testFramework - ' based on `testFramework` setting'","location":{"start":{"line":41,"column":22},"end":{"line":41,"column":110}},"range":[2233,2321],"originalLines":"            log.debug(\"Using testSelector \" + this.options.testFramework + \" based on `testFramework` setting\");","mutatedLines":"            log.debug('Using testSelector ' + this.options.testFramework - ' based on `testFramework` setting');"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":40,"column":65},"end":{"line":43,"column":9}},"range":[2208,2407],"originalLines":"        if (this.testSelectorExists(this.options.testFramework)) {\r\n            log.debug(\"Using testSelector \" + this.options.testFramework + \" based on `testFramework` setting\");\r\n            return this.createTestSelector(this.options.testFramework);\r\n        }","mutatedLines":"        if (this.testSelectorExists(this.options.testFramework)) {\n}"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":40,"column":12},"end":{"line":40,"column":63}},"range":[2155,2206],"originalLines":"        if (this.testSelectorExists(this.options.testFramework)) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":40,"column":12},"end":{"line":40,"column":63}},"range":[2155,2206],"originalLines":"        if (this.testSelectorExists(this.options.testFramework)) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":39,"column":102},"end":{"line":48,"column":5}},"range":[2140,2704],"originalLines":"    TestSelectorOrchestrator.prototype.determineTestSelectorBasedOnTestFrameworkSetting = function () {\r\n        if (this.testSelectorExists(this.options.testFramework)) {\r\n            log.debug(\"Using testSelector \" + this.options.testFramework + \" based on `testFramework` setting\");\r\n            return this.createTestSelector(this.options.testFramework);\r\n        }\r\n        else {\r\n            log.warn(\"Could not find test selector `\" + this.options.testFramework + \"` (based on the configured testFramework). \" + WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + IGNORE_WARNING + \" \" + this.informAboutKnownTestSelectors());\r\n            return null;\r\n        }\r\n    };","mutatedLines":"    TestSelectorOrchestrator.prototype.determineTestSelectorBasedOnTestFrameworkSetting = function () {\n};"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'Could not find test selector `' - this.options.testSelector","location":{"start":{"line":35,"column":21},"end":{"line":35,"column":81}},"range":[1841,1901],"originalLines":"            log.warn(\"Could not find test selector `\" + this.options.testSelector + \"`. \" + WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + this.informAboutKnownTestSelectors());","mutatedLines":"            log.warn('Could not find test selector `' - this.options.testSelector + \"`. \" + WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + this.informAboutKnownTestSelectors());"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'Could not find test selector `' + this.options.testSelector - '`. '","location":{"start":{"line":35,"column":21},"end":{"line":35,"column":89}},"range":[1841,1909],"originalLines":"            log.warn(\"Could not find test selector `\" + this.options.testSelector + \"`. \" + WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + this.informAboutKnownTestSelectors());","mutatedLines":"            log.warn('Could not find test selector `' + this.options.testSelector - '`. ' + WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + this.informAboutKnownTestSelectors());"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'Could not find test selector `' + this.options.testSelector + '`. ' - WARNING_RUNNING_WITHOUT_SELECTOR","location":{"start":{"line":35,"column":21},"end":{"line":35,"column":124}},"range":[1841,1944],"originalLines":"            log.warn(\"Could not find test selector `\" + this.options.testSelector + \"`. \" + WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + this.informAboutKnownTestSelectors());","mutatedLines":"            log.warn('Could not find test selector `' + this.options.testSelector + '`. ' - WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + this.informAboutKnownTestSelectors());"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'Could not find test selector `' + this.options.testSelector + '`. ' + WARNING_RUNNING_WITHOUT_SELECTOR - ' '","location":{"start":{"line":35,"column":21},"end":{"line":35,"column":130}},"range":[1841,1950],"originalLines":"            log.warn(\"Could not find test selector `\" + this.options.testSelector + \"`. \" + WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + this.informAboutKnownTestSelectors());","mutatedLines":"            log.warn('Could not find test selector `' + this.options.testSelector + '`. ' + WARNING_RUNNING_WITHOUT_SELECTOR - ' ' + this.informAboutKnownTestSelectors());"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'Could not find test selector `' + this.options.testSelector + '`. ' + WARNING_RUNNING_WITHOUT_SELECTOR + ' ' - this.informAboutKnownTestSelectors()","location":{"start":{"line":35,"column":21},"end":{"line":35,"column":169}},"range":[1841,1989],"originalLines":"            log.warn(\"Could not find test selector `\" + this.options.testSelector + \"`. \" + WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + this.informAboutKnownTestSelectors());","mutatedLines":"            log.warn('Could not find test selector `' + this.options.testSelector + '`. ' + WARNING_RUNNING_WITHOUT_SELECTOR + ' ' - this.informAboutKnownTestSelectors());"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":34,"column":13},"end":{"line":37,"column":9}},"range":[1817,2028],"originalLines":"        else {\r\n            log.warn(\"Could not find test selector `\" + this.options.testSelector + \"`. \" + WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + this.informAboutKnownTestSelectors());\r\n            return null;\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'Using testSelector ' - this.options.testSelector","location":{"start":{"line":31,"column":22},"end":{"line":31,"column":71}},"range":[1631,1680],"originalLines":"            log.debug(\"Using testSelector \" + this.options.testSelector + \" based on `testSelector` setting\");","mutatedLines":"            log.debug('Using testSelector ' - this.options.testSelector + \" based on `testSelector` setting\");"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'Using testSelector ' + this.options.testSelector - ' based on `testSelector` setting'","location":{"start":{"line":31,"column":22},"end":{"line":31,"column":108}},"range":[1631,1717],"originalLines":"            log.debug(\"Using testSelector \" + this.options.testSelector + \" based on `testSelector` setting\");","mutatedLines":"            log.debug('Using testSelector ' + this.options.testSelector - ' based on `testSelector` setting');"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":30,"column":64},"end":{"line":33,"column":9}},"range":[1606,1802],"originalLines":"        if (this.testSelectorExists(this.options.testSelector)) {\r\n            log.debug(\"Using testSelector \" + this.options.testSelector + \" based on `testSelector` setting\");\r\n            return this.createTestSelector(this.options.testSelector);\r\n        }","mutatedLines":"        if (this.testSelectorExists(this.options.testSelector)) {\n}"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":30,"column":12},"end":{"line":30,"column":62}},"range":[1554,1604],"originalLines":"        if (this.testSelectorExists(this.options.testSelector)) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":30,"column":12},"end":{"line":30,"column":62}},"range":[1554,1604],"originalLines":"        if (this.testSelectorExists(this.options.testSelector)) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":29,"column":101},"end":{"line":38,"column":5}},"range":[1539,2035],"originalLines":"    TestSelectorOrchestrator.prototype.determineTestSelectorBasedOnTestSelectorSetting = function () {\r\n        if (this.testSelectorExists(this.options.testSelector)) {\r\n            log.debug(\"Using testSelector \" + this.options.testSelector + \" based on `testSelector` setting\");\r\n            return this.createTestSelector(this.options.testSelector);\r\n        }\r\n        else {\r\n            log.warn(\"Could not find test selector `\" + this.options.testSelector + \"`. \" + WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + this.informAboutKnownTestSelectors());\r\n            return null;\r\n        }\r\n    };","mutatedLines":"    TestSelectorOrchestrator.prototype.determineTestSelectorBasedOnTestSelectorSetting = function () {\n};"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'Missing config settings `testFramework` or `testSelector`. ' - WARNING_RUNNING_WITHOUT_SELECTOR","location":{"start":{"line":24,"column":25},"end":{"line":24,"column":121}},"range":[1251,1347],"originalLines":"                log.warn(\"Missing config settings `testFramework` or `testSelector`. \" + WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + IGNORE_WARNING);","mutatedLines":"                log.warn('Missing config settings `testFramework` or `testSelector`. ' - WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + IGNORE_WARNING);"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'Missing config settings `testFramework` or `testSelector`. ' + WARNING_RUNNING_WITHOUT_SELECTOR - ' '","location":{"start":{"line":24,"column":25},"end":{"line":24,"column":127}},"range":[1251,1353],"originalLines":"                log.warn(\"Missing config settings `testFramework` or `testSelector`. \" + WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + IGNORE_WARNING);","mutatedLines":"                log.warn('Missing config settings `testFramework` or `testSelector`. ' + WARNING_RUNNING_WITHOUT_SELECTOR - ' ' + IGNORE_WARNING);"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'Missing config settings `testFramework` or `testSelector`. ' + WARNING_RUNNING_WITHOUT_SELECTOR + ' ' - IGNORE_WARNING","location":{"start":{"line":24,"column":25},"end":{"line":24,"column":144}},"range":[1251,1370],"originalLines":"                log.warn(\"Missing config settings `testFramework` or `testSelector`. \" + WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + IGNORE_WARNING);","mutatedLines":"                log.warn('Missing config settings `testFramework` or `testSelector`. ' + WARNING_RUNNING_WITHOUT_SELECTOR + ' ' - IGNORE_WARNING);"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":23,"column":17},"end":{"line":25,"column":13}},"range":[1223,1387],"originalLines":"            else {\r\n                log.warn(\"Missing config settings `testFramework` or `testSelector`. \" + WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + IGNORE_WARNING);\r\n            }","mutatedLines":"            else {\n}"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":20,"column":44},"end":{"line":22,"column":13}},"range":[1099,1204],"originalLines":"            if (this.options.testFramework) {\r\n                testSelector = this.determineTestSelectorBasedOnTestFrameworkSetting();\r\n            }","mutatedLines":"            if (this.options.testFramework) {\n}"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":20,"column":16},"end":{"line":20,"column":42}},"range":[1071,1097],"originalLines":"            if (this.options.testFramework) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":20,"column":16},"end":{"line":20,"column":42}},"range":[1071,1097],"originalLines":"            if (this.options.testFramework) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":19,"column":13},"end":{"line":26,"column":9}},"range":[1052,1398],"originalLines":"        else {\r\n            if (this.options.testFramework) {\r\n                testSelector = this.determineTestSelectorBasedOnTestFrameworkSetting();\r\n            }\r\n            else {\r\n                log.warn(\"Missing config settings `testFramework` or `testSelector`. \" + WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + IGNORE_WARNING);\r\n            }\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":16,"column":93},"end":{"line":18,"column":9}},"range":[944,1037],"originalLines":"        else if (this.options.testSelector === null || this.options.testSelector === 'null') {\r\n            log.debug('Running without testSelector (testSelector was null).');\r\n        }","mutatedLines":"        else if (this.options.testSelector === null || this.options.testSelector === 'null') {\n}"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"ReverseConditional","status":1,"replacement":"this.options.testSelector !== 'null'","location":{"start":{"line":16,"column":55},"end":{"line":16,"column":91}},"range":[906,942],"originalLines":"        else if (this.options.testSelector === null || this.options.testSelector === 'null') {","mutatedLines":"        else if (this.options.testSelector === null || this.options.testSelector !== 'null') {"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"ReverseConditional","status":1,"replacement":"this.options.testSelector !== null","location":{"start":{"line":16,"column":17},"end":{"line":16,"column":51}},"range":[868,902],"originalLines":"        else if (this.options.testSelector === null || this.options.testSelector === 'null') {","mutatedLines":"        else if (this.options.testSelector !== null || this.options.testSelector === 'null') {"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"ReverseConditional","status":1,"replacement":"this.options.testSelector === null && this.options.testSelector === 'null'","location":{"start":{"line":16,"column":17},"end":{"line":16,"column":91}},"range":[868,942],"originalLines":"        else if (this.options.testSelector === null || this.options.testSelector === 'null') {","mutatedLines":"        else if (this.options.testSelector === null && this.options.testSelector === 'null') {"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":16,"column":17},"end":{"line":16,"column":91}},"range":[868,942],"originalLines":"        else if (this.options.testSelector === null || this.options.testSelector === 'null') {","mutatedLines":"        else if (true) {"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":16,"column":17},"end":{"line":16,"column":91}},"range":[868,942],"originalLines":"        else if (this.options.testSelector === null || this.options.testSelector === 'null') {","mutatedLines":"        else if (false) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":89,"column":50},"end":{"line":98,"column":5}},"range":[2258,2465],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"    return new Promise(function (resolve, reject) {\r\n        fs.rmdir(dirToDelete, function (error) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve();\r\n            }\r\n        });\r\n    });","mutatedLines":"    return new Promise(function (resolve, reject) {\n});"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":13,"column":79},"end":{"line":15,"column":9}},"range":[753,849],"originalLines":"        if (this.options.testSelector && this.options.testSelector !== 'null') {\r\n            testSelector = this.determineTestSelectorBasedOnTestSelectorSetting();\r\n        }","mutatedLines":"        if (this.options.testSelector && this.options.testSelector !== 'null') {\n}"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"ReverseConditional","status":1,"replacement":"this.options.testSelector || this.options.testSelector !== 'null'","location":{"start":{"line":13,"column":12},"end":{"line":13,"column":77}},"range":[686,751],"originalLines":"        if (this.options.testSelector && this.options.testSelector !== 'null') {","mutatedLines":"        if (this.options.testSelector || this.options.testSelector !== 'null') {"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":13,"column":12},"end":{"line":13,"column":77}},"range":[686,751],"originalLines":"        if (this.options.testSelector && this.options.testSelector !== 'null') {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":13,"column":12},"end":{"line":13,"column":77}},"range":[686,751],"originalLines":"        if (this.options.testSelector && this.options.testSelector !== 'null') {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":11,"column":75},"end":{"line":28,"column":5}},"range":[637,1435],"originalLines":"    TestSelectorOrchestrator.prototype.determineTestSelector = function () {\r\n        var testSelector = null;\r\n        if (this.options.testSelector && this.options.testSelector !== 'null') {\r\n            testSelector = this.determineTestSelectorBasedOnTestSelectorSetting();\r\n        }\r\n        else if (this.options.testSelector === null || this.options.testSelector === 'null') {\r\n            log.debug('Running without testSelector (testSelector was null).');\r\n        }\r\n        else {\r\n            if (this.options.testFramework) {\r\n                testSelector = this.determineTestSelectorBasedOnTestFrameworkSetting();\r\n            }\r\n            else {\r\n                log.warn(\"Missing config settings `testFramework` or `testSelector`. \" + WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + IGNORE_WARNING);\r\n            }\r\n        }\r\n        return testSelector;\r\n    };","mutatedLines":"    TestSelectorOrchestrator.prototype.determineTestSelector = function () {\n};"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":8,"column":47},"end":{"line":10,"column":5}},"range":[519,560],"originalLines":"    function TestSelectorOrchestrator(options) {\r\n        this.options = options;\r\n    }","mutatedLines":"    function TestSelectorOrchestrator(options) {\n}"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":7,"column":44},"end":{"line":62,"column":1}},"range":[469,3509],"originalLines":"var TestSelectorOrchestrator = (function () {\r\n    function TestSelectorOrchestrator(options) {\r\n        this.options = options;\r\n    }\r\n    TestSelectorOrchestrator.prototype.determineTestSelector = function () {\r\n        var testSelector = null;\r\n        if (this.options.testSelector && this.options.testSelector !== 'null') {\r\n            testSelector = this.determineTestSelectorBasedOnTestSelectorSetting();\r\n        }\r\n        else if (this.options.testSelector === null || this.options.testSelector === 'null') {\r\n            log.debug('Running without testSelector (testSelector was null).');\r\n        }\r\n        else {\r\n            if (this.options.testFramework) {\r\n                testSelector = this.determineTestSelectorBasedOnTestFrameworkSetting();\r\n            }\r\n            else {\r\n                log.warn(\"Missing config settings `testFramework` or `testSelector`. \" + WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + IGNORE_WARNING);\r\n            }\r\n        }\r\n        return testSelector;\r\n    };\r\n    TestSelectorOrchestrator.prototype.determineTestSelectorBasedOnTestSelectorSetting = function () {\r\n        if (this.testSelectorExists(this.options.testSelector)) {\r\n            log.debug(\"Using testSelector \" + this.options.testSelector + \" based on `testSelector` setting\");\r\n            return this.createTestSelector(this.options.testSelector);\r\n        }\r\n        else {\r\n            log.warn(\"Could not find test selector `\" + this.options.testSelector + \"`. \" + WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + this.informAboutKnownTestSelectors());\r\n            return null;\r\n        }\r\n    };\r\n    TestSelectorOrchestrator.prototype.determineTestSelectorBasedOnTestFrameworkSetting = function () {\r\n        if (this.testSelectorExists(this.options.testFramework)) {\r\n            log.debug(\"Using testSelector \" + this.options.testFramework + \" based on `testFramework` setting\");\r\n            return this.createTestSelector(this.options.testFramework);\r\n        }\r\n        else {\r\n            log.warn(\"Could not find test selector `\" + this.options.testFramework + \"` (based on the configured testFramework). \" + WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + IGNORE_WARNING + \" \" + this.informAboutKnownTestSelectors());\r\n            return null;\r\n        }\r\n    };\r\n    TestSelectorOrchestrator.prototype.informAboutKnownTestSelectors = function () {\r\n        return \"Did you forget to load a plugin? Known test selectors: \" + JSON.stringify(test_selector_1.TestSelectorFactory.instance().knownNames()) + \".\";\r\n    };\r\n    TestSelectorOrchestrator.prototype.createTestSelector = function (name) {\r\n        return test_selector_1.TestSelectorFactory.instance().create(name, this.createSettings());\r\n    };\r\n    TestSelectorOrchestrator.prototype.testSelectorExists = function (maybeSelector) {\r\n        return test_selector_1.TestSelectorFactory.instance().knownNames().indexOf(maybeSelector) > -1;\r\n    };\r\n    TestSelectorOrchestrator.prototype.createSettings = function () {\r\n        return { options: this.options };\r\n    };\r\n    return TestSelectorOrchestrator;\r\n}());","mutatedLines":"var TestSelectorOrchestrator = (function () {\n}());"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"Math","status":1,"replacement":"this.options.port - index","location":{"start":{"line":221,"column":18},"end":{"line":221,"column":43}},"range":[10657,10682],"originalLines":"            port: this.options.port + index","mutatedLines":"            port: this.options.port - index"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":214,"column":35},"end":{"line":216,"column":9}},"range":[10380,10494],"originalLines":"        if (testSelectionFilePath) {\r\n            files = [{ path: testSelectionFilePath, mutated: false, included: true }].concat(files);\r\n        }","mutatedLines":"        if (testSelectionFilePath) {\n}"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":214,"column":12},"end":{"line":214,"column":33}},"range":[10357,10378],"originalLines":"        if (testSelectionFilePath) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":214,"column":12},"end":{"line":214,"column":33}},"range":[10357,10378],"originalLines":"        if (testSelectionFilePath) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":213,"column":30},"end":{"line":213,"column":44}},"range":[10329,10343],"originalLines":"        if (index === void 0) { index = 0; }","mutatedLines":"        if (index === void 0) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":65,"column":50},"end":{"line":74,"column":5}},"range":[1660,1871],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"    return new Promise(function (resolve, reject) {\r\n        fs.stat(path, function (error, stats) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve(stats);\r\n            }\r\n        });\r\n    });","mutatedLines":"    return new Promise(function (resolve, reject) {\n});"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"ReverseConditional","status":1,"replacement":"index !== void 0","location":{"start":{"line":213,"column":12},"end":{"line":213,"column":28}},"range":[10311,10327],"originalLines":"        if (index === void 0) { index = 0; }","mutatedLines":"        if (index !== void 0) { index = 0; }"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":213,"column":12},"end":{"line":213,"column":28}},"range":[10311,10327],"originalLines":"        if (index === void 0) { index = 0; }","mutatedLines":"        if (false) { index = 0; }"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":2,"replacement":"false","location":{"start":{"line":67,"column":16},"end":{"line":67,"column":21}},"range":[1728,1733],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"            if (error) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":212,"column":120},"end":{"line":225,"column":5}},"range":[10296,10920],"originalLines":"    TestRunnerOrchestrator.prototype.createTestRunner = function (files, coverageEnabled, testSelectionFilePath, index) {\r\n        if (index === void 0) { index = 0; }\r\n        if (testSelectionFilePath) {\r\n            files = [{ path: testSelectionFilePath, mutated: false, included: true }].concat(files);\r\n        }\r\n        var settings = {\r\n            coverageEnabled: coverageEnabled,\r\n            files: files,\r\n            strykerOptions: this.options,\r\n            port: this.options.port + index\r\n        };\r\n        log.debug(\"Creating test runner %s using settings {port: %s, coverageEnabled: %s}\", index, settings.port, settings.coverageEnabled);\r\n        return IsolatedTestRunnerAdapterFactory_1.default.create(settings);\r\n    };","mutatedLines":"    TestRunnerOrchestrator.prototype.createTestRunner = function (files, coverageEnabled, testSelectionFilePath, index) {\n};"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"Math","status":1,"replacement":"folder - path.dirname(relativePath)","location":{"start":{"line":204,"column":80},"end":{"line":204,"column":115}},"range":[9790,9825],"originalLines":"                var folderName = StrykerTempFolder_1.default.ensureFolderExists(folder + path.dirname(relativePath));","mutatedLines":"                var folderName = StrykerTempFolder_1.default.ensureFolderExists(folder - path.dirname(relativePath));"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":202,"column":63},"end":{"line":208,"column":13}},"range":[9641,10063],"originalLines":"            var copyPromises = _this.files.map(function (file) {\r\n                var relativePath = file.path.substr(cwd.length);\r\n                var folderName = StrykerTempFolder_1.default.ensureFolderExists(folder + path.dirname(relativePath));\r\n                var targetFile = path.join(folderName, path.basename(relativePath));\r\n                fileMap[file.path] = targetFile;\r\n                return StrykerTempFolder_1.default.copyFile(file.path, targetFile);\r\n            });","mutatedLines":"            var copyPromises = _this.files.map(function (file) {\n});"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":199,"column":54},"end":{"line":210,"column":9}},"range":[9489,10164],"originalLines":"        return new Promise(function (resolve, reject) {\r\n            var fileMap = Object.create(null);\r\n            var cwd = process.cwd();\r\n            var copyPromises = _this.files.map(function (file) {\r\n                var relativePath = file.path.substr(cwd.length);\r\n                var folderName = StrykerTempFolder_1.default.ensureFolderExists(folder + path.dirname(relativePath));\r\n                var targetFile = path.join(folderName, path.basename(relativePath));\r\n                fileMap[file.path] = targetFile;\r\n                return StrykerTempFolder_1.default.copyFile(file.path, targetFile);\r\n            });\r\n            Promise.all(copyPromises).then(function () { resolve(fileMap); }, reject);\r\n        });","mutatedLines":"        return new Promise(function (resolve, reject) {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":54,"column":16},"end":{"line":54,"column":21}},"range":[1408,1413],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"            if (error) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":197,"column":78},"end":{"line":211,"column":5}},"range":[9405,10173],"originalLines":"    TestRunnerOrchestrator.prototype.copyAllFilesToFolder = function (folder) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            var fileMap = Object.create(null);\r\n            var cwd = process.cwd();\r\n            var copyPromises = _this.files.map(function (file) {\r\n                var relativePath = file.path.substr(cwd.length);\r\n                var folderName = StrykerTempFolder_1.default.ensureFolderExists(folder + path.dirname(relativePath));\r\n                var targetFile = path.join(folderName, path.basename(relativePath));\r\n                fileMap[file.path] = targetFile;\r\n                return StrykerTempFolder_1.default.copyFile(file.path, targetFile);\r\n            });\r\n            Promise.all(copyPromises).then(function () { resolve(fileMap); }, reject);\r\n        });\r\n    };","mutatedLines":"    TestRunnerOrchestrator.prototype.copyAllFilesToFolder = function (folder) {\n};"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":189,"column":68},"end":{"line":193,"column":5}},"range":[8970,9171],"originalLines":"    TestRunnerOrchestrator.prototype.createTempFolder = function () {\r\n        var tempFolder = StrykerTempFolder_1.default.createRandomFolder('test-runner-files');\r\n        log.debug('Creating a sandbox for files in %s', tempFolder);\r\n        return tempFolder;\r\n    };","mutatedLines":"    TestRunnerOrchestrator.prototype.createTempFolder = function () {\n};"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":40,"column":55},"end":{"line":47,"column":9}},"range":[1068,1223],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"        nodeGlob(expression, function (error, matches) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve(matches);\r\n            }\r\n        });","mutatedLines":"        nodeGlob(expression, function (error, matches) {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":52,"column":50},"end":{"line":61,"column":5}},"range":[1337,1551],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"    return new Promise(function (resolve, reject) {\r\n        fs.readdir(path, function (error, files) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve(files);\r\n            }\r\n        });\r\n    });","mutatedLines":"    return new Promise(function (resolve, reject) {\n});"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":179,"column":70},"end":{"line":179,"column":155}},"range":[8493,8578],"originalLines":"            var runnerFiles = _this.files.map(function (originalFile) { return _.assign(_.cloneDeep(originalFile), { path: fileMap[originalFile.path] }); });","mutatedLines":"            var runnerFiles = _this.files.map(function (originalFile) {\n});"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":176,"column":16},"end":{"line":176,"column":34}},"range":[8298,8316],"originalLines":"            if (_this.testSelector) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":39,"column":50},"end":{"line":48,"column":5}},"range":[1010,1232],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"    return new Promise(function (resolve, reject) {\r\n        nodeGlob(expression, function (error, matches) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve(matches);\r\n            }\r\n        });\r\n    });","mutatedLines":"    return new Promise(function (resolve, reject) {\n});"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":174,"column":77},"end":{"line":187,"column":9}},"range":[8232,8890],"originalLines":"        return this.copyAllFilesToFolder(tempFolder).then(function (fileMap) {\r\n            var testSelectionFilePath = null;\r\n            if (_this.testSelector) {\r\n                testSelectionFilePath = _this.createTestSelectorFileName(tempFolder);\r\n            }\r\n            var runnerFiles = _this.files.map(function (originalFile) { return _.assign(_.cloneDeep(originalFile), { path: fileMap[originalFile.path] }); });\r\n            var runner = _this.createTestRunner(runnerFiles, false, testSelectionFilePath, index);\r\n            return {\r\n                index: index,\r\n                fileMap: fileMap,\r\n                runner: runner,\r\n                testSelectionFilePath: testSelectionFilePath\r\n            };\r\n        });","mutatedLines":"        return this.copyAllFilesToFolder(tempFolder).then(function (fileMap) {\n});"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":167,"column":13},"end":{"line":169,"column":9}},"range":[7926,7983],"originalLines":"        else {\r\n            return Promise.resolve(void 0);\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":163,"column":31},"end":{"line":166,"column":9}},"range":[7734,7911],"originalLines":"        if (this.testSelector) {\r\n            var fileContent = this.testSelector.select(ids);\r\n            return StrykerTempFolder_1.default.writeFile(sandbox.testSelectionFilePath, fileContent);\r\n        }","mutatedLines":"        if (this.testSelector) {\n}"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":163,"column":12},"end":{"line":163,"column":29}},"range":[7715,7732],"originalLines":"        if (this.testSelector) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":163,"column":12},"end":{"line":163,"column":29}},"range":[7715,7732],"originalLines":"        if (this.testSelector) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":162,"column":85},"end":{"line":170,"column":5}},"range":[7700,7990],"originalLines":"    TestRunnerOrchestrator.prototype.selectTestsIfPossible = function (sandbox, ids) {\r\n        if (this.testSelector) {\r\n            var fileContent = this.testSelector.select(ids);\r\n            return StrykerTempFolder_1.default.writeFile(sandbox.testSelectionFilePath, fileContent);\r\n        }\r\n        else {\r\n            return Promise.resolve(void 0);\r\n        }\r\n    };","mutatedLines":"    TestRunnerOrchestrator.prototype.selectTestsIfPossible = function (sandbox, ids) {\n};"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":157,"column":43},"end":{"line":159,"column":9}},"range":[7486,7563],"originalLines":"        for (var i = 0; i < cpuCount; i++) {\r\n            allPromises.push(this.createInitializedSandbox(i));\r\n        }","mutatedLines":"        for (var i = 0; i < cpuCount; i++) {\n}"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"UnaryOperator","status":1,"replacement":"i--","location":{"start":{"line":157,"column":38},"end":{"line":157,"column":41}},"range":[7481,7484],"originalLines":"        for (var i = 0; i < cpuCount; i++) {","mutatedLines":"        for (var i = 0; i < cpuCount; i--) {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"ReverseConditional","status":1,"replacement":"i >= cpuCount","location":{"start":{"line":157,"column":24},"end":{"line":157,"column":36}},"range":[7467,7479],"originalLines":"        for (var i = 0; i < cpuCount; i++) {","mutatedLines":"        for (var i = 0; i >= cpuCount; i++) {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"ConditionalBoundary","status":1,"replacement":"i <= cpuCount","location":{"start":{"line":157,"column":24},"end":{"line":157,"column":36}},"range":[7467,7479],"originalLines":"        for (var i = 0; i < cpuCount; i++) {","mutatedLines":"        for (var i = 0; i <= cpuCount; i++) {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":157,"column":24},"end":{"line":157,"column":36}},"range":[7467,7479],"originalLines":"        for (var i = 0; i < cpuCount; i++) {","mutatedLines":"        for (var i = 0; false; i++) {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'Creating ' - cpuCount","location":{"start":{"line":156,"column":17},"end":{"line":156,"column":39}},"range":[7378,7400],"originalLines":"        log.info(\"Creating \" + cpuCount + \" test runners (based on cpu count)\");","mutatedLines":"        log.info('Creating ' - cpuCount + \" test runners (based on cpu count)\");"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'Creating ' + cpuCount - ' test runners (based on cpu count)'","location":{"start":{"line":156,"column":17},"end":{"line":156,"column":78}},"range":[7378,7439],"originalLines":"        log.info(\"Creating \" + cpuCount + \" test runners (based on cpu count)\");","mutatedLines":"        log.info('Creating ' + cpuCount - ' test runners (based on cpu count)');"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":152,"column":77},"end":{"line":161,"column":5}},"range":[7246,7612],"originalLines":"    TestRunnerOrchestrator.prototype.createTestRunnerSandboxes = function () {\r\n        var cpuCount = os.cpus().length;\r\n        var testRunnerSandboxes = [];\r\n        var allPromises = [];\r\n        log.info(\"Creating \" + cpuCount + \" test runners (based on cpu count)\");\r\n        for (var i = 0; i < cpuCount; i++) {\r\n            allPromises.push(this.createInitializedSandbox(i));\r\n        }\r\n        return Promise.all(allPromises);\r\n    };","mutatedLines":"    TestRunnerOrchestrator.prototype.createTestRunnerSandboxes = function () {\n};"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":143,"column":80},"end":{"line":145,"column":21}},"range":[6930,7021],"originalLines":"                    if (runResult.result !== test_runner_1.TestResult.Complete) {\r\n                        runResults[currentTestIndex] = runResult;\r\n                    }","mutatedLines":"                    if (runResult.result !== test_runner_1.TestResult.Complete) {\n}"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"ReverseConditional","status":1,"replacement":"runResult.result === test_runner_1.TestResult.Complete","location":{"start":{"line":143,"column":24},"end":{"line":143,"column":78}},"range":[6874,6928],"originalLines":"                    if (runResult.result !== test_runner_1.TestResult.Complete) {","mutatedLines":"                    if (runResult.result === test_runner_1.TestResult.Complete) {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":143,"column":24},"end":{"line":143,"column":78}},"range":[6874,6928],"originalLines":"                    if (runResult.result !== test_runner_1.TestResult.Complete) {","mutatedLines":"                    if (true) {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":143,"column":24},"end":{"line":143,"column":78}},"range":[6874,6928],"originalLines":"                    if (runResult.result !== test_runner_1.TestResult.Complete) {","mutatedLines":"                    if (false) {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":142,"column":21},"end":{"line":148,"column":17}},"range":[6847,7129],"originalLines":"                else {\r\n                    if (runResult.result !== test_runner_1.TestResult.Complete) {\r\n                        runResults[currentTestIndex] = runResult;\r\n                    }\r\n                    sandbox.runner.dispose();\r\n                    resolve(runResults);\r\n                }","mutatedLines":"                else {\n}"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"Math","status":1,"replacement":"currentTestIndex - 1","location":{"start":{"line":140,"column":79},"end":{"line":140,"column":99}},"range":[6782,6802],"originalLines":"                    resolve(_this.runSingleTestsRecursive(sandbox, runResults, currentTestIndex + 1));","mutatedLines":"                    resolve(_this.runSingleTestsRecursive(sandbox, runResults, currentTestIndex - 1));"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":138,"column":127},"end":{"line":141,"column":17}},"range":[6637,6824],"originalLines":"                if (runResult.result === test_runner_1.TestResult.Complete && runResult.succeeded > 0 || runResult.failed > 0) {\r\n                    runResults[currentTestIndex] = runResult;\r\n                    resolve(_this.runSingleTestsRecursive(sandbox, runResults, currentTestIndex + 1));\r\n                }","mutatedLines":"                if (runResult.result === test_runner_1.TestResult.Complete && runResult.succeeded > 0 || runResult.failed > 0) {\n}"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"ReverseConditional","status":1,"replacement":"runResult.failed <= 0","location":{"start":{"line":138,"column":105},"end":{"line":138,"column":125}},"range":[6615,6635],"originalLines":"                if (runResult.result === test_runner_1.TestResult.Complete && runResult.succeeded > 0 || runResult.failed > 0) {","mutatedLines":"                if (runResult.result === test_runner_1.TestResult.Complete && runResult.succeeded > 0 || runResult.failed <= 0) {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"ConditionalBoundary","status":1,"replacement":"runResult.failed >= 0","location":{"start":{"line":138,"column":105},"end":{"line":138,"column":125}},"range":[6615,6635],"originalLines":"                if (runResult.result === test_runner_1.TestResult.Complete && runResult.succeeded > 0 || runResult.failed > 0) {","mutatedLines":"                if (runResult.result === test_runner_1.TestResult.Complete && runResult.succeeded > 0 || runResult.failed >= 0) {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"ReverseConditional","status":1,"replacement":"runResult.succeeded <= 0","location":{"start":{"line":138,"column":78},"end":{"line":138,"column":101}},"range":[6588,6611],"originalLines":"                if (runResult.result === test_runner_1.TestResult.Complete && runResult.succeeded > 0 || runResult.failed > 0) {","mutatedLines":"                if (runResult.result === test_runner_1.TestResult.Complete && runResult.succeeded <= 0 || runResult.failed > 0) {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"ConditionalBoundary","status":1,"replacement":"runResult.succeeded >= 0","location":{"start":{"line":138,"column":78},"end":{"line":138,"column":101}},"range":[6588,6611],"originalLines":"                if (runResult.result === test_runner_1.TestResult.Complete && runResult.succeeded > 0 || runResult.failed > 0) {","mutatedLines":"                if (runResult.result === test_runner_1.TestResult.Complete && runResult.succeeded >= 0 || runResult.failed > 0) {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"ReverseConditional","status":1,"replacement":"runResult.result !== test_runner_1.TestResult.Complete","location":{"start":{"line":138,"column":20},"end":{"line":138,"column":74}},"range":[6530,6584],"originalLines":"                if (runResult.result === test_runner_1.TestResult.Complete && runResult.succeeded > 0 || runResult.failed > 0) {","mutatedLines":"                if (runResult.result !== test_runner_1.TestResult.Complete && runResult.succeeded > 0 || runResult.failed > 0) {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"ReverseConditional","status":1,"replacement":"runResult.result === test_runner_1.TestResult.Complete || runResult.succeeded > 0","location":{"start":{"line":138,"column":20},"end":{"line":138,"column":101}},"range":[6530,6611],"originalLines":"                if (runResult.result === test_runner_1.TestResult.Complete && runResult.succeeded > 0 || runResult.failed > 0) {","mutatedLines":"                if (runResult.result === test_runner_1.TestResult.Complete || runResult.succeeded > 0 || runResult.failed > 0) {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"ReverseConditional","status":1,"replacement":"runResult.result === test_runner_1.TestResult.Complete && runResult.succeeded > 0 && runResult.failed > 0","location":{"start":{"line":138,"column":20},"end":{"line":138,"column":125}},"range":[6530,6635],"originalLines":"                if (runResult.result === test_runner_1.TestResult.Complete && runResult.succeeded > 0 || runResult.failed > 0) {","mutatedLines":"                if (runResult.result === test_runner_1.TestResult.Complete && runResult.succeeded > 0 && runResult.failed > 0) {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":138,"column":20},"end":{"line":138,"column":125}},"range":[6530,6635],"originalLines":"                if (runResult.result === test_runner_1.TestResult.Complete && runResult.succeeded > 0 || runResult.failed > 0) {","mutatedLines":"                if (true) {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":138,"column":20},"end":{"line":138,"column":125}},"range":[6530,6635],"originalLines":"                if (runResult.result === test_runner_1.TestResult.Complete && runResult.succeeded > 0 || runResult.failed > 0) {","mutatedLines":"                if (false) {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":137,"column":43},"end":{"line":149,"column":13}},"range":[6507,7144],"originalLines":"                .then(function (runResult) {\r\n                if (runResult.result === test_runner_1.TestResult.Complete && runResult.succeeded > 0 || runResult.failed > 0) {\r\n                    runResults[currentTestIndex] = runResult;\r\n                    resolve(_this.runSingleTestsRecursive(sandbox, runResults, currentTestIndex + 1));\r\n                }\r\n                else {\r\n                    if (runResult.result !== test_runner_1.TestResult.Complete) {\r\n                        runResults[currentTestIndex] = runResult;\r\n                    }\r\n                    sandbox.runner.dispose();\r\n                    resolve(runResults);\r\n                }\r\n            });","mutatedLines":"                .then(function (runResult) {\n});"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":136,"column":34},"end":{"line":136,"column":84}},"range":[6411,6461],"originalLines":"                .then(function () { return sandbox.runner.run({ timeout: 10000 }); })","mutatedLines":"                .then(function () {\n})"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":134,"column":46},"end":{"line":150,"column":9}},"range":[6304,7157],"originalLines":"        return new Promise(function (resolve) {\r\n            _this.selectTestsIfPossible(sandbox, [currentTestIndex])\r\n                .then(function () { return sandbox.runner.run({ timeout: 10000 }); })\r\n                .then(function (runResult) {\r\n                if (runResult.result === test_runner_1.TestResult.Complete && runResult.succeeded > 0 || runResult.failed > 0) {\r\n                    runResults[currentTestIndex] = runResult;\r\n                    resolve(_this.runSingleTestsRecursive(sandbox, runResults, currentTestIndex + 1));\r\n                }\r\n                else {\r\n                    if (runResult.result !== test_runner_1.TestResult.Complete) {\r\n                        runResults[currentTestIndex] = runResult;\r\n                    }\r\n                    sandbox.runner.dispose();\r\n                    resolve(runResults);\r\n                }\r\n            });\r\n        });","mutatedLines":"        return new Promise(function (resolve) {\n});"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":132,"column":112},"end":{"line":151,"column":5}},"range":[6228,7166],"originalLines":"    TestRunnerOrchestrator.prototype.runSingleTestsRecursive = function (sandbox, runResults, currentTestIndex) {\r\n        var _this = this;\r\n        return new Promise(function (resolve) {\r\n            _this.selectTestsIfPossible(sandbox, [currentTestIndex])\r\n                .then(function () { return sandbox.runner.run({ timeout: 10000 }); })\r\n                .then(function (runResult) {\r\n                if (runResult.result === test_runner_1.TestResult.Complete && runResult.succeeded > 0 || runResult.failed > 0) {\r\n                    runResults[currentTestIndex] = runResult;\r\n                    resolve(_this.runSingleTestsRecursive(sandbox, runResults, currentTestIndex + 1));\r\n                }\r\n                else {\r\n                    if (runResult.result !== test_runner_1.TestResult.Complete) {\r\n                        runResults[currentTestIndex] = runResult;\r\n                    }\r\n                    sandbox.runner.dispose();\r\n                    resolve(runResults);\r\n                }\r\n            });\r\n        });\r\n    };","mutatedLines":"    TestRunnerOrchestrator.prototype.runSingleTestsRecursive = function (sandbox, runResults, currentTestIndex) {\n};"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":114,"column":13},"end":{"line":117,"column":9}},"range":[5528,5623],"originalLines":"        else {\r\n            testNames = [];\r\n            status = report_1.MutantStatus.UNTESTED;\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":107,"column":25},"end":{"line":109,"column":21}},"range":[5323,5413],"originalLines":"                    else {\r\n                        status = report_1.MutantStatus.SURVIVED;\r\n                    }","mutatedLines":"                    else {\n}"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":104,"column":46},"end":{"line":106,"column":21}},"range":[5208,5296],"originalLines":"                    if (runResult.failed > 0) {\r\n                        status = report_1.MutantStatus.KILLED;\r\n                    }","mutatedLines":"                    if (runResult.failed > 0) {\n}"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"ReverseConditional","status":1,"replacement":"runResult.failed <= 0","location":{"start":{"line":104,"column":24},"end":{"line":104,"column":44}},"range":[5186,5206],"originalLines":"                    if (runResult.failed > 0) {","mutatedLines":"                    if (runResult.failed <= 0) {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"ConditionalBoundary","status":1,"replacement":"runResult.failed >= 0","location":{"start":{"line":104,"column":24},"end":{"line":104,"column":44}},"range":[5186,5206],"originalLines":"                    if (runResult.failed > 0) {","mutatedLines":"                    if (runResult.failed >= 0) {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":104,"column":24},"end":{"line":104,"column":44}},"range":[5186,5206],"originalLines":"                    if (runResult.failed > 0) {","mutatedLines":"                    if (true) {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":104,"column":24},"end":{"line":104,"column":44}},"range":[5186,5206],"originalLines":"                    if (runResult.failed > 0) {","mutatedLines":"                    if (false) {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":94,"column":23},"end":{"line":113,"column":9}},"range":[4678,5513],"originalLines":"        if (runResult) {\r\n            switch (runResult.result) {\r\n                case test_runner_1.TestResult.Timeout:\r\n                    status = report_1.MutantStatus.TIMEDOUT;\r\n                    break;\r\n                case test_runner_1.TestResult.Error:\r\n                    log.debug('Converting a test result `error` to mutant status `killed`.');\r\n                    status = report_1.MutantStatus.KILLED;\r\n                    break;\r\n                case test_runner_1.TestResult.Complete:\r\n                    if (runResult.failed > 0) {\r\n                        status = report_1.MutantStatus.KILLED;\r\n                    }\r\n                    else {\r\n                        status = report_1.MutantStatus.SURVIVED;\r\n                    }\r\n                    break;\r\n            }\r\n            testNames = runResult.testNames;\r\n        }","mutatedLines":"        if (runResult) {\n}"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":94,"column":12},"end":{"line":94,"column":21}},"range":[4667,4676],"originalLines":"        if (runResult) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":94,"column":12},"end":{"line":94,"column":21}},"range":[4667,4676],"originalLines":"        if (runResult) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":91,"column":94},"end":{"line":131,"column":5}},"range":[4607,6113],"originalLines":"    TestRunnerOrchestrator.prototype.collectFrozenMutantResult = function (mutant, runResult) {\r\n        var status;\r\n        var testNames;\r\n        if (runResult) {\r\n            switch (runResult.result) {\r\n                case test_runner_1.TestResult.Timeout:\r\n                    status = report_1.MutantStatus.TIMEDOUT;\r\n                    break;\r\n                case test_runner_1.TestResult.Error:\r\n                    log.debug('Converting a test result `error` to mutant status `killed`.');\r\n                    status = report_1.MutantStatus.KILLED;\r\n                    break;\r\n                case test_runner_1.TestResult.Complete:\r\n                    if (runResult.failed > 0) {\r\n                        status = report_1.MutantStatus.KILLED;\r\n                    }\r\n                    else {\r\n                        status = report_1.MutantStatus.SURVIVED;\r\n                    }\r\n                    break;\r\n            }\r\n            testNames = runResult.testNames;\r\n        }\r\n        else {\r\n            testNames = [];\r\n            status = report_1.MutantStatus.UNTESTED;\r\n        }\r\n        var result = {\r\n            sourceFilePath: mutant.filename,\r\n            mutatorName: mutant.mutatorName,\r\n            status: status,\r\n            replacement: mutant.replacement,\r\n            location: mutant.location,\r\n            range: mutant.range,\r\n            testsRan: testNames,\r\n            originalLines: mutant.originalLines,\r\n            mutatedLines: mutant.mutatedLines,\r\n        };\r\n        objectUtils_1.freezeRecursively(result);\r\n        return result;\r\n    };","mutatedLines":"    TestRunnerOrchestrator.prototype.collectFrozenMutantResult = function (mutant, runResult) {\n};"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"Math","status":1,"replacement":"this.options.timeoutFactor / baseTimeout","location":{"start":{"line":89,"column":16},"end":{"line":89,"column":56}},"range":[4436,4476],"originalLines":"        return (this.options.timeoutFactor * baseTimeout) + this.options.timeoutMs;","mutatedLines":"        return (this.options.timeoutFactor / baseTimeout) + this.options.timeoutMs;"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"Math","status":1,"replacement":"this.options.timeoutFactor * baseTimeout - this.options.timeoutMs","location":{"start":{"line":89,"column":15},"end":{"line":89,"column":82}},"range":[4435,4502],"originalLines":"        return (this.options.timeoutFactor * baseTimeout) + this.options.timeoutMs;","mutatedLines":"        return this.options.timeoutFactor * baseTimeout - this.options.timeoutMs;"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":88,"column":79},"end":{"line":90,"column":5}},"range":[4417,4510],"originalLines":"    TestRunnerOrchestrator.prototype.calculateTimeout = function (baseTimeout) {\r\n        return (this.options.timeoutFactor * baseTimeout) + this.options.timeoutMs;\r\n    };","mutatedLines":"    TestRunnerOrchestrator.prototype.calculateTimeout = function (baseTimeout) {\n};"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":84,"column":81},"end":{"line":87,"column":5}},"range":[4224,4335],"originalLines":"    TestRunnerOrchestrator.prototype.reportAllMutantsTested = function (results) {\r\n        objectUtils_1.freezeRecursively(results);\r\n        this.reporter.onAllMutantsTested(results);\r\n    };","mutatedLines":"    TestRunnerOrchestrator.prototype.reportAllMutantsTested = function (results) {\n};"},{"sourceFilePath":"/stryker/src/TestSelectorOrchestrator.js","mutatorName":"ReverseConditional","status":1,"replacement":"this.options.testSelector === 'null'","location":{"start":{"line":13,"column":41},"end":{"line":13,"column":77}},"range":[715,751],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"        if (this.options.testSelector && this.options.testSelector !== 'null') {","mutatedLines":"        if (this.options.testSelector && this.options.testSelector === 'null') {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":81,"column":34},"end":{"line":81,"column":53}},"range":[4099,4118],"originalLines":"                .then(function () { return results; });","mutatedLines":"                .then(function () {\n});"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":80,"column":34},"end":{"line":80,"column":135}},"range":[3961,4062],"originalLines":"                .then(function () { return Promise.all(sandboxes.map(function (testRunner) { return testRunner.runner.dispose(); })); })","mutatedLines":"                .then(function () {\n})"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":79,"column":34},"end":{"line":79,"column":83}},"range":[3875,3924],"originalLines":"                .then(function () { return _this.reportAllMutantsTested(results); })","mutatedLines":"                .then(function () {\n})"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":70,"column":25},"end":{"line":74,"column":21}},"range":[3469,3707],"originalLines":"                    else {\r\n                        var result = _this.collectFrozenMutantResult(mutant);\r\n                        results.push(result);\r\n                        return Promise.resolve(_this.reporter.onMutantTested(result));\r\n                    }","mutatedLines":"                    else {\n}"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":171,"column":81},"end":{"line":188,"column":5}},"range":[8074,8899],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants \"before each\" hook for \"should not select test files\"","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants \"before each\" hook for \"should have created 2 test runners\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"    TestRunnerOrchestrator.prototype.createInitializedSandbox = function (index) {\r\n        var _this = this;\r\n        var tempFolder = this.createTempFolder();\r\n        return this.copyAllFilesToFolder(tempFolder).then(function (fileMap) {\r\n            var testSelectionFilePath = null;\r\n            if (_this.testSelector) {\r\n                testSelectionFilePath = _this.createTestSelectorFileName(tempFolder);\r\n            }\r\n            var runnerFiles = _this.files.map(function (originalFile) { return _.assign(_.cloneDeep(originalFile), { path: fileMap[originalFile.path] }); });\r\n            var runner = _this.createTestRunner(runnerFiles, false, testSelectionFilePath, index);\r\n            return {\r\n                index: index,\r\n                fileMap: fileMap,\r\n                runner: runner,\r\n                testSelectionFilePath: testSelectionFilePath\r\n            };\r\n        });\r\n    };","mutatedLines":"    TestRunnerOrchestrator.prototype.createInitializedSandbox = function (index) {\n};"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":68,"column":46},"end":{"line":68,"column":83}},"range":[3380,3417],"originalLines":"                            .then(function () { return sandboxes.push(sandbox_1); });","mutatedLines":"                            .then(function () {\n});"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":213,"column":12},"end":{"line":213,"column":28}},"range":[10311,10327],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"        if (index === void 0) { index = 0; }","mutatedLines":"        if (true) { index = 0; }"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":61,"column":46},"end":{"line":61,"column":144}},"range":[2866,2964],"originalLines":"                            .then(function () { return sandbox_1.runner.run({ timeout: _this.calculateTimeout(mutant.timeSpentScopedTests) }); })","mutatedLines":"                            .then(function () {\n})"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"ReverseConditional","status":1,"replacement":"mutant.scopedTestIds.length <= 0","location":{"start":{"line":57,"column":24},"end":{"line":57,"column":55}},"range":[2503,2534],"originalLines":"                    if (mutant.scopedTestIds.length > 0) {","mutatedLines":"                    if (mutant.scopedTestIds.length <= 0) {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"ConditionalBoundary","status":1,"replacement":"mutant.scopedTestIds.length >= 0","location":{"start":{"line":57,"column":24},"end":{"line":57,"column":55}},"range":[2503,2534],"originalLines":"                    if (mutant.scopedTestIds.length > 0) {","mutatedLines":"                    if (mutant.scopedTestIds.length >= 0) {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":57,"column":24},"end":{"line":57,"column":55}},"range":[2503,2534],"originalLines":"                    if (mutant.scopedTestIds.length > 0) {","mutatedLines":"                    if (true) {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":57,"column":24},"end":{"line":57,"column":55}},"range":[2503,2534],"originalLines":"                    if (mutant.scopedTestIds.length > 0) {","mutatedLines":"                    if (false) {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":55,"column":21},"end":{"line":75,"column":17}},"range":[2427,3726],"originalLines":"                else {\r\n                    var mutant = mutants.pop();\r\n                    if (mutant.scopedTestIds.length > 0) {\r\n                        var sandbox_1 = sandboxes.pop();\r\n                        var sourceFileCopy_1 = sandbox_1.fileMap[mutant.filename];\r\n                        return Promise.all([mutant.save(sourceFileCopy_1), _this.selectTestsIfPossible(sandbox_1, mutant.scopedTestIds)])\r\n                            .then(function () { return sandbox_1.runner.run({ timeout: _this.calculateTimeout(mutant.timeSpentScopedTests) }); })\r\n                            .then(function (runResult) {\r\n                            var result = _this.collectFrozenMutantResult(mutant, runResult);\r\n                            results.push(result);\r\n                            _this.reporter.onMutantTested(result);\r\n                            return mutant.reset(sourceFileCopy_1);\r\n                        })\r\n                            .then(function () { return sandboxes.push(sandbox_1); });\r\n                    }\r\n                    else {\r\n                        var result = _this.collectFrozenMutantResult(mutant);\r\n                        results.push(result);\r\n                        return Promise.resolve(_this.reporter.onMutantTested(result));\r\n                    }\r\n                }","mutatedLines":"                else {\n}"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":52,"column":42},"end":{"line":54,"column":17}},"range":[2350,2404],"originalLines":"                if (mutants.length === 0) {\r\n                    return null;\r\n                }","mutatedLines":"                if (mutants.length === 0) {\n}"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"ReverseConditional","status":1,"replacement":"mutants.length !== 0","location":{"start":{"line":52,"column":20},"end":{"line":52,"column":40}},"range":[2328,2348],"originalLines":"                if (mutants.length === 0) {","mutatedLines":"                if (mutants.length !== 0) {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":176,"column":16},"end":{"line":176,"column":34}},"range":[8298,8316],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"            if (_this.testSelector) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":52,"column":20},"end":{"line":52,"column":40}},"range":[2328,2348],"originalLines":"                if (mutants.length === 0) {","mutatedLines":"                if (true) {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":194,"column":84},"end":{"line":196,"column":5}},"range":[9258,9324],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"    TestRunnerOrchestrator.prototype.createTestSelectorFileName = function (folder) {\r\n        return path.join(folder, '___testSelection.js');\r\n    };","mutatedLines":"    TestRunnerOrchestrator.prototype.createTestSelectorFileName = function (folder) {\n};"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":51,"column":46},"end":{"line":76,"column":13}},"range":[2305,3741],"originalLines":"            var promiseProducer = function () {\r\n                if (mutants.length === 0) {\r\n                    return null;\r\n                }\r\n                else {\r\n                    var mutant = mutants.pop();\r\n                    if (mutant.scopedTestIds.length > 0) {\r\n                        var sandbox_1 = sandboxes.pop();\r\n                        var sourceFileCopy_1 = sandbox_1.fileMap[mutant.filename];\r\n                        return Promise.all([mutant.save(sourceFileCopy_1), _this.selectTestsIfPossible(sandbox_1, mutant.scopedTestIds)])\r\n                            .then(function () { return sandbox_1.runner.run({ timeout: _this.calculateTimeout(mutant.timeSpentScopedTests) }); })\r\n                            .then(function (runResult) {\r\n                            var result = _this.collectFrozenMutantResult(mutant, runResult);\r\n                            results.push(result);\r\n                            _this.reporter.onMutantTested(result);\r\n                            return mutant.reset(sourceFileCopy_1);\r\n                        })\r\n                            .then(function () { return sandboxes.push(sandbox_1); });\r\n                    }\r\n                    else {\r\n                        var result = _this.collectFrozenMutantResult(mutant);\r\n                        results.push(result);\r\n                        return Promise.resolve(_this.reporter.onMutantTested(result));\r\n                    }\r\n                }\r\n            };","mutatedLines":"            var promiseProducer = function () {\n};"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":46,"column":71},"end":{"line":83,"column":5}},"range":[2088,4140],"originalLines":"    TestRunnerOrchestrator.prototype.runMutations = function (mutants) {\r\n        var _this = this;\r\n        mutants = _.clone(mutants);\r\n        var results = [];\r\n        return this.createTestRunnerSandboxes().then(function (sandboxes) {\r\n            var promiseProducer = function () {\r\n                if (mutants.length === 0) {\r\n                    return null;\r\n                }\r\n                else {\r\n                    var mutant = mutants.pop();\r\n                    if (mutant.scopedTestIds.length > 0) {\r\n                        var sandbox_1 = sandboxes.pop();\r\n                        var sourceFileCopy_1 = sandbox_1.fileMap[mutant.filename];\r\n                        return Promise.all([mutant.save(sourceFileCopy_1), _this.selectTestsIfPossible(sandbox_1, mutant.scopedTestIds)])\r\n                            .then(function () { return sandbox_1.runner.run({ timeout: _this.calculateTimeout(mutant.timeSpentScopedTests) }); })\r\n                            .then(function (runResult) {\r\n                            var result = _this.collectFrozenMutantResult(mutant, runResult);\r\n                            results.push(result);\r\n                            _this.reporter.onMutantTested(result);\r\n                            return mutant.reset(sourceFileCopy_1);\r\n                        })\r\n                            .then(function () { return sandboxes.push(sandbox_1); });\r\n                    }\r\n                    else {\r\n                        var result = _this.collectFrozenMutantResult(mutant);\r\n                        results.push(result);\r\n                        return Promise.resolve(_this.reporter.onMutantTested(result));\r\n                    }\r\n                }\r\n            };\r\n            return new PromisePool(promiseProducer, sandboxes.length)\r\n                .start()\r\n                .then(function () { return _this.reportAllMutantsTested(results); })\r\n                .then(function () { return Promise.all(sandboxes.map(function (testRunner) { return testRunner.runner.dispose(); })); })\r\n                .then(function () { return results; });\r\n        });\r\n    };","mutatedLines":"    TestRunnerOrchestrator.prototype.runMutations = function (mutants) {\n};"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":176,"column":36},"end":{"line":178,"column":13}},"range":[8318,8421],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"            if (_this.testSelector) {\r\n                testSelectionFilePath = _this.createTestSelectorFileName(tempFolder);\r\n            }","mutatedLines":"            if (_this.testSelector) {\n}"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":44,"column":131},"end":{"line":44,"column":154}},"range":[1978,2001],"originalLines":"        return this.runSingleTestsRecursive(sandbox, [], 0).then(function (testResults) { return runner.dispose().then(function () { return testResults; }); });","mutatedLines":"        return this.runSingleTestsRecursive(sandbox, [], 0).then(function (testResults) { return runner.dispose().then(function () {\n}); });"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":35,"column":78},"end":{"line":45,"column":5}},"range":[1488,2014],"originalLines":"    TestRunnerOrchestrator.prototype.initialRunWithTestSelector = function () {\r\n        var testSelectionFilePath = this.createTestSelectorFileName(this.createTempFolder());\r\n        var runner = this.createTestRunner(this.files, true, testSelectionFilePath);\r\n        var sandbox = {\r\n            runner: runner,\r\n            fileMap: null,\r\n            testSelectionFilePath: testSelectionFilePath,\r\n            index: 0\r\n        };\r\n        return this.runSingleTestsRecursive(sandbox, [], 0).then(function (testResults) { return runner.dispose().then(function () { return testResults; }); });\r\n    };","mutatedLines":"    TestRunnerOrchestrator.prototype.initialRunWithTestSelector = function () {\n};"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":30,"column":78},"end":{"line":33,"column":9}},"range":[1316,1398],"originalLines":"        return testRunner.run({ timeout: 10000 }).then(function (testResults) {\r\n            testRunner.dispose();\r\n            return [testResults];\r\n        });","mutatedLines":"        return testRunner.run({ timeout: 10000 }).then(function (testResults) {\n});"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":28,"column":80},"end":{"line":34,"column":5}},"range":[1168,1407],"originalLines":"    TestRunnerOrchestrator.prototype.initalRunWithoutTestSelector = function () {\r\n        var testRunner = this.createTestRunner(this.files, true);\r\n        return testRunner.run({ timeout: 10000 }).then(function (testResults) {\r\n            testRunner.dispose();\r\n            return [testResults];\r\n        });\r\n    };","mutatedLines":"    TestRunnerOrchestrator.prototype.initalRunWithoutTestSelector = function () {\n};"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":24,"column":13},"end":{"line":26,"column":9}},"range":[1009,1078],"originalLines":"        else {\r\n            return this.initalRunWithoutTestSelector();\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":21,"column":31},"end":{"line":23,"column":9}},"range":[927,994],"originalLines":"        if (this.testSelector) {\r\n            return this.initialRunWithTestSelector();\r\n        }","mutatedLines":"        if (this.testSelector) {\n}"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":21,"column":12},"end":{"line":21,"column":29}},"range":[908,925],"originalLines":"        if (this.testSelector) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":21,"column":12},"end":{"line":21,"column":29}},"range":[908,925],"originalLines":"        if (this.testSelector) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":20,"column":62},"end":{"line":27,"column":5}},"range":[893,1085],"originalLines":"    TestRunnerOrchestrator.prototype.initialRun = function () {\r\n        if (this.testSelector) {\r\n            return this.initialRunWithTestSelector();\r\n        }\r\n        else {\r\n            return this.initalRunWithoutTestSelector();\r\n        }\r\n    };","mutatedLines":"    TestRunnerOrchestrator.prototype.initialRun = function () {\n};"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":14,"column":76},"end":{"line":19,"column":5}},"range":[681,829],"originalLines":"    function TestRunnerOrchestrator(options, files, testSelector, reporter) {\r\n        this.options = options;\r\n        this.files = files;\r\n        this.testSelector = testSelector;\r\n        this.reporter = reporter;\r\n    }","mutatedLines":"    function TestRunnerOrchestrator(options, files, testSelector, reporter) {\n}"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":13,"column":42},"end":{"line":227,"column":1}},"range":[602,10960],"originalLines":"var TestRunnerOrchestrator = (function () {\r\n    function TestRunnerOrchestrator(options, files, testSelector, reporter) {\r\n        this.options = options;\r\n        this.files = files;\r\n        this.testSelector = testSelector;\r\n        this.reporter = reporter;\r\n    }\r\n    TestRunnerOrchestrator.prototype.initialRun = function () {\r\n        if (this.testSelector) {\r\n            return this.initialRunWithTestSelector();\r\n        }\r\n        else {\r\n            return this.initalRunWithoutTestSelector();\r\n        }\r\n    };\r\n    TestRunnerOrchestrator.prototype.initalRunWithoutTestSelector = function () {\r\n        var testRunner = this.createTestRunner(this.files, true);\r\n        return testRunner.run({ timeout: 10000 }).then(function (testResults) {\r\n            testRunner.dispose();\r\n            return [testResults];\r\n        });\r\n    };\r\n    TestRunnerOrchestrator.prototype.initialRunWithTestSelector = function () {\r\n        var testSelectionFilePath = this.createTestSelectorFileName(this.createTempFolder());\r\n        var runner = this.createTestRunner(this.files, true, testSelectionFilePath);\r\n        var sandbox = {\r\n            runner: runner,\r\n            fileMap: null,\r\n            testSelectionFilePath: testSelectionFilePath,\r\n            index: 0\r\n        };\r\n        return this.runSingleTestsRecursive(sandbox, [], 0).then(function (testResults) { return runner.dispose().then(function () { return testResults; }); });\r\n    };\r\n    TestRunnerOrchestrator.prototype.runMutations = function (mutants) {\r\n        var _this = this;\r\n        mutants = _.clone(mutants);\r\n        var results = [];\r\n        return this.createTestRunnerSandboxes().then(function (sandboxes) {\r\n            var promiseProducer = function () {\r\n                if (mutants.length === 0) {\r\n                    return null;\r\n                }\r\n                else {\r\n                    var mutant = mutants.pop();\r\n                    if (mutant.scopedTestIds.length > 0) {\r\n                        var sandbox_1 = sandboxes.pop();\r\n                        var sourceFileCopy_1 = sandbox_1.fileMap[mutant.filename];\r\n                        return Promise.all([mutant.save(sourceFileCopy_1), _this.selectTestsIfPossible(sandbox_1, mutant.scopedTestIds)])\r\n                            .then(function () { return sandbox_1.runner.run({ timeout: _this.calculateTimeout(mutant.timeSpentScopedTests) }); })\r\n                            .then(function (runResult) {\r\n                            var result = _this.collectFrozenMutantResult(mutant, runResult);\r\n                            results.push(result);\r\n                            _this.reporter.onMutantTested(result);\r\n                            return mutant.reset(sourceFileCopy_1);\r\n                        })\r\n                            .then(function () { return sandboxes.push(sandbox_1); });\r\n                    }\r\n                    else {\r\n                        var result = _this.collectFrozenMutantResult(mutant);\r\n                        results.push(result);\r\n                        return Promise.resolve(_this.reporter.onMutantTested(result));\r\n                    }\r\n                }\r\n            };\r\n            return new PromisePool(promiseProducer, sandboxes.length)\r\n                .start()\r\n                .then(function () { return _this.reportAllMutantsTested(results); })\r\n                .then(function () { return Promise.all(sandboxes.map(function (testRunner) { return testRunner.runner.dispose(); })); })\r\n                .then(function () { return results; });\r\n        });\r\n    };\r\n    TestRunnerOrchestrator.prototype.reportAllMutantsTested = function (results) {\r\n        objectUtils_1.freezeRecursively(results);\r\n        this.reporter.onAllMutantsTested(results);\r\n    };\r\n    TestRunnerOrchestrator.prototype.calculateTimeout = function (baseTimeout) {\r\n        return (this.options.timeoutFactor * baseTimeout) + this.options.timeoutMs;\r\n    };\r\n    TestRunnerOrchestrator.prototype.collectFrozenMutantResult = function (mutant, runResult) {\r\n        var status;\r\n        var testNames;\r\n        if (runResult) {\r\n            switch (runResult.result) {\r\n                case test_runner_1.TestResult.Timeout:\r\n                    status = report_1.MutantStatus.TIMEDOUT;\r\n                    break;\r\n                case test_runner_1.TestResult.Error:\r\n                    log.debug('Converting a test result `error` to mutant status `killed`.');\r\n                    status = report_1.MutantStatus.KILLED;\r\n                    break;\r\n                case test_runner_1.TestResult.Complete:\r\n                    if (runResult.failed > 0) {\r\n                        status = report_1.MutantStatus.KILLED;\r\n                    }\r\n                    else {\r\n                        status = report_1.MutantStatus.SURVIVED;\r\n                    }\r\n                    break;\r\n            }\r\n            testNames = runResult.testNames;\r\n        }\r\n        else {\r\n            testNames = [];\r\n            status = report_1.MutantStatus.UNTESTED;\r\n        }\r\n        var result = {\r\n            sourceFilePath: mutant.filename,\r\n            mutatorName: mutant.mutatorName,\r\n            status: status,\r\n            replacement: mutant.replacement,\r\n            location: mutant.location,\r\n            range: mutant.range,\r\n            testsRan: testNames,\r\n            originalLines: mutant.originalLines,\r\n            mutatedLines: mutant.mutatedLines,\r\n        };\r\n        objectUtils_1.freezeRecursively(result);\r\n        return result;\r\n    };\r\n    TestRunnerOrchestrator.prototype.runSingleTestsRecursive = function (sandbox, runResults, currentTestIndex) {\r\n        var _this = this;\r\n        return new Promise(function (resolve) {\r\n            _this.selectTestsIfPossible(sandbox, [currentTestIndex])\r\n                .then(function () { return sandbox.runner.run({ timeout: 10000 }); })\r\n                .then(function (runResult) {\r\n                if (runResult.result === test_runner_1.TestResult.Complete && runResult.succeeded > 0 || runResult.failed > 0) {\r\n                    runResults[currentTestIndex] = runResult;\r\n                    resolve(_this.runSingleTestsRecursive(sandbox, runResults, currentTestIndex + 1));\r\n                }\r\n                else {\r\n                    if (runResult.result !== test_runner_1.TestResult.Complete) {\r\n                        runResults[currentTestIndex] = runResult;\r\n                    }\r\n                    sandbox.runner.dispose();\r\n                    resolve(runResults);\r\n                }\r\n            });\r\n        });\r\n    };\r\n    TestRunnerOrchestrator.prototype.createTestRunnerSandboxes = function () {\r\n        var cpuCount = os.cpus().length;\r\n        var testRunnerSandboxes = [];\r\n        var allPromises = [];\r\n        log.info(\"Creating \" + cpuCount + \" test runners (based on cpu count)\");\r\n        for (var i = 0; i < cpuCount; i++) {\r\n            allPromises.push(this.createInitializedSandbox(i));\r\n        }\r\n        return Promise.all(allPromises);\r\n    };\r\n    TestRunnerOrchestrator.prototype.selectTestsIfPossible = function (sandbox, ids) {\r\n        if (this.testSelector) {\r\n            var fileContent = this.testSelector.select(ids);\r\n            return StrykerTempFolder_1.default.writeFile(sandbox.testSelectionFilePath, fileContent);\r\n        }\r\n        else {\r\n            return Promise.resolve(void 0);\r\n        }\r\n    };\r\n    TestRunnerOrchestrator.prototype.createInitializedSandbox = function (index) {\r\n        var _this = this;\r\n        var tempFolder = this.createTempFolder();\r\n        return this.copyAllFilesToFolder(tempFolder).then(function (fileMap) {\r\n            var testSelectionFilePath = null;\r\n            if (_this.testSelector) {\r\n                testSelectionFilePath = _this.createTestSelectorFileName(tempFolder);\r\n            }\r\n            var runnerFiles = _this.files.map(function (originalFile) { return _.assign(_.cloneDeep(originalFile), { path: fileMap[originalFile.path] }); });\r\n            var runner = _this.createTestRunner(runnerFiles, false, testSelectionFilePath, index);\r\n            return {\r\n                index: index,\r\n                fileMap: fileMap,\r\n                runner: runner,\r\n                testSelectionFilePath: testSelectionFilePath\r\n            };\r\n        });\r\n    };\r\n    TestRunnerOrchestrator.prototype.createTempFolder = function () {\r\n        var tempFolder = StrykerTempFolder_1.default.createRandomFolder('test-runner-files');\r\n        log.debug('Creating a sandbox for files in %s', tempFolder);\r\n        return tempFolder;\r\n    };\r\n    TestRunnerOrchestrator.prototype.createTestSelectorFileName = function (folder) {\r\n        return path.join(folder, '___testSelection.js');\r\n    };\r\n    TestRunnerOrchestrator.prototype.copyAllFilesToFolder = function (folder) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            var fileMap = Object.create(null);\r\n            var cwd = process.cwd();\r\n            var copyPromises = _this.files.map(function (file) {\r\n                var relativePath = file.path.substr(cwd.length);\r\n                var folderName = StrykerTempFolder_1.default.ensureFolderExists(folder + path.dirname(relativePath));\r\n                var targetFile = path.join(folderName, path.basename(relativePath));\r\n                fileMap[file.path] = targetFile;\r\n                return StrykerTempFolder_1.default.copyFile(file.path, targetFile);\r\n            });\r\n            Promise.all(copyPromises).then(function () { resolve(fileMap); }, reject);\r\n        });\r\n    };\r\n    TestRunnerOrchestrator.prototype.createTestRunner = function (files, coverageEnabled, testSelectionFilePath, index) {\r\n        if (index === void 0) { index = 0; }\r\n        if (testSelectionFilePath) {\r\n            files = [{ path: testSelectionFilePath, mutated: false, included: true }].concat(files);\r\n        }\r\n        var settings = {\r\n            coverageEnabled: coverageEnabled,\r\n            files: files,\r\n            strykerOptions: this.options,\r\n            port: this.options.port + index\r\n        };\r\n        log.debug(\"Creating test runner %s using settings {port: %s, coverageEnabled: %s}\", index, settings.port, settings.coverageEnabled);\r\n        return IsolatedTestRunnerAdapterFactory_1.default.create(settings);\r\n    };\r\n    return TestRunnerOrchestrator;\r\n}());","mutatedLines":"var TestRunnerOrchestrator = (function () {\n}());"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"Math","status":1,"replacement":"'\\n\\t' - error","location":{"start":{"line":115,"column":66},"end":{"line":115,"column":80}},"range":[6198,6212],"originalLines":"            errors.forEach(function (error) { return message_2 += \"\\n\\t\" + error; });","mutatedLines":"            errors.forEach(function (error) { return message_2 += '\\n\\t' - error; });"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":115,"column":44},"end":{"line":115,"column":83}},"range":[6176,6215],"originalLines":"            errors.forEach(function (error) { return message_2 += \"\\n\\t\" + error; });","mutatedLines":"            errors.forEach(function (error) {\n});"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":113,"column":31},"end":{"line":117,"column":9}},"range":[6046,6263],"originalLines":"        if (errors.length > 0) {\r\n            var message_2 = 'One or more tests errored in the initial test run:';\r\n            errors.forEach(function (error) { return message_2 += \"\\n\\t\" + error; });\r\n            log.error(message_2);\r\n        }","mutatedLines":"        if (errors.length > 0) {\n}"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"ReverseConditional","status":1,"replacement":"errors.length <= 0","location":{"start":{"line":113,"column":12},"end":{"line":113,"column":29}},"range":[6027,6044],"originalLines":"        if (errors.length > 0) {","mutatedLines":"        if (errors.length <= 0) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"ConditionalBoundary","status":1,"replacement":"errors.length >= 0","location":{"start":{"line":113,"column":12},"end":{"line":113,"column":29}},"range":[6027,6044],"originalLines":"        if (errors.length > 0) {","mutatedLines":"        if (errors.length >= 0) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":113,"column":12},"end":{"line":113,"column":29}},"range":[6027,6044],"originalLines":"        if (errors.length > 0) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":113,"column":12},"end":{"line":113,"column":29}},"range":[6027,6044],"originalLines":"        if (errors.length > 0) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":111,"column":38},"end":{"line":111,"column":73}},"range":[5954,5989],"originalLines":"            .map(function (runResult) { return runResult.errorMessages; }))","mutatedLines":"            .map(function (runResult) {\n}))"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"ReverseConditional","status":1,"replacement":"runResult.result !== test_runner_1.TestResult.Error","location":{"start":{"line":110,"column":50},"end":{"line":110,"column":101}},"range":[5859,5910],"originalLines":"            .filter(function (runResult) { return runResult.result === test_runner_1.TestResult.Error; })","mutatedLines":"            .filter(function (runResult) { return runResult.result !== test_runner_1.TestResult.Error; })"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":110,"column":41},"end":{"line":110,"column":104}},"range":[5850,5913],"originalLines":"            .filter(function (runResult) { return runResult.result === test_runner_1.TestResult.Error; })","mutatedLines":"            .filter(function (runResult) {\n})"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"Math","status":1,"replacement":"'\\n\\t' - filename","location":{"start":{"line":106,"column":78},"end":{"line":106,"column":95}},"range":[5689,5706],"originalLines":"            failedSpecNames.forEach(function (filename) { return message_1 += \"\\n\\t\" + filename; });","mutatedLines":"            failedSpecNames.forEach(function (filename) { return message_1 += '\\n\\t' - filename; });"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":106,"column":56},"end":{"line":106,"column":98}},"range":[5667,5709],"originalLines":"            failedSpecNames.forEach(function (filename) { return message_1 += \"\\n\\t\" + filename; });","mutatedLines":"            failedSpecNames.forEach(function (filename) {\n});"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":104,"column":40},"end":{"line":108,"column":9}},"range":[5528,5757],"originalLines":"        if (failedSpecNames.length > 0) {\r\n            var message_1 = 'One or more tests failed in the inial test run:';\r\n            failedSpecNames.forEach(function (filename) { return message_1 += \"\\n\\t\" + filename; });\r\n            log.error(message_1);\r\n        }","mutatedLines":"        if (failedSpecNames.length > 0) {\n}"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"ReverseConditional","status":1,"replacement":"failedSpecNames.length <= 0","location":{"start":{"line":104,"column":12},"end":{"line":104,"column":38}},"range":[5500,5526],"originalLines":"        if (failedSpecNames.length > 0) {","mutatedLines":"        if (failedSpecNames.length <= 0) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"ConditionalBoundary","status":1,"replacement":"failedSpecNames.length >= 0","location":{"start":{"line":104,"column":12},"end":{"line":104,"column":38}},"range":[5500,5526],"originalLines":"        if (failedSpecNames.length > 0) {","mutatedLines":"        if (failedSpecNames.length >= 0) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":104,"column":12},"end":{"line":104,"column":38}},"range":[5500,5526],"originalLines":"        if (failedSpecNames.length > 0) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":104,"column":12},"end":{"line":104,"column":38}},"range":[5500,5526],"originalLines":"        if (failedSpecNames.length > 0) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":102,"column":38},"end":{"line":102,"column":69}},"range":[5430,5461],"originalLines":"            .map(function (runResult) { return runResult.testNames; })))","mutatedLines":"            .map(function (runResult) {\n})))"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"ReverseConditional","status":1,"replacement":"runResult.result !== test_runner_1.TestResult.Complete","location":{"start":{"line":101,"column":50},"end":{"line":101,"column":104}},"range":[5332,5386],"originalLines":"            .filter(function (runResult) { return runResult.result === test_runner_1.TestResult.Complete; })","mutatedLines":"            .filter(function (runResult) { return runResult.result !== test_runner_1.TestResult.Complete; })"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":101,"column":41},"end":{"line":101,"column":107}},"range":[5323,5389],"originalLines":"            .filter(function (runResult) { return runResult.result === test_runner_1.TestResult.Complete; })","mutatedLines":"            .filter(function (runResult) {\n})"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":99,"column":68},"end":{"line":118,"column":5}},"range":[5213,6270],"originalLines":"    Stryker.prototype.logFailedTests = function (unsuccessfulTests) {\r\n        var failedSpecNames = _.uniq(_.flatten(unsuccessfulTests\r\n            .filter(function (runResult) { return runResult.result === test_runner_1.TestResult.Complete; })\r\n            .map(function (runResult) { return runResult.testNames; })))\r\n            .sort();\r\n        if (failedSpecNames.length > 0) {\r\n            var message_1 = 'One or more tests failed in the inial test run:';\r\n            failedSpecNames.forEach(function (filename) { return message_1 += \"\\n\\t\" + filename; });\r\n            log.error(message_1);\r\n        }\r\n        var errors = _.flatten(unsuccessfulTests\r\n            .filter(function (runResult) { return runResult.result === test_runner_1.TestResult.Error; })\r\n            .map(function (runResult) { return runResult.errorMessages; }))\r\n            .sort();\r\n        if (errors.length > 0) {\r\n            var message_2 = 'One or more tests errored in the initial test run:';\r\n            errors.forEach(function (error) { return message_2 += \"\\n\\t\" + error; });\r\n            log.error(message_2);\r\n        }\r\n    };","mutatedLines":"    Stryker.prototype.logFailedTests = function (unsuccessfulTests) {\n};"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":96,"column":54},"end":{"line":98,"column":5}},"range":[5077,5142],"originalLines":"    Stryker.prototype.setGlobalLogLevel = function () {\r\n        log4js.setGlobalLogLevel(this.config.logLevel);\r\n    };","mutatedLines":"    Stryker.prototype.setGlobalLogLevel = function () {\n};"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":90,"column":34},"end":{"line":92,"column":13}},"range":[4843,4916],"originalLines":"            if (result.succeeded) {\r\n                totalAmountOfTests += result.succeeded;\r\n            }","mutatedLines":"            if (result.succeeded) {\n}"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":90,"column":16},"end":{"line":90,"column":32}},"range":[4825,4841],"originalLines":"            if (result.succeeded) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":90,"column":16},"end":{"line":90,"column":32}},"range":[4825,4841],"originalLines":"            if (result.succeeded) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":89,"column":45},"end":{"line":93,"column":9}},"range":[4806,4927],"originalLines":"        runResults.forEach(function (result) {\r\n            if (result.succeeded) {\r\n                totalAmountOfTests += result.succeeded;\r\n            }\r\n        });","mutatedLines":"        runResults.forEach(function (result) {\n});"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":87,"column":73},"end":{"line":95,"column":5}},"range":[4721,5020],"originalLines":"    Stryker.prototype.logInitialTestRunSucceeded = function (runResults) {\r\n        var totalAmountOfTests = 0;\r\n        runResults.forEach(function (result) {\r\n            if (result.succeeded) {\r\n                totalAmountOfTests += result.succeeded;\r\n            }\r\n        });\r\n        log.info('Initial test run succeeded. Ran %s tests.', totalAmountOfTests);\r\n    };","mutatedLines":"    Stryker.prototype.logInitialTestRunSucceeded = function (runResults) {\n};"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"Math","status":1,"replacement":"'Using config: ' - JSON.stringify(this.config)","location":{"start":{"line":84,"column":22},"end":{"line":84,"column":68}},"range":[4579,4625],"originalLines":"            log.debug(\"Using config: \" + JSON.stringify(this.config));","mutatedLines":"            log.debug('Using config: ' - JSON.stringify(this.config));"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":83,"column":34},"end":{"line":85,"column":9}},"range":[4554,4638],"originalLines":"        if (log.isDebugEnabled()) {\r\n            log.debug(\"Using config: \" + JSON.stringify(this.config));\r\n        }","mutatedLines":"        if (log.isDebugEnabled()) {\n}"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":83,"column":12},"end":{"line":83,"column":32}},"range":[4532,4552],"originalLines":"        if (log.isDebugEnabled()) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":83,"column":12},"end":{"line":83,"column":32}},"range":[4532,4552],"originalLines":"        if (log.isDebugEnabled()) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":81,"column":49},"end":{"line":86,"column":5}},"range":[4462,4645],"originalLines":"    Stryker.prototype.freezeConfig = function () {\r\n        objectUtils_1.freezeRecursively(this.config);\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(\"Using config: \" + JSON.stringify(this.config));\r\n        }\r\n    };","mutatedLines":"    Stryker.prototype.freezeConfig = function () {\n};"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":77,"column":97},"end":{"line":79,"column":9}},"range":[4279,4401],"originalLines":"        config_1.ConfigWriterFactory.instance().knownNames().forEach(function (configWriterName) {\r\n            config_1.ConfigWriterFactory.instance().create(configWriterName, undefined).write(_this.config);\r\n        });","mutatedLines":"        config_1.ConfigWriterFactory.instance().knownNames().forEach(function (configWriterName) {\n});"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":75,"column":55},"end":{"line":80,"column":5}},"range":[4152,4410],"originalLines":"    Stryker.prototype.applyConfigWriters = function () {\r\n        var _this = this;\r\n        config_1.ConfigWriterFactory.instance().knownNames().forEach(function (configWriterName) {\r\n            config_1.ConfigWriterFactory.instance().create(configWriterName, undefined).write(_this.config);\r\n        });\r\n    };","mutatedLines":"    Stryker.prototype.applyConfigWriters = function () {\n};"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":71,"column":33},"end":{"line":73,"column":9}},"range":[4006,4087],"originalLines":"        if (this.config.plugins) {\r\n            new PluginLoader_1.default(this.config.plugins).load();\r\n        }","mutatedLines":"        if (this.config.plugins) {\n}"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":71,"column":12},"end":{"line":71,"column":31}},"range":[3985,4004],"originalLines":"        if (this.config.plugins) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":71,"column":12},"end":{"line":71,"column":31}},"range":[3985,4004],"originalLines":"        if (this.config.plugins) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":70,"column":48},"end":{"line":74,"column":5}},"range":[3970,4094],"originalLines":"    Stryker.prototype.loadPlugins = function () {\r\n        if (this.config.plugins) {\r\n            new PluginLoader_1.default(this.config.plugins).load();\r\n        }\r\n    };","mutatedLines":"    Stryker.prototype.loadPlugins = function () {\n};"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"ReverseConditional","status":1,"replacement":"runResult.result !== test_runner_1.TestResult.Complete","location":{"start":{"line":68,"column":86},"end":{"line":68,"column":140}},"range":[3852,3906],"originalLines":"        return runResults.filter(function (runResult) { return !(!runResult.failed && runResult.result === test_runner_1.TestResult.Complete); });","mutatedLines":"        return runResults.filter(function (runResult) { return !(!runResult.failed && runResult.result !== test_runner_1.TestResult.Complete); });"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"ReverseConditional","status":1,"replacement":"!runResult.failed || runResult.result === test_runner_1.TestResult.Complete","location":{"start":{"line":68,"column":65},"end":{"line":68,"column":140}},"range":[3831,3906],"originalLines":"        return runResults.filter(function (runResult) { return !(!runResult.failed && runResult.result === test_runner_1.TestResult.Complete); });","mutatedLines":"        return runResults.filter(function (runResult) { return !(!runResult.failed || runResult.result === test_runner_1.TestResult.Complete); });"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":68,"column":54},"end":{"line":68,"column":144}},"range":[3820,3910],"originalLines":"        return runResults.filter(function (runResult) { return !(!runResult.failed && runResult.result === test_runner_1.TestResult.Complete); });","mutatedLines":"        return runResults.filter(function (runResult) {\n});"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":80,"column":91},"end":{"line":80,"column":130}},"range":[4018,4057],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"                .then(function () { return Promise.all(sandboxes.map(function (testRunner) { return testRunner.runner.dispose(); })); })","mutatedLines":"                .then(function () { return Promise.all(sandboxes.map(function (testRunner) {\n})); })"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":67,"column":74},"end":{"line":69,"column":5}},"range":[3763,3919],"originalLines":"    Stryker.prototype.filterOutUnsuccesfulResults = function (runResults) {\r\n        return runResults.filter(function (runResult) { return !(!runResult.failed && runResult.result === test_runner_1.TestResult.Complete); });\r\n    };","mutatedLines":"    Stryker.prototype.filterOutUnsuccesfulResults = function (runResults) {\n};"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":65,"column":41},"end":{"line":65,"column":132}},"range":[3586,3677],"originalLines":"        }).then(function (mutantResults) { return StrykerTempFolder_1.default.clean().then(function () { return mutantResults; }); });","mutatedLines":"        }).then(function (mutantResults) {\n});"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":62,"column":17},"end":{"line":64,"column":13}},"range":[3488,3543],"originalLines":"            else {\r\n                return mutantResults;\r\n            }","mutatedLines":"            else {\n}"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":60,"column":53},"end":{"line":60,"column":78}},"range":[3427,3452],"originalLines":"                return maybePromise.then(function () { return mutantResults; });","mutatedLines":"                return maybePromise.then(function () {\n});"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":59,"column":55},"end":{"line":61,"column":13}},"range":[3371,3469],"originalLines":"            if (objectUtils_1.isPromise(maybePromise)) {\r\n                return maybePromise.then(function () { return mutantResults; });\r\n            }","mutatedLines":"            if (objectUtils_1.isPromise(maybePromise)) {\n}"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":62,"column":55},"end":{"line":67,"column":25}},"range":[3022,3331],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"                            .then(function (runResult) {\r\n                            var result = _this.collectFrozenMutantResult(mutant, runResult);\r\n                            results.push(result);\r\n                            _this.reporter.onMutantTested(result);\r\n                            return mutant.reset(sourceFileCopy_1);\r\n                        })","mutatedLines":"                            .then(function (runResult) {\n})"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":57,"column":57},"end":{"line":69,"column":21}},"range":[2536,3442],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"                    if (mutant.scopedTestIds.length > 0) {\r\n                        var sandbox_1 = sandboxes.pop();\r\n                        var sourceFileCopy_1 = sandbox_1.fileMap[mutant.filename];\r\n                        return Promise.all([mutant.save(sourceFileCopy_1), _this.selectTestsIfPossible(sandbox_1, mutant.scopedTestIds)])\r\n                            .then(function () { return sandbox_1.runner.run({ timeout: _this.calculateTimeout(mutant.timeSpentScopedTests) }); })\r\n                            .then(function (runResult) {\r\n                            var result = _this.collectFrozenMutantResult(mutant, runResult);\r\n                            results.push(result);\r\n                            _this.reporter.onMutantTested(result);\r\n                            return mutant.reset(sourceFileCopy_1);\r\n                        })\r\n                            .then(function () { return sandboxes.push(sandbox_1); });\r\n                    }","mutatedLines":"                    if (mutant.scopedTestIds.length > 0) {\n}"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":52,"column":20},"end":{"line":52,"column":40}},"range":[2328,2348],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants \"before each\" hook for \"should not select test files\"","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants \"before each\" hook for \"should have created 2 test runners\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"                if (mutants.length === 0) {","mutatedLines":"                if (false) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":59,"column":16},"end":{"line":59,"column":53}},"range":[3332,3369],"originalLines":"            if (objectUtils_1.isPromise(maybePromise)) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":53,"column":17},"end":{"line":56,"column":13}},"range":[3060,3219],"originalLines":"            else {\r\n                _this.logFailedTests(unsuccessfulTests);\r\n                throw new Error('There were failed tests in the initial test run');\r\n            }","mutatedLines":"            else {\n}"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":47,"column":41},"end":{"line":47,"column":62}},"range":[2699,2720],"originalLines":"                    .map(function (file) { return file.path; }));","mutatedLines":"                    .map(function (file) {\n}));"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":46,"column":49},"end":{"line":46,"column":78}},"range":[2626,2655],"originalLines":"                    .filter(function (inputFile) { return inputFile.mutated; })","mutatedLines":"                    .filter(function (inputFile) {\n})"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":42,"column":48},"end":{"line":52,"column":13}},"range":[2345,3041],"originalLines":"            if (unsuccessfulTests.length === 0) {\r\n                _this.logInitialTestRunSucceeded(runResults);\r\n                var mutatorOrchestrator = new MutatorOrchestrator_1.default(reporter);\r\n                var mutants = mutatorOrchestrator.generateMutants(inputFiles\r\n                    .filter(function (inputFile) { return inputFile.mutated; })\r\n                    .map(function (file) { return file.path; }));\r\n                log.info(mutants.length + \" Mutant(s) generated\");\r\n                var mutantRunResultMatcher = new MutantRunResultMatcher_1.default(mutants, runResults);\r\n                mutantRunResultMatcher.matchWithMutants();\r\n                return testRunnerOrchestrator.runMutations(mutants);\r\n            }","mutatedLines":"            if (unsuccessfulTests.length === 0) {\n}"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"ReverseConditional","status":1,"replacement":"unsuccessfulTests.length !== 0","location":{"start":{"line":42,"column":16},"end":{"line":42,"column":46}},"range":[2313,2343],"originalLines":"            if (unsuccessfulTests.length === 0) {","mutatedLines":"            if (unsuccessfulTests.length !== 0) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":42,"column":16},"end":{"line":42,"column":46}},"range":[2313,2343],"originalLines":"            if (unsuccessfulTests.length === 0) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":42,"column":16},"end":{"line":42,"column":46}},"range":[2313,2343],"originalLines":"            if (unsuccessfulTests.length === 0) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":37,"column":35},"end":{"line":57,"column":9}},"range":[2042,3230],"originalLines":"            .then(function (tuple) {\r\n            var runResults = tuple.runResults;\r\n            var inputFiles = tuple.inputFiles;\r\n            var testRunnerOrchestrator = tuple.testRunnerOrchestrator;\r\n            var unsuccessfulTests = _this.filterOutUnsuccesfulResults(runResults);\r\n            if (unsuccessfulTests.length === 0) {\r\n                _this.logInitialTestRunSucceeded(runResults);\r\n                var mutatorOrchestrator = new MutatorOrchestrator_1.default(reporter);\r\n                var mutants = mutatorOrchestrator.generateMutants(inputFiles\r\n                    .filter(function (inputFile) { return inputFile.mutated; })\r\n                    .map(function (file) { return file.path; }));\r\n                log.info(mutants.length + \" Mutant(s) generated\");\r\n                var mutantRunResultMatcher = new MutantRunResultMatcher_1.default(mutants, runResults);\r\n                mutantRunResultMatcher.matchWithMutants();\r\n                return testRunnerOrchestrator.runMutations(mutants);\r\n            }\r\n            else {\r\n                _this.logFailedTests(unsuccessfulTests);\r\n                throw new Error('There were failed tests in the initial test run');\r\n            }\r\n        }).then(function (mutantResults) {","mutatedLines":"            .then(function (tuple) {\n}).then(function (mutantResults) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":35,"column":82},"end":{"line":35,"column":194}},"range":[1879,1991],"originalLines":"            return testRunnerOrchestrator.initialRun().then(function (runResults) { return ({ runResults: runResults, inputFiles: inputFiles, testRunnerOrchestrator: testRunnerOrchestrator }); });","mutatedLines":"            return testRunnerOrchestrator.initialRun().then(function (runResults) {\n});"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":33,"column":40},"end":{"line":36,"column":9}},"range":[1664,2004],"originalLines":"            .then(function (inputFiles) {\r\n            var testRunnerOrchestrator = new TestRunnerOrchestrator_1.default(_this.config, inputFiles, testSelector, reporter);\r\n            return testRunnerOrchestrator.initialRun().then(function (runResults) { return ({ runResults: runResults, inputFiles: inputFiles, testRunnerOrchestrator: testRunnerOrchestrator }); });\r\n        })","mutatedLines":"            .then(function (inputFiles) {\n})"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":28,"column":52},"end":{"line":66,"column":5}},"range":[1293,3686],"originalLines":"    Stryker.prototype.runMutationTest = function () {\r\n        var _this = this;\r\n        var reporter = new ReporterOrchestrator_1.default(this.config).createBroadcastReporter();\r\n        var testSelector = new TestSelectorOrchestrator_1.default(this.config).determineTestSelector();\r\n        return new InputFileResolver_1.default(this.config.mutate, this.config.files).resolve()\r\n            .then(function (inputFiles) {\r\n            var testRunnerOrchestrator = new TestRunnerOrchestrator_1.default(_this.config, inputFiles, testSelector, reporter);\r\n            return testRunnerOrchestrator.initialRun().then(function (runResults) { return ({ runResults: runResults, inputFiles: inputFiles, testRunnerOrchestrator: testRunnerOrchestrator }); });\r\n        })\r\n            .then(function (tuple) {\r\n            var runResults = tuple.runResults;\r\n            var inputFiles = tuple.inputFiles;\r\n            var testRunnerOrchestrator = tuple.testRunnerOrchestrator;\r\n            var unsuccessfulTests = _this.filterOutUnsuccesfulResults(runResults);\r\n            if (unsuccessfulTests.length === 0) {\r\n                _this.logInitialTestRunSucceeded(runResults);\r\n                var mutatorOrchestrator = new MutatorOrchestrator_1.default(reporter);\r\n                var mutants = mutatorOrchestrator.generateMutants(inputFiles\r\n                    .filter(function (inputFile) { return inputFile.mutated; })\r\n                    .map(function (file) { return file.path; }));\r\n                log.info(mutants.length + \" Mutant(s) generated\");\r\n                var mutantRunResultMatcher = new MutantRunResultMatcher_1.default(mutants, runResults);\r\n                mutantRunResultMatcher.matchWithMutants();\r\n                return testRunnerOrchestrator.runMutations(mutants);\r\n            }\r\n            else {\r\n                _this.logFailedTests(unsuccessfulTests);\r\n                throw new Error('There were failed tests in the initial test run');\r\n            }\r\n        }).then(function (mutantResults) {\r\n            var maybePromise = reporter.wrapUp();\r\n            if (objectUtils_1.isPromise(maybePromise)) {\r\n                return maybePromise.then(function () { return mutantResults; });\r\n            }\r\n            else {\r\n                return mutantResults;\r\n            }\r\n        }).then(function (mutantResults) { return StrykerTempFolder_1.default.clean().then(function () { return mutantResults; }); });\r\n    };","mutatedLines":"    Stryker.prototype.runMutationTest = function () {\n};"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":19,"column":30},"end":{"line":27,"column":5}},"range":[951,1239],"originalLines":"    function Stryker(options) {\r\n        var configReader = new ConfigReader_1.default(options);\r\n        this.config = configReader.readConfig();\r\n        this.setGlobalLogLevel();\r\n        this.loadPlugins();\r\n        this.applyConfigWriters();\r\n        this.setGlobalLogLevel();\r\n        this.freezeConfig();\r\n    }","mutatedLines":"    function Stryker(options) {\n}"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":50,"column":74},"end":{"line":82,"column":9}},"range":[2256,4131],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"        return this.createTestRunnerSandboxes().then(function (sandboxes) {\r\n            var promiseProducer = function () {\r\n                if (mutants.length === 0) {\r\n                    return null;\r\n                }\r\n                else {\r\n                    var mutant = mutants.pop();\r\n                    if (mutant.scopedTestIds.length > 0) {\r\n                        var sandbox_1 = sandboxes.pop();\r\n                        var sourceFileCopy_1 = sandbox_1.fileMap[mutant.filename];\r\n                        return Promise.all([mutant.save(sourceFileCopy_1), _this.selectTestsIfPossible(sandbox_1, mutant.scopedTestIds)])\r\n                            .then(function () { return sandbox_1.runner.run({ timeout: _this.calculateTimeout(mutant.timeSpentScopedTests) }); })\r\n                            .then(function (runResult) {\r\n                            var result = _this.collectFrozenMutantResult(mutant, runResult);\r\n                            results.push(result);\r\n                            _this.reporter.onMutantTested(result);\r\n                            return mutant.reset(sourceFileCopy_1);\r\n                        })\r\n                            .then(function () { return sandboxes.push(sandbox_1); });\r\n                    }\r\n                    else {\r\n                        var result = _this.collectFrozenMutantResult(mutant);\r\n                        results.push(result);\r\n                        return Promise.resolve(_this.reporter.onMutantTested(result));\r\n                    }\r\n                }\r\n            };\r\n            return new PromisePool(promiseProducer, sandboxes.length)\r\n                .start()\r\n                .then(function () { return _this.reportAllMutantsTested(results); })\r\n                .then(function () { return Promise.all(sandboxes.map(function (testRunner) { return testRunner.runner.dispose(); })); })\r\n                .then(function () { return results; });\r\n        });","mutatedLines":"        return this.createTestRunnerSandboxes().then(function (sandboxes) {\n});"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":18,"column":27},"end":{"line":120,"column":1}},"range":[918,6295],"originalLines":"var Stryker = (function () {\r\n    function Stryker(options) {\r\n        var configReader = new ConfigReader_1.default(options);\r\n        this.config = configReader.readConfig();\r\n        this.setGlobalLogLevel();\r\n        this.loadPlugins();\r\n        this.applyConfigWriters();\r\n        this.setGlobalLogLevel();\r\n        this.freezeConfig();\r\n    }\r\n    Stryker.prototype.runMutationTest = function () {\r\n        var _this = this;\r\n        var reporter = new ReporterOrchestrator_1.default(this.config).createBroadcastReporter();\r\n        var testSelector = new TestSelectorOrchestrator_1.default(this.config).determineTestSelector();\r\n        return new InputFileResolver_1.default(this.config.mutate, this.config.files).resolve()\r\n            .then(function (inputFiles) {\r\n            var testRunnerOrchestrator = new TestRunnerOrchestrator_1.default(_this.config, inputFiles, testSelector, reporter);\r\n            return testRunnerOrchestrator.initialRun().then(function (runResults) { return ({ runResults: runResults, inputFiles: inputFiles, testRunnerOrchestrator: testRunnerOrchestrator }); });\r\n        })\r\n            .then(function (tuple) {\r\n            var runResults = tuple.runResults;\r\n            var inputFiles = tuple.inputFiles;\r\n            var testRunnerOrchestrator = tuple.testRunnerOrchestrator;\r\n            var unsuccessfulTests = _this.filterOutUnsuccesfulResults(runResults);\r\n            if (unsuccessfulTests.length === 0) {\r\n                _this.logInitialTestRunSucceeded(runResults);\r\n                var mutatorOrchestrator = new MutatorOrchestrator_1.default(reporter);\r\n                var mutants = mutatorOrchestrator.generateMutants(inputFiles\r\n                    .filter(function (inputFile) { return inputFile.mutated; })\r\n                    .map(function (file) { return file.path; }));\r\n                log.info(mutants.length + \" Mutant(s) generated\");\r\n                var mutantRunResultMatcher = new MutantRunResultMatcher_1.default(mutants, runResults);\r\n                mutantRunResultMatcher.matchWithMutants();\r\n                return testRunnerOrchestrator.runMutations(mutants);\r\n            }\r\n            else {\r\n                _this.logFailedTests(unsuccessfulTests);\r\n                throw new Error('There were failed tests in the initial test run');\r\n            }\r\n        }).then(function (mutantResults) {\r\n            var maybePromise = reporter.wrapUp();\r\n            if (objectUtils_1.isPromise(maybePromise)) {\r\n                return maybePromise.then(function () { return mutantResults; });\r\n            }\r\n            else {\r\n                return mutantResults;\r\n            }\r\n        }).then(function (mutantResults) { return StrykerTempFolder_1.default.clean().then(function () { return mutantResults; }); });\r\n    };\r\n    Stryker.prototype.filterOutUnsuccesfulResults = function (runResults) {\r\n        return runResults.filter(function (runResult) { return !(!runResult.failed && runResult.result === test_runner_1.TestResult.Complete); });\r\n    };\r\n    Stryker.prototype.loadPlugins = function () {\r\n        if (this.config.plugins) {\r\n            new PluginLoader_1.default(this.config.plugins).load();\r\n        }\r\n    };\r\n    Stryker.prototype.applyConfigWriters = function () {\r\n        var _this = this;\r\n        config_1.ConfigWriterFactory.instance().knownNames().forEach(function (configWriterName) {\r\n            config_1.ConfigWriterFactory.instance().create(configWriterName, undefined).write(_this.config);\r\n        });\r\n    };\r\n    Stryker.prototype.freezeConfig = function () {\r\n        objectUtils_1.freezeRecursively(this.config);\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(\"Using config: \" + JSON.stringify(this.config));\r\n        }\r\n    };\r\n    Stryker.prototype.logInitialTestRunSucceeded = function (runResults) {\r\n        var totalAmountOfTests = 0;\r\n        runResults.forEach(function (result) {\r\n            if (result.succeeded) {\r\n                totalAmountOfTests += result.succeeded;\r\n            }\r\n        });\r\n        log.info('Initial test run succeeded. Ran %s tests.', totalAmountOfTests);\r\n    };\r\n    Stryker.prototype.setGlobalLogLevel = function () {\r\n        log4js.setGlobalLogLevel(this.config.logLevel);\r\n    };\r\n    Stryker.prototype.logFailedTests = function (unsuccessfulTests) {\r\n        var failedSpecNames = _.uniq(_.flatten(unsuccessfulTests\r\n            .filter(function (runResult) { return runResult.result === test_runner_1.TestResult.Complete; })\r\n            .map(function (runResult) { return runResult.testNames; })))\r\n            .sort();\r\n        if (failedSpecNames.length > 0) {\r\n            var message_1 = 'One or more tests failed in the inial test run:';\r\n            failedSpecNames.forEach(function (filename) { return message_1 += \"\\n\\t\" + filename; });\r\n            log.error(message_1);\r\n        }\r\n        var errors = _.flatten(unsuccessfulTests\r\n            .filter(function (runResult) { return runResult.result === test_runner_1.TestResult.Error; })\r\n            .map(function (runResult) { return runResult.errorMessages; }))\r\n            .sort();\r\n        if (errors.length > 0) {\r\n            var message_2 = 'One or more tests errored in the initial test run:';\r\n            errors.forEach(function (error) { return message_2 += \"\\n\\t\" + error; });\r\n            log.error(message_2);\r\n        }\r\n    };\r\n    return Stryker;\r\n}());","mutatedLines":"var Stryker = (function () {\n}());"},{"sourceFilePath":"/stryker/src/stryker-cli.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":28,"column":29},"end":{"line":30,"column":5}},"range":[2092,2128],"originalLines":"    if (i.charAt(0) === '_') {\r\n        delete program[i];\r\n    }","mutatedLines":"    if (i.charAt(0) === '_') {\n}"},{"sourceFilePath":"/stryker/src/stryker-cli.js","mutatorName":"ReverseConditional","status":1,"replacement":"i.charAt(0) !== '_'","location":{"start":{"line":28,"column":8},"end":{"line":28,"column":27}},"range":[2071,2090],"originalLines":"    if (i.charAt(0) === '_') {","mutatedLines":"    if (i.charAt(0) !== '_') {"},{"sourceFilePath":"/stryker/src/stryker-cli.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":28,"column":8},"end":{"line":28,"column":27}},"range":[2071,2090],"originalLines":"    if (i.charAt(0) === '_') {","mutatedLines":"    if (true) {"},{"sourceFilePath":"/stryker/src/stryker-cli.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":28,"column":8},"end":{"line":28,"column":27}},"range":[2071,2090],"originalLines":"    if (i.charAt(0) === '_') {","mutatedLines":"    if (false) {"},{"sourceFilePath":"/stryker/src/stryker-cli.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":27,"column":23},"end":{"line":31,"column":1}},"range":[2060,2131],"originalLines":"for (var i in program) {\r\n    if (i.charAt(0) === '_') {\r\n        delete program[i];\r\n    }\r\n}","mutatedLines":"for (var i in program) {\n}"},{"sourceFilePath":"/stryker/src/stryker-cli.js","mutatorName":"ReverseConditional","status":1,"replacement":"program['logLevel'] && 'info'","location":{"start":{"line":22,"column":25},"end":{"line":22,"column":54}},"range":[1906,1935],"originalLines":"log4js.setGlobalLogLevel(program['logLevel'] || 'info');","mutatedLines":"log4js.setGlobalLogLevel(program['logLevel'] && 'info');"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":44,"column":88},"end":{"line":44,"column":158}},"range":[1935,2005],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"        return this.runSingleTestsRecursive(sandbox, [], 0).then(function (testResults) { return runner.dispose().then(function () { return testResults; }); });","mutatedLines":"        return this.runSingleTestsRecursive(sandbox, [], 0).then(function (testResults) {\n});"},{"sourceFilePath":"/stryker/src/stryker-cli.js","mutatorName":"Math","status":1,"replacement":"'A location to a config file. That file should export a function which accepts a \"config\" object\\n' - ConfigReader_1.CONFIG_SYNTAX_HELP","location":{"start":{"line":18,"column":53},"end":{"line":19,"column":37}},"range":[1560,1700],"originalLines":"    .option('-c, --configFile <configFileLocation>', 'A location to a config file. That file should export a function which accepts a \"config\" object\\n' +\r\n    ConfigReader_1.CONFIG_SYNTAX_HELP)","mutatedLines":"    .option('-c, --configFile <configFileLocation>', 'A location to a config file. That file should export a function which accepts a \"config\" object\\n' - ConfigReader_1.CONFIG_SYNTAX_HELP)"},{"sourceFilePath":"/stryker/src/reporters/ProgressReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":7,"column":66},"end":{"line":24,"column":5}},"range":[240,766],"originalLines":"    ProgressReporter.prototype.onMutantTested = function (result) {\r\n        var toLog;\r\n        switch (result.status) {\r\n            case report_1.MutantStatus.KILLED:\r\n                toLog = '.';\r\n                break;\r\n            case report_1.MutantStatus.TIMEDOUT:\r\n                toLog = chalk.yellow('T');\r\n                break;\r\n            case report_1.MutantStatus.SURVIVED:\r\n                toLog = chalk.bold.red('S');\r\n                break;\r\n            default:\r\n                toLog = '';\r\n                break;\r\n        }\r\n        process.stdout.write(toLog);\r\n    };","mutatedLines":"    ProgressReporter.prototype.onMutantTested = function (result) {\n};"},{"sourceFilePath":"/stryker/src/reporters/ProgressReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":5,"column":32},"end":{"line":6,"column":5}},"range":[164,172],"originalLines":"    function ProgressReporter() {\r\n    }","mutatedLines":"    function ProgressReporter() {\n}"},{"sourceFilePath":"/stryker/src/reporters/ProgressReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":4,"column":36},"end":{"line":26,"column":1}},"range":[129,800],"originalLines":"var ProgressReporter = (function () {\r\n    function ProgressReporter() {\r\n    }\r\n    ProgressReporter.prototype.onMutantTested = function (result) {\r\n        var toLog;\r\n        switch (result.status) {\r\n            case report_1.MutantStatus.KILLED:\r\n                toLog = '.';\r\n                break;\r\n            case report_1.MutantStatus.TIMEDOUT:\r\n                toLog = chalk.yellow('T');\r\n                break;\r\n            case report_1.MutantStatus.SURVIVED:\r\n                toLog = chalk.bold.red('S');\r\n                break;\r\n            default:\r\n                toLog = '';\r\n                break;\r\n        }\r\n        process.stdout.write(toLog);\r\n    };\r\n    return ProgressReporter;\r\n}());","mutatedLines":"var ProgressReporter = (function () {\n}());"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":54,"column":58},"end":{"line":54,"column":96}},"range":[2464,2502],"originalLines":"        return this.createBaseFolderTask.then(function () { return Promise.all(_this.allWork); });","mutatedLines":"        return this.createBaseFolderTask.then(function () {\n});"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":52,"column":57},"end":{"line":55,"column":5}},"range":[2376,2511],"originalLines":"    EventRecorderReporter.prototype.wrapUp = function () {\r\n        var _this = this;\r\n        return this.createBaseFolderTask.then(function () { return Promise.all(_this.allWork); });\r\n    };","mutatedLines":"    EventRecorderReporter.prototype.wrapUp = function () {\n};"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"Math","status":1,"replacement":"'0' - str","location":{"start":{"line":47,"column":22},"end":{"line":47,"column":31}},"range":[2252,2261],"originalLines":"                str = '0' + str;","mutatedLines":"                str = '0' - str;"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":46,"column":27},"end":{"line":48,"column":13}},"range":[2227,2277],"originalLines":"            if (i > input) {\r\n                str = '0' + str;\r\n            }","mutatedLines":"            if (i > input) {\n}"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"ReverseConditional","status":1,"replacement":"i <= input","location":{"start":{"line":46,"column":16},"end":{"line":46,"column":25}},"range":[2216,2225],"originalLines":"            if (i > input) {","mutatedLines":"            if (i <= input) {"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"ConditionalBoundary","status":1,"replacement":"i >= input","location":{"start":{"line":46,"column":16},"end":{"line":46,"column":25}},"range":[2216,2225],"originalLines":"            if (i > input) {","mutatedLines":"            if (i >= input) {"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":46,"column":16},"end":{"line":46,"column":25}},"range":[2216,2225],"originalLines":"            if (i > input) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":46,"column":16},"end":{"line":46,"column":25}},"range":[2216,2225],"originalLines":"            if (i > input) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":45,"column":47},"end":{"line":49,"column":9}},"range":[2197,2288],"originalLines":"        for (var i = 10000; i > 1; i = i / 10) {\r\n            if (i > input) {\r\n                str = '0' + str;\r\n            }\r\n        }","mutatedLines":"        for (var i = 10000; i > 1; i = i / 10) {\n}"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"Math","status":1,"replacement":"i * 10","location":{"start":{"line":45,"column":39},"end":{"line":45,"column":45}},"range":[2189,2195],"originalLines":"        for (var i = 10000; i > 1; i = i / 10) {","mutatedLines":"        for (var i = 10000; i > 1; i = i * 10) {"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"ReverseConditional","status":1,"replacement":"i <= 1","location":{"start":{"line":45,"column":28},"end":{"line":45,"column":33}},"range":[2178,2183],"originalLines":"        for (var i = 10000; i > 1; i = i / 10) {","mutatedLines":"        for (var i = 10000; i <= 1; i = i / 10) {"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"ConditionalBoundary","status":1,"replacement":"i >= 1","location":{"start":{"line":45,"column":28},"end":{"line":45,"column":33}},"range":[2178,2183],"originalLines":"        for (var i = 10000; i > 1; i = i / 10) {","mutatedLines":"        for (var i = 10000; i >= 1; i = i / 10) {"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":45,"column":28},"end":{"line":45,"column":33}},"range":[2178,2183],"originalLines":"        for (var i = 10000; i > 1; i = i / 10) {","mutatedLines":"        for (var i = 10000; false; i = i / 10) {"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":43,"column":62},"end":{"line":51,"column":5}},"range":[2110,2316],"originalLines":"    EventRecorderReporter.prototype.format = function (input) {\r\n        var str = input.toString();\r\n        for (var i = 10000; i > 1; i = i / 10) {\r\n            if (i > input) {\r\n                str = '0' + str;\r\n            }\r\n        }\r\n        return str;\r\n    };","mutatedLines":"    EventRecorderReporter.prototype.format = function (input) {\n};"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"Math","status":1,"replacement":"'Writing event ' - methodName","location":{"start":{"line":40,"column":18},"end":{"line":40,"column":47}},"range":[1913,1942],"originalLines":"        log.debug(\"Writing event \" + methodName + \" to file \" + filename);","mutatedLines":"        log.debug('Writing event ' - methodName + \" to file \" + filename);"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"Math","status":1,"replacement":"'Writing event ' + methodName - ' to file '","location":{"start":{"line":40,"column":18},"end":{"line":40,"column":61}},"range":[1913,1956],"originalLines":"        log.debug(\"Writing event \" + methodName + \" to file \" + filename);","mutatedLines":"        log.debug('Writing event ' + methodName - ' to file ' + filename);"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"Math","status":1,"replacement":"'Writing event ' + methodName + ' to file ' - filename","location":{"start":{"line":40,"column":18},"end":{"line":40,"column":72}},"range":[1913,1967],"originalLines":"        log.debug(\"Writing event \" + methodName + \" to file \" + filename);","mutatedLines":"        log.debug('Writing event ' + methodName + ' to file ' - filename);"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"Math","status":1,"replacement":"this.format(index) - '-'","location":{"start":{"line":39,"column":50},"end":{"line":39,"column":74}},"range":[1844,1868],"originalLines":"        var filename = path.join(this.baseFolder, this.format(index) + \"-\" + methodName + \".json\");","mutatedLines":"        var filename = path.join(this.baseFolder, this.format(index) - '-' + methodName + \".json\");"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"Math","status":1,"replacement":"this.format(index) + '-' - methodName","location":{"start":{"line":39,"column":50},"end":{"line":39,"column":87}},"range":[1844,1881],"originalLines":"        var filename = path.join(this.baseFolder, this.format(index) + \"-\" + methodName + \".json\");","mutatedLines":"        var filename = path.join(this.baseFolder, this.format(index) + '-' - methodName + \".json\");"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"Math","status":1,"replacement":"this.format(index) + '-' + methodName - '.json'","location":{"start":{"line":39,"column":50},"end":{"line":39,"column":97}},"range":[1844,1891],"originalLines":"        var filename = path.join(this.baseFolder, this.format(index) + \"-\" + methodName + \".json\");","mutatedLines":"        var filename = path.join(this.baseFolder, this.format(index) + '-' + methodName - '.json');"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":38,"column":85},"end":{"line":42,"column":5}},"range":[1791,2045],"originalLines":"    EventRecorderReporter.prototype.writeToFile = function (index, methodName, data) {\r\n        var filename = path.join(this.baseFolder, this.format(index) + \"-\" + methodName + \".json\");\r\n        log.debug(\"Writing event \" + methodName + \" to file \" + filename);\r\n        return fileUtils.writeFile(filename, JSON.stringify(data));\r\n    };","mutatedLines":"    EventRecorderReporter.prototype.writeToFile = function (index, methodName, data) {\n};"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"Math","status":1,"replacement":"'No base folder configuration found (using configuration: eventReporter: { baseDir: \\'output/folder\\' }), using default ' - DEFAULT_BASE_FOLDER","location":{"start":{"line":29,"column":30},"end":{"line":29,"column":171}},"range":[1352,1493],"originalLines":"                    log.debug(\"No base folder configuration found (using configuration: eventReporter: { baseDir: 'output/folder' }), using default \" + DEFAULT_BASE_FOLDER);","mutatedLines":"                    log.debug('No base folder configuration found (using configuration: eventReporter: { baseDir: \\'output/folder\\' }), using default ' - DEFAULT_BASE_FOLDER);"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":28,"column":21},"end":{"line":31,"column":17}},"range":[1319,1575],"originalLines":"                else {\r\n                    log.debug(\"No base folder configuration found (using configuration: eventReporter: { baseDir: 'output/folder' }), using default \" + DEFAULT_BASE_FOLDER);\r\n                    this._baseFolder = DEFAULT_BASE_FOLDER;\r\n                }","mutatedLines":"                else {\n}"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"Math","status":1,"replacement":"'Using configured output folder ' - this._baseFolder","location":{"start":{"line":26,"column":30},"end":{"line":26,"column":82}},"range":[1223,1275],"originalLines":"                    log.debug(\"Using configured output folder \" + this._baseFolder);","mutatedLines":"                    log.debug('Using configured output folder ' - this._baseFolder);"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":24,"column":95},"end":{"line":27,"column":17}},"range":[1108,1296],"originalLines":"                if (this.options['eventReporter'] && this.options['eventReporter']['baseDir']) {\r\n                    this._baseFolder = this.options['eventReporter']['baseDir'];\r\n                    log.debug(\"Using configured output folder \" + this._baseFolder);\r\n                }","mutatedLines":"                if (this.options['eventReporter'] && this.options['eventReporter']['baseDir']) {\n}"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"ReverseConditional","status":1,"replacement":"this.options['eventReporter'] || this.options['eventReporter']['baseDir']","location":{"start":{"line":24,"column":20},"end":{"line":24,"column":93}},"range":[1033,1106],"originalLines":"                if (this.options['eventReporter'] && this.options['eventReporter']['baseDir']) {","mutatedLines":"                if (this.options['eventReporter'] || this.options['eventReporter']['baseDir']) {"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":24,"column":20},"end":{"line":24,"column":93}},"range":[1033,1106],"originalLines":"                if (this.options['eventReporter'] && this.options['eventReporter']['baseDir']) {","mutatedLines":"                if (true) {"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":24,"column":20},"end":{"line":24,"column":93}},"range":[1033,1106],"originalLines":"                if (this.options['eventReporter'] && this.options['eventReporter']['baseDir']) {","mutatedLines":"                if (false) {"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":23,"column":35},"end":{"line":32,"column":13}},"range":[1010,1590],"originalLines":"            if (!this._baseFolder) {\r\n                if (this.options['eventReporter'] && this.options['eventReporter']['baseDir']) {\r\n                    this._baseFolder = this.options['eventReporter']['baseDir'];\r\n                    log.debug(\"Using configured output folder \" + this._baseFolder);\r\n                }\r\n                else {\r\n                    log.debug(\"No base folder configuration found (using configuration: eventReporter: { baseDir: 'output/folder' }), using default \" + DEFAULT_BASE_FOLDER);\r\n                    this._baseFolder = DEFAULT_BASE_FOLDER;\r\n                }\r\n            }","mutatedLines":"            if (!this._baseFolder) {\n}"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":23,"column":16},"end":{"line":23,"column":33}},"range":[991,1008],"originalLines":"            if (!this._baseFolder) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":23,"column":16},"end":{"line":23,"column":33}},"range":[991,1008],"originalLines":"            if (!this._baseFolder) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":22,"column":25},"end":{"line":34,"column":9}},"range":[972,1639],"originalLines":"        get: function () {\r\n            if (!this._baseFolder) {\r\n                if (this.options['eventReporter'] && this.options['eventReporter']['baseDir']) {\r\n                    this._baseFolder = this.options['eventReporter']['baseDir'];\r\n                    log.debug(\"Using configured output folder \" + this._baseFolder);\r\n                }\r\n                else {\r\n                    log.debug(\"No base folder configuration found (using configuration: eventReporter: { baseDir: 'output/folder' }), using default \" + DEFAULT_BASE_FOLDER);\r\n                    this._baseFolder = DEFAULT_BASE_FOLDER;\r\n                }\r\n            }\r\n            return this._baseFolder;\r\n        },","mutatedLines":"        get: function () {\n},"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"UnaryOperator","status":1,"replacement":"index--","location":{"start":{"line":17,"column":106},"end":{"line":17,"column":113}},"range":[805,812],"originalLines":"                _this.allWork.push(_this.createBaseFolderTask.then(function () { return _this.writeToFile(index++, method, data); }));","mutatedLines":"                _this.allWork.push(_this.createBaseFolderTask.then(function () { return _this.writeToFile(index--, method, data); }));"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":17,"column":79},"end":{"line":17,"column":131}},"range":[778,830],"originalLines":"                _this.allWork.push(_this.createBaseFolderTask.then(function () { return _this.writeToFile(index++, method, data); }));","mutatedLines":"                _this.allWork.push(_this.createBaseFolderTask.then(function () {\n}));"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":16,"column":44},"end":{"line":18,"column":13}},"range":[696,848],"originalLines":"            _this[method] = function (data) {\r\n                _this.allWork.push(_this.createBaseFolderTask.then(function () { return _this.writeToFile(index++, method, data); }));\r\n            };","mutatedLines":"            _this[method] = function (data) {\n};"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":15,"column":77},"end":{"line":19,"column":9}},"range":[649,860],"originalLines":"        BroadcastReporter_1.ALL_EVENT_METHOD_NAMES.forEach(function (method) {\r\n            _this[method] = function (data) {\r\n                _this.allWork.push(_this.createBaseFolderTask.then(function () { return _this.writeToFile(index++, method, data); }));\r\n            };\r\n        });","mutatedLines":"        BroadcastReporter_1.ALL_EVENT_METHOD_NAMES.forEach(function (method) {\n});"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":9,"column":44},"end":{"line":20,"column":5}},"range":[380,869],"originalLines":"    function EventRecorderReporter(options) {\r\n        var _this = this;\r\n        this.options = options;\r\n        this.allWork = [];\r\n        var index = 0;\r\n        this.createBaseFolderTask = fileUtils.cleanFolder(this.baseFolder);\r\n        BroadcastReporter_1.ALL_EVENT_METHOD_NAMES.forEach(function (method) {\r\n            _this[method] = function (data) {\r\n                _this.allWork.push(_this.createBaseFolderTask.then(function () { return _this.writeToFile(index++, method, data); }));\r\n            };\r\n        });\r\n    }","mutatedLines":"    function EventRecorderReporter(options) {\n}"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":8,"column":41},"end":{"line":57,"column":1}},"range":[333,2550],"originalLines":"var EventRecorderReporter = (function () {\r\n    function EventRecorderReporter(options) {\r\n        var _this = this;\r\n        this.options = options;\r\n        this.allWork = [];\r\n        var index = 0;\r\n        this.createBaseFolderTask = fileUtils.cleanFolder(this.baseFolder);\r\n        BroadcastReporter_1.ALL_EVENT_METHOD_NAMES.forEach(function (method) {\r\n            _this[method] = function (data) {\r\n                _this.allWork.push(_this.createBaseFolderTask.then(function () { return _this.writeToFile(index++, method, data); }));\r\n            };\r\n        });\r\n    }\r\n    Object.defineProperty(EventRecorderReporter.prototype, \"baseFolder\", {\r\n        get: function () {\r\n            if (!this._baseFolder) {\r\n                if (this.options['eventReporter'] && this.options['eventReporter']['baseDir']) {\r\n                    this._baseFolder = this.options['eventReporter']['baseDir'];\r\n                    log.debug(\"Using configured output folder \" + this._baseFolder);\r\n                }\r\n                else {\r\n                    log.debug(\"No base folder configuration found (using configuration: eventReporter: { baseDir: 'output/folder' }), using default \" + DEFAULT_BASE_FOLDER);\r\n                    this._baseFolder = DEFAULT_BASE_FOLDER;\r\n                }\r\n            }\r\n            return this._baseFolder;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    EventRecorderReporter.prototype.writeToFile = function (index, methodName, data) {\r\n        var filename = path.join(this.baseFolder, this.format(index) + \"-\" + methodName + \".json\");\r\n        log.debug(\"Writing event \" + methodName + \" to file \" + filename);\r\n        return fileUtils.writeFile(filename, JSON.stringify(data));\r\n    };\r\n    EventRecorderReporter.prototype.format = function (input) {\r\n        var str = input.toString();\r\n        for (var i = 10000; i > 1; i = i / 10) {\r\n            if (i > input) {\r\n                str = '0' + str;\r\n            }\r\n        }\r\n        return str;\r\n    };\r\n    EventRecorderReporter.prototype.wrapUp = function () {\r\n        var _this = this;\r\n        return this.createBaseFolderTask.then(function () { return Promise.all(_this.allWork); });\r\n    };\r\n    return EventRecorderReporter;\r\n}());","mutatedLines":"var EventRecorderReporter = (function () {\n}());"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":82,"column":13},"end":{"line":84,"column":9}},"range":[4034,4078],"originalLines":"        else {\r\n            color = chalk.red;\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":79,"column":29},"end":{"line":81,"column":9}},"range":[3972,4019],"originalLines":"        else if (score > 50) {\r\n            color = chalk.yellow;\r\n        }","mutatedLines":"        else if (score > 50) {\n}"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"ReverseConditional","status":1,"replacement":"score <= 50","location":{"start":{"line":79,"column":17},"end":{"line":79,"column":27}},"range":[3960,3970],"originalLines":"        else if (score > 50) {","mutatedLines":"        else if (score <= 50) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"ConditionalBoundary","status":1,"replacement":"score >= 50","location":{"start":{"line":79,"column":17},"end":{"line":79,"column":27}},"range":[3960,3970],"originalLines":"        else if (score > 50) {","mutatedLines":"        else if (score >= 50) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":79,"column":17},"end":{"line":79,"column":27}},"range":[3960,3970],"originalLines":"        else if (score > 50) {","mutatedLines":"        else if (true) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":79,"column":17},"end":{"line":79,"column":27}},"range":[3960,3970],"originalLines":"        else if (score > 50) {","mutatedLines":"        else if (false) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":76,"column":24},"end":{"line":78,"column":9}},"range":[3895,3941],"originalLines":"        if (score > 80) {\r\n            color = chalk.green;\r\n        }","mutatedLines":"        if (score > 80) {\n}"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"ReverseConditional","status":1,"replacement":"score <= 80","location":{"start":{"line":76,"column":12},"end":{"line":76,"column":22}},"range":[3883,3893],"originalLines":"        if (score > 80) {","mutatedLines":"        if (score <= 80) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"ConditionalBoundary","status":1,"replacement":"score >= 80","location":{"start":{"line":76,"column":12},"end":{"line":76,"column":22}},"range":[3883,3893],"originalLines":"        if (score > 80) {","mutatedLines":"        if (score >= 80) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":76,"column":12},"end":{"line":76,"column":22}},"range":[3883,3893],"originalLines":"        if (score > 80) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":76,"column":12},"end":{"line":76,"column":22}},"range":[3883,3893],"originalLines":"        if (score > 80) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":65,"column":103},"end":{"line":65,"column":128}},"range":[3648,3673],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"        }).then(function (mutantResults) { return StrykerTempFolder_1.default.clean().then(function () { return mutantResults; }); });","mutatedLines":"        }).then(function (mutantResults) { return StrykerTempFolder_1.default.clean().then(function () {\n}); });"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":74,"column":76},"end":{"line":86,"column":5}},"range":[3848,4108],"originalLines":"    ClearTextReporter.prototype.getColorForMutationScore = function (score) {\r\n        var color;\r\n        if (score > 80) {\r\n            color = chalk.green;\r\n        }\r\n        else if (score > 50) {\r\n            color = chalk.yellow;\r\n        }\r\n        else {\r\n            color = chalk.red;\r\n        }\r\n        return color;\r\n    };","mutatedLines":"    ClearTextReporter.prototype.getColorForMutationScore = function (score) {\n};"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"Math","status":2,"replacement":"mutants.length - ' Mutant(s) generated'","location":{"start":{"line":48,"column":25},"end":{"line":48,"column":64}},"range":[2750,2789],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"                log.info(mutants.length + \" Mutant(s) generated\");","mutatedLines":"                log.info(mutants.length - ' Mutant(s) generated');"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":59,"column":16},"end":{"line":59,"column":53}},"range":[3332,3369],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"            if (objectUtils_1.isPromise(maybePromise)) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":68,"column":55},"end":{"line":70,"column":13}},"range":[3646,3713],"originalLines":"            _.forEach(result.testsRan, function (spec) {\r\n                logImplementation('    ' + spec);\r\n            });","mutatedLines":"            _.forEach(result.testsRan, function (spec) {\n});"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"ConditionalBoundary","status":1,"replacement":"result.testsRan.length >= 0","location":{"start":{"line":66,"column":31},"end":{"line":66,"column":57}},"range":[3513,3539],"originalLines":"        if (result.testsRan && result.testsRan.length > 0) {","mutatedLines":"        if (result.testsRan && result.testsRan.length >= 0) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"ReverseConditional","status":1,"replacement":"result.testsRan || result.testsRan.length > 0","location":{"start":{"line":66,"column":12},"end":{"line":66,"column":57}},"range":[3494,3539],"originalLines":"        if (result.testsRan && result.testsRan.length > 0) {","mutatedLines":"        if (result.testsRan || result.testsRan.length > 0) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":66,"column":12},"end":{"line":66,"column":57}},"range":[3494,3539],"originalLines":"        if (result.testsRan && result.testsRan.length > 0) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":66,"column":12},"end":{"line":66,"column":57}},"range":[3494,3539],"originalLines":"        if (result.testsRan && result.testsRan.length > 0) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":57,"column":41},"end":{"line":65,"column":9}},"range":[3262,3554],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"        }).then(function (mutantResults) {\r\n            var maybePromise = reporter.wrapUp();\r\n            if (objectUtils_1.isPromise(maybePromise)) {\r\n                return maybePromise.then(function () { return mutantResults; });\r\n            }\r\n            else {\r\n                return mutantResults;\r\n            }\r\n        }).then(function (mutantResults) { return StrykerTempFolder_1.default.clean().then(function () { return mutantResults; }); });","mutatedLines":"        }).then(function (mutantResults) {\n}).then(function (mutantResults) { return StrykerTempFolder_1.default.clean().then(function () { return mutantResults; }); });"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"Math","status":1,"replacement":"'+   ' - line","location":{"start":{"line":63,"column":42},"end":{"line":63,"column":55}},"range":[3419,3432],"originalLines":"            logImplementation(chalk.green('+   ' + line));","mutatedLines":"            logImplementation(chalk.green('+   ' - line));"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"Math","status":1,"replacement":"'-   ' - line","location":{"start":{"line":60,"column":40},"end":{"line":60,"column":53}},"range":[3279,3292],"originalLines":"            logImplementation(chalk.red('-   ' + line));","mutatedLines":"            logImplementation(chalk.red('-   ' - line));"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":59,"column":65},"end":{"line":61,"column":9}},"range":[3236,3306],"originalLines":"        result.originalLines.split('\\n').forEach(function (line) {\r\n            logImplementation(chalk.red('-   ' + line));\r\n        });","mutatedLines":"        result.originalLines.split('\\n').forEach(function (line) {\n});"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"Math","status":1,"replacement":"'Mutator: ' - result.mutatorName","location":{"start":{"line":58,"column":26},"end":{"line":58,"column":58}},"range":[3135,3167],"originalLines":"        logImplementation('Mutator: ' + result.mutatorName);","mutatedLines":"        logImplementation('Mutator: ' - result.mutatorName);"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"Math","status":1,"replacement":"result.sourceFilePath - ': line '","location":{"start":{"line":57,"column":26},"end":{"line":57,"column":59}},"range":[3006,3039],"originalLines":"        logImplementation(result.sourceFilePath + ': line ' + result.location.start.line + ':' + result.location.start.column);","mutatedLines":"        logImplementation(result.sourceFilePath - ': line ' + result.location.start.line + ':' + result.location.start.column);"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"Math","status":1,"replacement":"result.sourceFilePath + ': line ' - result.location.start.line","location":{"start":{"line":57,"column":26},"end":{"line":57,"column":88}},"range":[3006,3068],"originalLines":"        logImplementation(result.sourceFilePath + ': line ' + result.location.start.line + ':' + result.location.start.column);","mutatedLines":"        logImplementation(result.sourceFilePath + ': line ' - result.location.start.line + ':' + result.location.start.column);"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"Math","status":1,"replacement":"result.sourceFilePath + ': line ' + result.location.start.line - ':'","location":{"start":{"line":57,"column":26},"end":{"line":57,"column":94}},"range":[3006,3074],"originalLines":"        logImplementation(result.sourceFilePath + ': line ' + result.location.start.line + ':' + result.location.start.column);","mutatedLines":"        logImplementation(result.sourceFilePath + ': line ' + result.location.start.line - ':' + result.location.start.column);"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"Math","status":1,"replacement":"result.sourceFilePath + ': line ' + result.location.start.line + ':' - result.location.start.column","location":{"start":{"line":57,"column":26},"end":{"line":57,"column":125}},"range":[3006,3105],"originalLines":"        logImplementation(result.sourceFilePath + ': line ' + result.location.start.line + ':' + result.location.start.column);","mutatedLines":"        logImplementation(result.sourceFilePath + ': line ' + result.location.start.line + ':' - result.location.start.column);"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":56,"column":87},"end":{"line":73,"column":5}},"range":[2977,3769],"originalLines":"    ClearTextReporter.prototype.logMutantResult = function (result, logImplementation) {\r\n        logImplementation(result.sourceFilePath + ': line ' + result.location.start.line + ':' + result.location.start.column);\r\n        logImplementation('Mutator: ' + result.mutatorName);\r\n        result.originalLines.split('\\n').forEach(function (line) {\r\n            logImplementation(chalk.red('-   ' + line));\r\n        });\r\n        result.mutatedLines.split('\\n').forEach(function (line) {\r\n            logImplementation(chalk.green('+   ' + line));\r\n        });\r\n        logImplementation('');\r\n        if (result.testsRan && result.testsRan.length > 0) {\r\n            logImplementation('Tests ran: ');\r\n            _.forEach(result.testsRan, function (spec) {\r\n                logImplementation('    ' + spec);\r\n            });\r\n            logImplementation('');\r\n        }\r\n    };","mutatedLines":"    ClearTextReporter.prototype.logMutantResult = function (result, logImplementation) {\n};"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"Math","status":1,"replacement":"mutationScoreCodebase - '%'","location":{"start":{"line":54,"column":76},"end":{"line":54,"column":103}},"range":[2850,2877],"originalLines":"        this.writeLine('Mutation score based on all code: ' + codebaseColor(mutationScoreCodebase + '%'));","mutatedLines":"        this.writeLine('Mutation score based on all code: ' + codebaseColor(mutationScoreCodebase - '%'));"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"Math","status":1,"replacement":"'Mutation score based on all code: ' - codebaseColor(mutationScoreCodebase + '%')","location":{"start":{"line":54,"column":23},"end":{"line":54,"column":104}},"range":[2797,2878],"originalLines":"        this.writeLine('Mutation score based on all code: ' + codebaseColor(mutationScoreCodebase + '%'));","mutatedLines":"        this.writeLine('Mutation score based on all code: ' - codebaseColor(mutationScoreCodebase + '%'));"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"Math","status":1,"replacement":"mutationScoreCodeCoverage - '%'","location":{"start":{"line":53,"column":84},"end":{"line":53,"column":115}},"range":[2738,2769],"originalLines":"        this.writeLine('Mutation score based on covered code: ' + codecoverageColor(mutationScoreCodeCoverage + '%'));","mutatedLines":"        this.writeLine('Mutation score based on covered code: ' + codecoverageColor(mutationScoreCodeCoverage - '%'));"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"Math","status":1,"replacement":"'Mutation score based on covered code: ' - codecoverageColor(mutationScoreCodeCoverage + '%')","location":{"start":{"line":53,"column":23},"end":{"line":53,"column":116}},"range":[2677,2770],"originalLines":"        this.writeLine('Mutation score based on covered code: ' + codecoverageColor(mutationScoreCodeCoverage + '%'));","mutatedLines":"        this.writeLine('Mutation score based on covered code: ' - codecoverageColor(mutationScoreCodeCoverage + '%'));"},{"sourceFilePath":"/stryker/src/stryker-cli.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":33,"column":26},"end":{"line":33,"column":73}},"range":[2209,2256],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"    .catch(function (err) { return log.error(\"an error occurred\", err); });","mutatedLines":"    .catch(function (err) {\n});"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"Math","status":1,"replacement":"mutantsKilled - ' mutants killed.'","location":{"start":{"line":52,"column":23},"end":{"line":52,"column":57}},"range":[2616,2650],"originalLines":"        this.writeLine(mutantsKilled + ' mutants killed.');","mutatedLines":"        this.writeLine(mutantsKilled - ' mutants killed.');"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"Math","status":1,"replacement":"mutantsUntested - ' mutants untested.'","location":{"start":{"line":50,"column":23},"end":{"line":50,"column":61}},"range":[2485,2523],"originalLines":"        this.writeLine(mutantsUntested + ' mutants untested.');","mutatedLines":"        this.writeLine(mutantsUntested - ' mutants untested.');"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"Math","status":1,"replacement":"mutantResults.length + mutantsUntested","location":{"start":{"line":49,"column":24},"end":{"line":49,"column":62}},"range":[2398,2436],"originalLines":"        this.writeLine((mutantResults.length - mutantsUntested) + ' mutants tested.');","mutatedLines":"        this.writeLine((mutantResults.length + mutantsUntested) + ' mutants tested.');"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"Math","status":1,"replacement":"mutantResults.length - mutantsUntested - ' mutants tested.'","location":{"start":{"line":49,"column":23},"end":{"line":49,"column":84}},"range":[2397,2458],"originalLines":"        this.writeLine((mutantResults.length - mutantsUntested) + ' mutants tested.');","mutatedLines":"        this.writeLine(mutantResults.length - mutantsUntested - ' mutants tested.');"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"UnaryOperator","status":1,"replacement":"-mutationScoreCodeCoverage","location":{"start":{"line":48,"column":62},"end":{"line":48,"column":88}},"range":[2344,2370],"originalLines":"        var codecoverageColor = this.getColorForMutationScore(+mutationScoreCodeCoverage);","mutatedLines":"        var codecoverageColor = this.getColorForMutationScore(-mutationScoreCodeCoverage);"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"UnaryOperator","status":1,"replacement":"-mutationScoreCodebase","location":{"start":{"line":47,"column":58},"end":{"line":47,"column":80}},"range":[2256,2278],"originalLines":"        var codebaseColor = this.getColorForMutationScore(+mutationScoreCodebase);","mutatedLines":"        var codebaseColor = this.getColorForMutationScore(-mutationScoreCodebase);"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"Math","status":1,"replacement":"mutantResults.length + mutantsUntested","location":{"start":{"line":46,"column":80},"end":{"line":46,"column":118}},"range":[2131,2169],"originalLines":"        var mutationScoreCodeCoverage = (((mutantsKilled + mutantsTimedOut) / ((mutantResults.length - mutantsUntested) || 1)) * 100).toFixed(2);","mutatedLines":"        var mutationScoreCodeCoverage = (((mutantsKilled + mutantsTimedOut) / ((mutantResults.length + mutantsUntested) || 1)) * 100).toFixed(2);"},{"sourceFilePath":"/stryker/src/stryker-cli.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":7,"column":19},"end":{"line":9,"column":1}},"range":[236,268],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"function list(val) {\r\n    return val.split(',');\r\n}","mutatedLines":"function list(val) {\n}"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"ReverseConditional","status":1,"replacement":"mutantResults.length - mutantsUntested && 1","location":{"start":{"line":46,"column":79},"end":{"line":46,"column":124}},"range":[2130,2175],"originalLines":"        var mutationScoreCodeCoverage = (((mutantsKilled + mutantsTimedOut) / ((mutantResults.length - mutantsUntested) || 1)) * 100).toFixed(2);","mutatedLines":"        var mutationScoreCodeCoverage = (((mutantsKilled + mutantsTimedOut) / (mutantResults.length - mutantsUntested && 1)) * 100).toFixed(2);"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"Math","status":1,"replacement":"(mutantsKilled + mutantsTimedOut) * (mutantResults.length - mutantsUntested || 1)","location":{"start":{"line":46,"column":42},"end":{"line":46,"column":125}},"range":[2093,2176],"originalLines":"        var mutationScoreCodeCoverage = (((mutantsKilled + mutantsTimedOut) / ((mutantResults.length - mutantsUntested) || 1)) * 100).toFixed(2);","mutatedLines":"        var mutationScoreCodeCoverage = (((mutantsKilled + mutantsTimedOut) * (mutantResults.length - mutantsUntested || 1)) * 100).toFixed(2);"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"Math","status":1,"replacement":"(mutantsKilled + mutantsTimedOut) / (mutantResults.length - mutantsUntested || 1) / 100","location":{"start":{"line":46,"column":41},"end":{"line":46,"column":132}},"range":[2092,2183],"originalLines":"        var mutationScoreCodeCoverage = (((mutantsKilled + mutantsTimedOut) / ((mutantResults.length - mutantsUntested) || 1)) * 100).toFixed(2);","mutatedLines":"        var mutationScoreCodeCoverage = ((mutantsKilled + mutantsTimedOut) / (mutantResults.length - mutantsUntested || 1) / 100).toFixed(2);"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"Math","status":1,"replacement":"mutantsKilled - mutantsTimedOut","location":{"start":{"line":45,"column":39},"end":{"line":45,"column":70}},"range":[1974,2005],"originalLines":"        var mutationScoreCodebase = (((mutantsKilled + mutantsTimedOut) / mutantResults.length) * 100).toFixed(2);","mutatedLines":"        var mutationScoreCodebase = (((mutantsKilled - mutantsTimedOut) / mutantResults.length) * 100).toFixed(2);"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"Math","status":1,"replacement":"(mutantsKilled + mutantsTimedOut) * mutantResults.length","location":{"start":{"line":45,"column":38},"end":{"line":45,"column":94}},"range":[1973,2029],"originalLines":"        var mutationScoreCodebase = (((mutantsKilled + mutantsTimedOut) / mutantResults.length) * 100).toFixed(2);","mutatedLines":"        var mutationScoreCodebase = (((mutantsKilled + mutantsTimedOut) * mutantResults.length) * 100).toFixed(2);"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"Math","status":1,"replacement":"(mutantsKilled + mutantsTimedOut) / mutantResults.length / 100","location":{"start":{"line":45,"column":37},"end":{"line":45,"column":101}},"range":[1972,2036],"originalLines":"        var mutationScoreCodebase = (((mutantsKilled + mutantsTimedOut) / mutantResults.length) * 100).toFixed(2);","mutatedLines":"        var mutationScoreCodebase = ((mutantsKilled + mutantsTimedOut) / mutantResults.length / 100).toFixed(2);"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"UnaryOperator","status":1,"replacement":"mutantsUntested--","location":{"start":{"line":39,"column":20},"end":{"line":39,"column":37}},"range":[1724,1741],"originalLines":"                    mutantsUntested++;","mutatedLines":"                    mutantsUntested--;"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"UnaryOperator","status":1,"replacement":"mutantsTimedOut--","location":{"start":{"line":30,"column":20},"end":{"line":30,"column":37}},"range":[1245,1262],"originalLines":"                    mutantsTimedOut++;","mutatedLines":"                    mutantsTimedOut--;"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"UnaryOperator","status":1,"replacement":"mutantsKilled--","location":{"start":{"line":25,"column":20},"end":{"line":25,"column":35}},"range":[993,1008],"originalLines":"                    mutantsKilled++;","mutatedLines":"                    mutantsKilled--;"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":22,"column":48},"end":{"line":44,"column":9}},"range":[880,1931],"originalLines":"        mutantResults.forEach(function (result) {\r\n            switch (result.status) {\r\n                case report_1.MutantStatus.KILLED:\r\n                    mutantsKilled++;\r\n                    log.debug(chalk.bold.green('Mutant killed!'));\r\n                    _this.logMutantResult(result, logDebugFn);\r\n                    break;\r\n                case report_1.MutantStatus.TIMEDOUT:\r\n                    mutantsTimedOut++;\r\n                    log.debug(chalk.bold.yellow('Mutant timed out!'));\r\n                    _this.logMutantResult(result, logDebugFn);\r\n                    break;\r\n                case report_1.MutantStatus.SURVIVED:\r\n                    _this.writeLine(chalk.bold.red('Mutant survived!'));\r\n                    _this.logMutantResult(result, writeLineFn);\r\n                    break;\r\n                case report_1.MutantStatus.UNTESTED:\r\n                    mutantsUntested++;\r\n                    log.debug(chalk.bold.yellow('Mutant untested!'));\r\n                    _this.logMutantResult(result, logDebugFn);\r\n                    break;\r\n            }\r\n        });","mutatedLines":"        mutantResults.forEach(function (result) {\n});"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":21,"column":43},"end":{"line":21,"column":77}},"range":[795,829],"originalLines":"        var writeLineFn = function (input) { return _this.writeLine(input); };","mutatedLines":"        var writeLineFn = function (input) {\n};"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":20,"column":42},"end":{"line":20,"column":70}},"range":[721,749],"originalLines":"        var logDebugFn = function (input) { return log.debug(input); };","mutatedLines":"        var logDebugFn = function (input) {\n};"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":14,"column":78},"end":{"line":55,"column":5}},"range":[522,2887],"originalLines":"    ClearTextReporter.prototype.onAllMutantsTested = function (mutantResults) {\r\n        var _this = this;\r\n        this.writeLine();\r\n        var mutantsKilled = 0;\r\n        var mutantsTimedOut = 0;\r\n        var mutantsUntested = 0;\r\n        var logDebugFn = function (input) { return log.debug(input); };\r\n        var writeLineFn = function (input) { return _this.writeLine(input); };\r\n        mutantResults.forEach(function (result) {\r\n            switch (result.status) {\r\n                case report_1.MutantStatus.KILLED:\r\n                    mutantsKilled++;\r\n                    log.debug(chalk.bold.green('Mutant killed!'));\r\n                    _this.logMutantResult(result, logDebugFn);\r\n                    break;\r\n                case report_1.MutantStatus.TIMEDOUT:\r\n                    mutantsTimedOut++;\r\n                    log.debug(chalk.bold.yellow('Mutant timed out!'));\r\n                    _this.logMutantResult(result, logDebugFn);\r\n                    break;\r\n                case report_1.MutantStatus.SURVIVED:\r\n                    _this.writeLine(chalk.bold.red('Mutant survived!'));\r\n                    _this.logMutantResult(result, writeLineFn);\r\n                    break;\r\n                case report_1.MutantStatus.UNTESTED:\r\n                    mutantsUntested++;\r\n                    log.debug(chalk.bold.yellow('Mutant untested!'));\r\n                    _this.logMutantResult(result, logDebugFn);\r\n                    break;\r\n            }\r\n        });\r\n        var mutationScoreCodebase = (((mutantsKilled + mutantsTimedOut) / mutantResults.length) * 100).toFixed(2);\r\n        var mutationScoreCodeCoverage = (((mutantsKilled + mutantsTimedOut) / ((mutantResults.length - mutantsUntested) || 1)) * 100).toFixed(2);\r\n        var codebaseColor = this.getColorForMutationScore(+mutationScoreCodebase);\r\n        var codecoverageColor = this.getColorForMutationScore(+mutationScoreCodeCoverage);\r\n        this.writeLine((mutantResults.length - mutantsUntested) + ' mutants tested.');\r\n        this.writeLine(mutantsUntested + ' mutants untested.');\r\n        this.writeLine(mutantsTimedOut + ' mutants timed out.');\r\n        this.writeLine(mutantsKilled + ' mutants killed.');\r\n        this.writeLine('Mutation score based on covered code: ' + codecoverageColor(mutationScoreCodeCoverage + '%'));\r\n        this.writeLine('Mutation score based on all code: ' + codebaseColor(mutationScoreCodebase + '%'));\r\n    };","mutatedLines":"    ClearTextReporter.prototype.onAllMutantsTested = function (mutantResults) {\n};"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"ReverseConditional","status":1,"replacement":"output && ''","location":{"start":{"line":12,"column":24},"end":{"line":12,"column":36}},"range":[412,424],"originalLines":"        this.out.write((output || '') + \"\\n\");","mutatedLines":"        this.out.write((output && '') + \"\\n\");"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"Math","status":1,"replacement":"(output || '') - '\\n'","location":{"start":{"line":12,"column":23},"end":{"line":12,"column":44}},"range":[411,432],"originalLines":"        this.out.write((output || '') + \"\\n\");","mutatedLines":"        this.out.write((output || '') - '\\n');"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":11,"column":62},"end":{"line":13,"column":5}},"range":[385,441],"originalLines":"    ClearTextReporter.prototype.writeLine = function (output) {\r\n        this.out.write((output || '') + \"\\n\");\r\n    };","mutatedLines":"    ClearTextReporter.prototype.writeLine = function (output) {\n};"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":8,"column":33},"end":{"line":10,"column":5}},"range":[277,321],"originalLines":"    function ClearTextReporter() {\r\n        this.out = process.stdout;\r\n    }","mutatedLines":"    function ClearTextReporter() {\n}"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":7,"column":37},"end":{"line":88,"column":1}},"range":[241,4143],"originalLines":"var ClearTextReporter = (function () {\r\n    function ClearTextReporter() {\r\n        this.out = process.stdout;\r\n    }\r\n    ClearTextReporter.prototype.writeLine = function (output) {\r\n        this.out.write((output || '') + \"\\n\");\r\n    };\r\n    ClearTextReporter.prototype.onAllMutantsTested = function (mutantResults) {\r\n        var _this = this;\r\n        this.writeLine();\r\n        var mutantsKilled = 0;\r\n        var mutantsTimedOut = 0;\r\n        var mutantsUntested = 0;\r\n        var logDebugFn = function (input) { return log.debug(input); };\r\n        var writeLineFn = function (input) { return _this.writeLine(input); };\r\n        mutantResults.forEach(function (result) {\r\n            switch (result.status) {\r\n                case report_1.MutantStatus.KILLED:\r\n                    mutantsKilled++;\r\n                    log.debug(chalk.bold.green('Mutant killed!'));\r\n                    _this.logMutantResult(result, logDebugFn);\r\n                    break;\r\n                case report_1.MutantStatus.TIMEDOUT:\r\n                    mutantsTimedOut++;\r\n                    log.debug(chalk.bold.yellow('Mutant timed out!'));\r\n                    _this.logMutantResult(result, logDebugFn);\r\n                    break;\r\n                case report_1.MutantStatus.SURVIVED:\r\n                    _this.writeLine(chalk.bold.red('Mutant survived!'));\r\n                    _this.logMutantResult(result, writeLineFn);\r\n                    break;\r\n                case report_1.MutantStatus.UNTESTED:\r\n                    mutantsUntested++;\r\n                    log.debug(chalk.bold.yellow('Mutant untested!'));\r\n                    _this.logMutantResult(result, logDebugFn);\r\n                    break;\r\n            }\r\n        });\r\n        var mutationScoreCodebase = (((mutantsKilled + mutantsTimedOut) / mutantResults.length) * 100).toFixed(2);\r\n        var mutationScoreCodeCoverage = (((mutantsKilled + mutantsTimedOut) / ((mutantResults.length - mutantsUntested) || 1)) * 100).toFixed(2);\r\n        var codebaseColor = this.getColorForMutationScore(+mutationScoreCodebase);\r\n        var codecoverageColor = this.getColorForMutationScore(+mutationScoreCodeCoverage);\r\n        this.writeLine((mutantResults.length - mutantsUntested) + ' mutants tested.');\r\n        this.writeLine(mutantsUntested + ' mutants untested.');\r\n        this.writeLine(mutantsTimedOut + ' mutants timed out.');\r\n        this.writeLine(mutantsKilled + ' mutants killed.');\r\n        this.writeLine('Mutation score based on covered code: ' + codecoverageColor(mutationScoreCodeCoverage + '%'));\r\n        this.writeLine('Mutation score based on all code: ' + codebaseColor(mutationScoreCodebase + '%'));\r\n    };\r\n    ClearTextReporter.prototype.logMutantResult = function (result, logImplementation) {\r\n        logImplementation(result.sourceFilePath + ': line ' + result.location.start.line + ':' + result.location.start.column);\r\n        logImplementation('Mutator: ' + result.mutatorName);\r\n        result.originalLines.split('\\n').forEach(function (line) {\r\n            logImplementation(chalk.red('-   ' + line));\r\n        });\r\n        result.mutatedLines.split('\\n').forEach(function (line) {\r\n            logImplementation(chalk.green('+   ' + line));\r\n        });\r\n        logImplementation('');\r\n        if (result.testsRan && result.testsRan.length > 0) {\r\n            logImplementation('Tests ran: ');\r\n            _.forEach(result.testsRan, function (spec) {\r\n                logImplementation('    ' + spec);\r\n            });\r\n            logImplementation('');\r\n        }\r\n    };\r\n    ClearTextReporter.prototype.getColorForMutationScore = function (score) {\r\n        var color;\r\n        if (score > 80) {\r\n            color = chalk.green;\r\n        }\r\n        else if (score > 50) {\r\n            color = chalk.yellow;\r\n        }\r\n        else {\r\n            color = chalk.red;\r\n        }\r\n        return color;\r\n    };\r\n    return ClearTextReporter;\r\n}());","mutatedLines":"var ClearTextReporter = (function () {\n}());"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"Math","status":1,"replacement":"'An error occurred during \\'' - methodName","location":{"start":{"line":40,"column":18},"end":{"line":40,"column":59}},"range":[1764,1805],"originalLines":"        log.error(\"An error occurred during '\" + methodName + \"' on reporter '\" + reporterName + \"'. Error is: \" + error);","mutatedLines":"        log.error('An error occurred during \\'' - methodName + \"' on reporter '\" + reporterName + \"'. Error is: \" + error);"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"Math","status":1,"replacement":"'An error occurred during \\'' + methodName - '\\' on reporter \\''","location":{"start":{"line":40,"column":18},"end":{"line":40,"column":79}},"range":[1764,1825],"originalLines":"        log.error(\"An error occurred during '\" + methodName + \"' on reporter '\" + reporterName + \"'. Error is: \" + error);","mutatedLines":"        log.error('An error occurred during \\'' + methodName - '\\' on reporter \\'' + reporterName + \"'. Error is: \" + error);"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"Math","status":1,"replacement":"'An error occurred during \\'' + methodName + '\\' on reporter \\'' - reporterName","location":{"start":{"line":40,"column":18},"end":{"line":40,"column":94}},"range":[1764,1840],"originalLines":"        log.error(\"An error occurred during '\" + methodName + \"' on reporter '\" + reporterName + \"'. Error is: \" + error);","mutatedLines":"        log.error('An error occurred during \\'' + methodName + '\\' on reporter \\'' - reporterName + \"'. Error is: \" + error);"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"Math","status":1,"replacement":"'An error occurred during \\'' + methodName + '\\' on reporter \\'' + reporterName - '\\'. Error is: '","location":{"start":{"line":40,"column":18},"end":{"line":40,"column":112}},"range":[1764,1858],"originalLines":"        log.error(\"An error occurred during '\" + methodName + \"' on reporter '\" + reporterName + \"'. Error is: \" + error);","mutatedLines":"        log.error('An error occurred during \\'' + methodName + '\\' on reporter \\'' + reporterName - '\\'. Error is: ' + error);"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"Math","status":1,"replacement":"'An error occurred during \\'' + methodName + '\\' on reporter \\'' + reporterName + '\\'. Error is: ' - error","location":{"start":{"line":40,"column":18},"end":{"line":40,"column":120}},"range":[1764,1866],"originalLines":"        log.error(\"An error occurred during '\" + methodName + \"' on reporter '\" + reporterName + \"'. Error is: \" + error);","mutatedLines":"        log.error('An error occurred during \\'' + methodName + '\\' on reporter \\'' + reporterName + '\\'. Error is: ' - error);"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":39,"column":89},"end":{"line":41,"column":5}},"range":[1743,1875],"originalLines":"    BroadcastReporter.prototype.handleError = function (error, methodName, reporterName) {\r\n        log.error(\"An error occurred during '\" + methodName + \"' on reporter '\" + reporterName + \"'. Error is: \" + error);\r\n    };","mutatedLines":"    BroadcastReporter.prototype.handleError = function (error, methodName, reporterName) {\n};"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":35,"column":32},"end":{"line":37,"column":9}},"range":[1586,1644],"originalLines":"        if (allPromises.length) {\r\n            return Promise.all(allPromises);\r\n        }","mutatedLines":"        if (allPromises.length) {\n}"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":35,"column":12},"end":{"line":35,"column":30}},"range":[1566,1584],"originalLines":"        if (allPromises.length) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":35,"column":12},"end":{"line":35,"column":30}},"range":[1566,1584],"originalLines":"        if (allPromises.length) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":30,"column":30},"end":{"line":32,"column":17}},"range":[1425,1524],"originalLines":"                catch (error) {\r\n                    _this.handleError(error, methodName, namedReporter.name);\r\n                }","mutatedLines":"                catch (error) {\n}"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":25,"column":77},"end":{"line":27,"column":25}},"range":[1233,1348],"originalLines":"                        allPromises.push(maybePromise.catch(function (error) {\r\n                            _this.handleError(error, methodName, namedReporter.name);\r\n                        }));","mutatedLines":"                        allPromises.push(maybePromise.catch(function (error) {\n}));"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":24,"column":63},"end":{"line":28,"column":21}},"range":[1153,1374],"originalLines":"                    if (objectUtils_1.isPromise(maybePromise)) {\r\n                        allPromises.push(maybePromise.catch(function (error) {\r\n                            _this.handleError(error, methodName, namedReporter.name);\r\n                        }));\r\n                    }","mutatedLines":"                    if (objectUtils_1.isPromise(maybePromise)) {\n}"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":24,"column":24},"end":{"line":24,"column":61}},"range":[1114,1151],"originalLines":"                    if (objectUtils_1.isPromise(maybePromise)) {","mutatedLines":"                    if (true) {"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":24,"column":24},"end":{"line":24,"column":61}},"range":[1114,1151],"originalLines":"                    if (objectUtils_1.isPromise(maybePromise)) {","mutatedLines":"                    if (false) {"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":22,"column":20},"end":{"line":29,"column":17}},"range":[1014,1393],"originalLines":"                try {\r\n                    var maybePromise = reporter[methodName](eventArgs);\r\n                    if (objectUtils_1.isPromise(maybePromise)) {\r\n                        allPromises.push(maybePromise.catch(function (error) {\r\n                            _this.handleError(error, methodName, namedReporter.name);\r\n                        }));\r\n                    }\r\n                }","mutatedLines":"                try {\n}"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":21,"column":84},"end":{"line":33,"column":13}},"range":[991,1539],"originalLines":"            if (reporter[methodName] && typeof reporter[methodName] === 'function') {\r\n                try {\r\n                    var maybePromise = reporter[methodName](eventArgs);\r\n                    if (objectUtils_1.isPromise(maybePromise)) {\r\n                        allPromises.push(maybePromise.catch(function (error) {\r\n                            _this.handleError(error, methodName, namedReporter.name);\r\n                        }));\r\n                    }\r\n                }\r\n                catch (error) {\r\n                    _this.handleError(error, methodName, namedReporter.name);\r\n                }\r\n            }","mutatedLines":"            if (reporter[methodName] && typeof reporter[methodName] === 'function') {\n}"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"ReverseConditional","status":1,"replacement":"typeof reporter[methodName] !== 'function'","location":{"start":{"line":21,"column":40},"end":{"line":21,"column":82}},"range":[947,989],"originalLines":"            if (reporter[methodName] && typeof reporter[methodName] === 'function') {","mutatedLines":"            if (reporter[methodName] && typeof reporter[methodName] !== 'function') {"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"ReverseConditional","status":1,"replacement":"reporter[methodName] || typeof reporter[methodName] === 'function'","location":{"start":{"line":21,"column":16},"end":{"line":21,"column":82}},"range":[923,989],"originalLines":"            if (reporter[methodName] && typeof reporter[methodName] === 'function') {","mutatedLines":"            if (reporter[methodName] || typeof reporter[methodName] === 'function') {"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":21,"column":16},"end":{"line":21,"column":82}},"range":[923,989],"originalLines":"            if (reporter[methodName] && typeof reporter[methodName] === 'function') {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":21,"column":16},"end":{"line":21,"column":82}},"range":[923,989],"originalLines":"            if (reporter[methodName] && typeof reporter[methodName] === 'function') {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":19,"column":56},"end":{"line":34,"column":9}},"range":[852,1550],"originalLines":"        this.reporters.forEach(function (namedReporter) {\r\n            var reporter = namedReporter.reporter;\r\n            if (reporter[methodName] && typeof reporter[methodName] === 'function') {\r\n                try {\r\n                    var maybePromise = reporter[methodName](eventArgs);\r\n                    if (objectUtils_1.isPromise(maybePromise)) {\r\n                        allPromises.push(maybePromise.catch(function (error) {\r\n                            _this.handleError(error, methodName, namedReporter.name);\r\n                        }));\r\n                    }\r\n                }\r\n                catch (error) {\r\n                    _this.handleError(error, methodName, namedReporter.name);\r\n                }\r\n            }\r\n        });","mutatedLines":"        this.reporters.forEach(function (namedReporter) {\n});"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":16,"column":77},"end":{"line":38,"column":5}},"range":[735,1651],"originalLines":"    BroadcastReporter.prototype.broadcast = function (methodName, eventArgs) {\r\n        var _this = this;\r\n        var allPromises = [];\r\n        this.reporters.forEach(function (namedReporter) {\r\n            var reporter = namedReporter.reporter;\r\n            if (reporter[methodName] && typeof reporter[methodName] === 'function') {\r\n                try {\r\n                    var maybePromise = reporter[methodName](eventArgs);\r\n                    if (objectUtils_1.isPromise(maybePromise)) {\r\n                        allPromises.push(maybePromise.catch(function (error) {\r\n                            _this.handleError(error, methodName, namedReporter.name);\r\n                        }));\r\n                    }\r\n                }\r\n                catch (error) {\r\n                    _this.handleError(error, methodName, namedReporter.name);\r\n                }\r\n            }\r\n        });\r\n        if (allPromises.length) {\r\n            return Promise.all(allPromises);\r\n        }\r\n    };","mutatedLines":"    BroadcastReporter.prototype.broadcast = function (methodName, eventArgs) {\n};"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":11,"column":43},"end":{"line":13,"column":13}},"range":[565,635],"originalLines":"            _this[method] = function (arg) {\r\n                return _this.broadcast(method, arg);\r\n            };","mutatedLines":"            _this[method] = function (arg) {\n};"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":10,"column":82},"end":{"line":14,"column":9}},"range":[519,647],"originalLines":"        exports.ALL_EVENT_METHOD_NAMES.concat('wrapUp').forEach(function (method) {\r\n            _this[method] = function (arg) {\r\n                return _this.broadcast(method, arg);\r\n            };\r\n        });","mutatedLines":"        exports.ALL_EVENT_METHOD_NAMES.concat('wrapUp').forEach(function (method) {\n});"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":7,"column":42},"end":{"line":15,"column":5}},"range":[370,656],"originalLines":"    function BroadcastReporter(reporters) {\r\n        var _this = this;\r\n        this.reporters = reporters;\r\n        exports.ALL_EVENT_METHOD_NAMES.concat('wrapUp').forEach(function (method) {\r\n            _this[method] = function (arg) {\r\n                return _this.broadcast(method, arg);\r\n            };\r\n        });\r\n    }","mutatedLines":"    function BroadcastReporter(reporters) {\n}"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":6,"column":37},"end":{"line":43,"column":1}},"range":[325,1910],"originalLines":"var BroadcastReporter = (function () {\r\n    function BroadcastReporter(reporters) {\r\n        var _this = this;\r\n        this.reporters = reporters;\r\n        exports.ALL_EVENT_METHOD_NAMES.concat('wrapUp').forEach(function (method) {\r\n            _this[method] = function (arg) {\r\n                return _this.broadcast(method, arg);\r\n            };\r\n        });\r\n    }\r\n    BroadcastReporter.prototype.broadcast = function (methodName, eventArgs) {\r\n        var _this = this;\r\n        var allPromises = [];\r\n        this.reporters.forEach(function (namedReporter) {\r\n            var reporter = namedReporter.reporter;\r\n            if (reporter[methodName] && typeof reporter[methodName] === 'function') {\r\n                try {\r\n                    var maybePromise = reporter[methodName](eventArgs);\r\n                    if (objectUtils_1.isPromise(maybePromise)) {\r\n                        allPromises.push(maybePromise.catch(function (error) {\r\n                            _this.handleError(error, methodName, namedReporter.name);\r\n                        }));\r\n                    }\r\n                }\r\n                catch (error) {\r\n                    _this.handleError(error, methodName, namedReporter.name);\r\n                }\r\n            }\r\n        });\r\n        if (allPromises.length) {\r\n            return Promise.all(allPromises);\r\n        }\r\n    };\r\n    BroadcastReporter.prototype.handleError = function (error, methodName, reporterName) {\r\n        log.error(\"An error occurred during '\" + methodName + \"' on reporter '\" + reporterName + \"'. Error is: \" + error);\r\n    };\r\n    return BroadcastReporter;\r\n}());","mutatedLines":"var BroadcastReporter = (function () {\n}());"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":42,"column":74},"end":{"line":46,"column":5}},"range":[2051,2358],"originalLines":"    ReporterOrchestrator.prototype.registerDefaultReporters = function () {\r\n        report_1.ReporterFactory.instance().register('progress', ProgressReporter_1.default);\r\n        report_1.ReporterFactory.instance().register('clear-text', ClearTextReporter_1.default);\r\n        report_1.ReporterFactory.instance().register('event-recorder', EventRecorderReporter_1.default);\r\n    };","mutatedLines":"    ReporterOrchestrator.prototype.registerDefaultReporters = function () {\n};"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'Possible reporters: ' - possibleReportersCsv","location":{"start":{"line":40,"column":17},"end":{"line":40,"column":62}},"range":[1920,1965],"originalLines":"        log.warn(\"Possible reporters: \" + possibleReportersCsv);","mutatedLines":"        log.warn('Possible reporters: ' - possibleReportersCsv);"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":35,"column":45},"end":{"line":37,"column":13}},"range":[1782,1845],"originalLines":"            if (possibleReportersCsv.length) {\r\n                possibleReportersCsv += ', ';\r\n            }","mutatedLines":"            if (possibleReportersCsv.length) {\n}"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":35,"column":16},"end":{"line":35,"column":43}},"range":[1753,1780],"originalLines":"            if (possibleReportersCsv.length) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":35,"column":16},"end":{"line":35,"column":43}},"range":[1753,1780],"originalLines":"            if (possibleReportersCsv.length) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":34,"column":81},"end":{"line":39,"column":9}},"range":[1734,1899],"originalLines":"        report_1.ReporterFactory.instance().knownNames().forEach(function (name) {\r\n            if (possibleReportersCsv.length) {\r\n                possibleReportersCsv += ', ';\r\n            }\r\n            possibleReportersCsv += name;\r\n        });","mutatedLines":"        report_1.ReporterFactory.instance().knownNames().forEach(function (name) {\n});"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":32,"column":70},"end":{"line":41,"column":5}},"range":[1610,1974],"originalLines":"    ReporterOrchestrator.prototype.logPossibleReporters = function () {\r\n        var possibleReportersCsv = '';\r\n        report_1.ReporterFactory.instance().knownNames().forEach(function (name) {\r\n            if (possibleReportersCsv.length) {\r\n                possibleReportersCsv += ', ';\r\n            }\r\n            possibleReportersCsv += name;\r\n        });\r\n        log.warn(\"Possible reporters: \" + possibleReportersCsv);\r\n    };","mutatedLines":"    ReporterOrchestrator.prototype.logPossibleReporters = function () {\n};"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":26,"column":13},"end":{"line":29,"column":9}},"range":[1284,1470],"originalLines":"        else {\r\n            log.warn(\"No reporter configured. Please configure one or more reporters in the (for example: reporter: 'progress')\");\r\n            this.logPossibleReporters();\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":22,"column":17},"end":{"line":24,"column":13}},"range":[1099,1258],"originalLines":"            else {\r\n                reporters.push({ name: reporterOption, reporter: report_1.ReporterFactory.instance().create(reporterOption, this.options) });\r\n            }","mutatedLines":"            else {\n}"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":20,"column":63},"end":{"line":20,"column":196}},"range":[930,1063],"originalLines":"                reporterOption.forEach(function (reporterName) { return reporters.push({ name: reporterName, reporter: report_1.ReporterFactory.instance().create(reporterName, _this.options) }); });","mutatedLines":"                reporterOption.forEach(function (reporterName) {\n});"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":19,"column":47},"end":{"line":21,"column":13}},"range":[864,1080],"originalLines":"            if (Array.isArray(reporterOption)) {\r\n                reporterOption.forEach(function (reporterName) { return reporters.push({ name: reporterName, reporter: report_1.ReporterFactory.instance().create(reporterName, _this.options) }); });\r\n            }","mutatedLines":"            if (Array.isArray(reporterOption)) {\n}"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":19,"column":16},"end":{"line":19,"column":45}},"range":[833,862],"originalLines":"            if (Array.isArray(reporterOption)) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":19,"column":16},"end":{"line":19,"column":45}},"range":[833,862],"originalLines":"            if (Array.isArray(reporterOption)) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":18,"column":28},"end":{"line":25,"column":9}},"range":[814,1269],"originalLines":"        if (reporterOption) {\r\n            if (Array.isArray(reporterOption)) {\r\n                reporterOption.forEach(function (reporterName) { return reporters.push({ name: reporterName, reporter: report_1.ReporterFactory.instance().create(reporterName, _this.options) }); });\r\n            }\r\n            else {\r\n                reporters.push({ name: reporterOption, reporter: report_1.ReporterFactory.instance().create(reporterOption, this.options) });\r\n            }\r\n        }","mutatedLines":"        if (reporterOption) {\n}"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":18,"column":12},"end":{"line":18,"column":26}},"range":[798,812],"originalLines":"        if (reporterOption) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":62,"column":64},"end":{"line":64,"column":9}},"range":[3374,3446],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"        result.mutatedLines.split('\\n').forEach(function (line) {\r\n            logImplementation(chalk.green('+   ' + line));\r\n        });","mutatedLines":"        result.mutatedLines.split('\\n').forEach(function (line) {\n});"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":18,"column":12},"end":{"line":18,"column":26}},"range":[798,812],"originalLines":"        if (reporterOption) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"Math","status":2,"replacement":"'    ' - spec","location":{"start":{"line":69,"column":34},"end":{"line":69,"column":47}},"range":[3683,3696],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"                logImplementation('    ' + spec);","mutatedLines":"                logImplementation('    ' - spec);"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":10,"column":43},"end":{"line":13,"column":5}},"range":[516,599],"originalLines":"    function ReporterOrchestrator(options) {\r\n        this.options = options;\r\n        this.registerDefaultReporters();\r\n    }","mutatedLines":"    function ReporterOrchestrator(options) {\n}"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":58,"column":17},"end":{"line":60,"column":13}},"range":[2692,2795],"originalLines":"            else {\r\n                log.warn('Error during loading \"%s\" plugin:\\n  %s', name, e.message);\r\n            }","mutatedLines":"            else {\n}"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"Math","status":1,"replacement":"'Cannot find plugin \"%s\".\\n  Did you forget to install it ?\\n' - '  npm install %s --save-dev'","location":{"start":{"line":55,"column":25},"end":{"line":56,"column":49}},"range":[2529,2644],"originalLines":"                log.warn('Cannot find plugin \"%s\".\\n  Did you forget to install it ?\\n' +\r\n                    '  npm install %s --save-dev', name, name);","mutatedLines":"                log.warn('Cannot find plugin \"%s\".\\n  Did you forget to install it ?\\n' - '  npm install %s --save-dev', name, name);"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":54,"column":81},"end":{"line":57,"column":13}},"range":[2501,2673],"originalLines":"            if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(name) !== -1) {\r\n                log.warn('Cannot find plugin \"%s\".\\n  Did you forget to install it ?\\n' +\r\n                    '  npm install %s --save-dev', name, name);\r\n            }","mutatedLines":"            if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(name) !== -1) {\n}"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":66,"column":59},"end":{"line":72,"column":9}},"range":[3541,3762],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"        if (result.testsRan && result.testsRan.length > 0) {\r\n            logImplementation('Tests ran: ');\r\n            _.forEach(result.testsRan, function (spec) {\r\n                logImplementation('    ' + spec);\r\n            });\r\n            logImplementation('');\r\n        }","mutatedLines":"        if (result.testsRan && result.testsRan.length > 0) {\n}"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"ReverseConditional","status":2,"replacement":"result.testsRan.length <= 0","location":{"start":{"line":66,"column":31},"end":{"line":66,"column":57}},"range":[3513,3539],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"        if (result.testsRan && result.testsRan.length > 0) {","mutatedLines":"        if (result.testsRan && result.testsRan.length <= 0) {"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"UnaryOperator","status":1,"replacement":"+1","location":{"start":{"line":54,"column":77},"end":{"line":54,"column":79}},"range":[2497,2499],"originalLines":"            if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(name) !== -1) {","mutatedLines":"            if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(name) !== +1) {"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"ReverseConditional","status":1,"replacement":"e.code === 'MODULE_NOT_FOUND' || e.message.indexOf(name) !== -1","location":{"start":{"line":54,"column":16},"end":{"line":54,"column":79}},"range":[2436,2499],"originalLines":"            if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(name) !== -1) {","mutatedLines":"            if (e.code === 'MODULE_NOT_FOUND' || e.message.indexOf(name) !== -1) {"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":54,"column":16},"end":{"line":54,"column":79}},"range":[2436,2499],"originalLines":"            if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(name) !== -1) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":54,"column":16},"end":{"line":54,"column":79}},"range":[2436,2499],"originalLines":"            if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(name) !== -1) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":53,"column":18},"end":{"line":61,"column":9}},"range":[2417,2806],"originalLines":"        catch (e) {\r\n            if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(name) !== -1) {\r\n                log.warn('Cannot find plugin \"%s\".\\n  Did you forget to install it ?\\n' +\r\n                    '  npm install %s --save-dev', name, name);\r\n            }\r\n            else {\r\n                log.warn('Error during loading \"%s\" plugin:\\n  %s', name, e.message);\r\n            }\r\n        }","mutatedLines":"        catch (e) {\n}"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":50,"column":12},"end":{"line":52,"column":9}},"range":[2340,2397],"originalLines":"        try {\r\n            fileUtils_1.importModule(name);\r\n        }","mutatedLines":"        try {\n}"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"Math","status":1,"replacement":"'Loading plugins ' - name","location":{"start":{"line":49,"column":18},"end":{"line":49,"column":43}},"range":[2299,2324],"originalLines":"        log.debug(\"Loading plugins \" + name);","mutatedLines":"        log.debug('Loading plugins ' - name);"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":48,"column":59},"end":{"line":62,"column":5}},"range":[2278,2813],"originalLines":"    PluginLoader.prototype.requirePlugin = function (name) {\r\n        log.debug(\"Loading plugins \" + name);\r\n        try {\r\n            fileUtils_1.importModule(name);\r\n        }\r\n        catch (e) {\r\n            if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(name) !== -1) {\r\n                log.warn('Cannot find plugin \"%s\".\\n  Did you forget to install it ?\\n' +\r\n                    '  npm install %s --save-dev', name, name);\r\n            }\r\n            else {\r\n                log.warn('Error during loading \"%s\" plugin:\\n  %s', name, e.message);\r\n            }\r\n        }\r\n    };","mutatedLines":"    PluginLoader.prototype.requirePlugin = function (name) {\n};"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":42,"column":17},"end":{"line":44,"column":13}},"range":[2062,2171],"originalLines":"            else {\r\n                log.warn('Ignoring plugin %s, as its not a string type', pluginExpression);\r\n            }","mutatedLines":"            else {\n}"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"Math","status":2,"replacement":"mutantsTimedOut - ' mutants timed out.'","location":{"start":{"line":51,"column":23},"end":{"line":51,"column":62}},"range":[2550,2589],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"        this.writeLine(mutantsTimedOut + ' mutants timed out.');","mutatedLines":"        this.writeLine(mutantsTimedOut - ' mutants timed out.');"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":38,"column":21},"end":{"line":40,"column":17}},"range":[1955,2028],"originalLines":"                else {\r\n                    modules.push(pluginExpression);\r\n                }","mutatedLines":"                else {\n}"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":32,"column":47},"end":{"line":35,"column":21}},"range":[1658,1835],"originalLines":"                        .map(function (plugin) {\r\n                        log.debug('Loading plugins %s (matched with expression %s)', plugin, pluginExpression);\r\n                        return plugin;\r\n                    })","mutatedLines":"                        .map(function (plugin) {\n})"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":31,"column":47},"end":{"line":31,"column":80}},"range":[1575,1608],"originalLines":"                        .map(function (plugin) { return path.basename(plugin); })","mutatedLines":"                        .map(function (plugin) {\n})"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":27,"column":46},"end":{"line":29,"column":21}},"range":[1370,1497],"originalLines":"                    if (plugins.length === 0) {\r\n                        log.debug('Expression %s not resulted in plugins to load', pluginExpression);\r\n                    }","mutatedLines":"                    if (plugins.length === 0) {\n}"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"ReverseConditional","status":1,"replacement":"plugins.length !== 0","location":{"start":{"line":27,"column":24},"end":{"line":27,"column":44}},"range":[1348,1368],"originalLines":"                    if (plugins.length === 0) {","mutatedLines":"                    if (plugins.length !== 0) {"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":27,"column":24},"end":{"line":27,"column":44}},"range":[1348,1368],"originalLines":"                    if (plugins.length === 0) {","mutatedLines":"                    if (true) {"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":27,"column":24},"end":{"line":27,"column":44}},"range":[1348,1368],"originalLines":"                    if (plugins.length === 0) {","mutatedLines":"                    if (false) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"Math","status":1,"replacement":"mutantsKilled - mutantsTimedOut","location":{"start":{"line":46,"column":43},"end":{"line":46,"column":74}},"range":[2094,2125],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"        var mutationScoreCodeCoverage = (((mutantsKilled + mutantsTimedOut) / ((mutantResults.length - mutantsUntested) || 1)) * 100).toFixed(2);","mutatedLines":"        var mutationScoreCodeCoverage = (((mutantsKilled - mutantsTimedOut) / ((mutantResults.length - mutantsUntested) || 1)) * 100).toFixed(2);"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"Math","status":1,"replacement":"pluginDirectory - '/'","location":{"start":{"line":26,"column":60},"end":{"line":26,"column":81}},"range":[1283,1304],"originalLines":"                        .map(function (pluginName) { return pluginDirectory + '/' + pluginName; });","mutatedLines":"                        .map(function (pluginName) { return pluginDirectory - '/' + pluginName; });"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":26,"column":51},"end":{"line":26,"column":97}},"range":[1274,1320],"originalLines":"                        .map(function (pluginName) { return pluginDirectory + '/' + pluginName; });","mutatedLines":"                        .map(function (pluginName) {\n});"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"UnaryOperator","status":1,"replacement":"+1","location":{"start":{"line":25,"column":104},"end":{"line":25,"column":106}},"range":[1188,1190],"originalLines":"                        .filter(function (pluginName) { return IGNORED_PACKAGES.indexOf(pluginName) === -1 && regexp.test(pluginName); })","mutatedLines":"                        .filter(function (pluginName) { return IGNORED_PACKAGES.indexOf(pluginName) === +1 && regexp.test(pluginName); })"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"ReverseConditional","status":1,"replacement":"IGNORED_PACKAGES.indexOf(pluginName) !== -1","location":{"start":{"line":25,"column":63},"end":{"line":25,"column":106}},"range":[1147,1190],"originalLines":"                        .filter(function (pluginName) { return IGNORED_PACKAGES.indexOf(pluginName) === -1 && regexp.test(pluginName); })","mutatedLines":"                        .filter(function (pluginName) { return IGNORED_PACKAGES.indexOf(pluginName) !== -1 && regexp.test(pluginName); })"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"ReverseConditional","status":1,"replacement":"IGNORED_PACKAGES.indexOf(pluginName) === -1 || regexp.test(pluginName)","location":{"start":{"line":25,"column":63},"end":{"line":25,"column":133}},"range":[1147,1217],"originalLines":"                        .filter(function (pluginName) { return IGNORED_PACKAGES.indexOf(pluginName) === -1 && regexp.test(pluginName); })","mutatedLines":"                        .filter(function (pluginName) { return IGNORED_PACKAGES.indexOf(pluginName) === -1 || regexp.test(pluginName); })"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":25,"column":54},"end":{"line":25,"column":136}},"range":[1138,1220],"originalLines":"                        .filter(function (pluginName) { return IGNORED_PACKAGES.indexOf(pluginName) === -1 && regexp.test(pluginName); })","mutatedLines":"                        .filter(function (pluginName) {\n})"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"Math","status":1,"replacement":"'^' - pluginExpression.replace('*', '.*')","location":{"start":{"line":22,"column":44},"end":{"line":22,"column":85}},"range":[883,924],"originalLines":"                    var regexp = new RegExp('^' + pluginExpression.replace('*', '.*'));","mutatedLines":"                    var regexp = new RegExp('^' - pluginExpression.replace('*', '.*'));"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"Math","status":1,"replacement":"__dirname - '/../..'","location":{"start":{"line":21,"column":57},"end":{"line":21,"column":77}},"range":[815,835],"originalLines":"                    var pluginDirectory = path.normalize(__dirname + '/../..');","mutatedLines":"                    var pluginDirectory = path.normalize(__dirname - '/../..');"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":20,"column":58},"end":{"line":37,"column":17}},"range":[755,1932],"originalLines":"                if (pluginExpression.indexOf('*') !== -1) {\r\n                    var pluginDirectory = path.normalize(__dirname + '/../..');\r\n                    var regexp = new RegExp('^' + pluginExpression.replace('*', '.*'));\r\n                    log.debug('Loading %s from %s', pluginExpression, pluginDirectory);\r\n                    var plugins = fs.readdirSync(pluginDirectory)\r\n                        .filter(function (pluginName) { return IGNORED_PACKAGES.indexOf(pluginName) === -1 && regexp.test(pluginName); })\r\n                        .map(function (pluginName) { return pluginDirectory + '/' + pluginName; });\r\n                    if (plugins.length === 0) {\r\n                        log.debug('Expression %s not resulted in plugins to load', pluginExpression);\r\n                    }\r\n                    plugins\r\n                        .map(function (plugin) { return path.basename(plugin); })\r\n                        .map(function (plugin) {\r\n                        log.debug('Loading plugins %s (matched with expression %s)', plugin, pluginExpression);\r\n                        return plugin;\r\n                    })\r\n                        .forEach(function (p) { return modules.push(p); });\r\n                }","mutatedLines":"                if (pluginExpression.indexOf('*') !== -1) {\n}"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"UnaryOperator","status":1,"replacement":"+1","location":{"start":{"line":20,"column":54},"end":{"line":20,"column":56}},"range":[751,753],"originalLines":"                if (pluginExpression.indexOf('*') !== -1) {","mutatedLines":"                if (pluginExpression.indexOf('*') !== +1) {"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"ReverseConditional","status":1,"replacement":"pluginExpression.indexOf('*') === -1","location":{"start":{"line":20,"column":20},"end":{"line":20,"column":56}},"range":[717,753],"originalLines":"                if (pluginExpression.indexOf('*') !== -1) {","mutatedLines":"                if (pluginExpression.indexOf('*') === -1) {"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":20,"column":20},"end":{"line":20,"column":56}},"range":[717,753],"originalLines":"                if (pluginExpression.indexOf('*') !== -1) {","mutatedLines":"                if (true) {"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":20,"column":20},"end":{"line":20,"column":56}},"range":[717,753],"originalLines":"                if (pluginExpression.indexOf('*') !== -1) {","mutatedLines":"                if (false) {"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":19,"column":46},"end":{"line":41,"column":13}},"range":[694,2043],"originalLines":"            if (_.isString(pluginExpression)) {\r\n                if (pluginExpression.indexOf('*') !== -1) {\r\n                    var pluginDirectory = path.normalize(__dirname + '/../..');\r\n                    var regexp = new RegExp('^' + pluginExpression.replace('*', '.*'));\r\n                    log.debug('Loading %s from %s', pluginExpression, pluginDirectory);\r\n                    var plugins = fs.readdirSync(pluginDirectory)\r\n                        .filter(function (pluginName) { return IGNORED_PACKAGES.indexOf(pluginName) === -1 && regexp.test(pluginName); })\r\n                        .map(function (pluginName) { return pluginDirectory + '/' + pluginName; });\r\n                    if (plugins.length === 0) {\r\n                        log.debug('Expression %s not resulted in plugins to load', pluginExpression);\r\n                    }\r\n                    plugins\r\n                        .map(function (plugin) { return path.basename(plugin); })\r\n                        .map(function (plugin) {\r\n                        log.debug('Loading plugins %s (matched with expression %s)', plugin, pluginExpression);\r\n                        return plugin;\r\n                    })\r\n                        .forEach(function (p) { return modules.push(p); });\r\n                }\r\n                else {\r\n                    modules.push(pluginExpression);\r\n                }\r\n            }","mutatedLines":"            if (_.isString(pluginExpression)) {\n}"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":19,"column":16},"end":{"line":19,"column":44}},"range":[664,692],"originalLines":"            if (_.isString(pluginExpression)) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":19,"column":16},"end":{"line":19,"column":44}},"range":[664,692],"originalLines":"            if (_.isString(pluginExpression)) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":18,"column":57},"end":{"line":45,"column":9}},"range":[645,2182],"originalLines":"        this.plugins.forEach(function (pluginExpression) {\r\n            if (_.isString(pluginExpression)) {\r\n                if (pluginExpression.indexOf('*') !== -1) {\r\n                    var pluginDirectory = path.normalize(__dirname + '/../..');\r\n                    var regexp = new RegExp('^' + pluginExpression.replace('*', '.*'));\r\n                    log.debug('Loading %s from %s', pluginExpression, pluginDirectory);\r\n                    var plugins = fs.readdirSync(pluginDirectory)\r\n                        .filter(function (pluginName) { return IGNORED_PACKAGES.indexOf(pluginName) === -1 && regexp.test(pluginName); })\r\n                        .map(function (pluginName) { return pluginDirectory + '/' + pluginName; });\r\n                    if (plugins.length === 0) {\r\n                        log.debug('Expression %s not resulted in plugins to load', pluginExpression);\r\n                    }\r\n                    plugins\r\n                        .map(function (plugin) { return path.basename(plugin); })\r\n                        .map(function (plugin) {\r\n                        log.debug('Loading plugins %s (matched with expression %s)', plugin, pluginExpression);\r\n                        return plugin;\r\n                    })\r\n                        .forEach(function (p) { return modules.push(p); });\r\n                }\r\n                else {\r\n                    modules.push(pluginExpression);\r\n                }\r\n            }\r\n            else {\r\n                log.warn('Ignoring plugin %s, as its not a string type', pluginExpression);\r\n            }\r\n        });","mutatedLines":"        this.plugins.forEach(function (pluginExpression) {\n});"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":16,"column":52},"end":{"line":47,"column":5}},"range":[558,2216],"originalLines":"    PluginLoader.prototype.getModules = function () {\r\n        var modules = [];\r\n        this.plugins.forEach(function (pluginExpression) {\r\n            if (_.isString(pluginExpression)) {\r\n                if (pluginExpression.indexOf('*') !== -1) {\r\n                    var pluginDirectory = path.normalize(__dirname + '/../..');\r\n                    var regexp = new RegExp('^' + pluginExpression.replace('*', '.*'));\r\n                    log.debug('Loading %s from %s', pluginExpression, pluginDirectory);\r\n                    var plugins = fs.readdirSync(pluginDirectory)\r\n                        .filter(function (pluginName) { return IGNORED_PACKAGES.indexOf(pluginName) === -1 && regexp.test(pluginName); })\r\n                        .map(function (pluginName) { return pluginDirectory + '/' + pluginName; });\r\n                    if (plugins.length === 0) {\r\n                        log.debug('Expression %s not resulted in plugins to load', pluginExpression);\r\n                    }\r\n                    plugins\r\n                        .map(function (plugin) { return path.basename(plugin); })\r\n                        .map(function (plugin) {\r\n                        log.debug('Loading plugins %s (matched with expression %s)', plugin, pluginExpression);\r\n                        return plugin;\r\n                    })\r\n                        .forEach(function (p) { return modules.push(p); });\r\n                }\r\n                else {\r\n                    modules.push(pluginExpression);\r\n                }\r\n            }\r\n            else {\r\n                log.warn('Ignoring plugin %s, as its not a string type', pluginExpression);\r\n            }\r\n        });\r\n        return modules;\r\n    };","mutatedLines":"    PluginLoader.prototype.getModules = function () {\n};"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":13,"column":46},"end":{"line":15,"column":5}},"range":[439,503],"originalLines":"    PluginLoader.prototype.load = function () {\r\n        this.getModules().forEach(this.requirePlugin);\r\n    };","mutatedLines":"    PluginLoader.prototype.load = function () {\n};"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":10,"column":35},"end":{"line":12,"column":5}},"range":[350,391],"originalLines":"    function PluginLoader(plugins) {\r\n        this.plugins = plugins;\r\n    }","mutatedLines":"    function PluginLoader(plugins) {\n}"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":9,"column":32},"end":{"line":64,"column":1}},"range":[312,2843],"originalLines":"var PluginLoader = (function () {\r\n    function PluginLoader(plugins) {\r\n        this.plugins = plugins;\r\n    }\r\n    PluginLoader.prototype.load = function () {\r\n        this.getModules().forEach(this.requirePlugin);\r\n    };\r\n    PluginLoader.prototype.getModules = function () {\r\n        var modules = [];\r\n        this.plugins.forEach(function (pluginExpression) {\r\n            if (_.isString(pluginExpression)) {\r\n                if (pluginExpression.indexOf('*') !== -1) {\r\n                    var pluginDirectory = path.normalize(__dirname + '/../..');\r\n                    var regexp = new RegExp('^' + pluginExpression.replace('*', '.*'));\r\n                    log.debug('Loading %s from %s', pluginExpression, pluginDirectory);\r\n                    var plugins = fs.readdirSync(pluginDirectory)\r\n                        .filter(function (pluginName) { return IGNORED_PACKAGES.indexOf(pluginName) === -1 && regexp.test(pluginName); })\r\n                        .map(function (pluginName) { return pluginDirectory + '/' + pluginName; });\r\n                    if (plugins.length === 0) {\r\n                        log.debug('Expression %s not resulted in plugins to load', pluginExpression);\r\n                    }\r\n                    plugins\r\n                        .map(function (plugin) { return path.basename(plugin); })\r\n                        .map(function (plugin) {\r\n                        log.debug('Loading plugins %s (matched with expression %s)', plugin, pluginExpression);\r\n                        return plugin;\r\n                    })\r\n                        .forEach(function (p) { return modules.push(p); });\r\n                }\r\n                else {\r\n                    modules.push(pluginExpression);\r\n                }\r\n            }\r\n            else {\r\n                log.warn('Ignoring plugin %s, as its not a string type', pluginExpression);\r\n            }\r\n        });\r\n        return modules;\r\n    };\r\n    PluginLoader.prototype.requirePlugin = function (name) {\r\n        log.debug(\"Loading plugins \" + name);\r\n        try {\r\n            fileUtils_1.importModule(name);\r\n        }\r\n        catch (e) {\r\n            if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(name) !== -1) {\r\n                log.warn('Cannot find plugin \"%s\".\\n  Did you forget to install it ?\\n' +\r\n                    '  npm install %s --save-dev', name, name);\r\n            }\r\n            else {\r\n                log.warn('Error during loading \"%s\" plugin:\\n  %s', name, e.message);\r\n            }\r\n        }\r\n    };\r\n    return PluginLoader;\r\n}());","mutatedLines":"var PluginLoader = (function () {\n}());"},{"sourceFilePath":"/stryker/src/mutators/UnaryOperatorMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":11,"column":36},"end":{"line":17,"column":5}},"range":[501,725],"originalLines":"    function UnaryOperatorMutator() {\r\n        _super.call(this, 'UnaryOperator', [esprima_1.Syntax.UpdateExpression, esprima_1.Syntax.UnaryExpression], {\r\n            '++': '--',\r\n            '--': '++',\r\n            '-': '+',\r\n            '+': '-' });\r\n    }","mutatedLines":"    function UnaryOperatorMutator() {\n}"},{"sourceFilePath":"/stryker/src/mutators/UnaryOperatorMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":9,"column":46},"end":{"line":19,"column":1}},"range":[416,762],"originalLines":"var UnaryOperatorMutator = (function (_super) {\r\n    __extends(UnaryOperatorMutator, _super);\r\n    function UnaryOperatorMutator() {\r\n        _super.call(this, 'UnaryOperator', [esprima_1.Syntax.UpdateExpression, esprima_1.Syntax.UnaryExpression], {\r\n            '++': '--',\r\n            '--': '++',\r\n            '-': '+',\r\n            '+': '-' });\r\n    }\r\n    return UnaryOperatorMutator;\r\n}(OperatorMutator_1.default));","mutatedLines":"var UnaryOperatorMutator = (function (_super) {\n}(OperatorMutator_1.default));"},{"sourceFilePath":"/stryker/src/mutators/UnaryOperatorMutator.js","mutatorName":"ReverseConditional","status":1,"replacement":"b !== null","location":{"start":{"line":5,"column":18},"end":{"line":5,"column":28}},"range":[201,211],"originalLines":"    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());","mutatedLines":"    d.prototype = b !== null ? Object.create(b) : (__.prototype = b.prototype, new __());"},{"sourceFilePath":"/stryker/src/mutators/UnaryOperatorMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":4,"column":18},"end":{"line":4,"column":43}},"range":[156,181],"originalLines":"    function __() { this.constructor = d; }","mutatedLines":"    function __() {\n}"},{"sourceFilePath":"/stryker/src/mutators/UnaryOperatorMutator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":3,"column":25},"end":{"line":3,"column":44}},"range":[103,122],"originalLines":"    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];","mutatedLines":"    for (var p in b) if (true) d[p] = b[p];"},{"sourceFilePath":"/stryker/src/mutators/UnaryOperatorMutator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":3,"column":25},"end":{"line":3,"column":44}},"range":[103,122],"originalLines":"    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];","mutatedLines":"    for (var p in b) if (false) d[p] = b[p];"},{"sourceFilePath":"/stryker/src/mutators/UnaryOperatorMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":2,"column":60},"end":{"line":6,"column":1}},"range":[75,275],"originalLines":"var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};","mutatedLines":"var __extends = (this && this.__extends) || function (d, b) {\n};"},{"sourceFilePath":"/stryker/src/mutators/UnaryOperatorMutator.js","mutatorName":"ReverseConditional","status":1,"replacement":"this || this.__extends","location":{"start":{"line":2,"column":17},"end":{"line":2,"column":39}},"range":[32,54],"originalLines":"var __extends = (this && this.__extends) || function (d, b) {","mutatedLines":"var __extends = (this || this.__extends) || function (d, b) {"},{"sourceFilePath":"/stryker/src/mutators/UnaryOperatorMutator.js","mutatorName":"ReverseConditional","status":1,"replacement":"this && this.__extends && function (d, b) {\n    for (var p in b)\n        if (b.hasOwnProperty(p))\n            d[p] = b[p];\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}","location":{"start":{"line":2,"column":16},"end":{"line":6,"column":1}},"range":[31,275],"originalLines":"var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};","mutatedLines":"var __extends = this && this.__extends && function (d, b) {\n    for (var p in b)\n        if (b.hasOwnProperty(p))\n            d[p] = b[p];\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};"},{"sourceFilePath":"/stryker/src/mutators/ReverseConditionalMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":11,"column":41},"end":{"line":23,"column":5}},"range":[516,901],"originalLines":"    function ReverseConditionalMutator() {\r\n        _super.call(this, 'ReverseConditional', [esprima_1.Syntax.BinaryExpression, esprima_1.Syntax.LogicalExpression], {\r\n            '==': '!=',\r\n            '!=': '==',\r\n            '===': '!==',\r\n            '!==': '===',\r\n            '<=': '>',\r\n            '>=': '<',\r\n            '<': '>=',\r\n            '>': '<=',\r\n            '&&': '||',\r\n            '||': '&&' });\r\n    }","mutatedLines":"    function ReverseConditionalMutator() {\n}"},{"sourceFilePath":"/stryker/src/mutators/ReverseConditionalMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":9,"column":51},"end":{"line":25,"column":1}},"range":[421,943],"originalLines":"var ReverseConditionalMutator = (function (_super) {\r\n    __extends(ReverseConditionalMutator, _super);\r\n    function ReverseConditionalMutator() {\r\n        _super.call(this, 'ReverseConditional', [esprima_1.Syntax.BinaryExpression, esprima_1.Syntax.LogicalExpression], {\r\n            '==': '!=',\r\n            '!=': '==',\r\n            '===': '!==',\r\n            '!==': '===',\r\n            '<=': '>',\r\n            '>=': '<',\r\n            '<': '>=',\r\n            '>': '<=',\r\n            '&&': '||',\r\n            '||': '&&' });\r\n    }\r\n    return ReverseConditionalMutator;\r\n}(OperatorMutator_1.default));","mutatedLines":"var ReverseConditionalMutator = (function (_super) {\n}(OperatorMutator_1.default));"},{"sourceFilePath":"/stryker/src/mutators/ReverseConditionalMutator.js","mutatorName":"ReverseConditional","status":1,"replacement":"b !== null","location":{"start":{"line":5,"column":18},"end":{"line":5,"column":28}},"range":[201,211],"originalLines":"    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());","mutatedLines":"    d.prototype = b !== null ? Object.create(b) : (__.prototype = b.prototype, new __());"},{"sourceFilePath":"/stryker/src/mutators/ReverseConditionalMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":4,"column":18},"end":{"line":4,"column":43}},"range":[156,181],"originalLines":"    function __() { this.constructor = d; }","mutatedLines":"    function __() {\n}"},{"sourceFilePath":"/stryker/src/mutators/ReverseConditionalMutator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":3,"column":25},"end":{"line":3,"column":44}},"range":[103,122],"originalLines":"    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];","mutatedLines":"    for (var p in b) if (true) d[p] = b[p];"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":9,"column":40},"end":{"line":48,"column":1}},"range":[470,2396],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker \"before each\" hook for \"should use the config writer to override config\"","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"var ReporterOrchestrator = (function () {\r\n    function ReporterOrchestrator(options) {\r\n        this.options = options;\r\n        this.registerDefaultReporters();\r\n    }\r\n    ReporterOrchestrator.prototype.createBroadcastReporter = function () {\r\n        var _this = this;\r\n        var reporters = [];\r\n        var reporterOption = this.options.reporter;\r\n        if (reporterOption) {\r\n            if (Array.isArray(reporterOption)) {\r\n                reporterOption.forEach(function (reporterName) { return reporters.push({ name: reporterName, reporter: report_1.ReporterFactory.instance().create(reporterName, _this.options) }); });\r\n            }\r\n            else {\r\n                reporters.push({ name: reporterOption, reporter: report_1.ReporterFactory.instance().create(reporterOption, this.options) });\r\n            }\r\n        }\r\n        else {\r\n            log.warn(\"No reporter configured. Please configure one or more reporters in the (for example: reporter: 'progress')\");\r\n            this.logPossibleReporters();\r\n        }\r\n        return new BroadcastReporter_1.default(reporters);\r\n    };\r\n    ReporterOrchestrator.prototype.logPossibleReporters = function () {\r\n        var possibleReportersCsv = '';\r\n        report_1.ReporterFactory.instance().knownNames().forEach(function (name) {\r\n            if (possibleReportersCsv.length) {\r\n                possibleReportersCsv += ', ';\r\n            }\r\n            possibleReportersCsv += name;\r\n        });\r\n        log.warn(\"Possible reporters: \" + possibleReportersCsv);\r\n    };\r\n    ReporterOrchestrator.prototype.registerDefaultReporters = function () {\r\n        report_1.ReporterFactory.instance().register('progress', ProgressReporter_1.default);\r\n        report_1.ReporterFactory.instance().register('clear-text', ClearTextReporter_1.default);\r\n        report_1.ReporterFactory.instance().register('event-recorder', EventRecorderReporter_1.default);\r\n    };\r\n    return ReporterOrchestrator;\r\n}());","mutatedLines":"var ReporterOrchestrator = (function () {\n}());"},{"sourceFilePath":"/stryker/src/mutators/ReverseConditionalMutator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":3,"column":25},"end":{"line":3,"column":44}},"range":[103,122],"originalLines":"    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];","mutatedLines":"    for (var p in b) if (false) d[p] = b[p];"},{"sourceFilePath":"/stryker/src/mutators/ReverseConditionalMutator.js","mutatorName":"ReverseConditional","status":1,"replacement":"this || this.__extends","location":{"start":{"line":2,"column":17},"end":{"line":2,"column":39}},"range":[32,54],"originalLines":"var __extends = (this && this.__extends) || function (d, b) {","mutatedLines":"var __extends = (this || this.__extends) || function (d, b) {"},{"sourceFilePath":"/stryker/src/mutators/ReverseConditionalMutator.js","mutatorName":"ReverseConditional","status":1,"replacement":"this && this.__extends && function (d, b) {\n    for (var p in b)\n        if (b.hasOwnProperty(p))\n            d[p] = b[p];\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}","location":{"start":{"line":2,"column":16},"end":{"line":6,"column":1}},"range":[31,275],"originalLines":"var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};","mutatedLines":"var __extends = this && this.__extends && function (d, b) {\n    for (var p in b)\n        if (b.hasOwnProperty(p))\n            d[p] = b[p];\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};"},{"sourceFilePath":"/stryker/src/mutators/RemoveConditionalsMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":30,"column":67},"end":{"line":32,"column":5}},"range":[1337,1395],"originalLines":"    RemoveConditionalsMutator.prototype.copyNode = function (node) {\r\n        return JSON.parse(JSON.stringify(node));\r\n    };","mutatedLines":"    RemoveConditionalsMutator.prototype.copyNode = function (node) {\n};"},{"sourceFilePath":"/stryker/src/mutators/RemoveConditionalsMutator.js","mutatorName":"ReverseConditional","status":1,"replacement":"this.types.indexOf(node.type) < 0","location":{"start":{"line":27,"column":26},"end":{"line":27,"column":60}},"range":[1217,1251],"originalLines":"        return !!(node && this.types.indexOf(node.type) >= 0);","mutatedLines":"        return !!(node && this.types.indexOf(node.type) < 0);"},{"sourceFilePath":"/stryker/src/TestRunnerOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":209,"column":55},"end":{"line":209,"column":76}},"range":[10122,10143],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants \"before each\" hook for \"should not select test files\"","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants \"before each\" hook for \"should have created 2 test runners\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"            Promise.all(copyPromises).then(function () { resolve(fileMap); }, reject);","mutatedLines":"            Promise.all(copyPromises).then(function () {\n}, reject);"},{"sourceFilePath":"/stryker/src/mutators/RemoveConditionalsMutator.js","mutatorName":"ConditionalBoundary","status":1,"replacement":"this.types.indexOf(node.type) > 0","location":{"start":{"line":27,"column":26},"end":{"line":27,"column":60}},"range":[1217,1251],"originalLines":"        return !!(node && this.types.indexOf(node.type) >= 0);","mutatedLines":"        return !!(node && this.types.indexOf(node.type) > 0);"},{"sourceFilePath":"/stryker/src/mutators/RemoveConditionalsMutator.js","mutatorName":"ReverseConditional","status":1,"replacement":"node || this.types.indexOf(node.type) >= 0","location":{"start":{"line":27,"column":18},"end":{"line":27,"column":60}},"range":[1209,1251],"originalLines":"        return !!(node && this.types.indexOf(node.type) >= 0);","mutatedLines":"        return !!(node || this.types.indexOf(node.type) >= 0);"},{"sourceFilePath":"/stryker/src/mutators/RemoveConditionalsMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":22,"column":89},"end":{"line":25,"column":5}},"range":[1030,1117],"originalLines":"    RemoveConditionalsMutator.prototype.mutateTestExpression = function (node, newValue) {\r\n        node.type = esprima_1.Syntax.Literal;\r\n        node.value = newValue;\r\n    };","mutatedLines":"    RemoveConditionalsMutator.prototype.mutateTestExpression = function (node, newValue) {\n};"},{"sourceFilePath":"/stryker/src/mutators/RemoveConditionalsMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":14,"column":60},"end":{"line":18,"column":13}},"range":[712,897],"originalLines":"            if (node.type === esprima_1.Syntax.IfStatement) {\r\n                var mutatedTrueNode = copy(node.test);\r\n                this.mutateTestExpression(mutatedTrueNode, true);\r\n                nodes.push(mutatedTrueNode);\r\n            }","mutatedLines":"            if (node.type === esprima_1.Syntax.IfStatement) {\n}"},{"sourceFilePath":"/stryker/src/mutators/RemoveConditionalsMutator.js","mutatorName":"ReverseConditional","status":1,"replacement":"node.type !== esprima_1.Syntax.IfStatement","location":{"start":{"line":14,"column":16},"end":{"line":14,"column":58}},"range":[668,710],"originalLines":"            if (node.type === esprima_1.Syntax.IfStatement) {","mutatedLines":"            if (node.type !== esprima_1.Syntax.IfStatement) {"},{"sourceFilePath":"/stryker/src/mutators/RemoveConditionalsMutator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":14,"column":16},"end":{"line":14,"column":58}},"range":[668,710],"originalLines":"            if (node.type === esprima_1.Syntax.IfStatement) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/mutators/RemoveConditionalsMutator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":14,"column":16},"end":{"line":14,"column":58}},"range":[668,710],"originalLines":"            if (node.type === esprima_1.Syntax.IfStatement) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/mutators/RemoveConditionalsMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":10,"column":34},"end":{"line":19,"column":9}},"range":[488,908],"originalLines":"        if (this.canMutate(node)) {\r\n            var mutatedFalseNode = copy(node.test);\r\n            this.mutateTestExpression(mutatedFalseNode, false);\r\n            nodes.push(mutatedFalseNode);\r\n            if (node.type === esprima_1.Syntax.IfStatement) {\r\n                var mutatedTrueNode = copy(node.test);\r\n                this.mutateTestExpression(mutatedTrueNode, true);\r\n                nodes.push(mutatedTrueNode);\r\n            }\r\n        }","mutatedLines":"        if (this.canMutate(node)) {\n}"},{"sourceFilePath":"/stryker/src/mutators/RemoveConditionalsMutator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":10,"column":12},"end":{"line":10,"column":32}},"range":[466,486],"originalLines":"        if (this.canMutate(node)) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/mutators/RemoveConditionalsMutator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":10,"column":12},"end":{"line":10,"column":32}},"range":[466,486],"originalLines":"        if (this.canMutate(node)) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/mutators/RemoveConditionalsMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":8,"column":79},"end":{"line":21,"column":5}},"range":[426,938],"originalLines":"    RemoveConditionalsMutator.prototype.applyMutations = function (node, copy) {\r\n        var nodes = [];\r\n        if (this.canMutate(node)) {\r\n            var mutatedFalseNode = copy(node.test);\r\n            this.mutateTestExpression(mutatedFalseNode, false);\r\n            nodes.push(mutatedFalseNode);\r\n            if (node.type === esprima_1.Syntax.IfStatement) {\r\n                var mutatedTrueNode = copy(node.test);\r\n                this.mutateTestExpression(mutatedTrueNode, true);\r\n                nodes.push(mutatedTrueNode);\r\n            }\r\n        }\r\n        return nodes;\r\n    };","mutatedLines":"    RemoveConditionalsMutator.prototype.applyMutations = function (node, copy) {\n};"},{"sourceFilePath":"/stryker/src/mutators/RemoveConditionalsMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":4,"column":41},"end":{"line":7,"column":5}},"range":[141,345],"originalLines":"    function RemoveConditionalsMutator() {\r\n        this.name = 'RemoveConditionals';\r\n        this.types = [esprima_1.Syntax.DoWhileStatement, esprima_1.Syntax.IfStatement, esprima_1.Syntax.ForStatement, esprima_1.Syntax.WhileStatement];\r\n    }","mutatedLines":"    function RemoveConditionalsMutator() {\n}"},{"sourceFilePath":"/stryker/src/mutators/RemoveConditionalsMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":3,"column":45},"end":{"line":34,"column":1}},"range":[97,1438],"originalLines":"var RemoveConditionalsMutator = (function () {\r\n    function RemoveConditionalsMutator() {\r\n        this.name = 'RemoveConditionals';\r\n        this.types = [esprima_1.Syntax.DoWhileStatement, esprima_1.Syntax.IfStatement, esprima_1.Syntax.ForStatement, esprima_1.Syntax.WhileStatement];\r\n    }\r\n    RemoveConditionalsMutator.prototype.applyMutations = function (node, copy) {\r\n        var nodes = [];\r\n        if (this.canMutate(node)) {\r\n            var mutatedFalseNode = copy(node.test);\r\n            this.mutateTestExpression(mutatedFalseNode, false);\r\n            nodes.push(mutatedFalseNode);\r\n            if (node.type === esprima_1.Syntax.IfStatement) {\r\n                var mutatedTrueNode = copy(node.test);\r\n                this.mutateTestExpression(mutatedTrueNode, true);\r\n                nodes.push(mutatedTrueNode);\r\n            }\r\n        }\r\n        return nodes;\r\n    };\r\n    RemoveConditionalsMutator.prototype.mutateTestExpression = function (node, newValue) {\r\n        node.type = esprima_1.Syntax.Literal;\r\n        node.value = newValue;\r\n    };\r\n    RemoveConditionalsMutator.prototype.canMutate = function (node) {\r\n        return !!(node && this.types.indexOf(node.type) >= 0);\r\n    };\r\n    ;\r\n    RemoveConditionalsMutator.prototype.copyNode = function (node) {\r\n        return JSON.parse(JSON.stringify(node));\r\n    };\r\n    return RemoveConditionalsMutator;\r\n}());","mutatedLines":"var RemoveConditionalsMutator = (function () {\n}());"},{"sourceFilePath":"/stryker/src/mutators/OperatorMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":20,"column":64},"end":{"line":22,"column":5}},"range":[767,817],"originalLines":"    OperatorMutator.prototype.getOperator = function (operator) {\r\n        return this.operators[operator];\r\n    };","mutatedLines":"    OperatorMutator.prototype.getOperator = function (operator) {\n};"},{"sourceFilePath":"/stryker/src/mutators/OperatorMutator.js","mutatorName":"ReverseConditional","status":1,"replacement":"this.types.indexOf(node.type) < 0","location":{"start":{"line":18,"column":26},"end":{"line":18,"column":60}},"range":[622,656],"originalLines":"        return !!(node && this.types.indexOf(node.type) >= 0 && this.getOperator(node.operator));","mutatedLines":"        return !!(node && this.types.indexOf(node.type) < 0 && this.getOperator(node.operator));"},{"sourceFilePath":"/stryker/src/mutators/OperatorMutator.js","mutatorName":"ConditionalBoundary","status":1,"replacement":"this.types.indexOf(node.type) > 0","location":{"start":{"line":18,"column":26},"end":{"line":18,"column":60}},"range":[622,656],"originalLines":"        return !!(node && this.types.indexOf(node.type) >= 0 && this.getOperator(node.operator));","mutatedLines":"        return !!(node && this.types.indexOf(node.type) > 0 && this.getOperator(node.operator));"},{"sourceFilePath":"/stryker/src/mutators/OperatorMutator.js","mutatorName":"ReverseConditional","status":1,"replacement":"node || this.types.indexOf(node.type) >= 0","location":{"start":{"line":18,"column":18},"end":{"line":18,"column":60}},"range":[614,656],"originalLines":"        return !!(node && this.types.indexOf(node.type) >= 0 && this.getOperator(node.operator));","mutatedLines":"        return !!(node || this.types.indexOf(node.type) >= 0 && this.getOperator(node.operator));"},{"sourceFilePath":"/stryker/src/mutators/OperatorMutator.js","mutatorName":"ReverseConditional","status":1,"replacement":"node && this.types.indexOf(node.type) >= 0 || this.getOperator(node.operator)","location":{"start":{"line":18,"column":18},"end":{"line":18,"column":95}},"range":[614,691],"originalLines":"        return !!(node && this.types.indexOf(node.type) >= 0 && this.getOperator(node.operator));","mutatedLines":"        return !!(node && this.types.indexOf(node.type) >= 0 || this.getOperator(node.operator));"},{"sourceFilePath":"/stryker/src/mutators/OperatorMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":17,"column":58},"end":{"line":19,"column":5}},"range":[593,700],"originalLines":"    OperatorMutator.prototype.canMutate = function (node) {\r\n        return !!(node && this.types.indexOf(node.type) >= 0 && this.getOperator(node.operator));\r\n    };","mutatedLines":"    OperatorMutator.prototype.canMutate = function (node) {\n};"},{"sourceFilePath":"/stryker/src/mutators/OperatorMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":10,"column":34},"end":{"line":14,"column":9}},"range":[340,502],"originalLines":"        if (this.canMutate(node)) {\r\n            var mutatedNode = copy(node);\r\n            mutatedNode.operator = this.getOperator(node.operator);\r\n            nodes.push(mutatedNode);\r\n        }","mutatedLines":"        if (this.canMutate(node)) {\n}"},{"sourceFilePath":"/stryker/src/mutators/OperatorMutator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":10,"column":12},"end":{"line":10,"column":32}},"range":[318,338],"originalLines":"        if (this.canMutate(node)) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/mutators/OperatorMutator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":10,"column":12},"end":{"line":10,"column":32}},"range":[318,338],"originalLines":"        if (this.canMutate(node)) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/mutators/OperatorMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":8,"column":69},"end":{"line":16,"column":5}},"range":[278,532],"originalLines":"    OperatorMutator.prototype.applyMutations = function (node, copy) {\r\n        var nodes = [];\r\n        if (this.canMutate(node)) {\r\n            var mutatedNode = copy(node);\r\n            mutatedNode.operator = this.getOperator(node.operator);\r\n            nodes.push(mutatedNode);\r\n        }\r\n        return nodes;\r\n    };","mutatedLines":"    OperatorMutator.prototype.applyMutations = function (node, copy) {\n};"},{"sourceFilePath":"/stryker/src/mutators/OperatorMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":3,"column":53},"end":{"line":7,"column":5}},"range":[106,207],"originalLines":"    function OperatorMutator(name, types, operators) {\r\n        this.name = name;\r\n        this.types = types;\r\n        this.operators = operators;\r\n    }","mutatedLines":"    function OperatorMutator(name, types, operators) {\n}"},{"sourceFilePath":"/stryker/src/mutators/OperatorMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":2,"column":35},"end":{"line":24,"column":1}},"range":[50,850],"originalLines":"var OperatorMutator = (function () {\r\n    function OperatorMutator(name, types, operators) {\r\n        this.name = name;\r\n        this.types = types;\r\n        this.operators = operators;\r\n    }\r\n    OperatorMutator.prototype.applyMutations = function (node, copy) {\r\n        var nodes = [];\r\n        if (this.canMutate(node)) {\r\n            var mutatedNode = copy(node);\r\n            mutatedNode.operator = this.getOperator(node.operator);\r\n            nodes.push(mutatedNode);\r\n        }\r\n        return nodes;\r\n    };\r\n    OperatorMutator.prototype.canMutate = function (node) {\r\n        return !!(node && this.types.indexOf(node.type) >= 0 && this.getOperator(node.operator));\r\n    };\r\n    OperatorMutator.prototype.getOperator = function (operator) {\r\n        return this.operators[operator];\r\n    };\r\n    return OperatorMutator;\r\n}());","mutatedLines":"var OperatorMutator = (function () {\n}());"},{"sourceFilePath":"/stryker/src/mutators/MathMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":11,"column":27},"end":{"line":18,"column":5}},"range":[474,674],"originalLines":"    function MathMutator() {\r\n        _super.call(this, 'Math', [esprima_1.Syntax.BinaryExpression], {\r\n            '+': '-',\r\n            '-': '+',\r\n            '*': '/',\r\n            '/': '*',\r\n            '%': '*' });\r\n    }","mutatedLines":"    function MathMutator() {\n}"},{"sourceFilePath":"/stryker/src/mutators/MathMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":9,"column":37},"end":{"line":20,"column":1}},"range":[407,702],"originalLines":"var MathMutator = (function (_super) {\r\n    __extends(MathMutator, _super);\r\n    function MathMutator() {\r\n        _super.call(this, 'Math', [esprima_1.Syntax.BinaryExpression], {\r\n            '+': '-',\r\n            '-': '+',\r\n            '*': '/',\r\n            '/': '*',\r\n            '%': '*' });\r\n    }\r\n    return MathMutator;\r\n}(OperatorMutator_1.default));","mutatedLines":"var MathMutator = (function (_super) {\n}(OperatorMutator_1.default));"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"ReverseConditional","status":2,"replacement":"e.message.indexOf(name) === -1","location":{"start":{"line":54,"column":49},"end":{"line":54,"column":79}},"range":[2469,2499],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"            if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(name) !== -1) {","mutatedLines":"            if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(name) === -1) {"},{"sourceFilePath":"/stryker/src/mutators/MathMutator.js","mutatorName":"ReverseConditional","status":1,"replacement":"b !== null","location":{"start":{"line":5,"column":18},"end":{"line":5,"column":28}},"range":[201,211],"originalLines":"    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());","mutatedLines":"    d.prototype = b !== null ? Object.create(b) : (__.prototype = b.prototype, new __());"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":14,"column":73},"end":{"line":31,"column":5}},"range":[674,1537],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"    ReporterOrchestrator.prototype.createBroadcastReporter = function () {\r\n        var _this = this;\r\n        var reporters = [];\r\n        var reporterOption = this.options.reporter;\r\n        if (reporterOption) {\r\n            if (Array.isArray(reporterOption)) {\r\n                reporterOption.forEach(function (reporterName) { return reporters.push({ name: reporterName, reporter: report_1.ReporterFactory.instance().create(reporterName, _this.options) }); });\r\n            }\r\n            else {\r\n                reporters.push({ name: reporterOption, reporter: report_1.ReporterFactory.instance().create(reporterOption, this.options) });\r\n            }\r\n        }\r\n        else {\r\n            log.warn(\"No reporter configured. Please configure one or more reporters in the (for example: reporter: 'progress')\");\r\n            this.logPossibleReporters();\r\n        }\r\n        return new BroadcastReporter_1.default(reporters);\r\n    };","mutatedLines":"    ReporterOrchestrator.prototype.createBroadcastReporter = function () {\n};"},{"sourceFilePath":"/stryker/src/mutators/MathMutator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":3,"column":25},"end":{"line":3,"column":44}},"range":[103,122],"originalLines":"    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];","mutatedLines":"    for (var p in b) if (true) d[p] = b[p];"},{"sourceFilePath":"/stryker/src/mutators/MathMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":2,"column":60},"end":{"line":6,"column":1}},"range":[75,275],"originalLines":"var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};","mutatedLines":"var __extends = (this && this.__extends) || function (d, b) {\n};"},{"sourceFilePath":"/stryker/src/mutators/MathMutator.js","mutatorName":"ReverseConditional","status":1,"replacement":"this || this.__extends","location":{"start":{"line":2,"column":17},"end":{"line":2,"column":39}},"range":[32,54],"originalLines":"var __extends = (this && this.__extends) || function (d, b) {","mutatedLines":"var __extends = (this || this.__extends) || function (d, b) {"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"ReverseConditional","status":1,"replacement":"e.code !== 'MODULE_NOT_FOUND'","location":{"start":{"line":54,"column":16},"end":{"line":54,"column":45}},"range":[2436,2465],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"            if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(name) !== -1) {","mutatedLines":"            if (e.code !== 'MODULE_NOT_FOUND' && e.message.indexOf(name) !== -1) {"},{"sourceFilePath":"/stryker/src/mutators/MathMutator.js","mutatorName":"ReverseConditional","status":1,"replacement":"this && this.__extends && function (d, b) {\n    for (var p in b)\n        if (b.hasOwnProperty(p))\n            d[p] = b[p];\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}","location":{"start":{"line":2,"column":16},"end":{"line":6,"column":1}},"range":[31,275],"originalLines":"var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};","mutatedLines":"var __extends = this && this.__extends && function (d, b) {\n    for (var p in b)\n        if (b.hasOwnProperty(p))\n            d[p] = b[p];\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};"},{"sourceFilePath":"/stryker/src/mutators/ConditionalBoundaryMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":9,"column":51},"end":{"line":20,"column":1}},"range":[421,763],"originalLines":"var ConditionalBoundayMutator = (function (_super) {\r\n    __extends(ConditionalBoundayMutator, _super);\r\n    function ConditionalBoundayMutator() {\r\n        _super.call(this, 'ConditionalBoundary', [esprima_1.Syntax.BinaryExpression], {\r\n            '<': '<=',\r\n            '<=': '<',\r\n            '>': '>=',\r\n            '>=': '>'\r\n        });\r\n    }\r\n    return ConditionalBoundayMutator;\r\n}(OperatorMutator_1.default));","mutatedLines":"var ConditionalBoundayMutator = (function (_super) {\n}(OperatorMutator_1.default));"},{"sourceFilePath":"/stryker/src/mutators/ConditionalBoundaryMutator.js","mutatorName":"ReverseConditional","status":1,"replacement":"b !== null","location":{"start":{"line":5,"column":18},"end":{"line":5,"column":28}},"range":[201,211],"originalLines":"    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());","mutatedLines":"    d.prototype = b !== null ? Object.create(b) : (__.prototype = b.prototype, new __());"},{"sourceFilePath":"/stryker/src/mutators/ConditionalBoundaryMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":4,"column":18},"end":{"line":4,"column":43}},"range":[156,181],"originalLines":"    function __() { this.constructor = d; }","mutatedLines":"    function __() {\n}"},{"sourceFilePath":"/stryker/src/mutators/ConditionalBoundaryMutator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":3,"column":25},"end":{"line":3,"column":44}},"range":[103,122],"originalLines":"    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];","mutatedLines":"    for (var p in b) if (true) d[p] = b[p];"},{"sourceFilePath":"/stryker/src/mutators/ConditionalBoundaryMutator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":3,"column":25},"end":{"line":3,"column":44}},"range":[103,122],"originalLines":"    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];","mutatedLines":"    for (var p in b) if (false) d[p] = b[p];"},{"sourceFilePath":"/stryker/src/mutators/ConditionalBoundaryMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":2,"column":60},"end":{"line":6,"column":1}},"range":[75,275],"originalLines":"var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};","mutatedLines":"var __extends = (this && this.__extends) || function (d, b) {\n};"},{"sourceFilePath":"/stryker/src/mutators/ConditionalBoundaryMutator.js","mutatorName":"ReverseConditional","status":1,"replacement":"this || this.__extends","location":{"start":{"line":2,"column":17},"end":{"line":2,"column":39}},"range":[32,54],"originalLines":"var __extends = (this && this.__extends) || function (d, b) {","mutatedLines":"var __extends = (this || this.__extends) || function (d, b) {"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":36,"column":46},"end":{"line":36,"column":73}},"range":[1884,1911],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"                        .forEach(function (p) { return modules.push(p); });","mutatedLines":"                        .forEach(function (p) {\n});"},{"sourceFilePath":"/stryker/src/mutators/ConditionalBoundaryMutator.js","mutatorName":"ReverseConditional","status":1,"replacement":"this && this.__extends && function (d, b) {\n    for (var p in b)\n        if (b.hasOwnProperty(p))\n            d[p] = b[p];\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}","location":{"start":{"line":2,"column":16},"end":{"line":6,"column":1}},"range":[31,275],"originalLines":"var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};","mutatedLines":"var __extends = this && this.__extends && function (d, b) {\n    for (var p in b)\n        if (b.hasOwnProperty(p))\n            d[p] = b[p];\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};"},{"sourceFilePath":"/stryker/src/mutators/BlockStatementMutator.js","mutatorName":"ConditionalBoundary","status":1,"replacement":"this.types.indexOf(node.type) > 0","location":{"start":{"line":18,"column":26},"end":{"line":18,"column":60}},"range":[631,665],"originalLines":"        return !!(node && this.types.indexOf(node.type) >= 0);","mutatedLines":"        return !!(node && this.types.indexOf(node.type) > 0);"},{"sourceFilePath":"/stryker/src/mutators/BlockStatementMutator.js","mutatorName":"ReverseConditional","status":1,"replacement":"node || this.types.indexOf(node.type) >= 0","location":{"start":{"line":18,"column":18},"end":{"line":18,"column":60}},"range":[623,665],"originalLines":"        return !!(node && this.types.indexOf(node.type) >= 0);","mutatedLines":"        return !!(node || this.types.indexOf(node.type) >= 0);"},{"sourceFilePath":"/stryker/src/mutators/BlockStatementMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":17,"column":64},"end":{"line":19,"column":5}},"range":[602,674],"originalLines":"    BlockStatementMutator.prototype.canMutate = function (node) {\r\n        return !!(node && this.types.indexOf(node.type) >= 0);\r\n    };","mutatedLines":"    BlockStatementMutator.prototype.canMutate = function (node) {\n};"},{"sourceFilePath":"/stryker/src/mutators/BlockStatementMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":10,"column":34},"end":{"line":14,"column":9}},"range":[376,505],"originalLines":"        if (this.canMutate(node)) {\r\n            var mutatedNode = copy(node);\r\n            mutatedNode.body = [];\r\n            nodes.push(mutatedNode);\r\n        }","mutatedLines":"        if (this.canMutate(node)) {\n}"},{"sourceFilePath":"/stryker/src/mutators/BlockStatementMutator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":10,"column":12},"end":{"line":10,"column":32}},"range":[354,374],"originalLines":"        if (this.canMutate(node)) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/mutators/BlockStatementMutator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":10,"column":12},"end":{"line":10,"column":32}},"range":[354,374],"originalLines":"        if (this.canMutate(node)) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/mutators/BlockStatementMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":8,"column":75},"end":{"line":16,"column":5}},"range":[314,535],"originalLines":"    BlockStatementMutator.prototype.applyMutations = function (node, copy) {\r\n        var nodes = [];\r\n        if (this.canMutate(node)) {\r\n            var mutatedNode = copy(node);\r\n            mutatedNode.body = [];\r\n            nodes.push(mutatedNode);\r\n        }\r\n        return nodes;\r\n    };","mutatedLines":"    BlockStatementMutator.prototype.applyMutations = function (node, copy) {\n};"},{"sourceFilePath":"/stryker/src/mutators/BlockStatementMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":4,"column":37},"end":{"line":7,"column":5}},"range":[133,237],"originalLines":"    function BlockStatementMutator() {\r\n        this.name = 'BlockStatement';\r\n        this.types = [esprima_1.Syntax.BlockStatement];\r\n    }","mutatedLines":"    function BlockStatementMutator() {\n}"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"Math","status":1,"replacement":"pluginDirectory + '/' - pluginName","location":{"start":{"line":26,"column":60},"end":{"line":26,"column":94}},"range":[1283,1317],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"                        .map(function (pluginName) { return pluginDirectory + '/' + pluginName; });","mutatedLines":"                        .map(function (pluginName) { return pluginDirectory + '/' - pluginName; });"},{"sourceFilePath":"/stryker/src/mutators/BlockStatementMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":3,"column":41},"end":{"line":22,"column":1}},"range":[93,720],"originalLines":"var BlockStatementMutator = (function () {\r\n    function BlockStatementMutator() {\r\n        this.name = 'BlockStatement';\r\n        this.types = [esprima_1.Syntax.BlockStatement];\r\n    }\r\n    BlockStatementMutator.prototype.applyMutations = function (node, copy) {\r\n        var nodes = [];\r\n        if (this.canMutate(node)) {\r\n            var mutatedNode = copy(node);\r\n            mutatedNode.body = [];\r\n            nodes.push(mutatedNode);\r\n        }\r\n        return nodes;\r\n    };\r\n    BlockStatementMutator.prototype.canMutate = function (node) {\r\n        return !!(node && this.types.indexOf(node.type) >= 0);\r\n    };\r\n    ;\r\n    return BlockStatementMutator;\r\n}());","mutatedLines":"var BlockStatementMutator = (function () {\n}());"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'The mutator named \\'' + mutator.name - '\\' caused an error: '","location":{"start":{"line":93,"column":40},"end":{"line":93,"column":100}},"range":[5073,5133],"originalLines":"                        throw new Error(\"The mutator named '\" + mutator.name + \"' caused an error: \" + error);","mutatedLines":"                        throw new Error('The mutator named \\'' + mutator.name - '\\' caused an error: ' + error);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'The mutator named \\'' + mutator.name + '\\' caused an error: ' - error","location":{"start":{"line":93,"column":40},"end":{"line":93,"column":108}},"range":[5073,5141],"originalLines":"                        throw new Error(\"The mutator named '\" + mutator.name + \"' caused an error: \" + error);","mutatedLines":"                        throw new Error('The mutator named \\'' + mutator.name + '\\' caused an error: ' - error);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":92,"column":34},"end":{"line":94,"column":21}},"range":[5030,5166],"originalLines":"                    catch (error) {\r\n                        throw new Error(\"The mutator named '\" + mutator.name + \"' caused an error: \" + error);\r\n                    }","mutatedLines":"                    catch (error) {\n}"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":86,"column":68},"end":{"line":90,"column":25}},"range":[4628,4969],"originalLines":"                        mutatedNodes.forEach(function (mutatedNode) {\r\n                            var mutatedCode = parserUtils.generate(mutatedNode);\r\n                            var originalNode = nodes[mutatedNode.nodeID];\r\n                            mutants.push(new Mutant_1.default(mutator.name, sourceFile, originalCode, mutatedCode, originalNode.loc, originalNode.range));\r\n                        });","mutatedLines":"                        mutatedNodes.forEach(function (mutatedNode) {\n});"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"ReverseConditional","status":1,"replacement":"mutatedNodes.length <= 1","location":{"start":{"line":84,"column":119},"end":{"line":84,"column":142}},"range":[4311,4334],"originalLines":"                            log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);","mutatedLines":"                            log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length <= 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"ConditionalBoundary","status":1,"replacement":"mutatedNodes.length >= 1","location":{"start":{"line":84,"column":119},"end":{"line":84,"column":142}},"range":[4311,4334],"originalLines":"                            log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);","mutatedLines":"                            log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length >= 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'The mutator \\'' - mutator.name","location":{"start":{"line":84,"column":38},"end":{"line":84,"column":68}},"range":[4230,4260],"originalLines":"                            log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);","mutatedLines":"                            log.debug('The mutator \\'' - mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'The mutator \\'' + mutator.name - '\\' mutated '","location":{"start":{"line":84,"column":38},"end":{"line":84,"column":83}},"range":[4230,4275],"originalLines":"                            log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);","mutatedLines":"                            log.debug('The mutator \\'' + mutator.name - '\\' mutated ' + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'The mutator \\'' + mutator.name + '\\' mutated ' - mutatedNodes.length","location":{"start":{"line":84,"column":38},"end":{"line":84,"column":105}},"range":[4230,4297],"originalLines":"                            log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);","mutatedLines":"                            log.debug('The mutator \\'' + mutator.name + '\\' mutated ' - mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length - ' node'","location":{"start":{"line":84,"column":38},"end":{"line":84,"column":115}},"range":[4230,4307],"originalLines":"                            log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);","mutatedLines":"                            log.debug('The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length - ' node' + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' - (mutatedNodes.length > 1 ? 's' : '')","location":{"start":{"line":84,"column":38},"end":{"line":84,"column":154}},"range":[4230,4346],"originalLines":"                            log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);","mutatedLines":"                            log.debug('The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' - (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') - ' between (Ln '","location":{"start":{"line":84,"column":38},"end":{"line":84,"column":172}},"range":[4230,4364],"originalLines":"                            log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);","mutatedLines":"                            log.debug('The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') - ' between (Ln ' + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') + ' between (Ln ' - astnode.loc.start.line","location":{"start":{"line":84,"column":38},"end":{"line":84,"column":197}},"range":[4230,4389],"originalLines":"                            log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);","mutatedLines":"                            log.debug('The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') + ' between (Ln ' - astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') + ' between (Ln ' + astnode.loc.start.line - ', Col '","location":{"start":{"line":84,"column":38},"end":{"line":84,"column":208}},"range":[4230,4400],"originalLines":"                            log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);","mutatedLines":"                            log.debug('The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') + ' between (Ln ' + astnode.loc.start.line - ', Col ' + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') + ' between (Ln ' + astnode.loc.start.line + ', Col ' - astnode.loc.start.column","location":{"start":{"line":84,"column":38},"end":{"line":84,"column":235}},"range":[4230,4427],"originalLines":"                            log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);","mutatedLines":"                            log.debug('The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') + ' between (Ln ' + astnode.loc.start.line + ', Col ' - astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') + ' between (Ln ' + astnode.loc.start.line + ', Col ' + astnode.loc.start.column - ') and (Ln '","location":{"start":{"line":84,"column":38},"end":{"line":84,"column":250}},"range":[4230,4442],"originalLines":"                            log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);","mutatedLines":"                            log.debug('The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') + ' between (Ln ' + astnode.loc.start.line + ', Col ' + astnode.loc.start.column - ') and (Ln ' + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') + ' between (Ln ' + astnode.loc.start.line + ', Col ' + astnode.loc.start.column + ') and (Ln ' - astnode.loc.end.line","location":{"start":{"line":84,"column":38},"end":{"line":84,"column":273}},"range":[4230,4465],"originalLines":"                            log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);","mutatedLines":"                            log.debug('The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') + ' between (Ln ' + astnode.loc.start.line + ', Col ' + astnode.loc.start.column + ') and (Ln ' - astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') + ' between (Ln ' + astnode.loc.start.line + ', Col ' + astnode.loc.start.column + ') and (Ln ' + astnode.loc.end.line - ', Col '","location":{"start":{"line":84,"column":38},"end":{"line":84,"column":284}},"range":[4230,4476],"originalLines":"                            log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);","mutatedLines":"                            log.debug('The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') + ' between (Ln ' + astnode.loc.start.line + ', Col ' + astnode.loc.start.column + ') and (Ln ' + astnode.loc.end.line - ', Col ' + astnode.loc.end.column + \") in file \" + sourceFile);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') + ' between (Ln ' + astnode.loc.start.line + ', Col ' + astnode.loc.start.column + ') and (Ln ' + astnode.loc.end.line + ', Col ' - astnode.loc.end.column","location":{"start":{"line":84,"column":38},"end":{"line":84,"column":309}},"range":[4230,4501],"originalLines":"                            log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);","mutatedLines":"                            log.debug('The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') + ' between (Ln ' + astnode.loc.start.line + ', Col ' + astnode.loc.start.column + ') and (Ln ' + astnode.loc.end.line + ', Col ' - astnode.loc.end.column + \") in file \" + sourceFile);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') + ' between (Ln ' + astnode.loc.start.line + ', Col ' + astnode.loc.start.column + ') and (Ln ' + astnode.loc.end.line + ', Col ' + astnode.loc.end.column - ') in file '","location":{"start":{"line":84,"column":38},"end":{"line":84,"column":324}},"range":[4230,4516],"originalLines":"                            log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);","mutatedLines":"                            log.debug('The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') + ' between (Ln ' + astnode.loc.start.line + ', Col ' + astnode.loc.start.column + ') and (Ln ' + astnode.loc.end.line + ', Col ' + astnode.loc.end.column - ') in file ' + sourceFile);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') + ' between (Ln ' + astnode.loc.start.line + ', Col ' + astnode.loc.start.column + ') and (Ln ' + astnode.loc.end.line + ', Col ' + astnode.loc.end.column + ') in file ' - sourceFile","location":{"start":{"line":84,"column":38},"end":{"line":84,"column":337}},"range":[4230,4529],"originalLines":"                            log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);","mutatedLines":"                            log.debug('The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') + ' between (Ln ' + astnode.loc.start.line + ', Col ' + astnode.loc.start.column + ') and (Ln ' + astnode.loc.end.line + ', Col ' + astnode.loc.end.column + ') in file ' - sourceFile);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":83,"column":53},"end":{"line":85,"column":25}},"range":[4189,4558],"originalLines":"                        if (mutatedNodes.length > 0) {\r\n                            log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);\r\n                        }","mutatedLines":"                        if (mutatedNodes.length > 0) {\n}"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"ReverseConditional","status":1,"replacement":"mutatedNodes.length <= 0","location":{"start":{"line":83,"column":28},"end":{"line":83,"column":51}},"range":[4164,4187],"originalLines":"                        if (mutatedNodes.length > 0) {","mutatedLines":"                        if (mutatedNodes.length <= 0) {"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"ConditionalBoundary","status":1,"replacement":"mutatedNodes.length >= 0","location":{"start":{"line":83,"column":28},"end":{"line":83,"column":51}},"range":[4164,4187],"originalLines":"                        if (mutatedNodes.length > 0) {","mutatedLines":"                        if (mutatedNodes.length >= 0) {"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":83,"column":28},"end":{"line":83,"column":51}},"range":[4164,4187],"originalLines":"                        if (mutatedNodes.length > 0) {","mutatedLines":"                        if (true) {"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":83,"column":28},"end":{"line":83,"column":51}},"range":[4164,4187],"originalLines":"                        if (mutatedNodes.length > 0) {","mutatedLines":"                        if (false) {"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":80,"column":102},"end":{"line":82,"column":25}},"range":[4021,4132],"originalLines":"                        var mutatedNodes = mutator.applyMutations(astnode, function (node, deepClone) {\r\n                            return deepClone ? _.cloneDeep(node) : _.clone(node);\r\n                        });","mutatedLines":"                        var mutatedNodes = mutator.applyMutations(astnode, function (node, deepClone) {\n});"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":79,"column":24},"end":{"line":91,"column":21}},"range":[3916,4994],"originalLines":"                    try {\r\n                        var mutatedNodes = mutator.applyMutations(astnode, function (node, deepClone) {\r\n                            return deepClone ? _.cloneDeep(node) : _.clone(node);\r\n                        });\r\n                        if (mutatedNodes.length > 0) {\r\n                            log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);\r\n                        }\r\n                        mutatedNodes.forEach(function (mutatedNode) {\r\n                            var mutatedCode = parserUtils.generate(mutatedNode);\r\n                            var originalNode = nodes[mutatedNode.nodeID];\r\n                            mutants.push(new Mutant_1.default(mutator.name, sourceFile, originalCode, mutatedCode, originalNode.loc, originalNode.range));\r\n                        });\r\n                    }","mutatedLines":"                    try {\n}"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":78,"column":58},"end":{"line":95,"column":17}},"range":[3889,5185],"originalLines":"                _this.mutators.forEach(function (mutator) {\r\n                    try {\r\n                        var mutatedNodes = mutator.applyMutations(astnode, function (node, deepClone) {\r\n                            return deepClone ? _.cloneDeep(node) : _.clone(node);\r\n                        });\r\n                        if (mutatedNodes.length > 0) {\r\n                            log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);\r\n                        }\r\n                        mutatedNodes.forEach(function (mutatedNode) {\r\n                            var mutatedCode = parserUtils.generate(mutatedNode);\r\n                            var originalNode = nodes[mutatedNode.nodeID];\r\n                            mutants.push(new Mutant_1.default(mutator.name, sourceFile, originalCode, mutatedCode, originalNode.loc, originalNode.range));\r\n                        });\r\n                    }\r\n                    catch (error) {\r\n                        throw new Error(\"The mutator named '\" + mutator.name + \"' caused an error: \" + error);\r\n                    }\r\n                });","mutatedLines":"                _this.mutators.forEach(function (mutator) {\n});"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":76,"column":30},"end":{"line":96,"column":13}},"range":[3787,5202],"originalLines":"            if (astnode.type) {\r\n                Object.freeze(astnode);\r\n                _this.mutators.forEach(function (mutator) {\r\n                    try {\r\n                        var mutatedNodes = mutator.applyMutations(astnode, function (node, deepClone) {\r\n                            return deepClone ? _.cloneDeep(node) : _.clone(node);\r\n                        });\r\n                        if (mutatedNodes.length > 0) {\r\n                            log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);\r\n                        }\r\n                        mutatedNodes.forEach(function (mutatedNode) {\r\n                            var mutatedCode = parserUtils.generate(mutatedNode);\r\n                            var originalNode = nodes[mutatedNode.nodeID];\r\n                            mutants.push(new Mutant_1.default(mutator.name, sourceFile, originalCode, mutatedCode, originalNode.loc, originalNode.range));\r\n                        });\r\n                    }\r\n                    catch (error) {\r\n                        throw new Error(\"The mutator named '\" + mutator.name + \"' caused an error: \" + error);\r\n                    }\r\n                });\r\n            }","mutatedLines":"            if (astnode.type) {\n}"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":76,"column":16},"end":{"line":76,"column":28}},"range":[3773,3785],"originalLines":"            if (astnode.type) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":76,"column":16},"end":{"line":76,"column":28}},"range":[3773,3785],"originalLines":"            if (astnode.type) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":75,"column":41},"end":{"line":97,"column":9}},"range":[3754,5213],"originalLines":"        nodes.forEach(function (astnode) {\r\n            if (astnode.type) {\r\n                Object.freeze(astnode);\r\n                _this.mutators.forEach(function (mutator) {\r\n                    try {\r\n                        var mutatedNodes = mutator.applyMutations(astnode, function (node, deepClone) {\r\n                            return deepClone ? _.cloneDeep(node) : _.clone(node);\r\n                        });\r\n                        if (mutatedNodes.length > 0) {\r\n                            log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);\r\n                        }\r\n                        mutatedNodes.forEach(function (mutatedNode) {\r\n                            var mutatedCode = parserUtils.generate(mutatedNode);\r\n                            var originalNode = nodes[mutatedNode.nodeID];\r\n                            mutants.push(new Mutant_1.default(mutator.name, sourceFile, originalCode, mutatedCode, originalNode.loc, originalNode.range));\r\n                        });\r\n                    }\r\n                    catch (error) {\r\n                        throw new Error(\"The mutator named '\" + mutator.name + \"' caused an error: \" + error);\r\n                    }\r\n                });\r\n            }\r\n        });","mutatedLines":"        nodes.forEach(function (astnode) {\n});"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":72,"column":96},"end":{"line":99,"column":5}},"range":[3656,5247],"originalLines":"    MutatorOrchestrator.prototype.findMutants = function (sourceFile, originalCode, ast, nodes) {\r\n        var _this = this;\r\n        var mutants = [];\r\n        nodes.forEach(function (astnode) {\r\n            if (astnode.type) {\r\n                Object.freeze(astnode);\r\n                _this.mutators.forEach(function (mutator) {\r\n                    try {\r\n                        var mutatedNodes = mutator.applyMutations(astnode, function (node, deepClone) {\r\n                            return deepClone ? _.cloneDeep(node) : _.clone(node);\r\n                        });\r\n                        if (mutatedNodes.length > 0) {\r\n                            log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);\r\n                        }\r\n                        mutatedNodes.forEach(function (mutatedNode) {\r\n                            var mutatedCode = parserUtils.generate(mutatedNode);\r\n                            var originalNode = nodes[mutatedNode.nodeID];\r\n                            mutants.push(new Mutant_1.default(mutator.name, sourceFile, originalCode, mutatedCode, originalNode.loc, originalNode.range));\r\n                        });\r\n                    }\r\n                    catch (error) {\r\n                        throw new Error(\"The mutator named '\" + mutator.name + \"' caused an error: \" + error);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n        return mutants;\r\n    };","mutatedLines":"    MutatorOrchestrator.prototype.findMutants = function (sourceFile, originalCode, ast, nodes) {\n};"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":63,"column":72},"end":{"line":71,"column":5}},"range":[2969,3557],"originalLines":"    MutatorOrchestrator.prototype.registerDefaultMutators = function () {\r\n        var mutatorFactory = mutant_1.MutatorFactory.instance();\r\n        mutatorFactory.register('BlockStatement', BlockStatementMutator_1.default);\r\n        mutatorFactory.register('ConditionalBoundary', ConditionalBoundaryMutator_1.default);\r\n        mutatorFactory.register('Math', MathMutator_1.default);\r\n        mutatorFactory.register('RemoveConditionals', RemoveConditionalsMutator_1.default);\r\n        mutatorFactory.register('ReverseConditional', ReverseConditionalMutator_1.default);\r\n        mutatorFactory.register('UnaryOperator', UnaryOperatorMutator_1.default);\r\n    };","mutatedLines":"    MutatorOrchestrator.prototype.registerDefaultMutators = function () {\n};"},{"sourceFilePath":"/stryker/src/mutators/ReverseConditionalMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":2,"column":60},"end":{"line":6,"column":1}},"range":[75,275],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation \"before each\" hook for \"should return an array with a single mutant\"","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};","mutatedLines":"var __extends = (this && this.__extends) || function (d, b) {\n};"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":59,"column":67},"end":{"line":62,"column":5}},"range":[2763,2894],"originalLines":"    MutatorOrchestrator.prototype.reportAllFilesRead = function () {\r\n        objectUtils_1.freezeRecursively(this.sourceFiles);\r\n        this.reporter.onAllSourceFilesRead(this.sourceFiles);\r\n    };","mutatedLines":"    MutatorOrchestrator.prototype.reportAllFilesRead = function () {\n};"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'Skipping file ' - err.path","location":{"start":{"line":41,"column":33},"end":{"line":41,"column":60}},"range":[2064,2091],"originalLines":"                        log.info(\"Skipping file \" + err.path + \" because it does not exist\");","mutatedLines":"                        log.info('Skipping file ' - err.path + \" because it does not exist\");"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"Math","status":1,"replacement":"'Skipping file ' + err.path - ' because it does not exist'","location":{"start":{"line":41,"column":33},"end":{"line":41,"column":91}},"range":[2064,2122],"originalLines":"                        log.info(\"Skipping file \" + err.path + \" because it does not exist\");","mutatedLines":"                        log.info('Skipping file ' + err.path - ' because it does not exist');"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":38,"column":24},"end":{"line":47,"column":13}},"range":[1955,2299],"originalLines":"            catch (err) {\r\n                switch (err.code) {\r\n                    case 'ENOENT':\r\n                        log.info(\"Skipping file \" + err.path + \" because it does not exist\");\r\n                        break;\r\n                    default:\r\n                        console.log(err);\r\n                        throw err;\r\n                }\r\n            }","mutatedLines":"            catch (err) {\n}"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":30,"column":16},"end":{"line":37,"column":13}},"range":[1467,1929],"originalLines":"            try {\r\n                var fileContent = fileUtils.readFile(sourceFile);\r\n                _this.reportFileRead(sourceFile, fileContent);\r\n                var abstractSyntaxTree = parserUtils.parse(fileContent);\r\n                var nodes = parserUtils.collectFrozenNodes(abstractSyntaxTree);\r\n                var newMutants = _this.findMutants(sourceFile, fileContent, abstractSyntaxTree, nodes);\r\n                mutants = mutants.concat(newMutants);\r\n            }","mutatedLines":"            try {\n}"},{"sourceFilePath":"/stryker/src/mutators/RemoveConditionalsMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":26,"column":68},"end":{"line":28,"column":5}},"range":[1188,1260],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"    RemoveConditionalsMutator.prototype.canMutate = function (node) {\r\n        return !!(node && this.types.indexOf(node.type) >= 0);\r\n    };","mutatedLines":"    RemoveConditionalsMutator.prototype.canMutate = function (node) {\n};"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":29,"column":50},"end":{"line":48,"column":9}},"range":[1448,2310],"originalLines":"        sourceFiles.forEach(function (sourceFile) {\r\n            try {\r\n                var fileContent = fileUtils.readFile(sourceFile);\r\n                _this.reportFileRead(sourceFile, fileContent);\r\n                var abstractSyntaxTree = parserUtils.parse(fileContent);\r\n                var nodes = parserUtils.collectFrozenNodes(abstractSyntaxTree);\r\n                var newMutants = _this.findMutants(sourceFile, fileContent, abstractSyntaxTree, nodes);\r\n                mutants = mutants.concat(newMutants);\r\n            }\r\n            catch (err) {\r\n                switch (err.code) {\r\n                    case 'ENOENT':\r\n                        log.info(\"Skipping file \" + err.path + \" because it does not exist\");\r\n                        break;\r\n                    default:\r\n                        console.log(err);\r\n                        throw err;\r\n                }\r\n            }\r\n        });","mutatedLines":"        sourceFiles.forEach(function (sourceFile) {\n});"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":23,"column":60},"end":{"line":23,"column":126}},"range":[1157,1223],"originalLines":"        mutatorFactory.knownNames().forEach(function (name) { return _this.mutators.push(mutatorFactory.create(name, null)); });","mutatedLines":"        mutatorFactory.knownNames().forEach(function (name) {\n});"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":17,"column":43},"end":{"line":24,"column":5}},"range":[896,1232],"originalLines":"    function MutatorOrchestrator(reporter) {\r\n        var _this = this;\r\n        this.reporter = reporter;\r\n        this.mutators = [];\r\n        this.registerDefaultMutators();\r\n        var mutatorFactory = mutant_1.MutatorFactory.instance();\r\n        mutatorFactory.knownNames().forEach(function (name) { return _this.mutators.push(mutatorFactory.create(name, null)); });\r\n    }","mutatedLines":"    function MutatorOrchestrator(reporter) {\n}"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":16,"column":39},"end":{"line":102,"column":1}},"range":[850,5291],"originalLines":"var MutatorOrchestrator = (function () {\r\n    function MutatorOrchestrator(reporter) {\r\n        var _this = this;\r\n        this.reporter = reporter;\r\n        this.mutators = [];\r\n        this.registerDefaultMutators();\r\n        var mutatorFactory = mutant_1.MutatorFactory.instance();\r\n        mutatorFactory.knownNames().forEach(function (name) { return _this.mutators.push(mutatorFactory.create(name, null)); });\r\n    }\r\n    MutatorOrchestrator.prototype.generateMutants = function (sourceFiles) {\r\n        var _this = this;\r\n        var mutants = [];\r\n        this.sourceFiles = [];\r\n        sourceFiles.forEach(function (sourceFile) {\r\n            try {\r\n                var fileContent = fileUtils.readFile(sourceFile);\r\n                _this.reportFileRead(sourceFile, fileContent);\r\n                var abstractSyntaxTree = parserUtils.parse(fileContent);\r\n                var nodes = parserUtils.collectFrozenNodes(abstractSyntaxTree);\r\n                var newMutants = _this.findMutants(sourceFile, fileContent, abstractSyntaxTree, nodes);\r\n                mutants = mutants.concat(newMutants);\r\n            }\r\n            catch (err) {\r\n                switch (err.code) {\r\n                    case 'ENOENT':\r\n                        log.info(\"Skipping file \" + err.path + \" because it does not exist\");\r\n                        break;\r\n                    default:\r\n                        console.log(err);\r\n                        throw err;\r\n                }\r\n            }\r\n        });\r\n        this.reportAllFilesRead();\r\n        return mutants;\r\n    };\r\n    ;\r\n    MutatorOrchestrator.prototype.reportFileRead = function (path, content) {\r\n        var fileToReport = { path: path, content: content };\r\n        objectUtils_1.freezeRecursively(fileToReport);\r\n        this.sourceFiles.push(fileToReport);\r\n        this.reporter.onSourceFileRead(fileToReport);\r\n    };\r\n    MutatorOrchestrator.prototype.reportAllFilesRead = function () {\r\n        objectUtils_1.freezeRecursively(this.sourceFiles);\r\n        this.reporter.onAllSourceFilesRead(this.sourceFiles);\r\n    };\r\n    MutatorOrchestrator.prototype.registerDefaultMutators = function () {\r\n        var mutatorFactory = mutant_1.MutatorFactory.instance();\r\n        mutatorFactory.register('BlockStatement', BlockStatementMutator_1.default);\r\n        mutatorFactory.register('ConditionalBoundary', ConditionalBoundaryMutator_1.default);\r\n        mutatorFactory.register('Math', MathMutator_1.default);\r\n        mutatorFactory.register('RemoveConditionals', RemoveConditionalsMutator_1.default);\r\n        mutatorFactory.register('ReverseConditional', ReverseConditionalMutator_1.default);\r\n        mutatorFactory.register('UnaryOperator', UnaryOperatorMutator_1.default);\r\n    };\r\n    MutatorOrchestrator.prototype.findMutants = function (sourceFile, originalCode, ast, nodes) {\r\n        var _this = this;\r\n        var mutants = [];\r\n        nodes.forEach(function (astnode) {\r\n            if (astnode.type) {\r\n                Object.freeze(astnode);\r\n                _this.mutators.forEach(function (mutator) {\r\n                    try {\r\n                        var mutatedNodes = mutator.applyMutations(astnode, function (node, deepClone) {\r\n                            return deepClone ? _.cloneDeep(node) : _.clone(node);\r\n                        });\r\n                        if (mutatedNodes.length > 0) {\r\n                            log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);\r\n                        }\r\n                        mutatedNodes.forEach(function (mutatedNode) {\r\n                            var mutatedCode = parserUtils.generate(mutatedNode);\r\n                            var originalNode = nodes[mutatedNode.nodeID];\r\n                            mutants.push(new Mutant_1.default(mutator.name, sourceFile, originalCode, mutatedCode, originalNode.loc, originalNode.range));\r\n                        });\r\n                    }\r\n                    catch (error) {\r\n                        throw new Error(\"The mutator named '\" + mutator.name + \"' caused an error: \" + error);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n        return mutants;\r\n    };\r\n    ;\r\n    return MutatorOrchestrator;\r\n}());","mutatedLines":"var MutatorOrchestrator = (function () {\n}());"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"ReverseConditional","status":1,"replacement":"mutantIsAfterStart || mutantIsBeforeEnd","location":{"start":{"line":62,"column":15},"end":{"line":62,"column":54}},"range":[3150,3189],"originalLines":"        return mutantIsAfterStart && mutantIsBeforeEnd;","mutatedLines":"        return mutantIsAfterStart || mutantIsBeforeEnd;"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"ReverseConditional","status":1,"replacement":"mutant.location.start.column > location.end.column","location":{"start":{"line":61,"column":65},"end":{"line":61,"column":116}},"range":[3080,3131],"originalLines":"            (mutant.location.start.line === location.end.line && mutant.location.start.column <= location.end.column);","mutatedLines":"            (mutant.location.start.line === location.end.line && mutant.location.start.column > location.end.column);"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"ConditionalBoundary","status":1,"replacement":"mutant.location.start.column < location.end.column","location":{"start":{"line":61,"column":65},"end":{"line":61,"column":116}},"range":[3080,3131],"originalLines":"            (mutant.location.start.line === location.end.line && mutant.location.start.column <= location.end.column);","mutatedLines":"            (mutant.location.start.line === location.end.line && mutant.location.start.column < location.end.column);"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"ReverseConditional","status":1,"replacement":"mutant.location.start.line !== location.end.line","location":{"start":{"line":61,"column":13},"end":{"line":61,"column":61}},"range":[3028,3076],"originalLines":"            (mutant.location.start.line === location.end.line && mutant.location.start.column <= location.end.column);","mutatedLines":"            (mutant.location.start.line !== location.end.line && mutant.location.start.column <= location.end.column);"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"ReverseConditional","status":1,"replacement":"mutant.location.start.line === location.end.line || mutant.location.start.column <= location.end.column","location":{"start":{"line":61,"column":13},"end":{"line":61,"column":116}},"range":[3028,3131],"originalLines":"            (mutant.location.start.line === location.end.line && mutant.location.start.column <= location.end.column);","mutatedLines":"            (mutant.location.start.line === location.end.line || mutant.location.start.column <= location.end.column);"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"ReverseConditional","status":1,"replacement":"mutant.location.start.line >= location.end.line","location":{"start":{"line":60,"column":32},"end":{"line":60,"column":78}},"range":[2964,3010],"originalLines":"        var mutantIsBeforeEnd = mutant.location.start.line < location.end.line ||","mutatedLines":"        var mutantIsBeforeEnd = mutant.location.start.line >= location.end.line ||"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"ConditionalBoundary","status":1,"replacement":"mutant.location.start.line <= location.end.line","location":{"start":{"line":60,"column":32},"end":{"line":60,"column":78}},"range":[2964,3010],"originalLines":"        var mutantIsBeforeEnd = mutant.location.start.line < location.end.line ||","mutatedLines":"        var mutantIsBeforeEnd = mutant.location.start.line <= location.end.line ||"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"ReverseConditional","status":1,"replacement":"mutant.location.start.line < location.end.line && (mutant.location.start.line === location.end.line && mutant.location.start.column <= location.end.column)","location":{"start":{"line":60,"column":32},"end":{"line":61,"column":117}},"range":[2964,3132],"originalLines":"        var mutantIsBeforeEnd = mutant.location.start.line < location.end.line ||\r\n            (mutant.location.start.line === location.end.line && mutant.location.start.column <= location.end.column);","mutatedLines":"        var mutantIsBeforeEnd = mutant.location.start.line < location.end.line && (mutant.location.start.line === location.end.line && mutant.location.start.column <= location.end.column);"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"ReverseConditional","status":1,"replacement":"mutant.location.end.column < location.start.column","location":{"start":{"line":59,"column":65},"end":{"line":59,"column":116}},"range":[2877,2928],"originalLines":"            (mutant.location.end.line === location.start.line && mutant.location.end.column >= location.start.column);","mutatedLines":"            (mutant.location.end.line === location.start.line && mutant.location.end.column < location.start.column);"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"ConditionalBoundary","status":1,"replacement":"mutant.location.end.column > location.start.column","location":{"start":{"line":59,"column":65},"end":{"line":59,"column":116}},"range":[2877,2928],"originalLines":"            (mutant.location.end.line === location.start.line && mutant.location.end.column >= location.start.column);","mutatedLines":"            (mutant.location.end.line === location.start.line && mutant.location.end.column > location.start.column);"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"ReverseConditional","status":1,"replacement":"mutant.location.end.line !== location.start.line","location":{"start":{"line":59,"column":13},"end":{"line":59,"column":61}},"range":[2825,2873],"originalLines":"            (mutant.location.end.line === location.start.line && mutant.location.end.column >= location.start.column);","mutatedLines":"            (mutant.location.end.line !== location.start.line && mutant.location.end.column >= location.start.column);"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"ReverseConditional","status":1,"replacement":"mutant.location.end.line === location.start.line || mutant.location.end.column >= location.start.column","location":{"start":{"line":59,"column":13},"end":{"line":59,"column":116}},"range":[2825,2928],"originalLines":"            (mutant.location.end.line === location.start.line && mutant.location.end.column >= location.start.column);","mutatedLines":"            (mutant.location.end.line === location.start.line || mutant.location.end.column >= location.start.column);"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"ReverseConditional","status":1,"replacement":"mutant.location.end.line <= location.start.line","location":{"start":{"line":58,"column":33},"end":{"line":58,"column":79}},"range":[2761,2807],"originalLines":"        var mutantIsAfterStart = mutant.location.end.line > location.start.line ||","mutatedLines":"        var mutantIsAfterStart = mutant.location.end.line <= location.start.line ||"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"ConditionalBoundary","status":1,"replacement":"mutant.location.end.line >= location.start.line","location":{"start":{"line":58,"column":33},"end":{"line":58,"column":79}},"range":[2761,2807],"originalLines":"        var mutantIsAfterStart = mutant.location.end.line > location.start.line ||","mutatedLines":"        var mutantIsAfterStart = mutant.location.end.line >= location.start.line ||"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"ReverseConditional","status":1,"replacement":"mutant.location.end.line > location.start.line && (mutant.location.end.line === location.start.line && mutant.location.end.column >= location.start.column)","location":{"start":{"line":58,"column":33},"end":{"line":59,"column":117}},"range":[2761,2929],"originalLines":"        var mutantIsAfterStart = mutant.location.end.line > location.start.line ||\r\n            (mutant.location.end.line === location.start.line && mutant.location.end.column >= location.start.column);","mutatedLines":"        var mutantIsAfterStart = mutant.location.end.line > location.start.line && (mutant.location.end.line === location.start.line && mutant.location.end.column >= location.start.column);"},{"sourceFilePath":"/stryker/src/mutators/MathMutator.js","mutatorName":"RemoveConditionals","status":2,"replacement":"false","location":{"start":{"line":3,"column":25},"end":{"line":3,"column":44}},"range":[103,122],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];","mutatedLines":"    for (var p in b) if (false) d[p] = b[p];"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":57,"column":89},"end":{"line":63,"column":5}},"range":[2725,3197],"originalLines":"    MutantRunResultMatcher.prototype.statementCoversMutant = function (mutant, location) {\r\n        var mutantIsAfterStart = mutant.location.end.line > location.start.line ||\r\n            (mutant.location.end.line === location.start.line && mutant.location.end.column >= location.start.column);\r\n        var mutantIsBeforeEnd = mutant.location.start.line < location.end.line ||\r\n            (mutant.location.start.line === location.end.line && mutant.location.start.column <= location.end.column);\r\n        return mutantIsAfterStart && mutantIsBeforeEnd;\r\n    };","mutatedLines":"    MutantRunResultMatcher.prototype.statementCoversMutant = function (mutant, location) {\n};"},{"sourceFilePath":"/stryker/src/mutators/ConditionalBoundaryMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":11,"column":41},"end":{"line":18,"column":5}},"range":[516,721],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation \"before each\" hook for \"should return an array with a single mutant\"","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"    function ConditionalBoundayMutator() {\r\n        _super.call(this, 'ConditionalBoundary', [esprima_1.Syntax.BinaryExpression], {\r\n            '<': '<=',\r\n            '<=': '<',\r\n            '>': '>=',\r\n            '>=': '>'\r\n        });\r\n    }","mutatedLines":"    function ConditionalBoundayMutator() {\n}"},{"sourceFilePath":"/stryker/src/mutators/MathMutator.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":4,"column":18},"end":{"line":4,"column":43}},"range":[156,181],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"    function __() { this.constructor = d; }","mutatedLines":"    function __() {\n}"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":51,"column":16},"end":{"line":51,"column":52}},"range":[2461,2497],"originalLines":"            if (coversLessLines || coversLessColumns) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"Math","status":1,"replacement":"originalLocation.end.column + newLocation.end.column","location":{"start":{"line":50,"column":122},"end":{"line":50,"column":174}},"range":[2385,2437],"originalLines":"            var coversLessColumns = lineDifference === 0 && (newLocation.start.column - originalLocation.start.column) + (originalLocation.end.column - newLocation.end.column) > 0;","mutatedLines":"            var coversLessColumns = lineDifference === 0 && (newLocation.start.column - originalLocation.start.column) + (originalLocation.end.column + newLocation.end.column) > 0;"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"Math","status":1,"replacement":"newLocation.start.column + originalLocation.start.column","location":{"start":{"line":50,"column":61},"end":{"line":50,"column":117}},"range":[2324,2380],"originalLines":"            var coversLessColumns = lineDifference === 0 && (newLocation.start.column - originalLocation.start.column) + (originalLocation.end.column - newLocation.end.column) > 0;","mutatedLines":"            var coversLessColumns = lineDifference === 0 && (newLocation.start.column + originalLocation.start.column) + (originalLocation.end.column - newLocation.end.column) > 0;"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"Math","status":1,"replacement":"newLocation.start.column - originalLocation.start.column - (originalLocation.end.column - newLocation.end.column)","location":{"start":{"line":50,"column":60},"end":{"line":50,"column":175}},"range":[2323,2438],"originalLines":"            var coversLessColumns = lineDifference === 0 && (newLocation.start.column - originalLocation.start.column) + (originalLocation.end.column - newLocation.end.column) > 0;","mutatedLines":"            var coversLessColumns = lineDifference === 0 && newLocation.start.column - originalLocation.start.column - (originalLocation.end.column - newLocation.end.column) > 0;"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"ReverseConditional","status":1,"replacement":"newLocation.start.column - originalLocation.start.column + (originalLocation.end.column - newLocation.end.column) <= 0","location":{"start":{"line":50,"column":60},"end":{"line":50,"column":179}},"range":[2323,2442],"originalLines":"            var coversLessColumns = lineDifference === 0 && (newLocation.start.column - originalLocation.start.column) + (originalLocation.end.column - newLocation.end.column) > 0;","mutatedLines":"            var coversLessColumns = lineDifference === 0 && newLocation.start.column - originalLocation.start.column + (originalLocation.end.column - newLocation.end.column) <= 0;"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"ConditionalBoundary","status":1,"replacement":"newLocation.start.column - originalLocation.start.column + (originalLocation.end.column - newLocation.end.column) >= 0","location":{"start":{"line":50,"column":60},"end":{"line":50,"column":179}},"range":[2323,2442],"originalLines":"            var coversLessColumns = lineDifference === 0 && (newLocation.start.column - originalLocation.start.column) + (originalLocation.end.column - newLocation.end.column) > 0;","mutatedLines":"            var coversLessColumns = lineDifference === 0 && newLocation.start.column - originalLocation.start.column + (originalLocation.end.column - newLocation.end.column) >= 0;"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"ReverseConditional","status":1,"replacement":"lineDifference !== 0","location":{"start":{"line":50,"column":36},"end":{"line":50,"column":56}},"range":[2299,2319],"originalLines":"            var coversLessColumns = lineDifference === 0 && (newLocation.start.column - originalLocation.start.column) + (originalLocation.end.column - newLocation.end.column) > 0;","mutatedLines":"            var coversLessColumns = lineDifference !== 0 && (newLocation.start.column - originalLocation.start.column) + (originalLocation.end.column - newLocation.end.column) > 0;"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"ReverseConditional","status":1,"replacement":"lineDifference === 0 || newLocation.start.column - originalLocation.start.column + (originalLocation.end.column - newLocation.end.column) > 0","location":{"start":{"line":50,"column":36},"end":{"line":50,"column":179}},"range":[2299,2442],"originalLines":"            var coversLessColumns = lineDifference === 0 && (newLocation.start.column - originalLocation.start.column) + (originalLocation.end.column - newLocation.end.column) > 0;","mutatedLines":"            var coversLessColumns = lineDifference === 0 || newLocation.start.column - originalLocation.start.column + (originalLocation.end.column - newLocation.end.column) > 0;"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"ReverseConditional","status":1,"replacement":"lineDifference <= 0","location":{"start":{"line":49,"column":34},"end":{"line":49,"column":52}},"range":[2242,2260],"originalLines":"            var coversLessLines = lineDifference > 0;","mutatedLines":"            var coversLessLines = lineDifference <= 0;"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"ConditionalBoundary","status":1,"replacement":"lineDifference >= 0","location":{"start":{"line":49,"column":34},"end":{"line":49,"column":52}},"range":[2242,2260],"originalLines":"            var coversLessLines = lineDifference > 0;","mutatedLines":"            var coversLessLines = lineDifference >= 0;"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"Math","status":1,"replacement":"newLocation.end.line + newLocation.start.line","location":{"start":{"line":48,"column":94},"end":{"line":48,"column":139}},"range":[2159,2204],"originalLines":"            var lineDifference = (originalLocation.end.line - originalLocation.start.line) - (newLocation.end.line - newLocation.start.line);","mutatedLines":"            var lineDifference = (originalLocation.end.line - originalLocation.start.line) - (newLocation.end.line + newLocation.start.line);"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"Math","status":1,"replacement":"originalLocation.end.line + originalLocation.start.line","location":{"start":{"line":48,"column":34},"end":{"line":48,"column":89}},"range":[2099,2154],"originalLines":"            var lineDifference = (originalLocation.end.line - originalLocation.start.line) - (newLocation.end.line - newLocation.start.line);","mutatedLines":"            var lineDifference = (originalLocation.end.line + originalLocation.start.line) - (newLocation.end.line - newLocation.start.line);"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"Math","status":1,"replacement":"originalLocation.end.line - originalLocation.start.line + (newLocation.end.line - newLocation.start.line)","location":{"start":{"line":48,"column":33},"end":{"line":48,"column":140}},"range":[2098,2205],"originalLines":"            var lineDifference = (originalLocation.end.line - originalLocation.start.line) - (newLocation.end.line - newLocation.start.line);","mutatedLines":"            var lineDifference = originalLocation.end.line - originalLocation.start.line + (newLocation.end.line - newLocation.start.line);"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":47,"column":13},"end":{"line":54,"column":9}},"range":[2062,2580],"originalLines":"        else {\r\n            var lineDifference = (originalLocation.end.line - originalLocation.start.line) - (newLocation.end.line - newLocation.start.line);\r\n            var coversLessLines = lineDifference > 0;\r\n            var coversLessColumns = lineDifference === 0 && (newLocation.start.column - originalLocation.start.column) + (originalLocation.end.column - newLocation.end.column) > 0;\r\n            if (coversLessLines || coversLessColumns) {\r\n                statementIsSmallestStatement = true;\r\n            }\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":44,"column":31},"end":{"line":46,"column":9}},"range":[1985,2047],"originalLines":"        if (!originalLocation) {\r\n            statementIsSmallestStatement = true;\r\n        }","mutatedLines":"        if (!originalLocation) {\n}"},{"sourceFilePath":"/stryker/src/mutators/BlockStatementMutator.js","mutatorName":"ReverseConditional","status":1,"replacement":"this.types.indexOf(node.type) < 0","location":{"start":{"line":18,"column":26},"end":{"line":18,"column":60}},"range":[631,665],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation \"before each\" hook for \"should return an array with a single mutant\"","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"        return !!(node && this.types.indexOf(node.type) >= 0);","mutatedLines":"        return !!(node && this.types.indexOf(node.type) < 0);"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":44,"column":12},"end":{"line":44,"column":29}},"range":[1966,1983],"originalLines":"        if (!originalLocation) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":42,"column":103},"end":{"line":56,"column":5}},"range":[1900,2633],"originalLines":"    MutantRunResultMatcher.prototype.isNewSmallestStatement = function (originalLocation, newLocation) {\r\n        var statementIsSmallestStatement = false;\r\n        if (!originalLocation) {\r\n            statementIsSmallestStatement = true;\r\n        }\r\n        else {\r\n            var lineDifference = (originalLocation.end.line - originalLocation.start.line) - (newLocation.end.line - newLocation.start.line);\r\n            var coversLessLines = lineDifference > 0;\r\n            var coversLessColumns = lineDifference === 0 && (newLocation.start.column - originalLocation.start.column) + (originalLocation.end.column - newLocation.end.column) > 0;\r\n            if (coversLessLines || coversLessColumns) {\r\n                statementIsSmallestStatement = true;\r\n            }\r\n        }\r\n        return statementIsSmallestStatement;\r\n    };","mutatedLines":"    MutantRunResultMatcher.prototype.isNewSmallestStatement = function (originalLocation, newLocation) {\n};"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":36,"column":150},"end":{"line":38,"column":13}},"range":[1673,1739],"originalLines":"            if (_this.statementCoversMutant(mutant, location) && _this.isNewSmallestStatement(coveredFile.statementMap[smallestStatement], location)) {\r\n                smallestStatement = statementId;\r\n            }","mutatedLines":"            if (_this.statementCoversMutant(mutant, location) && _this.isNewSmallestStatement(coveredFile.statementMap[smallestStatement], location)) {\n}"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"ReverseConditional","status":1,"replacement":"_this.statementCoversMutant(mutant, location) || _this.isNewSmallestStatement(coveredFile.statementMap[smallestStatement], location)","location":{"start":{"line":36,"column":16},"end":{"line":36,"column":148}},"range":[1539,1671],"originalLines":"            if (_this.statementCoversMutant(mutant, location) && _this.isNewSmallestStatement(coveredFile.statementMap[smallestStatement], location)) {","mutatedLines":"            if (_this.statementCoversMutant(mutant, location) || _this.isNewSmallestStatement(coveredFile.statementMap[smallestStatement], location)) {"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"Math","status":2,"replacement":"'The mutator named \\'' - mutator.name","location":{"start":{"line":93,"column":40},"end":{"line":93,"column":76}},"range":[5073,5109],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"                        throw new Error(\"The mutator named '\" + mutator.name + \"' caused an error: \" + error);","mutatedLines":"                        throw new Error('The mutator named \\'' - mutator.name + \"' caused an error: \" + error);"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":36,"column":16},"end":{"line":36,"column":148}},"range":[1539,1671],"originalLines":"            if (_this.statementCoversMutant(mutant, location) && _this.isNewSmallestStatement(coveredFile.statementMap[smallestStatement], location)) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":34,"column":77},"end":{"line":39,"column":9}},"range":[1453,1750],"originalLines":"        Object.keys(coveredFile.statementMap).forEach(function (statementId) {\r\n            var location = coveredFile.statementMap[statementId];\r\n            if (_this.statementCoversMutant(mutant, location) && _this.isNewSmallestStatement(coveredFile.statementMap[smallestStatement], location)) {\r\n                smallestStatement = statementId;\r\n            }\r\n        });","mutatedLines":"        Object.keys(coveredFile.statementMap).forEach(function (statementId) {\n});"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":31,"column":100},"end":{"line":41,"column":5}},"range":[1314,1794],"originalLines":"    MutantRunResultMatcher.prototype.findSmallestCoveringStatement = function (mutant, coveredFile) {\r\n        var _this = this;\r\n        var smallestStatement;\r\n        Object.keys(coveredFile.statementMap).forEach(function (statementId) {\r\n            var location = coveredFile.statementMap[statementId];\r\n            if (_this.statementCoversMutant(mutant, location) && _this.isNewSmallestStatement(coveredFile.statementMap[smallestStatement], location)) {\r\n                smallestStatement = statementId;\r\n            }\r\n        });\r\n        return smallestStatement;\r\n    };","mutatedLines":"    MutantRunResultMatcher.prototype.findSmallestCoveringStatement = function (mutant, coveredFile) {\n};"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":25,"column":29},"end":{"line":27,"column":17}},"range":[1089,1174],"originalLines":"                if (covered) {\r\n                    mutant.addRunResultForTest(id, testResult);\r\n                }","mutatedLines":"                if (covered) {\n}"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":25,"column":20},"end":{"line":25,"column":27}},"range":[1080,1087],"originalLines":"                if (covered) {","mutatedLines":"                if (true) {"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":25,"column":20},"end":{"line":25,"column":27}},"range":[1080,1087],"originalLines":"                if (covered) {","mutatedLines":"                if (false) {"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":22,"column":21},"end":{"line":24,"column":17}},"range":[1001,1058],"originalLines":"                else {\r\n                    covered = true;\r\n                }","mutatedLines":"                else {\n}"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"ReverseConditional","status":1,"replacement":"coveredFile.s[smallestStatement] <= 0","location":{"start":{"line":19,"column":34},"end":{"line":19,"column":70}},"range":[899,935],"originalLines":"                        covered = coveredFile.s[smallestStatement] > 0;","mutatedLines":"                        covered = coveredFile.s[smallestStatement] <= 0;"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"ConditionalBoundary","status":1,"replacement":"coveredFile.s[smallestStatement] >= 0","location":{"start":{"line":19,"column":34},"end":{"line":19,"column":70}},"range":[899,935],"originalLines":"                        covered = coveredFile.s[smallestStatement] > 0;","mutatedLines":"                        covered = coveredFile.s[smallestStatement] >= 0;"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":16,"column":48},"end":{"line":18,"column":25}},"range":[728,863],"originalLines":"                        if (!smallestStatement) {\r\n                            smallestStatement = _this.findSmallestCoveringStatement(mutant, coveredFile);\r\n                        }","mutatedLines":"                        if (!smallestStatement) {\n}"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":16,"column":28},"end":{"line":16,"column":46}},"range":[708,726],"originalLines":"                        if (!smallestStatement) {","mutatedLines":"                        if (true) {"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":16,"column":28},"end":{"line":16,"column":46}},"range":[708,726],"originalLines":"                        if (!smallestStatement) {","mutatedLines":"                        if (false) {"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":15,"column":37},"end":{"line":20,"column":21}},"range":[677,959],"originalLines":"                    if (coveredFile) {\r\n                        if (!smallestStatement) {\r\n                            smallestStatement = _this.findSmallestCoveringStatement(mutant, coveredFile);\r\n                        }\r\n                        covered = coveredFile.s[smallestStatement] > 0;\r\n                    }","mutatedLines":"                    if (coveredFile) {\n}"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":15,"column":24},"end":{"line":15,"column":35}},"range":[664,675],"originalLines":"                    if (coveredFile) {","mutatedLines":"                    if (true) {"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":15,"column":24},"end":{"line":15,"column":35}},"range":[664,675],"originalLines":"                    if (coveredFile) {","mutatedLines":"                    if (false) {"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":13,"column":41},"end":{"line":21,"column":17}},"range":[560,978],"originalLines":"                if (testResult.coverage) {\r\n                    var coveredFile = testResult.coverage[mutant.filename];\r\n                    if (coveredFile) {\r\n                        if (!smallestStatement) {\r\n                            smallestStatement = _this.findSmallestCoveringStatement(mutant, coveredFile);\r\n                        }\r\n                        covered = coveredFile.s[smallestStatement] > 0;\r\n                    }\r\n                }","mutatedLines":"                if (testResult.coverage) {\n}"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":13,"column":20},"end":{"line":13,"column":39}},"range":[539,558],"originalLines":"                if (testResult.coverage) {","mutatedLines":"                if (true) {"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":13,"column":20},"end":{"line":13,"column":39}},"range":[539,558],"originalLines":"                if (testResult.coverage) {","mutatedLines":"                if (false) {"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":11,"column":71},"end":{"line":28,"column":13}},"range":[478,1189],"originalLines":"            _this.runResultsByTestId.forEach(function (testResult, id) {\r\n                var covered = false;\r\n                if (testResult.coverage) {\r\n                    var coveredFile = testResult.coverage[mutant.filename];\r\n                    if (coveredFile) {\r\n                        if (!smallestStatement) {\r\n                            smallestStatement = _this.findSmallestCoveringStatement(mutant, coveredFile);\r\n                        }\r\n                        covered = coveredFile.s[smallestStatement] > 0;\r\n                    }\r\n                }\r\n                else {\r\n                    covered = true;\r\n                }\r\n                if (covered) {\r\n                    mutant.addRunResultForTest(id, testResult);\r\n                }\r\n            });","mutatedLines":"            _this.runResultsByTestId.forEach(function (testResult, id) {\n});"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":9,"column":47},"end":{"line":29,"column":9}},"range":[368,1202],"originalLines":"        this.mutants.forEach(function (mutant) {\r\n            var smallestStatement;\r\n            _this.runResultsByTestId.forEach(function (testResult, id) {\r\n                var covered = false;\r\n                if (testResult.coverage) {\r\n                    var coveredFile = testResult.coverage[mutant.filename];\r\n                    if (coveredFile) {\r\n                        if (!smallestStatement) {\r\n                            smallestStatement = _this.findSmallestCoveringStatement(mutant, coveredFile);\r\n                        }\r\n                        covered = coveredFile.s[smallestStatement] > 0;\r\n                    }\r\n                }\r\n                else {\r\n                    covered = true;\r\n                }\r\n                if (covered) {\r\n                    mutant.addRunResultForTest(id, testResult);\r\n                }\r\n            });\r\n        });","mutatedLines":"        this.mutants.forEach(function (mutant) {\n});"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":7,"column":68},"end":{"line":30,"column":5}},"range":[291,1211],"originalLines":"    MutantRunResultMatcher.prototype.matchWithMutants = function () {\r\n        var _this = this;\r\n        this.mutants.forEach(function (mutant) {\r\n            var smallestStatement;\r\n            _this.runResultsByTestId.forEach(function (testResult, id) {\r\n                var covered = false;\r\n                if (testResult.coverage) {\r\n                    var coveredFile = testResult.coverage[mutant.filename];\r\n                    if (coveredFile) {\r\n                        if (!smallestStatement) {\r\n                            smallestStatement = _this.findSmallestCoveringStatement(mutant, coveredFile);\r\n                        }\r\n                        covered = coveredFile.s[smallestStatement] > 0;\r\n                    }\r\n                }\r\n                else {\r\n                    covered = true;\r\n                }\r\n                if (covered) {\r\n                    mutant.addRunResultForTest(id, testResult);\r\n                }\r\n            });\r\n        });\r\n    };","mutatedLines":"    MutantRunResultMatcher.prototype.matchWithMutants = function () {\n};"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":3,"column":65},"end":{"line":6,"column":5}},"range":[125,221],"originalLines":"    function MutantRunResultMatcher(mutants, runResultsByTestId) {\r\n        this.mutants = mutants;\r\n        this.runResultsByTestId = runResultsByTestId;\r\n    }","mutatedLines":"    function MutantRunResultMatcher(mutants, runResultsByTestId) {\n}"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":2,"column":42},"end":{"line":65,"column":1}},"range":[57,3237],"originalLines":"var MutantRunResultMatcher = (function () {\r\n    function MutantRunResultMatcher(mutants, runResultsByTestId) {\r\n        this.mutants = mutants;\r\n        this.runResultsByTestId = runResultsByTestId;\r\n    }\r\n    MutantRunResultMatcher.prototype.matchWithMutants = function () {\r\n        var _this = this;\r\n        this.mutants.forEach(function (mutant) {\r\n            var smallestStatement;\r\n            _this.runResultsByTestId.forEach(function (testResult, id) {\r\n                var covered = false;\r\n                if (testResult.coverage) {\r\n                    var coveredFile = testResult.coverage[mutant.filename];\r\n                    if (coveredFile) {\r\n                        if (!smallestStatement) {\r\n                            smallestStatement = _this.findSmallestCoveringStatement(mutant, coveredFile);\r\n                        }\r\n                        covered = coveredFile.s[smallestStatement] > 0;\r\n                    }\r\n                }\r\n                else {\r\n                    covered = true;\r\n                }\r\n                if (covered) {\r\n                    mutant.addRunResultForTest(id, testResult);\r\n                }\r\n            });\r\n        });\r\n    };\r\n    MutantRunResultMatcher.prototype.findSmallestCoveringStatement = function (mutant, coveredFile) {\r\n        var _this = this;\r\n        var smallestStatement;\r\n        Object.keys(coveredFile.statementMap).forEach(function (statementId) {\r\n            var location = coveredFile.statementMap[statementId];\r\n            if (_this.statementCoversMutant(mutant, location) && _this.isNewSmallestStatement(coveredFile.statementMap[smallestStatement], location)) {\r\n                smallestStatement = statementId;\r\n            }\r\n        });\r\n        return smallestStatement;\r\n    };\r\n    MutantRunResultMatcher.prototype.isNewSmallestStatement = function (originalLocation, newLocation) {\r\n        var statementIsSmallestStatement = false;\r\n        if (!originalLocation) {\r\n            statementIsSmallestStatement = true;\r\n        }\r\n        else {\r\n            var lineDifference = (originalLocation.end.line - originalLocation.start.line) - (newLocation.end.line - newLocation.start.line);\r\n            var coversLessLines = lineDifference > 0;\r\n            var coversLessColumns = lineDifference === 0 && (newLocation.start.column - originalLocation.start.column) + (originalLocation.end.column - newLocation.end.column) > 0;\r\n            if (coversLessLines || coversLessColumns) {\r\n                statementIsSmallestStatement = true;\r\n            }\r\n        }\r\n        return statementIsSmallestStatement;\r\n    };\r\n    MutantRunResultMatcher.prototype.statementCoversMutant = function (mutant, location) {\r\n        var mutantIsAfterStart = mutant.location.end.line > location.start.line ||\r\n            (mutant.location.end.line === location.start.line && mutant.location.end.column >= location.start.column);\r\n        var mutantIsBeforeEnd = mutant.location.start.line < location.end.line ||\r\n            (mutant.location.start.line === location.end.line && mutant.location.start.column <= location.end.column);\r\n        return mutantIsAfterStart && mutantIsBeforeEnd;\r\n    };\r\n    return MutantRunResultMatcher;\r\n}());","mutatedLines":"var MutantRunResultMatcher = (function () {\n}());"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":76,"column":49},"end":{"line":78,"column":5}},"range":[3072,3164],"originalLines":"    Mutant.prototype.reset = function (filename) {\r\n        return StrykerTempFolder_1.default.writeFile(filename, this.originalCode);\r\n    };","mutatedLines":"    Mutant.prototype.reset = function (filename) {\n};"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":72,"column":48},"end":{"line":74,"column":5}},"range":[2922,3013],"originalLines":"    Mutant.prototype.save = function (filename) {\r\n        return StrykerTempFolder_1.default.writeFile(filename, this.mutatedCode);\r\n    };","mutatedLines":"    Mutant.prototype.save = function (filename) {\n};"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"Math","status":1,"replacement":"this.originalCode.substr(0, this.range[0]) - this.replacement","location":{"start":{"line":67,"column":19},"end":{"line":67,"column":80}},"range":[2692,2753],"originalLines":"            return this.originalCode.substr(0, this.range[0]) + this.replacement + this.originalCode.substr(this.range[1]);","mutatedLines":"            return this.originalCode.substr(0, this.range[0]) - this.replacement + this.originalCode.substr(this.range[1]);"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"Math","status":1,"replacement":"this.originalCode.substr(0, this.range[0]) + this.replacement - this.originalCode.substr(this.range[1])","location":{"start":{"line":67,"column":19},"end":{"line":67,"column":122}},"range":[2692,2795],"originalLines":"            return this.originalCode.substr(0, this.range[0]) + this.replacement + this.originalCode.substr(this.range[1]);","mutatedLines":"            return this.originalCode.substr(0, this.range[0]) + this.replacement - this.originalCode.substr(this.range[1]);"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":66,"column":25},"end":{"line":68,"column":9}},"range":[2670,2807],"originalLines":"        get: function () {\r\n            return this.originalCode.substr(0, this.range[0]) + this.replacement + this.originalCode.substr(this.range[1]);\r\n        },","mutatedLines":"        get: function () {\n},"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"Math","status":1,"replacement":"this.originalCode.substring(startIndex, this.range[0]) - this.replacement","location":{"start":{"line":60,"column":19},"end":{"line":60,"column":92}},"range":[2376,2449],"originalLines":"            return this.originalCode.substring(startIndex, this.range[0]) + this.replacement + this.originalCode.substring(this.range[1], endIndex);","mutatedLines":"            return this.originalCode.substring(startIndex, this.range[0]) - this.replacement + this.originalCode.substring(this.range[1], endIndex);"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"Math","status":1,"replacement":"this.originalCode.substring(startIndex, this.range[0]) + this.replacement - this.originalCode.substring(this.range[1], endIndex)","location":{"start":{"line":60,"column":19},"end":{"line":60,"column":147}},"range":[2376,2504],"originalLines":"            return this.originalCode.substring(startIndex, this.range[0]) + this.replacement + this.originalCode.substring(this.range[1], endIndex);","mutatedLines":"            return this.originalCode.substring(startIndex, this.range[0]) + this.replacement - this.originalCode.substring(this.range[1], endIndex);"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":58,"column":25},"end":{"line":61,"column":9}},"range":[2263,2516],"originalLines":"        get: function () {\r\n            var _a = this.getMutationLineIndexes(), startIndex = _a[0], endIndex = _a[1];\r\n            return this.originalCode.substring(startIndex, this.range[0]) + this.replacement + this.originalCode.substring(this.range[1], endIndex);\r\n        },","mutatedLines":"        get: function () {\n},"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":53,"column":76},"end":{"line":58,"column":5}},"range":[2466,2693],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"    MutatorOrchestrator.prototype.reportFileRead = function (path, content) {\r\n        var fileToReport = { path: path, content: content };\r\n        objectUtils_1.freezeRecursively(fileToReport);\r\n        this.sourceFiles.push(fileToReport);\r\n        this.reporter.onSourceFileRead(fileToReport);\r\n    };","mutatedLines":"    MutatorOrchestrator.prototype.reportFileRead = function (path, content) {\n};"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":50,"column":25},"end":{"line":53,"column":9}},"range":[1934,2108],"originalLines":"        get: function () {\r\n            var _a = this.getMutationLineIndexes(), startIndex = _a[0], endIndex = _a[1];\r\n            return this.originalCode.substring(startIndex, endIndex);\r\n        },","mutatedLines":"        get: function () {\n},"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":44,"column":91},"end":{"line":46,"column":9}},"range":[1743,1785],"originalLines":"        while (endIndexLines < this.originalCode.length && !this.isNewLine(endIndexLines)) {\r\n            endIndexLines++;\r\n        }","mutatedLines":"        while (endIndexLines < this.originalCode.length && !this.isNewLine(endIndexLines)) {\n}"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"ReverseConditional","status":1,"replacement":"endIndexLines >= this.originalCode.length","location":{"start":{"line":44,"column":15},"end":{"line":44,"column":55}},"range":[1667,1707],"originalLines":"        while (endIndexLines < this.originalCode.length && !this.isNewLine(endIndexLines)) {","mutatedLines":"        while (endIndexLines >= this.originalCode.length && !this.isNewLine(endIndexLines)) {"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"ConditionalBoundary","status":1,"replacement":"endIndexLines <= this.originalCode.length","location":{"start":{"line":44,"column":15},"end":{"line":44,"column":55}},"range":[1667,1707],"originalLines":"        while (endIndexLines < this.originalCode.length && !this.isNewLine(endIndexLines)) {","mutatedLines":"        while (endIndexLines <= this.originalCode.length && !this.isNewLine(endIndexLines)) {"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"ReverseConditional","status":1,"replacement":"endIndexLines < this.originalCode.length || !this.isNewLine(endIndexLines)","location":{"start":{"line":44,"column":15},"end":{"line":44,"column":89}},"range":[1667,1741],"originalLines":"        while (endIndexLines < this.originalCode.length && !this.isNewLine(endIndexLines)) {","mutatedLines":"        while (endIndexLines < this.originalCode.length || !this.isNewLine(endIndexLines)) {"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":44,"column":15},"end":{"line":44,"column":89}},"range":[1667,1741],"originalLines":"        while (endIndexLines < this.originalCode.length && !this.isNewLine(endIndexLines)) {","mutatedLines":"        while (false) {"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"UnaryOperator","status":1,"replacement":"startIndexLines++","location":{"start":{"line":42,"column":12},"end":{"line":42,"column":29}},"range":[1621,1638],"originalLines":"            startIndexLines--;","mutatedLines":"            startIndexLines++;"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":41,"column":76},"end":{"line":43,"column":9}},"range":[1606,1650],"originalLines":"        while (startIndexLines > 0 && !this.isNewLine(startIndexLines - 1)) {\r\n            startIndexLines--;\r\n        }","mutatedLines":"        while (startIndexLines > 0 && !this.isNewLine(startIndexLines - 1)) {\n}"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":25,"column":75},"end":{"line":51,"column":5}},"range":[1309,2380],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void \"before each\" hook for \"should resolve the stryker promise\"","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up \"before each\" hook for \"should resolve the stryker promise\"","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"    MutatorOrchestrator.prototype.generateMutants = function (sourceFiles) {\r\n        var _this = this;\r\n        var mutants = [];\r\n        this.sourceFiles = [];\r\n        sourceFiles.forEach(function (sourceFile) {\r\n            try {\r\n                var fileContent = fileUtils.readFile(sourceFile);\r\n                _this.reportFileRead(sourceFile, fileContent);\r\n                var abstractSyntaxTree = parserUtils.parse(fileContent);\r\n                var nodes = parserUtils.collectFrozenNodes(abstractSyntaxTree);\r\n                var newMutants = _this.findMutants(sourceFile, fileContent, abstractSyntaxTree, nodes);\r\n                mutants = mutants.concat(newMutants);\r\n            }\r\n            catch (err) {\r\n                switch (err.code) {\r\n                    case 'ENOENT':\r\n                        log.info(\"Skipping file \" + err.path + \" because it does not exist\");\r\n                        break;\r\n                    default:\r\n                        console.log(err);\r\n                        throw err;\r\n                }\r\n            }\r\n        });\r\n        this.reportAllFilesRead();\r\n        return mutants;\r\n    };","mutatedLines":"    MutatorOrchestrator.prototype.generateMutants = function (sourceFiles) {\n};"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"Math","status":1,"replacement":"startIndexLines + 1","location":{"start":{"line":41,"column":54},"end":{"line":41,"column":73}},"range":[1584,1603],"originalLines":"        while (startIndexLines > 0 && !this.isNewLine(startIndexLines - 1)) {","mutatedLines":"        while (startIndexLines > 0 && !this.isNewLine(startIndexLines + 1)) {"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"ConditionalBoundary","status":1,"replacement":"startIndexLines >= 0","location":{"start":{"line":41,"column":15},"end":{"line":41,"column":34}},"range":[1545,1564],"originalLines":"        while (startIndexLines > 0 && !this.isNewLine(startIndexLines - 1)) {","mutatedLines":"        while (startIndexLines >= 0 && !this.isNewLine(startIndexLines - 1)) {"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"ReverseConditional","status":1,"replacement":"startIndexLines > 0 || !this.isNewLine(startIndexLines - 1)","location":{"start":{"line":41,"column":15},"end":{"line":41,"column":74}},"range":[1545,1604],"originalLines":"        while (startIndexLines > 0 && !this.isNewLine(startIndexLines - 1)) {","mutatedLines":"        while (startIndexLines > 0 || !this.isNewLine(startIndexLines - 1)) {"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":41,"column":15},"end":{"line":41,"column":74}},"range":[1545,1604],"originalLines":"        while (startIndexLines > 0 && !this.isNewLine(startIndexLines - 1)) {","mutatedLines":"        while (false) {"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":39,"column":58},"end":{"line":48,"column":5}},"range":[1450,1842],"originalLines":"    Mutant.prototype.getMutationLineIndexes = function () {\r\n        var startIndexLines = this.range[0], endIndexLines = this.range[1];\r\n        while (startIndexLines > 0 && !this.isNewLine(startIndexLines - 1)) {\r\n            startIndexLines--;\r\n        }\r\n        while (endIndexLines < this.originalCode.length && !this.isNewLine(endIndexLines)) {\r\n            endIndexLines++;\r\n        }\r\n        return [startIndexLines, endIndexLines];\r\n    };","mutatedLines":"    Mutant.prototype.getMutationLineIndexes = function () {\n};"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"ReverseConditional","status":1,"replacement":"char !== '\\r'","location":{"start":{"line":37,"column":32},"end":{"line":37,"column":45}},"range":[1368,1381],"originalLines":"        return char === '\\n' || char === '\\r';","mutatedLines":"        return char === '\\n' || char !== '\\r';"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"ReverseConditional","status":1,"replacement":"char !== '\\n'","location":{"start":{"line":37,"column":15},"end":{"line":37,"column":28}},"range":[1351,1364],"originalLines":"        return char === '\\n' || char === '\\r';","mutatedLines":"        return char !== '\\n' || char === '\\r';"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"ReverseConditional","status":1,"replacement":"char === '\\n' && char === '\\r'","location":{"start":{"line":37,"column":15},"end":{"line":37,"column":45}},"range":[1351,1381],"originalLines":"        return char === '\\n' || char === '\\r';","mutatedLines":"        return char === '\\n' && char === '\\r';"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":35,"column":50},"end":{"line":38,"column":5}},"range":[1287,1389],"originalLines":"    Mutant.prototype.isNewLine = function (index) {\r\n        var char = this.originalCode[index];\r\n        return char === '\\n' || char === '\\r';\r\n    };","mutatedLines":"    Mutant.prototype.isNewLine = function (index) {\n};"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":30,"column":71},"end":{"line":34,"column":5}},"range":[1074,1234],"originalLines":"    Mutant.prototype.addRunResultForTest = function (index, runResult) {\r\n        this._scopedTestIds.push(index);\r\n        this._timeSpentScopedTests += runResult.timeSpent;\r\n        this.scopedTestsById[index] = runResult;\r\n    };","mutatedLines":"    Mutant.prototype.addRunResultForTest = function (index, runResult) {\n};"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":24,"column":25},"end":{"line":26,"column":9}},"range":[876,936],"originalLines":"        get: function () {\r\n            return this._timeSpentScopedTests;\r\n        },","mutatedLines":"        get: function () {\n},"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":17,"column":25},"end":{"line":19,"column":9}},"range":[660,713],"originalLines":"        get: function () {\r\n            return this._scopedTestIds;\r\n        },","mutatedLines":"        get: function () {\n},"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":4,"column":87},"end":{"line":15,"column":5}},"range":[196,569],"originalLines":"    function Mutant(mutatorName, filename, originalCode, replacement, location, range) {\r\n        this.mutatorName = mutatorName;\r\n        this.filename = filename;\r\n        this.originalCode = originalCode;\r\n        this.replacement = replacement;\r\n        this.location = location;\r\n        this.range = range;\r\n        this.scopedTestsById = [];\r\n        this._scopedTestIds = [];\r\n        this.specsRan = [];\r\n        this._timeSpentScopedTests = 0;\r\n    }","mutatedLines":"    function Mutant(mutatorName, filename, originalCode, replacement, location, range) {\n}"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":3,"column":26},"end":{"line":81,"column":1}},"range":[106,3195],"originalLines":"var Mutant = (function () {\r\n    function Mutant(mutatorName, filename, originalCode, replacement, location, range) {\r\n        this.mutatorName = mutatorName;\r\n        this.filename = filename;\r\n        this.originalCode = originalCode;\r\n        this.replacement = replacement;\r\n        this.location = location;\r\n        this.range = range;\r\n        this.scopedTestsById = [];\r\n        this._scopedTestIds = [];\r\n        this.specsRan = [];\r\n        this._timeSpentScopedTests = 0;\r\n    }\r\n    Object.defineProperty(Mutant.prototype, \"scopedTestIds\", {\r\n        get: function () {\r\n            return this._scopedTestIds;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Mutant.prototype, \"timeSpentScopedTests\", {\r\n        get: function () {\r\n            return this._timeSpentScopedTests;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Mutant.prototype.addRunResultForTest = function (index, runResult) {\r\n        this._scopedTestIds.push(index);\r\n        this._timeSpentScopedTests += runResult.timeSpent;\r\n        this.scopedTestsById[index] = runResult;\r\n    };\r\n    Mutant.prototype.isNewLine = function (index) {\r\n        var char = this.originalCode[index];\r\n        return char === '\\n' || char === '\\r';\r\n    };\r\n    Mutant.prototype.getMutationLineIndexes = function () {\r\n        var startIndexLines = this.range[0], endIndexLines = this.range[1];\r\n        while (startIndexLines > 0 && !this.isNewLine(startIndexLines - 1)) {\r\n            startIndexLines--;\r\n        }\r\n        while (endIndexLines < this.originalCode.length && !this.isNewLine(endIndexLines)) {\r\n            endIndexLines++;\r\n        }\r\n        return [startIndexLines, endIndexLines];\r\n    };\r\n    Object.defineProperty(Mutant.prototype, \"originalLines\", {\r\n        get: function () {\r\n            var _a = this.getMutationLineIndexes(), startIndex = _a[0], endIndex = _a[1];\r\n            return this.originalCode.substring(startIndex, endIndex);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Mutant.prototype, \"mutatedLines\", {\r\n        get: function () {\r\n            var _a = this.getMutationLineIndexes(), startIndex = _a[0], endIndex = _a[1];\r\n            return this.originalCode.substring(startIndex, this.range[0]) + this.replacement + this.originalCode.substring(this.range[1], endIndex);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Mutant.prototype, \"mutatedCode\", {\r\n        get: function () {\r\n            return this.originalCode.substr(0, this.range[0]) + this.replacement + this.originalCode.substr(this.range[1]);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Mutant.prototype.save = function (filename) {\r\n        return StrykerTempFolder_1.default.writeFile(filename, this.mutatedCode);\r\n    };\r\n    ;\r\n    Mutant.prototype.reset = function (filename) {\r\n        return StrykerTempFolder_1.default.writeFile(filename, this.originalCode);\r\n    };\r\n    ;\r\n    return Mutant;\r\n}());","mutatedLines":"var Mutant = (function () {\n}());"},{"sourceFilePath":"/stryker/src/jasmine_test_selector/JasmineTestSelector.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":8,"column":58},"end":{"line":10,"column":5}},"range":[584,676],"originalLines":"    JasmineTestSelector.prototype.select = function (ids) {\r\n        return INTERCEPTOR_CODE.replace('%IDS_PLACEHOLDER%', JSON.stringify(ids));\r\n    };","mutatedLines":"    JasmineTestSelector.prototype.select = function (ids) {\n};"},{"sourceFilePath":"/stryker/src/jasmine_test_selector/JasmineTestSelector.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":5,"column":43},"end":{"line":7,"column":5}},"range":[481,524],"originalLines":"    function JasmineTestSelector(settings) {\r\n        this.settings = settings;\r\n    }","mutatedLines":"    function JasmineTestSelector(settings) {\n}"},{"sourceFilePath":"/stryker/src/jasmine_test_selector/JasmineTestSelector.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":4,"column":39},"end":{"line":12,"column":1}},"range":[435,713],"originalLines":"var JasmineTestSelector = (function () {\r\n    function JasmineTestSelector(settings) {\r\n        this.settings = settings;\r\n    }\r\n    JasmineTestSelector.prototype.select = function (ids) {\r\n        return INTERCEPTOR_CODE.replace('%IDS_PLACEHOLDER%', JSON.stringify(ids));\r\n    };\r\n    return JasmineTestSelector;\r\n}());","mutatedLines":"var JasmineTestSelector = (function () {\n}());"},{"sourceFilePath":"/stryker/src/isolated-runner/Message.js","mutatorName":"ReverseConditional","status":1,"replacement":"exports.MessageType && (exports.MessageType = {})","location":{"start":{"line":10,"column":3},"end":{"line":10,"column":52}},"range":[441,490],"originalLines":"})(exports.MessageType || (exports.MessageType = {}));","mutatedLines":"})(exports.MessageType && (exports.MessageType = {}));"},{"sourceFilePath":"/stryker/src/isolated-runner/Message.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":2,"column":24},"end":{"line":10,"column":1}},"range":[39,439],"originalLines":"(function (MessageType) {\r\n    MessageType[MessageType[\"Start\"] = 0] = \"Start\";\r\n    MessageType[MessageType[\"Init\"] = 1] = \"Init\";\r\n    MessageType[MessageType[\"InitDone\"] = 2] = \"InitDone\";\r\n    MessageType[MessageType[\"Run\"] = 3] = \"Run\";\r\n    MessageType[MessageType[\"Result\"] = 4] = \"Result\";\r\n    MessageType[MessageType[\"Dispose\"] = 5] = \"Dispose\";\r\n    MessageType[MessageType[\"DisposeDone\"] = 6] = \"DisposeDone\";\r\n})(exports.MessageType || (exports.MessageType = {}));","mutatedLines":"(function (MessageType) {\n})(exports.MessageType || (exports.MessageType = {}));"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":51,"column":16},"end":{"line":51,"column":52}},"range":[2461,2497],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"            if (coversLessLines || coversLessColumns) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":80,"column":87},"end":{"line":91,"column":5}},"range":[3414,3719],"originalLines":"    TestRunnerChildProcessAdapterWorker.prototype.reportErrorResult = function (error) {\r\n        var message = {\r\n            type: Message_1.MessageType.Result,\r\n            body: {\r\n                result: {\r\n                    testNames: [],\r\n                    result: test_runner_1.TestResult.Error,\r\n                }\r\n            }\r\n        };\r\n        process.send(message);\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapterWorker.prototype.reportErrorResult = function (error) {\n};"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":51,"column":54},"end":{"line":53,"column":13}},"range":[2499,2569],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"            if (coversLessLines || coversLessColumns) {\r\n                statementIsSmallestStatement = true;\r\n            }","mutatedLines":"            if (coversLessLines || coversLessColumns) {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":70,"column":83},"end":{"line":72,"column":5}},"range":[3013,3074],"originalLines":"    TestRunnerChildProcessAdapterWorker.prototype.loadPlugins = function (plugins) {\r\n        new PluginLoader_1.default(plugins).load();\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapterWorker.prototype.loadPlugins = function (plugins) {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":64,"column":80},"end":{"line":66,"column":5}},"range":[2663,2739],"originalLines":"    TestRunnerChildProcessAdapterWorker.prototype.sendDisposeDone = function () {\r\n        process.send({ type: Message_1.MessageType.DisposeDone });\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapterWorker.prototype.sendDisposeDone = function () {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":60,"column":13},"end":{"line":62,"column":9}},"range":[2524,2573],"originalLines":"        else {\r\n            this.sendDisposeDone();\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"ReverseConditional","status":1,"replacement":"coversLessLines && coversLessColumns","location":{"start":{"line":51,"column":16},"end":{"line":51,"column":52}},"range":[2461,2497],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"            if (coversLessLines || coversLessColumns) {","mutatedLines":"            if (coversLessLines && coversLessColumns) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":57,"column":53},"end":{"line":59,"column":9}},"range":[2441,2509],"originalLines":"        if (objectUtils_1.isPromise(disposePromise)) {\r\n            disposePromise.then(this.sendDisposeDone);\r\n        }","mutatedLines":"        if (objectUtils_1.isPromise(disposePromise)) {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":57,"column":12},"end":{"line":57,"column":51}},"range":[2400,2439],"originalLines":"        if (objectUtils_1.isPromise(disposePromise)) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":54,"column":47},"end":{"line":56,"column":9}},"range":[2307,2386],"originalLines":"        if (this.underlyingTestRunner.dispose) {\r\n            disposePromise = this.underlyingTestRunner.dispose();\r\n        }","mutatedLines":"        if (this.underlyingTestRunner.dispose) {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":54,"column":12},"end":{"line":54,"column":45}},"range":[2272,2305],"originalLines":"        if (this.underlyingTestRunner.dispose) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":54,"column":12},"end":{"line":54,"column":45}},"range":[2272,2305],"originalLines":"        if (this.underlyingTestRunner.dispose) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":52,"column":72},"end":{"line":63,"column":5}},"range":[2219,2580],"originalLines":"    TestRunnerChildProcessAdapterWorker.prototype.dispose = function () {\r\n        var disposePromise = void 0;\r\n        if (this.underlyingTestRunner.dispose) {\r\n            disposePromise = this.underlyingTestRunner.dispose();\r\n        }\r\n        if (objectUtils_1.isPromise(disposePromise)) {\r\n            disposePromise.then(this.sendDisposeDone);\r\n        }\r\n        else {\r\n            this.sendDisposeDone();\r\n        }\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapterWorker.prototype.dispose = function () {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":49,"column":77},"end":{"line":51,"column":5}},"range":[2071,2144],"originalLines":"    TestRunnerChildProcessAdapterWorker.prototype.sendInitDone = function () {\r\n        process.send({ type: Message_1.MessageType.InitDone });\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapterWorker.prototype.sendInitDone = function () {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":45,"column":13},"end":{"line":47,"column":9}},"range":[1938,1984],"originalLines":"        else {\r\n            this.sendInitDone();\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":42,"column":50},"end":{"line":44,"column":9}},"range":[1861,1923],"originalLines":"        if (objectUtils_1.isPromise(initPromise)) {\r\n            initPromise.then(this.sendInitDone);\r\n        }","mutatedLines":"        if (objectUtils_1.isPromise(initPromise)) {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":42,"column":12},"end":{"line":42,"column":48}},"range":[1823,1859],"originalLines":"        if (objectUtils_1.isPromise(initPromise)) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":44,"column":12},"end":{"line":44,"column":29}},"range":[1966,1983],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants \"before each\" hook for \"should not have added the run results to the mutants\"","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants \"before each\" hook for \"should have added the run results to the mutants\"","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"        if (!originalLocation) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":42,"column":12},"end":{"line":42,"column":48}},"range":[1823,1859],"originalLines":"        if (objectUtils_1.isPromise(initPromise)) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":39,"column":12},"end":{"line":39,"column":42}},"range":[1704,1734],"originalLines":"        if (this.underlyingTestRunner.init) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":39,"column":12},"end":{"line":39,"column":42}},"range":[1704,1734],"originalLines":"        if (this.underlyingTestRunner.init) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":37,"column":69},"end":{"line":48,"column":5}},"range":[1654,1991],"originalLines":"    TestRunnerChildProcessAdapterWorker.prototype.init = function () {\r\n        var initPromise = void 0;\r\n        if (this.underlyingTestRunner.init) {\r\n            initPromise = this.underlyingTestRunner.init();\r\n        }\r\n        if (objectUtils_1.isPromise(initPromise)) {\r\n            initPromise.then(this.sendInitDone);\r\n        }\r\n        else {\r\n            this.sendInitDone();\r\n        }\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapterWorker.prototype.init = function () {\n};"},{"sourceFilePath":"/stryker/src/MutantRunResultMatcher.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":36,"column":16},"end":{"line":36,"column":148}},"range":[1539,1671],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"            if (_this.statementCoversMutant(mutant, location) && _this.isNewSmallestStatement(coveredFile.statementMap[smallestStatement], location)) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":33,"column":74},"end":{"line":36,"column":5}},"range":[1379,1582],"originalLines":"    TestRunnerChildProcessAdapterWorker.prototype.start = function (body) {\r\n        this.loadPlugins(body.runnerOptions.strykerOptions.plugins);\r\n        this.underlyingTestRunner = test_runner_1.TestRunnerFactory.instance().create(body.runnerName, body.runnerOptions);\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapterWorker.prototype.start = function (body) {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":12,"column":81},"end":{"line":32,"column":5}},"range":[550,1302],"originalLines":"    TestRunnerChildProcessAdapterWorker.prototype.listenToMessages = function () {\r\n        var _this = this;\r\n        process.on('message', function (message) {\r\n            switch (message.type) {\r\n                case Message_1.MessageType.Start:\r\n                    _this.start(message.body);\r\n                    break;\r\n                case Message_1.MessageType.Run:\r\n                    _this.run(message.body);\r\n                    break;\r\n                case Message_1.MessageType.Init:\r\n                    _this.init();\r\n                    break;\r\n                case Message_1.MessageType.Dispose:\r\n                    _this.dispose();\r\n                    break;\r\n                default:\r\n                    log.warn('Received unsupported message: {}', JSON.stringify(message));\r\n            }\r\n        });\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapterWorker.prototype.listenToMessages = function () {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":9,"column":51},"end":{"line":11,"column":5}},"range":[425,467],"originalLines":"    function TestRunnerChildProcessAdapterWorker() {\r\n        this.listenToMessages();\r\n    }","mutatedLines":"    function TestRunnerChildProcessAdapterWorker() {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":8,"column":55},"end":{"line":93,"column":1}},"range":[371,3772],"originalLines":"var TestRunnerChildProcessAdapterWorker = (function () {\r\n    function TestRunnerChildProcessAdapterWorker() {\r\n        this.listenToMessages();\r\n    }\r\n    TestRunnerChildProcessAdapterWorker.prototype.listenToMessages = function () {\r\n        var _this = this;\r\n        process.on('message', function (message) {\r\n            switch (message.type) {\r\n                case Message_1.MessageType.Start:\r\n                    _this.start(message.body);\r\n                    break;\r\n                case Message_1.MessageType.Run:\r\n                    _this.run(message.body);\r\n                    break;\r\n                case Message_1.MessageType.Init:\r\n                    _this.init();\r\n                    break;\r\n                case Message_1.MessageType.Dispose:\r\n                    _this.dispose();\r\n                    break;\r\n                default:\r\n                    log.warn('Received unsupported message: {}', JSON.stringify(message));\r\n            }\r\n        });\r\n    };\r\n    TestRunnerChildProcessAdapterWorker.prototype.start = function (body) {\r\n        this.loadPlugins(body.runnerOptions.strykerOptions.plugins);\r\n        this.underlyingTestRunner = test_runner_1.TestRunnerFactory.instance().create(body.runnerName, body.runnerOptions);\r\n    };\r\n    TestRunnerChildProcessAdapterWorker.prototype.init = function () {\r\n        var initPromise = void 0;\r\n        if (this.underlyingTestRunner.init) {\r\n            initPromise = this.underlyingTestRunner.init();\r\n        }\r\n        if (objectUtils_1.isPromise(initPromise)) {\r\n            initPromise.then(this.sendInitDone);\r\n        }\r\n        else {\r\n            this.sendInitDone();\r\n        }\r\n    };\r\n    TestRunnerChildProcessAdapterWorker.prototype.sendInitDone = function () {\r\n        process.send({ type: Message_1.MessageType.InitDone });\r\n    };\r\n    TestRunnerChildProcessAdapterWorker.prototype.dispose = function () {\r\n        var disposePromise = void 0;\r\n        if (this.underlyingTestRunner.dispose) {\r\n            disposePromise = this.underlyingTestRunner.dispose();\r\n        }\r\n        if (objectUtils_1.isPromise(disposePromise)) {\r\n            disposePromise.then(this.sendDisposeDone);\r\n        }\r\n        else {\r\n            this.sendDisposeDone();\r\n        }\r\n    };\r\n    TestRunnerChildProcessAdapterWorker.prototype.sendDisposeDone = function () {\r\n        process.send({ type: Message_1.MessageType.DisposeDone });\r\n    };\r\n    TestRunnerChildProcessAdapterWorker.prototype.run = function (body) {\r\n        this.underlyingTestRunner.run(body.runOptions).then(this.reportResult, this.reportErrorResult);\r\n    };\r\n    TestRunnerChildProcessAdapterWorker.prototype.loadPlugins = function (plugins) {\r\n        new PluginLoader_1.default(plugins).load();\r\n    };\r\n    TestRunnerChildProcessAdapterWorker.prototype.reportResult = function (result) {\r\n        var message = {\r\n            type: Message_1.MessageType.Result,\r\n            body: { result: result }\r\n        };\r\n        process.send(message);\r\n    };\r\n    TestRunnerChildProcessAdapterWorker.prototype.reportErrorResult = function (error) {\r\n        var message = {\r\n            type: Message_1.MessageType.Result,\r\n            body: {\r\n                result: {\r\n                    testNames: [],\r\n                    result: test_runner_1.TestResult.Error,\r\n                }\r\n            }\r\n        };\r\n        process.send(message);\r\n    };\r\n    return TestRunnerChildProcessAdapterWorker;\r\n}());","mutatedLines":"var TestRunnerChildProcessAdapterWorker = (function () {\n}());"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterFactory.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":5,"column":32},"end":{"line":7,"column":5}},"range":[207,318],"originalLines":"    create: function (settings) {\r\n        return new IsolatedTestRunnerAdapter_1.default(settings.strykerOptions.testRunner, settings);\r\n    }","mutatedLines":"    create: function (settings) {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":142,"column":75},"end":{"line":144,"column":5}},"range":[6189,6229],"originalLines":"    TestRunnerChildProcessAdapter.prototype.emptyMessage = function (type) {\r\n        return { type: type };\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapter.prototype.emptyMessage = function (type) {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":140,"column":30},"end":{"line":140,"column":123}},"range":[6009,6102],"originalLines":"            .then(function () { return _this.runPromiseFulfillmentCallback({ result: test_runner_1.TestResult.Timeout }); });","mutatedLines":"            .then(function () {\n});"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":139,"column":30},"end":{"line":139,"column":54}},"range":[5952,5976],"originalLines":"            .then(function () { return _this.init(); })","mutatedLines":"            .then(function () {\n})"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":138,"column":30},"end":{"line":138,"column":61}},"range":[5888,5919],"originalLines":"            .then(function () { return _this.startWorker(); })","mutatedLines":"            .then(function () {\n})"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":135,"column":72},"end":{"line":141,"column":5}},"range":[5804,6111],"originalLines":"    TestRunnerChildProcessAdapter.prototype.handleTimeout = function () {\r\n        var _this = this;\r\n        this.dispose()\r\n            .then(function () { return _this.startWorker(); })\r\n            .then(function () { return _this.init(); })\r\n            .then(function () { return _this.runPromiseFulfillmentCallback({ result: test_runner_1.TestResult.Timeout }); });\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapter.prototype.handleTimeout = function () {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":131,"column":58},"end":{"line":133,"column":9}},"range":[5661,5709],"originalLines":"        this.currentTimeoutTimer = setTimeout(function () {\r\n            _this.handleTimeout();\r\n        }, timeoutMs);","mutatedLines":"        this.currentTimeoutTimer = setTimeout(function () {\n}, timeoutMs);"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":129,"column":87},"end":{"line":134,"column":5}},"range":[5573,5729],"originalLines":"    TestRunnerChildProcessAdapter.prototype.markNoResultTimeout = function (timeoutMs) {\r\n        var _this = this;\r\n        this.currentTimeoutTimer = setTimeout(function () {\r\n            _this.handleTimeout();\r\n        }, timeoutMs);\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapter.prototype.markNoResultTimeout = function (timeoutMs) {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":125,"column":38},"end":{"line":127,"column":9}},"range":[5411,5476],"originalLines":"        if (this.currentTimeoutTimer) {\r\n            clearTimeout(this.currentTimeoutTimer);\r\n        }","mutatedLines":"        if (this.currentTimeoutTimer) {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":125,"column":12},"end":{"line":125,"column":36}},"range":[5385,5409],"originalLines":"        if (this.currentTimeoutTimer) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":125,"column":12},"end":{"line":125,"column":36}},"range":[5385,5409],"originalLines":"        if (this.currentTimeoutTimer) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":124,"column":76},"end":{"line":128,"column":5}},"range":[5370,5483],"originalLines":"    TestRunnerChildProcessAdapter.prototype.clearCurrentTimer = function () {\r\n        if (this.currentTimeoutTimer) {\r\n            clearTimeout(this.currentTimeoutTimer);\r\n        }\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapter.prototype.clearCurrentTimer = function () {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"Math","status":1,"replacement":"new Date().getTime() + this.currentRunStartedTimestamp.getTime()","location":{"start":{"line":121,"column":41},"end":{"line":121,"column":105}},"range":[5152,5216],"originalLines":"        message.body.result.timeSpent = (new Date().getTime() - this.currentRunStartedTimestamp.getTime());","mutatedLines":"        message.body.result.timeSpent = (new Date().getTime() + this.currentRunStartedTimestamp.getTime());"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":120,"column":85},"end":{"line":123,"column":5}},"range":[5108,5291],"originalLines":"    TestRunnerChildProcessAdapter.prototype.handleResultMessage = function (message) {\r\n        message.body.result.timeSpent = (new Date().getTime() - this.currentRunStartedTimestamp.getTime());\r\n        this.runPromiseFulfillmentCallback(message.body.result);\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapter.prototype.handleResultMessage = function (message) {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":117,"column":77},"end":{"line":119,"column":5}},"range":[4928,5020],"originalLines":"    TestRunnerChildProcessAdapter.prototype.sendDisposeCommand = function () {\r\n        this.workerProcess.send(this.emptyMessage(Message_1.MessageType.Dispose));\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapter.prototype.sendDisposeCommand = function () {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":114,"column":74},"end":{"line":116,"column":5}},"range":[4759,4848],"originalLines":"    TestRunnerChildProcessAdapter.prototype.sendInitCommand = function () {\r\n        this.workerProcess.send(this.emptyMessage(Message_1.MessageType.Init));\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapter.prototype.sendInitCommand = function () {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":104,"column":75},"end":{"line":113,"column":5}},"range":[4401,4682],"originalLines":"    TestRunnerChildProcessAdapter.prototype.sendStartCommand = function () {\r\n        var startMessage = {\r\n            type: Message_1.MessageType.Start,\r\n            body: {\r\n                runnerName: this.realTestRunnerName,\r\n                runnerOptions: this.options\r\n            }\r\n        };\r\n        this.workerProcess.send(startMessage);\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapter.prototype.sendStartCommand = function () {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":95,"column":80},"end":{"line":103,"column":5}},"range":[4116,4323],"originalLines":"    TestRunnerChildProcessAdapter.prototype.sendRunCommand = function (options) {\r\n        var message = {\r\n            type: Message_1.MessageType.Run,\r\n            body: {\r\n                runOptions: options\r\n            }\r\n        };\r\n        this.workerProcess.send(message);\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapter.prototype.sendRunCommand = function (options) {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":84,"column":34},"end":{"line":88,"column":13}},"range":[3645,3790],"originalLines":"                .then(function () {\r\n                clearTimeout(timer_1);\r\n                _this.workerProcess.kill();\r\n                _this.isDisposing = false;\r\n            });","mutatedLines":"                .then(function () {\n});"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":83,"column":67},"end":{"line":83,"column":128}},"range":[3547,3608],"originalLines":"            this.disposingPromise = new Promise(function (resolve) { return _this.disposePromiseFulfillmentCallback = resolve; })","mutatedLines":"            this.disposingPromise = new Promise(function (resolve) {\n})"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":81,"column":13},"end":{"line":93,"column":9}},"range":[3439,4026],"originalLines":"        else {\r\n            this.isDisposing = true;\r\n            this.disposingPromise = new Promise(function (resolve) { return _this.disposePromiseFulfillmentCallback = resolve; })\r\n                .then(function () {\r\n                clearTimeout(timer_1);\r\n                _this.workerProcess.kill();\r\n                _this.isDisposing = false;\r\n            });\r\n            this.clearCurrentTimer();\r\n            this.sendDisposeCommand();\r\n            var timer_1 = setTimeout(this.disposePromiseFulfillmentCallback, MAX_WAIT_FOR_DISPOSE);\r\n            return this.disposingPromise;\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":78,"column":30},"end":{"line":80,"column":9}},"range":[3369,3424],"originalLines":"        if (this.isDisposing) {\r\n            return this.disposingPromise;\r\n        }","mutatedLines":"        if (this.isDisposing) {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":78,"column":12},"end":{"line":78,"column":28}},"range":[3351,3367],"originalLines":"        if (this.isDisposing) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":78,"column":12},"end":{"line":78,"column":28}},"range":[3351,3367],"originalLines":"        if (this.isDisposing) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":76,"column":66},"end":{"line":94,"column":5}},"range":[3309,4033],"originalLines":"    TestRunnerChildProcessAdapter.prototype.dispose = function () {\r\n        var _this = this;\r\n        if (this.isDisposing) {\r\n            return this.disposingPromise;\r\n        }\r\n        else {\r\n            this.isDisposing = true;\r\n            this.disposingPromise = new Promise(function (resolve) { return _this.disposePromiseFulfillmentCallback = resolve; })\r\n                .then(function () {\r\n                clearTimeout(timer_1);\r\n                _this.workerProcess.kill();\r\n                _this.isDisposing = false;\r\n            });\r\n            this.clearCurrentTimer();\r\n            this.sendDisposeCommand();\r\n            var timer_1 = setTimeout(this.disposePromiseFulfillmentCallback, MAX_WAIT_FOR_DISPOSE);\r\n            return this.disposingPromise;\r\n        }\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapter.prototype.dispose = function () {\n};"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"UnaryOperator","status":1,"replacement":"endIndexLines--","location":{"start":{"line":45,"column":12},"end":{"line":45,"column":27}},"range":[1758,1773],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"            endIndexLines++;","mutatedLines":"            endIndexLines--;"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":69,"column":57},"end":{"line":73,"column":9}},"range":[3022,3198],"originalLines":"        this.runPromise = new Promise(function (resolve) {\r\n            _this.runPromiseFulfillmentCallback = resolve;\r\n            _this.sendRunCommand(options);\r\n            _this.currentRunStartedTimestamp = new Date();\r\n        });","mutatedLines":"        this.runPromise = new Promise(function (resolve) {\n});"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":66,"column":12},"end":{"line":66,"column":27}},"range":[2878,2893],"originalLines":"        if (options.timeout) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":66,"column":12},"end":{"line":66,"column":27}},"range":[2878,2893],"originalLines":"        if (options.timeout) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":63,"column":69},"end":{"line":75,"column":5}},"range":[2801,3240],"originalLines":"    TestRunnerChildProcessAdapter.prototype.run = function (options) {\r\n        var _this = this;\r\n        this.clearCurrentTimer();\r\n        if (options.timeout) {\r\n            this.markNoResultTimeout(options.timeout);\r\n        }\r\n        this.runPromise = new Promise(function (resolve) {\r\n            _this.runPromiseFulfillmentCallback = resolve;\r\n            _this.sendRunCommand(options);\r\n            _this.currentRunStartedTimestamp = new Date();\r\n        });\r\n        return this.runPromise;\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapter.prototype.run = function (options) {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":59,"column":58},"end":{"line":59,"column":116}},"range":[2595,2653],"originalLines":"        this.initPromise = new Promise(function (resolve) { return _this.initPromiseFulfillmentCallback = resolve; });","mutatedLines":"        this.initPromise = new Promise(function (resolve) {\n});"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":57,"column":63},"end":{"line":62,"column":5}},"range":[2507,2729],"originalLines":"    TestRunnerChildProcessAdapter.prototype.init = function () {\r\n        var _this = this;\r\n        this.initPromise = new Promise(function (resolve) { return _this.initPromiseFulfillmentCallback = resolve; });\r\n        this.sendInitCommand();\r\n        return this.initPromise;\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapter.prototype.init = function () {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"Math","status":1,"replacement":"'Retrieved unrecognized message from child process: ' - JSON.stringify(message)","location":{"start":{"line":52,"column":30},"end":{"line":52,"column":109}},"range":[2297,2376],"originalLines":"                    log.error(\"Retrieved unrecognized message from child process: \" + JSON.stringify(message));","mutatedLines":"                    log.error('Retrieved unrecognized message from child process: ' - JSON.stringify(message));"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":41,"column":44},"end":{"line":43,"column":21}},"range":[1834,1919],"originalLines":"                    if (!_this.isDisposing) {\r\n                        _this.handleResultMessage(message);\r\n                    }","mutatedLines":"                    if (!_this.isDisposing) {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":41,"column":24},"end":{"line":41,"column":42}},"range":[1814,1832],"originalLines":"                    if (!_this.isDisposing) {","mutatedLines":"                    if (true) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":41,"column":24},"end":{"line":41,"column":42}},"range":[1814,1832],"originalLines":"                    if (!_this.isDisposing) {","mutatedLines":"                    if (false) {"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"ReverseConditional","status":1,"replacement":"startIndexLines <= 0","location":{"start":{"line":41,"column":15},"end":{"line":41,"column":34}},"range":[1545,1564],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"        while (startIndexLines > 0 && !this.isNewLine(startIndexLines - 1)) {","mutatedLines":"        while (startIndexLines <= 0 && !this.isNewLine(startIndexLines - 1)) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":37,"column":60},"end":{"line":55,"column":9}},"range":[1658,2432],"originalLines":"        this.workerProcess.on('message', function (message) {\r\n            _this.clearCurrentTimer();\r\n            switch (message.type) {\r\n                case Message_1.MessageType.Result:\r\n                    if (!_this.isDisposing) {\r\n                        _this.handleResultMessage(message);\r\n                    }\r\n                    break;\r\n                case Message_1.MessageType.InitDone:\r\n                    _this.initPromiseFulfillmentCallback();\r\n                    break;\r\n                case Message_1.MessageType.DisposeDone:\r\n                    _this.disposePromiseFulfillmentCallback();\r\n                    break;\r\n                default:\r\n                    log.error(\"Retrieved unrecognized message from child process: \" + JSON.stringify(message));\r\n                    break;\r\n            }\r\n        });","mutatedLines":"        this.workerProcess.on('message', function (message) {\n});"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":32,"column":39},"end":{"line":36,"column":9}},"range":[1454,1596],"originalLines":"        if (this.workerProcess.stderr) {\r\n            this.workerProcess.stderr.on('data', function (data) {\r\n                log.error(data.toString());\r\n            });\r\n        }","mutatedLines":"        if (this.workerProcess.stderr) {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":32,"column":12},"end":{"line":32,"column":37}},"range":[1427,1452],"originalLines":"        if (this.workerProcess.stderr) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":32,"column":12},"end":{"line":32,"column":37}},"range":[1427,1452],"originalLines":"        if (this.workerProcess.stderr) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":27,"column":36},"end":{"line":29,"column":17}},"range":[1316,1385],"originalLines":"                if (traceEnabled_1) {\r\n                    log.trace(data.toString());\r\n                }","mutatedLines":"                if (traceEnabled_1) {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":27,"column":20},"end":{"line":27,"column":34}},"range":[1300,1314],"originalLines":"                if (traceEnabled_1) {","mutatedLines":"                if (true) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":27,"column":20},"end":{"line":27,"column":34}},"range":[1300,1314],"originalLines":"                if (traceEnabled_1) {","mutatedLines":"                if (false) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":26,"column":65},"end":{"line":30,"column":13}},"range":[1277,1400],"originalLines":"            this.workerProcess.stdout.on('data', function (data) {\r\n                if (traceEnabled_1) {\r\n                    log.trace(data.toString());\r\n                }\r\n            });","mutatedLines":"            this.workerProcess.stdout.on('data', function (data) {\n});"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":24,"column":39},"end":{"line":31,"column":9}},"range":[1153,1413],"originalLines":"        if (this.workerProcess.stdout) {\r\n            var traceEnabled_1 = log.isTraceEnabled();\r\n            this.workerProcess.stdout.on('data', function (data) {\r\n                if (traceEnabled_1) {\r\n                    log.trace(data.toString());\r\n                }\r\n            });\r\n        }","mutatedLines":"        if (this.workerProcess.stdout) {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":24,"column":12},"end":{"line":24,"column":37}},"range":[1126,1151],"originalLines":"        if (this.workerProcess.stdout) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":24,"column":12},"end":{"line":24,"column":37}},"range":[1126,1151],"originalLines":"        if (this.workerProcess.stdout) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":22,"column":80},"end":{"line":56,"column":5}},"range":[1084,2441],"originalLines":"    TestRunnerChildProcessAdapter.prototype.listenToWorkerProcess = function () {\r\n        var _this = this;\r\n        if (this.workerProcess.stdout) {\r\n            var traceEnabled_1 = log.isTraceEnabled();\r\n            this.workerProcess.stdout.on('data', function (data) {\r\n                if (traceEnabled_1) {\r\n                    log.trace(data.toString());\r\n                }\r\n            });\r\n        }\r\n        if (this.workerProcess.stderr) {\r\n            this.workerProcess.stderr.on('data', function (data) {\r\n                log.error(data.toString());\r\n            });\r\n        }\r\n        this.workerProcess.on('message', function (message) {\r\n            _this.clearCurrentTimer();\r\n            switch (message.type) {\r\n                case Message_1.MessageType.Result:\r\n                    if (!_this.isDisposing) {\r\n                        _this.handleResultMessage(message);\r\n                    }\r\n                    break;\r\n                case Message_1.MessageType.InitDone:\r\n                    _this.initPromiseFulfillmentCallback();\r\n                    break;\r\n                case Message_1.MessageType.DisposeDone:\r\n                    _this.disposePromiseFulfillmentCallback();\r\n                    break;\r\n                default:\r\n                    log.error(\"Retrieved unrecognized message from child process: \" + JSON.stringify(message));\r\n                    break;\r\n            }\r\n        });\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapter.prototype.listenToWorkerProcess = function () {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"Math","status":1,"replacement":"__dirname - '/IsolatedTestRunnerAdapterWorker'","location":{"start":{"line":18,"column":50},"end":{"line":18,"column":96}},"range":[831,877],"originalLines":"        this.workerProcess = child_process_1.fork(__dirname + \"/IsolatedTestRunnerAdapterWorker\", [], { silent: true, execArgv: execArgv });","mutatedLines":"        this.workerProcess = child_process_1.fork(__dirname - '/IsolatedTestRunnerAdapterWorker', [], { silent: true, execArgv: execArgv });"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"ReverseConditional","status":1,"replacement":"arg.substr(0, 11) !== '--debug-brk'","location":{"start":{"line":17,"column":51},"end":{"line":17,"column":86}},"range":[739,774],"originalLines":"        _.remove(execArgv, function (arg) { return arg.substr(0, 11) === '--debug-brk'; });","mutatedLines":"        _.remove(execArgv, function (arg) { return arg.substr(0, 11) !== '--debug-brk'; });"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":17,"column":42},"end":{"line":17,"column":89}},"range":[730,777],"originalLines":"        _.remove(execArgv, function (arg) { return arg.substr(0, 11) === '--debug-brk'; });","mutatedLines":"        _.remove(execArgv, function (arg) {\n});"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":15,"column":70},"end":{"line":21,"column":5}},"range":[634,1001],"originalLines":"    TestRunnerChildProcessAdapter.prototype.startWorker = function () {\r\n        var execArgv = _.clone(process.execArgv);\r\n        _.remove(execArgv, function (arg) { return arg.substr(0, 11) === '--debug-brk'; });\r\n        this.workerProcess = child_process_1.fork(__dirname + \"/IsolatedTestRunnerAdapterWorker\", [], { silent: true, execArgv: execArgv });\r\n        this.sendStartCommand();\r\n        this.listenToWorkerProcess();\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapter.prototype.startWorker = function () {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":10,"column":72},"end":{"line":14,"column":5}},"range":[437,562],"originalLines":"    function TestRunnerChildProcessAdapter(realTestRunnerName, options) {\r\n        this.realTestRunnerName = realTestRunnerName;\r\n        this.options = options;\r\n        this.startWorker();\r\n    }","mutatedLines":"    function TestRunnerChildProcessAdapter(realTestRunnerName, options) {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":9,"column":49},"end":{"line":146,"column":1}},"range":[362,6276],"originalLines":"var TestRunnerChildProcessAdapter = (function () {\r\n    function TestRunnerChildProcessAdapter(realTestRunnerName, options) {\r\n        this.realTestRunnerName = realTestRunnerName;\r\n        this.options = options;\r\n        this.startWorker();\r\n    }\r\n    TestRunnerChildProcessAdapter.prototype.startWorker = function () {\r\n        var execArgv = _.clone(process.execArgv);\r\n        _.remove(execArgv, function (arg) { return arg.substr(0, 11) === '--debug-brk'; });\r\n        this.workerProcess = child_process_1.fork(__dirname + \"/IsolatedTestRunnerAdapterWorker\", [], { silent: true, execArgv: execArgv });\r\n        this.sendStartCommand();\r\n        this.listenToWorkerProcess();\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.listenToWorkerProcess = function () {\r\n        var _this = this;\r\n        if (this.workerProcess.stdout) {\r\n            var traceEnabled_1 = log.isTraceEnabled();\r\n            this.workerProcess.stdout.on('data', function (data) {\r\n                if (traceEnabled_1) {\r\n                    log.trace(data.toString());\r\n                }\r\n            });\r\n        }\r\n        if (this.workerProcess.stderr) {\r\n            this.workerProcess.stderr.on('data', function (data) {\r\n                log.error(data.toString());\r\n            });\r\n        }\r\n        this.workerProcess.on('message', function (message) {\r\n            _this.clearCurrentTimer();\r\n            switch (message.type) {\r\n                case Message_1.MessageType.Result:\r\n                    if (!_this.isDisposing) {\r\n                        _this.handleResultMessage(message);\r\n                    }\r\n                    break;\r\n                case Message_1.MessageType.InitDone:\r\n                    _this.initPromiseFulfillmentCallback();\r\n                    break;\r\n                case Message_1.MessageType.DisposeDone:\r\n                    _this.disposePromiseFulfillmentCallback();\r\n                    break;\r\n                default:\r\n                    log.error(\"Retrieved unrecognized message from child process: \" + JSON.stringify(message));\r\n                    break;\r\n            }\r\n        });\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.init = function () {\r\n        var _this = this;\r\n        this.initPromise = new Promise(function (resolve) { return _this.initPromiseFulfillmentCallback = resolve; });\r\n        this.sendInitCommand();\r\n        return this.initPromise;\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.run = function (options) {\r\n        var _this = this;\r\n        this.clearCurrentTimer();\r\n        if (options.timeout) {\r\n            this.markNoResultTimeout(options.timeout);\r\n        }\r\n        this.runPromise = new Promise(function (resolve) {\r\n            _this.runPromiseFulfillmentCallback = resolve;\r\n            _this.sendRunCommand(options);\r\n            _this.currentRunStartedTimestamp = new Date();\r\n        });\r\n        return this.runPromise;\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.dispose = function () {\r\n        var _this = this;\r\n        if (this.isDisposing) {\r\n            return this.disposingPromise;\r\n        }\r\n        else {\r\n            this.isDisposing = true;\r\n            this.disposingPromise = new Promise(function (resolve) { return _this.disposePromiseFulfillmentCallback = resolve; })\r\n                .then(function () {\r\n                clearTimeout(timer_1);\r\n                _this.workerProcess.kill();\r\n                _this.isDisposing = false;\r\n            });\r\n            this.clearCurrentTimer();\r\n            this.sendDisposeCommand();\r\n            var timer_1 = setTimeout(this.disposePromiseFulfillmentCallback, MAX_WAIT_FOR_DISPOSE);\r\n            return this.disposingPromise;\r\n        }\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.sendRunCommand = function (options) {\r\n        var message = {\r\n            type: Message_1.MessageType.Run,\r\n            body: {\r\n                runOptions: options\r\n            }\r\n        };\r\n        this.workerProcess.send(message);\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.sendStartCommand = function () {\r\n        var startMessage = {\r\n            type: Message_1.MessageType.Start,\r\n            body: {\r\n                runnerName: this.realTestRunnerName,\r\n                runnerOptions: this.options\r\n            }\r\n        };\r\n        this.workerProcess.send(startMessage);\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.sendInitCommand = function () {\r\n        this.workerProcess.send(this.emptyMessage(Message_1.MessageType.Init));\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.sendDisposeCommand = function () {\r\n        this.workerProcess.send(this.emptyMessage(Message_1.MessageType.Dispose));\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.handleResultMessage = function (message) {\r\n        message.body.result.timeSpent = (new Date().getTime() - this.currentRunStartedTimestamp.getTime());\r\n        this.runPromiseFulfillmentCallback(message.body.result);\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.clearCurrentTimer = function () {\r\n        if (this.currentTimeoutTimer) {\r\n            clearTimeout(this.currentTimeoutTimer);\r\n        }\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.markNoResultTimeout = function (timeoutMs) {\r\n        var _this = this;\r\n        this.currentTimeoutTimer = setTimeout(function () {\r\n            _this.handleTimeout();\r\n        }, timeoutMs);\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.handleTimeout = function () {\r\n        var _this = this;\r\n        this.dispose()\r\n            .then(function () { return _this.startWorker(); })\r\n            .then(function () { return _this.init(); })\r\n            .then(function () { return _this.runPromiseFulfillmentCallback({ result: test_runner_1.TestResult.Timeout }); });\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.emptyMessage = function (type) {\r\n        return { type: type };\r\n    };\r\n    return TestRunnerChildProcessAdapter;\r\n}());","mutatedLines":"var TestRunnerChildProcessAdapter = (function () {\n}());"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":80,"column":36},"end":{"line":82,"column":13}},"range":[4244,4326],"originalLines":"            if (files.length === 0) {\r\n                _this.reportEmptyGlobbingExpression(expression);\r\n            }","mutatedLines":"            if (files.length === 0) {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":73,"column":83},"end":{"line":79,"column":5}},"range":[3160,3324],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"    TestRunnerChildProcessAdapterWorker.prototype.reportResult = function (result) {\r\n        var message = {\r\n            type: Message_1.MessageType.Result,\r\n            body: { result: result }\r\n        };\r\n        process.send(message);\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapterWorker.prototype.reportResult = function (result) {\n};"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"ReverseConditional","status":1,"replacement":"files.length !== 0","location":{"start":{"line":80,"column":16},"end":{"line":80,"column":34}},"range":[4224,4242],"originalLines":"            if (files.length === 0) {","mutatedLines":"            if (files.length !== 0) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":57,"column":12},"end":{"line":57,"column":51}},"range":[2400,2439],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"        if (objectUtils_1.isPromise(disposePromise)) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":80,"column":16},"end":{"line":80,"column":34}},"range":[4224,4242],"originalLines":"            if (files.length === 0) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":77,"column":62},"end":{"line":86,"column":5}},"range":[4109,4416],"originalLines":"    InputFileResolver.resolveFileGlob = function (expression) {\r\n        var _this = this;\r\n        return fileUtils_1.glob(expression).then(function (files) {\r\n            if (files.length === 0) {\r\n                _this.reportEmptyGlobbingExpression(expression);\r\n            }\r\n            fileUtils_1.normalize(files);\r\n            return files;\r\n        });\r\n    };","mutatedLines":"    InputFileResolver.resolveFileGlob = function (expression) {\n};"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":72,"column":68},"end":{"line":76,"column":5}},"range":[3877,4044],"originalLines":"    InputFileResolver.createInputFile = function (path, descriptor) {\r\n        var inputFile = _.assign({ path: path }, DEFAULT_INPUT_FILE_PROPERTIES, descriptor);\r\n        delete inputFile['pattern'];\r\n        return inputFile;\r\n    };","mutatedLines":"    InputFileResolver.createInputFile = function (path, descriptor) {\n};"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":70,"column":193},"end":{"line":70,"column":224}},"range":[3766,3797],"originalLines":"            .then(function (sourceFiles) { return sourceFiles.map(function (sourceFile) { return InputFileResolver.createInputFile(sourceFile, descriptor); }); }); })).then(function (promises) { return _.flatten(promises); });","mutatedLines":"            .then(function (sourceFiles) { return sourceFiles.map(function (sourceFile) { return InputFileResolver.createInputFile(sourceFile, descriptor); }); }); })).then(function (promises) {\n});"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":67,"column":72},"end":{"line":69,"column":5}},"range":[2814,2927],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"    TestRunnerChildProcessAdapterWorker.prototype.run = function (body) {\r\n        this.underlyingTestRunner.run(body.runOptions).then(this.reportResult, this.reportErrorResult);\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapterWorker.prototype.run = function (body) {\n};"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":70,"column":88},"end":{"line":70,"column":157}},"range":[3661,3730],"originalLines":"            .then(function (sourceFiles) { return sourceFiles.map(function (sourceFile) { return InputFileResolver.createInputFile(sourceFile, descriptor); }); }); })).then(function (promises) { return _.flatten(promises); });","mutatedLines":"            .then(function (sourceFiles) { return sourceFiles.map(function (sourceFile) {\n}); }); })).then(function (promises) { return _.flatten(promises); });"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":39,"column":44},"end":{"line":41,"column":9}},"range":[1736,1809],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"        if (this.underlyingTestRunner.init) {\r\n            initPromise = this.underlyingTestRunner.init();\r\n        }","mutatedLines":"        if (this.underlyingTestRunner.init) {\n}"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":69,"column":79},"end":{"line":70,"column":165}},"range":[3509,3738],"originalLines":"        return Promise.all(this.inputFileDescriptors.map(function (descriptor) { return InputFileResolver.resolveFileGlob(descriptor.pattern)\r\n            .then(function (sourceFiles) { return sourceFiles.map(function (sourceFile) { return InputFileResolver.createInputFile(sourceFile, descriptor); }); }); })).then(function (promises) { return _.flatten(promises); });","mutatedLines":"        return Promise.all(this.inputFileDescriptors.map(function (descriptor) {\n})).then(function (promises) { return _.flatten(promises); });"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":66,"column":35},"end":{"line":66,"column":63}},"range":[3319,3347],"originalLines":"            .then(function (files) { return _.flatten(files); });","mutatedLines":"            .then(function (files) {\n});"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":64,"column":69},"end":{"line":67,"column":5}},"range":[3186,3356],"originalLines":"    InputFileResolver.prototype.resolveMutateFileGlobs = function () {\r\n        return Promise.all(this.mutateFileExpressions.map(InputFileResolver.resolveFileGlob))\r\n            .then(function (files) { return _.flatten(files); });\r\n    };","mutatedLines":"    InputFileResolver.prototype.resolveMutateFileGlobs = function () {\n};"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":60,"column":13},"end":{"line":62,"column":9}},"range":[3068,3107],"originalLines":"        else {\r\n            return false;\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"Math","status":1,"replacement":"'File descriptor ' - JSON.stringify(maybeInputFileDescriptor)","location":{"start":{"line":57,"column":28},"end":{"line":57,"column":89}},"range":[2918,2979],"originalLines":"                throw Error(\"File descriptor \" + JSON.stringify(maybeInputFileDescriptor) + \" is missing mandatory property 'pattern'.\");","mutatedLines":"                throw Error('File descriptor ' - JSON.stringify(maybeInputFileDescriptor) + \" is missing mandatory property 'pattern'.\");"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"Math","status":1,"replacement":"'File descriptor ' + JSON.stringify(maybeInputFileDescriptor) - ' is missing mandatory property \\'pattern\\'.'","location":{"start":{"line":57,"column":28},"end":{"line":57,"column":135}},"range":[2918,3025],"originalLines":"                throw Error(\"File descriptor \" + JSON.stringify(maybeInputFileDescriptor) + \" is missing mandatory property 'pattern'.\");","mutatedLines":"                throw Error('File descriptor ' + JSON.stringify(maybeInputFileDescriptor) - ' is missing mandatory property \\'pattern\\'.');"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":56,"column":17},"end":{"line":58,"column":13}},"range":[2887,3042],"originalLines":"            else {\r\n                throw Error(\"File descriptor \" + JSON.stringify(maybeInputFileDescriptor) + \" is missing mandatory property 'pattern'.\");\r\n            }","mutatedLines":"            else {\n}"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":53,"column":79},"end":{"line":55,"column":13}},"range":[2822,2868],"originalLines":"            if (Object.keys(maybeInputFileDescriptor).indexOf('pattern') > -1) {\r\n                return true;\r\n            }","mutatedLines":"            if (Object.keys(maybeInputFileDescriptor).indexOf('pattern') > -1) {\n}"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"UnaryOperator","status":1,"replacement":"+1","location":{"start":{"line":53,"column":75},"end":{"line":53,"column":77}},"range":[2818,2820],"originalLines":"            if (Object.keys(maybeInputFileDescriptor).indexOf('pattern') > -1) {","mutatedLines":"            if (Object.keys(maybeInputFileDescriptor).indexOf('pattern') > +1) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":14,"column":49},"end":{"line":31,"column":9}},"range":[629,1293],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"        process.on('message', function (message) {\r\n            switch (message.type) {\r\n                case Message_1.MessageType.Start:\r\n                    _this.start(message.body);\r\n                    break;\r\n                case Message_1.MessageType.Run:\r\n                    _this.run(message.body);\r\n                    break;\r\n                case Message_1.MessageType.Init:\r\n                    _this.init();\r\n                    break;\r\n                case Message_1.MessageType.Dispose:\r\n                    _this.dispose();\r\n                    break;\r\n                default:\r\n                    log.warn('Received unsupported message: {}', JSON.stringify(message));\r\n            }\r\n        });","mutatedLines":"        process.on('message', function (message) {\n});"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"ReverseConditional","status":1,"replacement":"Object.keys(maybeInputFileDescriptor).indexOf('pattern') <= -1","location":{"start":{"line":53,"column":16},"end":{"line":53,"column":77}},"range":[2759,2820],"originalLines":"            if (Object.keys(maybeInputFileDescriptor).indexOf('pattern') > -1) {","mutatedLines":"            if (Object.keys(maybeInputFileDescriptor).indexOf('pattern') <= -1) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":53,"column":16},"end":{"line":53,"column":77}},"range":[2759,2820],"originalLines":"            if (Object.keys(maybeInputFileDescriptor).indexOf('pattern') > -1) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":53,"column":16},"end":{"line":53,"column":77}},"range":[2759,2820],"originalLines":"            if (Object.keys(maybeInputFileDescriptor).indexOf('pattern') > -1) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":52,"column":50},"end":{"line":59,"column":9}},"range":[2740,3053],"originalLines":"        if (_.isObject(maybeInputFileDescriptor)) {\r\n            if (Object.keys(maybeInputFileDescriptor).indexOf('pattern') > -1) {\r\n                return true;\r\n            }\r\n            else {\r\n                throw Error(\"File descriptor \" + JSON.stringify(maybeInputFileDescriptor) + \" is missing mandatory property 'pattern'.\");\r\n            }\r\n        }","mutatedLines":"        if (_.isObject(maybeInputFileDescriptor)) {\n}"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":52,"column":12},"end":{"line":52,"column":48}},"range":[2702,2738],"originalLines":"        if (_.isObject(maybeInputFileDescriptor)) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":52,"column":12},"end":{"line":52,"column":48}},"range":[2702,2738],"originalLines":"        if (_.isObject(maybeInputFileDescriptor)) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":51,"column":82},"end":{"line":63,"column":5}},"range":[2687,3114],"originalLines":"    InputFileResolver.isInputFileDescriptor = function (maybeInputFileDescriptor) {\r\n        if (_.isObject(maybeInputFileDescriptor)) {\r\n            if (Object.keys(maybeInputFileDescriptor).indexOf('pattern') > -1) {\r\n                return true;\r\n            }\r\n            else {\r\n                throw Error(\"File descriptor \" + JSON.stringify(maybeInputFileDescriptor) + \" is missing mandatory property 'pattern'.\");\r\n            }\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    };","mutatedLines":"    InputFileResolver.isInputFileDescriptor = function (maybeInputFileDescriptor) {\n};"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"Math","status":1,"replacement":"'Globbing expression \"' - expression","location":{"start":{"line":49,"column":17},"end":{"line":49,"column":54}},"range":[2520,2557],"originalLines":"        log.warn(\"Globbing expression \\\"\" + expression + \"\\\" did not result in any files.\");","mutatedLines":"        log.warn('Globbing expression \"' - expression + \"\\\" did not result in any files.\");"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"Math","status":1,"replacement":"'Globbing expression \"' + expression - '\" did not result in any files.'","location":{"start":{"line":49,"column":17},"end":{"line":49,"column":90}},"range":[2520,2593],"originalLines":"        log.warn(\"Globbing expression \\\"\" + expression + \"\\\" did not result in any files.\");","mutatedLines":"        log.warn('Globbing expression \"' + expression - '\" did not result in any files.');"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":48,"column":76},"end":{"line":50,"column":5}},"range":[2500,2602],"originalLines":"    InputFileResolver.reportEmptyGlobbingExpression = function (expression) {\r\n        log.warn(\"Globbing expression \\\"\" + expression + \"\\\" did not result in any files.\");\r\n    };","mutatedLines":"    InputFileResolver.reportEmptyGlobbingExpression = function (expression) {\n};"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":44,"column":13},"end":{"line":46,"column":9}},"range":[2278,2414],"originalLines":"        else {\r\n            log.warn(\"No files marked to be mutated, stryker will perform a dry-run without actually mutating anything.\");\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"Math","status":1,"replacement":"'Found ' - mutateFiles.length","location":{"start":{"line":42,"column":21},"end":{"line":42,"column":50}},"range":[2193,2222],"originalLines":"            log.info(\"Found \" + mutateFiles.length + \" file(s) to be mutated.\");","mutatedLines":"            log.info('Found ' - mutateFiles.length + \" file(s) to be mutated.\");"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"Math","status":1,"replacement":"'Found ' + mutateFiles.length - ' file(s) to be mutated.'","location":{"start":{"line":42,"column":21},"end":{"line":42,"column":78}},"range":[2193,2250],"originalLines":"            log.info(\"Found \" + mutateFiles.length + \" file(s) to be mutated.\");","mutatedLines":"            log.info('Found ' + mutateFiles.length - ' file(s) to be mutated.');"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":41,"column":32},"end":{"line":43,"column":9}},"range":[2169,2263],"originalLines":"        if (mutateFiles.length) {\r\n            log.info(\"Found \" + mutateFiles.length + \" file(s) to be mutated.\");\r\n        }","mutatedLines":"        if (mutateFiles.length) {\n}"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":41,"column":12},"end":{"line":41,"column":30}},"range":[2149,2167],"originalLines":"        if (mutateFiles.length) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":41,"column":12},"end":{"line":41,"column":30}},"range":[2149,2167],"originalLines":"        if (mutateFiles.length) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":40,"column":63},"end":{"line":40,"column":87}},"range":[2109,2133],"originalLines":"        var mutateFiles = allInputFiles.filter(function (file) { return file.mutated; });","mutatedLines":"        var mutateFiles = allInputFiles.filter(function (file) {\n});"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":39,"column":74},"end":{"line":47,"column":5}},"range":[2043,2421],"originalLines":"    InputFileResolver.warnAboutNoFilesToMutate = function (allInputFiles) {\r\n        var mutateFiles = allInputFiles.filter(function (file) { return file.mutated; });\r\n        if (mutateFiles.length) {\r\n            log.info(\"Found \" + mutateFiles.length + \" file(s) to be mutated.\");\r\n        }\r\n        else {\r\n            log.warn(\"No files marked to be mutated, stryker will perform a dry-run without actually mutating anything.\");\r\n        }\r\n    };","mutatedLines":"    InputFileResolver.warnAboutNoFilesToMutate = function (allInputFiles) {\n};"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"ReverseConditional","status":1,"replacement":"mutateFile !== file.path","location":{"start":{"line":37,"column":128},"end":{"line":37,"column":152}},"range":[1910,1934],"originalLines":"        allInputFiles.forEach(function (file) { return file.mutated = additionalMutateFiles.some(function (mutateFile) { return mutateFile === file.path; }) || file.mutated; });","mutatedLines":"        allInputFiles.forEach(function (file) { return file.mutated = additionalMutateFiles.some(function (mutateFile) { return mutateFile !== file.path; }) || file.mutated; });"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":37,"column":119},"end":{"line":37,"column":155}},"range":[1901,1937],"originalLines":"        allInputFiles.forEach(function (file) { return file.mutated = additionalMutateFiles.some(function (mutateFile) { return mutateFile === file.path; }) || file.mutated; });","mutatedLines":"        allInputFiles.forEach(function (file) { return file.mutated = additionalMutateFiles.some(function (mutateFile) {\n}) || file.mutated; });"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"ReverseConditional","status":1,"replacement":"additionalMutateFiles.some(function (mutateFile) {\n    return mutateFile === file.path;\n}) && file.mutated","location":{"start":{"line":37,"column":70},"end":{"line":37,"column":172}},"range":[1852,1954],"originalLines":"        allInputFiles.forEach(function (file) { return file.mutated = additionalMutateFiles.some(function (mutateFile) { return mutateFile === file.path; }) || file.mutated; });","mutatedLines":"        allInputFiles.forEach(function (file) { return file.mutated = additionalMutateFiles.some(function (mutateFile) {\n    return mutateFile === file.path;\n}) && file.mutated; });"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":37,"column":46},"end":{"line":37,"column":175}},"range":[1828,1957],"originalLines":"        allInputFiles.forEach(function (file) { return file.mutated = additionalMutateFiles.some(function (mutateFile) { return mutateFile === file.path; }) || file.mutated; });","mutatedLines":"        allInputFiles.forEach(function (file) {\n});"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":34,"column":31},"end":{"line":36,"column":9}},"range":[1720,1780],"originalLines":"        if (errors.length > 0) {\r\n            throw new Error(errors.join(' '));\r\n        }","mutatedLines":"        if (errors.length > 0) {\n}"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"ReverseConditional","status":1,"replacement":"errors.length <= 0","location":{"start":{"line":34,"column":12},"end":{"line":34,"column":29}},"range":[1701,1718],"originalLines":"        if (errors.length > 0) {","mutatedLines":"        if (errors.length <= 0) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"ConditionalBoundary","status":1,"replacement":"errors.length >= 0","location":{"start":{"line":34,"column":12},"end":{"line":34,"column":29}},"range":[1701,1718],"originalLines":"        if (errors.length > 0) {","mutatedLines":"        if (errors.length >= 0) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":34,"column":12},"end":{"line":34,"column":29}},"range":[1701,1718],"originalLines":"        if (errors.length > 0) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":34,"column":12},"end":{"line":34,"column":29}},"range":[1701,1718],"originalLines":"        if (errors.length > 0) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"Math","status":1,"replacement":"'Could not find mutate file \"' - mutateFile","location":{"start":{"line":31,"column":28},"end":{"line":31,"column":72}},"range":[1588,1632],"originalLines":"                errors.push(\"Could not find mutate file \\\"\" + mutateFile + \"\\\" in list of files.\");","mutatedLines":"                errors.push('Could not find mutate file \"' - mutateFile + \"\\\" in list of files.\");"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"Math","status":1,"replacement":"'Could not find mutate file \"' + mutateFile - '\" in list of files.'","location":{"start":{"line":31,"column":28},"end":{"line":31,"column":97}},"range":[1588,1657],"originalLines":"                errors.push(\"Could not find mutate file \\\"\" + mutateFile + \"\\\" in list of files.\");","mutatedLines":"                errors.push('Could not find mutate file \"' + mutateFile - '\" in list of files.');"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":30,"column":110},"end":{"line":32,"column":13}},"range":[1557,1674],"originalLines":"            if (!allInputFiles.filter(function (inputFile) { return inputFile.path === mutateFile; }).length) {\r\n                errors.push(\"Could not find mutate file \\\"\" + mutateFile + \"\\\" in list of files.\");\r\n            }","mutatedLines":"            if (!allInputFiles.filter(function (inputFile) { return inputFile.path === mutateFile; }).length) {\n}"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"ReverseConditional","status":1,"replacement":"inputFile.path !== mutateFile","location":{"start":{"line":30,"column":68},"end":{"line":30,"column":97}},"range":[1515,1544],"originalLines":"            if (!allInputFiles.filter(function (inputFile) { return inputFile.path === mutateFile; }).length) {","mutatedLines":"            if (!allInputFiles.filter(function (inputFile) { return inputFile.path !== mutateFile; }).length) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":30,"column":59},"end":{"line":30,"column":100}},"range":[1506,1547],"originalLines":"            if (!allInputFiles.filter(function (inputFile) { return inputFile.path === mutateFile; }).length) {","mutatedLines":"            if (!allInputFiles.filter(function (inputFile) {\n}).length) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":30,"column":16},"end":{"line":30,"column":108}},"range":[1463,1555],"originalLines":"            if (!allInputFiles.filter(function (inputFile) { return inputFile.path === mutateFile; }).length) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":30,"column":16},"end":{"line":30,"column":108}},"range":[1463,1555],"originalLines":"            if (!allInputFiles.filter(function (inputFile) { return inputFile.path === mutateFile; }).length) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":29,"column":60},"end":{"line":33,"column":9}},"range":[1444,1685],"originalLines":"        additionalMutateFiles.forEach(function (mutateFile) {\r\n            if (!allInputFiles.filter(function (inputFile) { return inputFile.path === mutateFile; }).length) {\r\n                errors.push(\"Could not find mutate file \\\"\" + mutateFile + \"\\\" in list of files.\");\r\n            }\r\n        });","mutatedLines":"        additionalMutateFiles.forEach(function (mutateFile) {\n});"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":27,"column":100},"end":{"line":38,"column":5}},"range":[1355,1966],"originalLines":"    InputFileResolver.markAdditionalFilesToMutate = function (allInputFiles, additionalMutateFiles) {\r\n        var errors = [];\r\n        additionalMutateFiles.forEach(function (mutateFile) {\r\n            if (!allInputFiles.filter(function (inputFile) { return inputFile.path === mutateFile; }).length) {\r\n                errors.push(\"Could not find mutate file \\\"\" + mutateFile + \"\\\" in list of files.\");\r\n            }\r\n        });\r\n        if (errors.length > 0) {\r\n            throw new Error(errors.join(' '));\r\n        }\r\n        allInputFiles.forEach(function (file) { return file.mutated = additionalMutateFiles.some(function (mutateFile) { return mutateFile === file.path; }) || file.mutated; });\r\n    };","mutatedLines":"    InputFileResolver.markAdditionalFilesToMutate = function (allInputFiles, additionalMutateFiles) {\n};"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":21,"column":139},"end":{"line":25,"column":9}},"range":[1022,1239],"originalLines":"        return this.resolveInputFileGlobs().then(function (allInputFiles) { return mutateFilePromise.then(function (additionalMutateFiles) {\r\n            InputFileResolver.markAdditionalFilesToMutate(allInputFiles, additionalMutateFiles);\r\n            InputFileResolver.warnAboutNoFilesToMutate(allInputFiles);\r\n            return allInputFiles;\r\n        }); });","mutatedLines":"        return this.resolveInputFileGlobs().then(function (allInputFiles) { return mutateFilePromise.then(function (additionalMutateFiles) {\n}); });"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":21,"column":74},"end":{"line":25,"column":13}},"range":[957,1243],"originalLines":"        return this.resolveInputFileGlobs().then(function (allInputFiles) { return mutateFilePromise.then(function (additionalMutateFiles) {\r\n            InputFileResolver.markAdditionalFilesToMutate(allInputFiles, additionalMutateFiles);\r\n            InputFileResolver.warnAboutNoFilesToMutate(allInputFiles);\r\n            return allInputFiles;\r\n        }); });","mutatedLines":"        return this.resolveInputFileGlobs().then(function (allInputFiles) {\n});"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":19,"column":54},"end":{"line":26,"column":5}},"range":[816,1252],"originalLines":"    InputFileResolver.prototype.resolve = function () {\r\n        var mutateFilePromise = this.resolveMutateFileGlobs();\r\n        return this.resolveInputFileGlobs().then(function (allInputFiles) { return mutateFilePromise.then(function (additionalMutateFiles) {\r\n            InputFileResolver.markAdditionalFilesToMutate(allInputFiles, additionalMutateFiles);\r\n            InputFileResolver.warnAboutNoFilesToMutate(allInputFiles);\r\n            return allInputFiles;\r\n        }); });\r\n    };","mutatedLines":"    InputFileResolver.prototype.resolve = function () {\n};"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":14,"column":17},"end":{"line":16,"column":13}},"range":[632,740],"originalLines":"            else {\r\n                return _.assign({ pattern: maybePattern }, DEFAULT_INPUT_FILE_PROPERTIES);\r\n            }","mutatedLines":"            else {\n}"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":11,"column":71},"end":{"line":13,"column":13}},"range":[559,613],"originalLines":"            if (InputFileResolver.isInputFileDescriptor(maybePattern)) {\r\n                return maybePattern;\r\n            }","mutatedLines":"            if (InputFileResolver.isInputFileDescriptor(maybePattern)) {\n}"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":11,"column":16},"end":{"line":11,"column":69}},"range":[504,557],"originalLines":"            if (InputFileResolver.isInputFileDescriptor(maybePattern)) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":11,"column":16},"end":{"line":11,"column":69}},"range":[504,557],"originalLines":"            if (InputFileResolver.isInputFileDescriptor(maybePattern)) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":10,"column":83},"end":{"line":17,"column":9}},"range":[485,751],"originalLines":"        this.inputFileDescriptors = allFileExpressions.map(function (maybePattern) {\r\n            if (InputFileResolver.isInputFileDescriptor(maybePattern)) {\r\n                return maybePattern;\r\n            }\r\n            else {\r\n                return _.assign({ pattern: maybePattern }, DEFAULT_INPUT_FILE_PROPERTIES);\r\n            }\r\n        });","mutatedLines":"        this.inputFileDescriptors = allFileExpressions.map(function (maybePattern) {\n});"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":33,"column":65},"end":{"line":35,"column":13}},"range":[1522,1583],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"            this.workerProcess.stderr.on('data', function (data) {\r\n                log.error(data.toString());\r\n            });","mutatedLines":"            this.workerProcess.stderr.on('data', function (data) {\n});"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"ReverseConditional","status":1,"replacement":"mutate && []","location":{"start":{"line":9,"column":37},"end":{"line":9,"column":49}},"range":[387,399],"originalLines":"        this.mutateFileExpressions = mutate || [];","mutatedLines":"        this.mutateFileExpressions = mutate && [];"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":7,"column":37},"end":{"line":88,"column":1}},"range":[285,4451],"originalLines":"var InputFileResolver = (function () {\r\n    function InputFileResolver(mutate, allFileExpressions) {\r\n        this.mutateFileExpressions = mutate || [];\r\n        this.inputFileDescriptors = allFileExpressions.map(function (maybePattern) {\r\n            if (InputFileResolver.isInputFileDescriptor(maybePattern)) {\r\n                return maybePattern;\r\n            }\r\n            else {\r\n                return _.assign({ pattern: maybePattern }, DEFAULT_INPUT_FILE_PROPERTIES);\r\n            }\r\n        });\r\n    }\r\n    InputFileResolver.prototype.resolve = function () {\r\n        var mutateFilePromise = this.resolveMutateFileGlobs();\r\n        return this.resolveInputFileGlobs().then(function (allInputFiles) { return mutateFilePromise.then(function (additionalMutateFiles) {\r\n            InputFileResolver.markAdditionalFilesToMutate(allInputFiles, additionalMutateFiles);\r\n            InputFileResolver.warnAboutNoFilesToMutate(allInputFiles);\r\n            return allInputFiles;\r\n        }); });\r\n    };\r\n    InputFileResolver.markAdditionalFilesToMutate = function (allInputFiles, additionalMutateFiles) {\r\n        var errors = [];\r\n        additionalMutateFiles.forEach(function (mutateFile) {\r\n            if (!allInputFiles.filter(function (inputFile) { return inputFile.path === mutateFile; }).length) {\r\n                errors.push(\"Could not find mutate file \\\"\" + mutateFile + \"\\\" in list of files.\");\r\n            }\r\n        });\r\n        if (errors.length > 0) {\r\n            throw new Error(errors.join(' '));\r\n        }\r\n        allInputFiles.forEach(function (file) { return file.mutated = additionalMutateFiles.some(function (mutateFile) { return mutateFile === file.path; }) || file.mutated; });\r\n    };\r\n    InputFileResolver.warnAboutNoFilesToMutate = function (allInputFiles) {\r\n        var mutateFiles = allInputFiles.filter(function (file) { return file.mutated; });\r\n        if (mutateFiles.length) {\r\n            log.info(\"Found \" + mutateFiles.length + \" file(s) to be mutated.\");\r\n        }\r\n        else {\r\n            log.warn(\"No files marked to be mutated, stryker will perform a dry-run without actually mutating anything.\");\r\n        }\r\n    };\r\n    InputFileResolver.reportEmptyGlobbingExpression = function (expression) {\r\n        log.warn(\"Globbing expression \\\"\" + expression + \"\\\" did not result in any files.\");\r\n    };\r\n    InputFileResolver.isInputFileDescriptor = function (maybeInputFileDescriptor) {\r\n        if (_.isObject(maybeInputFileDescriptor)) {\r\n            if (Object.keys(maybeInputFileDescriptor).indexOf('pattern') > -1) {\r\n                return true;\r\n            }\r\n            else {\r\n                throw Error(\"File descriptor \" + JSON.stringify(maybeInputFileDescriptor) + \" is missing mandatory property 'pattern'.\");\r\n            }\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    };\r\n    InputFileResolver.prototype.resolveMutateFileGlobs = function () {\r\n        return Promise.all(this.mutateFileExpressions.map(InputFileResolver.resolveFileGlob))\r\n            .then(function (files) { return _.flatten(files); });\r\n    };\r\n    InputFileResolver.prototype.resolveInputFileGlobs = function () {\r\n        return Promise.all(this.inputFileDescriptors.map(function (descriptor) { return InputFileResolver.resolveFileGlob(descriptor.pattern)\r\n            .then(function (sourceFiles) { return sourceFiles.map(function (sourceFile) { return InputFileResolver.createInputFile(sourceFile, descriptor); }); }); })).then(function (promises) { return _.flatten(promises); });\r\n    };\r\n    InputFileResolver.createInputFile = function (path, descriptor) {\r\n        var inputFile = _.assign({ path: path }, DEFAULT_INPUT_FILE_PROPERTIES, descriptor);\r\n        delete inputFile['pattern'];\r\n        return inputFile;\r\n    };\r\n    InputFileResolver.resolveFileGlob = function (expression) {\r\n        var _this = this;\r\n        return fileUtils_1.glob(expression).then(function (files) {\r\n            if (files.length === 0) {\r\n                _this.reportEmptyGlobbingExpression(expression);\r\n            }\r\n            fileUtils_1.normalize(files);\r\n            return files;\r\n        });\r\n    };\r\n    return InputFileResolver;\r\n}());","mutatedLines":"var InputFileResolver = (function () {\n}());"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":52,"column":39},"end":{"line":52,"column":42}},"range":[1912,1915],"originalLines":"            configModule = function () { };","mutatedLines":"            configModule = function () {\n};"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":50,"column":13},"end":{"line":53,"column":9}},"range":[1817,1927],"originalLines":"        else {\r\n            log.debug('No config file specified.');\r\n            configModule = function () { };\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"Math","status":1,"replacement":"'Config file must export a function!\\n' - exports.CONFIG_SYNTAX_HELP","location":{"start":{"line":46,"column":26},"end":{"line":46,"column":94}},"range":[1672,1740],"originalLines":"                log.fatal('Config file must export a function!\\n' + exports.CONFIG_SYNTAX_HELP);","mutatedLines":"                log.fatal('Config file must export a function!\\n' - exports.CONFIG_SYNTAX_HELP);"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":45,"column":45},"end":{"line":48,"column":13}},"range":[1643,1791],"originalLines":"            if (!_.isFunction(configModule)) {\r\n                log.fatal('Config file must export a function!\\n' + exports.CONFIG_SYNTAX_HELP);\r\n                process.exit(1);\r\n            }","mutatedLines":"            if (!_.isFunction(configModule)) {\n}"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":45,"column":16},"end":{"line":45,"column":43}},"range":[1614,1641],"originalLines":"            if (!_.isFunction(configModule)) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":45,"column":16},"end":{"line":45,"column":43}},"range":[1614,1641],"originalLines":"            if (!_.isFunction(configModule)) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"Math","status":1,"replacement":"'Invalid config file!\\n  ' - e.stack","location":{"start":{"line":41,"column":30},"end":{"line":41,"column":66}},"range":[1490,1526],"originalLines":"                    log.fatal('Invalid config file!\\n  ' + e.stack);","mutatedLines":"                    log.fatal('Invalid config file!\\n  ' - e.stack);"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":40,"column":21},"end":{"line":42,"column":17}},"range":[1457,1547],"originalLines":"                else {\r\n                    log.fatal('Invalid config file!\\n  ' + e.stack);\r\n                }","mutatedLines":"                else {\n}"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":36,"column":104},"end":{"line":39,"column":17}},"range":[1295,1434],"originalLines":"                if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(this.options.configFile) !== -1) {\r\n                    log.fatal('File %s does not exist!', this.options.configFile);\r\n                    log.fatal(e);\r\n                }","mutatedLines":"                if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(this.options.configFile) !== -1) {\n}"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"UnaryOperator","status":1,"replacement":"+1","location":{"start":{"line":36,"column":100},"end":{"line":36,"column":102}},"range":[1291,1293],"originalLines":"                if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(this.options.configFile) !== -1) {","mutatedLines":"                if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(this.options.configFile) !== +1) {"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"ReverseConditional","status":1,"replacement":"e.message.indexOf(this.options.configFile) === -1","location":{"start":{"line":36,"column":53},"end":{"line":36,"column":102}},"range":[1244,1293],"originalLines":"                if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(this.options.configFile) !== -1) {","mutatedLines":"                if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(this.options.configFile) === -1) {"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"ReverseConditional","status":1,"replacement":"e.code !== 'MODULE_NOT_FOUND'","location":{"start":{"line":36,"column":20},"end":{"line":36,"column":49}},"range":[1211,1240],"originalLines":"                if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(this.options.configFile) !== -1) {","mutatedLines":"                if (e.code !== 'MODULE_NOT_FOUND' && e.message.indexOf(this.options.configFile) !== -1) {"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"ReverseConditional","status":1,"replacement":"e.code === 'MODULE_NOT_FOUND' || e.message.indexOf(this.options.configFile) !== -1","location":{"start":{"line":36,"column":20},"end":{"line":36,"column":102}},"range":[1211,1293],"originalLines":"                if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(this.options.configFile) !== -1) {","mutatedLines":"                if (e.code === 'MODULE_NOT_FOUND' || e.message.indexOf(this.options.configFile) !== -1) {"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":36,"column":20},"end":{"line":36,"column":102}},"range":[1211,1293],"originalLines":"                if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(this.options.configFile) !== -1) {","mutatedLines":"                if (true) {"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":36,"column":20},"end":{"line":36,"column":102}},"range":[1211,1293],"originalLines":"                if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(this.options.configFile) !== -1) {","mutatedLines":"                if (false) {"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":35,"column":22},"end":{"line":44,"column":13}},"range":[1188,1596],"originalLines":"            catch (e) {\r\n                if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(this.options.configFile) !== -1) {\r\n                    log.fatal('File %s does not exist!', this.options.configFile);\r\n                    log.fatal(e);\r\n                }\r\n                else {\r\n                    log.fatal('Invalid config file!\\n  ' + e.stack);\r\n                }\r\n                process.exit(1);\r\n            }","mutatedLines":"            catch (e) {\n}"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"Math","status":1,"replacement":"process.cwd() - '/'","location":{"start":{"line":33,"column":39},"end":{"line":33,"column":58}},"range":[1102,1121],"originalLines":"                configModule = require(process.cwd() + \"/\" + this.options.configFile);","mutatedLines":"                configModule = require(process.cwd() - '/' + this.options.configFile);"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"Math","status":1,"replacement":"process.cwd() + '/' - this.options.configFile","location":{"start":{"line":33,"column":39},"end":{"line":33,"column":84}},"range":[1102,1147],"originalLines":"                configModule = require(process.cwd() + \"/\" + this.options.configFile);","mutatedLines":"                configModule = require(process.cwd() + '/' - this.options.configFile);"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":32,"column":16},"end":{"line":34,"column":13}},"range":[1060,1164],"originalLines":"            try {\r\n                configModule = require(process.cwd() + \"/\" + this.options.configFile);\r\n            }","mutatedLines":"            try {\n}"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":30,"column":37},"end":{"line":49,"column":9}},"range":[971,1802],"originalLines":"        if (this.options.configFile) {\r\n            log.debug('Loading config %s', this.options.configFile);\r\n            try {\r\n                configModule = require(process.cwd() + \"/\" + this.options.configFile);\r\n            }\r\n            catch (e) {\r\n                if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(this.options.configFile) !== -1) {\r\n                    log.fatal('File %s does not exist!', this.options.configFile);\r\n                    log.fatal(e);\r\n                }\r\n                else {\r\n                    log.fatal('Invalid config file!\\n  ' + e.stack);\r\n                }\r\n                process.exit(1);\r\n            }\r\n            if (!_.isFunction(configModule)) {\r\n                log.fatal('Config file must export a function!\\n' + exports.CONFIG_SYNTAX_HELP);\r\n                process.exit(1);\r\n            }\r\n        }","mutatedLines":"        if (this.options.configFile) {\n}"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":30,"column":12},"end":{"line":30,"column":35}},"range":[946,969],"originalLines":"        if (this.options.configFile) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":30,"column":12},"end":{"line":30,"column":35}},"range":[946,969],"originalLines":"        if (this.options.configFile) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":80,"column":16},"end":{"line":80,"column":34}},"range":[4224,4242],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called \"before each\" hook for \"should result in the expected input files\"","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called \"before each\" hook for \"should log a warning\"","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"            if (files.length === 0) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":28,"column":58},"end":{"line":55,"column":5}},"range":[904,1964],"originalLines":"    ConfigReader.prototype.loadConfigModule = function () {\r\n        var configModule;\r\n        if (this.options.configFile) {\r\n            log.debug('Loading config %s', this.options.configFile);\r\n            try {\r\n                configModule = require(process.cwd() + \"/\" + this.options.configFile);\r\n            }\r\n            catch (e) {\r\n                if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(this.options.configFile) !== -1) {\r\n                    log.fatal('File %s does not exist!', this.options.configFile);\r\n                    log.fatal(e);\r\n                }\r\n                else {\r\n                    log.fatal('Invalid config file!\\n  ' + e.stack);\r\n                }\r\n                process.exit(1);\r\n            }\r\n            if (!_.isFunction(configModule)) {\r\n                log.fatal('Config file must export a function!\\n' + exports.CONFIG_SYNTAX_HELP);\r\n                process.exit(1);\r\n            }\r\n        }\r\n        else {\r\n            log.debug('No config file specified.');\r\n            configModule = function () { };\r\n        }\r\n        return configModule;\r\n    };","mutatedLines":"    ConfigReader.prototype.loadConfigModule = function () {\n};"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":21,"column":18},"end":{"line":24,"column":9}},"range":[681,777],"originalLines":"        catch (e) {\r\n            log.fatal('Error in config file!\\n', e);\r\n            process.exit(1);\r\n        }","mutatedLines":"        catch (e) {\n}"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":15,"column":52},"end":{"line":27,"column":5}},"range":[501,843],"originalLines":"    ConfigReader.prototype.readConfig = function () {\r\n        var configModule = this.loadConfigModule();\r\n        var config = new config_1.Config();\r\n        try {\r\n            configModule(config);\r\n        }\r\n        catch (e) {\r\n            log.fatal('Error in config file!\\n', e);\r\n            process.exit(1);\r\n        }\r\n        config.set(this.options);\r\n        return config;\r\n    };","mutatedLines":"    ConfigReader.prototype.readConfig = function () {\n};"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":70,"column":41},"end":{"line":70,"column":161}},"range":[3614,3734],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called \"before each\" hook for \"should result in the expected input files\"","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files \"before each\" hook for \"should result in the expected input files\"","InputFileResolver without mutate property and without mutated: true in files \"before each\" hook for \"should warn about dry-run\"","InputFileResolver with file expressions that resolve in different order \"before each\" hook for \"should retain original glob order\"","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called \"before each\" hook for \"should log a warning\"","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"            .then(function (sourceFiles) { return sourceFiles.map(function (sourceFile) { return InputFileResolver.createInputFile(sourceFile, descriptor); }); }); })).then(function (promises) { return _.flatten(promises); });","mutatedLines":"            .then(function (sourceFiles) {\n}); })).then(function (promises) { return _.flatten(promises); });"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":12,"column":35},"end":{"line":14,"column":5}},"range":[406,447],"originalLines":"    function ConfigReader(options) {\r\n        this.options = options;\r\n    }","mutatedLines":"    function ConfigReader(options) {\n}"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":11,"column":32},"end":{"line":57,"column":1}},"range":[368,1994],"originalLines":"var ConfigReader = (function () {\r\n    function ConfigReader(options) {\r\n        this.options = options;\r\n    }\r\n    ConfigReader.prototype.readConfig = function () {\r\n        var configModule = this.loadConfigModule();\r\n        var config = new config_1.Config();\r\n        try {\r\n            configModule(config);\r\n        }\r\n        catch (e) {\r\n            log.fatal('Error in config file!\\n', e);\r\n            process.exit(1);\r\n        }\r\n        config.set(this.options);\r\n        return config;\r\n    };\r\n    ConfigReader.prototype.loadConfigModule = function () {\r\n        var configModule;\r\n        if (this.options.configFile) {\r\n            log.debug('Loading config %s', this.options.configFile);\r\n            try {\r\n                configModule = require(process.cwd() + \"/\" + this.options.configFile);\r\n            }\r\n            catch (e) {\r\n                if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(this.options.configFile) !== -1) {\r\n                    log.fatal('File %s does not exist!', this.options.configFile);\r\n                    log.fatal(e);\r\n                }\r\n                else {\r\n                    log.fatal('Invalid config file!\\n  ' + e.stack);\r\n                }\r\n                process.exit(1);\r\n            }\r\n            if (!_.isFunction(configModule)) {\r\n                log.fatal('Config file must export a function!\\n' + exports.CONFIG_SYNTAX_HELP);\r\n                process.exit(1);\r\n            }\r\n        }\r\n        else {\r\n            log.debug('No config file specified.');\r\n            configModule = function () { };\r\n        }\r\n        return configModule;\r\n    };\r\n    return ConfigReader;\r\n}());","mutatedLines":"var ConfigReader = (function () {\n}());"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"Math","status":1,"replacement":"'  module.exports = function(config) {\\n' + '    config.set({\\n' - '      // your config\\n'","location":{"start":{"line":5,"column":29},"end":{"line":7,"column":28}},"range":[152,253],"originalLines":"exports.CONFIG_SYNTAX_HELP = '  module.exports = function(config) {\\n' +\r\n    '    config.set({\\n' +\r\n    '      // your config\\n' +","mutatedLines":"exports.CONFIG_SYNTAX_HELP = '  module.exports = function(config) {\\n' + '    config.set({\\n' - '      // your config\\n' +"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"Math","status":1,"replacement":"'  module.exports = function(config) {\\n' + '    config.set({\\n' + '      // your config\\n' - '    });\\n'","location":{"start":{"line":5,"column":29},"end":{"line":8,"column":15}},"range":[152,272],"originalLines":"exports.CONFIG_SYNTAX_HELP = '  module.exports = function(config) {\\n' +\r\n    '    config.set({\\n' +\r\n    '      // your config\\n' +\r\n    '    });\\n' +","mutatedLines":"exports.CONFIG_SYNTAX_HELP = '  module.exports = function(config) {\\n' + '    config.set({\\n' + '      // your config\\n' - '    });\\n' +"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"Math","status":1,"replacement":"'  module.exports = function(config) {\\n' + '    config.set({\\n' + '      // your config\\n' + '    });\\n' - '  };\\n'","location":{"start":{"line":5,"column":29},"end":{"line":9,"column":12}},"range":[152,288],"originalLines":"exports.CONFIG_SYNTAX_HELP = '  module.exports = function(config) {\\n' +\r\n    '    config.set({\\n' +\r\n    '      // your config\\n' +\r\n    '    });\\n' +\r\n    '  };\\n';","mutatedLines":"exports.CONFIG_SYNTAX_HELP = '  module.exports = function(config) {\\n' + '    config.set({\\n' + '      // your config\\n' + '    });\\n' - '  };\\n';"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":68,"column":68},"end":{"line":71,"column":5}},"range":[3427,3806],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called \"before each\" hook for \"should result in the expected input files\"","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files \"before each\" hook for \"should result in the expected input files\"","InputFileResolver without mutate property and without mutated: true in files \"before each\" hook for \"should warn about dry-run\"","InputFileResolver with file expressions that resolve in different order \"before each\" hook for \"should retain original glob order\"","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called \"before each\" hook for \"should reject the result\"","InputFileResolver when a globbing expression does not result in a result and resolve is called \"before each\" hook for \"should log a warning\"","InputFileResolver when a globbing expression results in a reject \"before each\" hook for \"should reject the promise\"","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"    InputFileResolver.prototype.resolveInputFileGlobs = function () {\r\n        return Promise.all(this.inputFileDescriptors.map(function (descriptor) { return InputFileResolver.resolveFileGlob(descriptor.pattern)\r\n            .then(function (sourceFiles) { return sourceFiles.map(function (sourceFile) { return InputFileResolver.createInputFile(sourceFile, descriptor); }); }); })).then(function (promises) { return _.flatten(promises); });\r\n    };","mutatedLines":"    InputFileResolver.prototype.resolveInputFileGlobs = function () {\n};"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":79,"column":66},"end":{"line":85,"column":9}},"range":[4205,4407],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called \"before each\" hook for \"should result in the expected input files\"","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files \"before each\" hook for \"should result in the expected input files\"","InputFileResolver without mutate property and without mutated: true in files \"before each\" hook for \"should warn about dry-run\"","InputFileResolver with file expressions that resolve in different order \"before each\" hook for \"should retain original glob order\"","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called \"before each\" hook for \"should log a warning\"","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"        return fileUtils_1.glob(expression).then(function (files) {\r\n            if (files.length === 0) {\r\n                _this.reportEmptyGlobbingExpression(expression);\r\n            }\r\n            fileUtils_1.normalize(files);\r\n            return files;\r\n        });","mutatedLines":"        return fileUtils_1.glob(expression).then(function (files) {\n});"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"ConditionalBoundary","status":1,"replacement":"Object.keys(maybeInputFileDescriptor).indexOf('pattern') >= -1","location":{"start":{"line":53,"column":16},"end":{"line":53,"column":77}},"range":[2759,2820],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"            if (Object.keys(maybeInputFileDescriptor).indexOf('pattern') > -1) {","mutatedLines":"            if (Object.keys(maybeInputFileDescriptor).indexOf('pattern') >= -1) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":66,"column":29},"end":{"line":68,"column":9}},"range":[2895,2963],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose \"before each\" hook for \"should kill the child process and start a new one\"","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive \"before each\" hook for \"should kill the child process and start a new one\"","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"        if (options.timeout) {\r\n            this.markNoResultTimeout(options.timeout);\r\n        }","mutatedLines":"        if (options.timeout) {\n}"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":8,"column":59},"end":{"line":18,"column":5}},"range":[347,760],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called \"before each\" hook for \"should result in the expected input files\"","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files \"before each\" hook for \"should result in the expected input files\"","InputFileResolver without mutate property and without mutated: true in files \"before each\" hook for \"should warn about dry-run\"","InputFileResolver with file expressions that resolve in different order \"before each\" hook for \"should retain original glob order\"","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called \"before each\" hook for \"should reject the result\"","InputFileResolver when a globbing expression does not result in a result and resolve is called \"before each\" hook for \"should log a warning\"","InputFileResolver when a globbing expression results in a reject \"before each\" hook for \"should reject the promise\"","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"    function InputFileResolver(mutate, allFileExpressions) {\r\n        this.mutateFileExpressions = mutate || [];\r\n        this.inputFileDescriptors = allFileExpressions.map(function (maybePattern) {\r\n            if (InputFileResolver.isInputFileDescriptor(maybePattern)) {\r\n                return maybePattern;\r\n            }\r\n            else {\r\n                return _.assign({ pattern: maybePattern }, DEFAULT_INPUT_FILE_PROPERTIES);\r\n            }\r\n        });\r\n    }","mutatedLines":"    function InputFileResolver(mutate, allFileExpressions) {\n}"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":18,"column":12},"end":{"line":20,"column":9}},"range":[614,661],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"        try {\r\n            configModule(config);\r\n        }","mutatedLines":"        try {\n}"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"Math","status":2,"replacement":"'  module.exports = function(config) {\\n' - '    config.set({\\n'","location":{"start":{"line":5,"column":29},"end":{"line":6,"column":24}},"range":[152,221],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor should use the config writer to override config","Stryker constructor should freeze the config","Stryker constructor should load plugins","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when coverage can be collected but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should determine the testSelector","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when coverage can be collected without errors or failed tests and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have ran mutant 2 and mutant 4 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"exports.CONFIG_SYNTAX_HELP = '  module.exports = function(config) {\\n' +\r\n    '    config.set({\\n' +","mutatedLines":"exports.CONFIG_SYNTAX_HELP = '  module.exports = function(config) {\\n' - '    config.set({\\n' +"}]