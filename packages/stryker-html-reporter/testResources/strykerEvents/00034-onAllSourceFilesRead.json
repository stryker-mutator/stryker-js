[{"path":"/stryker/src/ConfigReader.js","content":"\"use strict\";\r\nvar config_1 = require('stryker-api/config');\r\nvar log4js = require('log4js');\r\nvar _ = require('lodash');\r\nvar VALID_COVERAGE_ANALYSIS_VALUES = ['perTest', 'all', 'off'];\r\nexports.CONFIG_SYNTAX_HELP = '  module.exports = function(config) {\\n' +\r\n    '    config.set({\\n' +\r\n    '      // your config\\n' +\r\n    '    });\\n' +\r\n    '  };\\n';\r\nvar log = log4js.getLogger('ConfigReader');\r\nvar ConfigReader = (function () {\r\n    function ConfigReader(options) {\r\n        this.options = options;\r\n    }\r\n    ConfigReader.prototype.readConfig = function () {\r\n        var configModule = this.loadConfigModule();\r\n        var config = new config_1.Config();\r\n        try {\r\n            configModule(config);\r\n        }\r\n        catch (e) {\r\n            log.fatal('Error in config file!\\n', e);\r\n            process.exit(1);\r\n        }\r\n        // merge the config from config file and cliOptions (precedence)\r\n        config.set(this.options);\r\n        this.validate(config);\r\n        return config;\r\n    };\r\n    ConfigReader.prototype.loadConfigModule = function () {\r\n        var configModule;\r\n        if (this.options.configFile) {\r\n            log.debug('Loading config %s', this.options.configFile);\r\n            try {\r\n                configModule = require(process.cwd() + \"/\" + this.options.configFile);\r\n            }\r\n            catch (e) {\r\n                if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(this.options.configFile) !== -1) {\r\n                    log.fatal('File %s does not exist!', this.options.configFile);\r\n                    log.fatal(e);\r\n                }\r\n                else {\r\n                    log.fatal('Invalid config file!\\n  ' + e.stack);\r\n                }\r\n                process.exit(1);\r\n            }\r\n            if (!_.isFunction(configModule)) {\r\n                log.fatal('Config file must export a function!\\n' + exports.CONFIG_SYNTAX_HELP);\r\n                process.exit(1);\r\n            }\r\n        }\r\n        else {\r\n            log.debug('No config file specified.');\r\n            // if no config file path is passed, we define a dummy config module.\r\n            configModule = function () { };\r\n        }\r\n        return configModule;\r\n    };\r\n    ConfigReader.prototype.validate = function (options) {\r\n        if (VALID_COVERAGE_ANALYSIS_VALUES.indexOf(options.coverageAnalysis) < 0) {\r\n            log.fatal(\"Value \\\"\" + options.coverageAnalysis + \"\\\" is invalid for `coverageAnalysis`. Expected one of the folowing: \" + VALID_COVERAGE_ANALYSIS_VALUES.map(function (v) { return (\"\\\"\" + v + \"\\\"\"); }).join(', '));\r\n            process.exit(1);\r\n        }\r\n        if (options.coverageAnalysis === 'perTest' && !options.testFramework) {\r\n            var validCoverageAnalysisSettingsExceptPerTest = VALID_COVERAGE_ANALYSIS_VALUES.filter(function (v) { return v !== 'perTest'; }).map(function (v) { return (\"\\\"\" + v + \"\\\"\"); }).join(', ');\r\n            log.fatal(\"Configured coverage analysis 'perTest' requires a test framework to be configured. Either configure your test framework (for example testFramework: 'jasmine') or set coverageAnalysis setting to one of the following: \" + validCoverageAnalysisSettingsExceptPerTest);\r\n            process.exit(1);\r\n        }\r\n    };\r\n    return ConfigReader;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = ConfigReader;\r\n//# sourceMappingURL=ConfigReader.js.map"},{"path":"/stryker/src/coverage/CoverageInstrumenter.js","content":"\"use strict\";\r\nvar log4js = require('log4js');\r\nvar stream_1 = require('stream');\r\nvar objectUtils_1 = require('../utils/objectUtils');\r\nvar CoverageInstrumenterStream_1 = require('./CoverageInstrumenterStream');\r\nvar log = log4js.getLogger('CoverageInstrumenter');\r\nvar COVERAGE_CURRENT_TEST_VARIABLE_NAME = '__strykerCoverageCurrentTest__';\r\n/**\r\n * Represents the CoverageInstrumenter\r\n * Responsible for managing the instrumentation of all files to be mutated.\r\n * In case of `perTest` coverageAnalysis it will hookin to the test framework to accomplish that.\r\n */\r\nvar CoverageInstrumenter = (function () {\r\n    function CoverageInstrumenter(coverageAnalysis, testFramework) {\r\n        this.coverageAnalysis = coverageAnalysis;\r\n        this.testFramework = testFramework;\r\n        this.coverageInstrumenterStreamPerFile = Object.create(null);\r\n    }\r\n    CoverageInstrumenter.prototype.instrumenterStreamForFile = function (file) {\r\n        if (file.mutated) {\r\n            /*\r\n            Coverage variable *must* have the name '__coverage__'. Only that variable\r\n            is reported back to the TestRunner process when using one of the karma\r\n            test framework adapters (karma-jasmine, karma-mocha, ...).\r\n      \r\n            However, when coverageAnalysis is 'perTest' we don't choose that variable name right away,\r\n            because we need that variable to hold all coverage results per test. Instead, we use __strykerCoverageCurrentTest__\r\n            and after each test copy over the value of that current test to the global coverage object __coverage__\r\n             */\r\n            switch (this.coverageAnalysis) {\r\n                case 'all':\r\n                    return this.createStreamForFile('__coverage__', file.path);\r\n                case 'perTest':\r\n                    return this.createStreamForFile(COVERAGE_CURRENT_TEST_VARIABLE_NAME, file.path);\r\n            }\r\n        }\r\n        // By default, do not instrument for code coverage\r\n        return new stream_1.PassThrough();\r\n    };\r\n    CoverageInstrumenter.prototype.hooksForTestRun = function () {\r\n        if (this.coverageAnalysis === 'perTest') {\r\n            log.debug(\"Adding test hooks file for coverageAnalysis \\\"perTest\\\"\");\r\n            return objectUtils_1.wrapInClosure(\"\\n          var id = 0, coverageStateAtStart;\\n          window.__coverage__ = globalCoverage = {};\\n\\n          \" + this.testFramework.beforeEach(beforeEachFragmentPerTest) + \"\\n          \" + this.testFramework.afterEach(afterEachFragmentPerTest) + \"\\n          \" + cloneFunctionFragment + \";\\n      \");\r\n        }\r\n        else {\r\n            return '';\r\n        }\r\n    };\r\n    CoverageInstrumenter.prototype.retrieveStatementMapsPerFile = function () {\r\n        var _this = this;\r\n        var statementMapsPerFile = Object.create(null);\r\n        Object.keys(this.coverageInstrumenterStreamPerFile)\r\n            .forEach(function (key) { return statementMapsPerFile[key] = _this.coverageInstrumenterStreamPerFile[key].statementMap; });\r\n        return statementMapsPerFile;\r\n    };\r\n    CoverageInstrumenter.prototype.createStreamForFile = function (coverageVariable, fileName) {\r\n        var stream = new CoverageInstrumenterStream_1.default(coverageVariable, fileName);\r\n        this.coverageInstrumenterStreamPerFile[fileName] = stream;\r\n        return stream;\r\n    };\r\n    return CoverageInstrumenter;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = CoverageInstrumenter;\r\nvar cloneFunctionFragment = \"    \\n    function clone(source) {\\n        var result = source;\\n        if (Array.isArray(source)) {\\n            result = [];\\n            source.forEach(function (child, index) {\\n                result[index] = clone(child);\\n            });\\n        } else if (typeof source == \\\"object\\\") {\\n            // it is an object literal\\n            result = {};\\n            for (var i in source) {\\n                result[i] = clone(source[i]);\\n            }\\n        }\\n        return result;\\n    }\";\r\nvar beforeEachFragmentPerTest = \"\\nif (!coverageStateAtStart) {\\n  coverageStateAtStart = clone(window.\" + COVERAGE_CURRENT_TEST_VARIABLE_NAME + \");\\n}\";\r\nvar afterEachFragmentPerTest = \"\\n       globalCoverage[id] = coverageResult = {};\\n      id++;\\n           var coveragePerTest = window.\" + COVERAGE_CURRENT_TEST_VARIABLE_NAME + \";\\n            Object.keys(coveragePerTest).forEach(function (file) {\\n                var coverage = coveragePerTest[file];\\n                coverageResult[file] = { s: coverage.s };\\n                coverage.s = clone(coverageStateAtStart[file].s);\\n            });\";\r\n//# sourceMappingURL=CoverageInstrumenter.js.map"},{"path":"/stryker/src/coverage/CoverageInstrumenterStream.js","content":"\"use strict\";\r\nvar __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar stream_1 = require('stream');\r\nvar istanbul_1 = require('istanbul');\r\nvar log4js = require('log4js');\r\nrequire('stryker-api/estree');\r\nvar coverageObjRegex = /\\{.*\"path\".*\"fnMap\".*\"statementMap\".*\"branchMap\".*\\}/g;\r\nvar log = log4js.getLogger('CoverageInstrumenterStream');\r\n/**\r\n * Represents a stream responsible to add code coverage instrumentation and reporting back on the statement map\r\n */\r\nvar CoverageInstrumenterStream = (function (_super) {\r\n    __extends(CoverageInstrumenterStream, _super);\r\n    function CoverageInstrumenterStream(coverageVariable, filename, opts) {\r\n        _super.call(this, opts);\r\n        this.coverageVariable = coverageVariable;\r\n        this.filename = filename;\r\n        this.opts = opts;\r\n        this.source = '';\r\n    }\r\n    CoverageInstrumenterStream.prototype._transform = function (chunk, encoding, callback) {\r\n        if (typeof chunk === 'string') {\r\n            this.source += chunk;\r\n        }\r\n        else {\r\n            this.source += chunk.toString();\r\n        }\r\n        callback();\r\n    };\r\n    CoverageInstrumenterStream.prototype._flush = function (callback) {\r\n        try {\r\n            var instrumenter = new istanbul_1.Instrumenter({ coverageVariable: this.coverageVariable });\r\n            var instrumentedCode = instrumenter.instrumentSync(this.source, this.filename);\r\n            coverageObjRegex.lastIndex = 0;\r\n            var coverageObjectMatch = coverageObjRegex.exec(instrumentedCode).toString();\r\n            var coverageObj = JSON.parse(coverageObjectMatch);\r\n            this.statementMap = coverageObj.statementMap;\r\n            this.push(instrumentedCode);\r\n        }\r\n        catch (err) {\r\n            var error = \"Error while instrumenting file \\\"\" + this.filename + \"\\\", error was: \" + err.toString();\r\n            log.error(error);\r\n            this.push(this.source);\r\n        }\r\n        callback();\r\n    };\r\n    return CoverageInstrumenterStream;\r\n}(stream_1.Transform));\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = CoverageInstrumenterStream;\r\n//# sourceMappingURL=CoverageInstrumenterStream.js.map"},{"path":"/stryker/src/FileStatements.js","content":"\"use strict\";\r\n//# sourceMappingURL=FileStatements.js.map"},{"path":"/stryker/src/InputFileResolver.js","content":"\"use strict\";\r\nvar fileUtils_1 = require('./utils/fileUtils');\r\nvar _ = require('lodash');\r\nvar log4js = require('log4js');\r\nvar log = log4js.getLogger('InputFileResolver');\r\nvar DEFAULT_INPUT_FILE_PROPERTIES = { mutated: false, included: true };\r\nvar InputFileResolver = (function () {\r\n    function InputFileResolver(mutate, allFileExpressions) {\r\n        this.mutateFileExpressions = mutate || [];\r\n        this.inputFileDescriptors = allFileExpressions.map(function (maybePattern) {\r\n            if (InputFileResolver.isInputFileDescriptor(maybePattern)) {\r\n                return maybePattern;\r\n            }\r\n            else {\r\n                return _.assign({ pattern: maybePattern }, DEFAULT_INPUT_FILE_PROPERTIES);\r\n            }\r\n        });\r\n    }\r\n    InputFileResolver.prototype.resolve = function () {\r\n        var mutateFilePromise = this.resolveMutateFileGlobs();\r\n        return this.resolveInputFileGlobs().then(function (allInputFiles) { return mutateFilePromise.then(function (additionalMutateFiles) {\r\n            InputFileResolver.markAdditionalFilesToMutate(allInputFiles, additionalMutateFiles);\r\n            InputFileResolver.warnAboutNoFilesToMutate(allInputFiles);\r\n            return allInputFiles;\r\n        }); });\r\n    };\r\n    InputFileResolver.markAdditionalFilesToMutate = function (allInputFiles, additionalMutateFiles) {\r\n        var errors = [];\r\n        additionalMutateFiles.forEach(function (mutateFile) {\r\n            if (!allInputFiles.filter(function (inputFile) { return inputFile.path === mutateFile; }).length) {\r\n                errors.push(\"Could not find mutate file \\\"\" + mutateFile + \"\\\" in list of files.\");\r\n            }\r\n        });\r\n        if (errors.length > 0) {\r\n            throw new Error(errors.join(' '));\r\n        }\r\n        allInputFiles.forEach(function (file) { return file.mutated = additionalMutateFiles.some(function (mutateFile) { return mutateFile === file.path; }) || file.mutated; });\r\n    };\r\n    InputFileResolver.warnAboutNoFilesToMutate = function (allInputFiles) {\r\n        var mutateFiles = allInputFiles.filter(function (file) { return file.mutated; });\r\n        if (mutateFiles.length) {\r\n            log.info(\"Found \" + mutateFiles.length + \" file(s) to be mutated.\");\r\n        }\r\n        else {\r\n            log.warn(\"No files marked to be mutated, stryker will perform a dry-run without actually mutating anything.\");\r\n        }\r\n    };\r\n    InputFileResolver.reportEmptyGlobbingExpression = function (expression) {\r\n        log.warn(\"Globbing expression \\\"\" + expression + \"\\\" did not result in any files.\");\r\n    };\r\n    InputFileResolver.isInputFileDescriptor = function (maybeInputFileDescriptor) {\r\n        if (_.isObject(maybeInputFileDescriptor)) {\r\n            if (Object.keys(maybeInputFileDescriptor).indexOf('pattern') > -1) {\r\n                return true;\r\n            }\r\n            else {\r\n                throw Error(\"File descriptor \" + JSON.stringify(maybeInputFileDescriptor) + \" is missing mandatory property 'pattern'.\");\r\n            }\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    };\r\n    InputFileResolver.prototype.resolveMutateFileGlobs = function () {\r\n        return Promise.all(this.mutateFileExpressions.map(InputFileResolver.resolveFileGlob))\r\n            .then(function (files) { return _.flatten(files); });\r\n    };\r\n    InputFileResolver.prototype.resolveInputFileGlobs = function () {\r\n        return Promise.all(this.inputFileDescriptors.map(function (descriptor) { return InputFileResolver.resolveFileGlob(descriptor.pattern)\r\n            .then(function (sourceFiles) { return sourceFiles.map(function (sourceFile) { return InputFileResolver.createInputFile(sourceFile, descriptor); }); }); })).then(function (promises) { return _.flatten(promises); });\r\n    };\r\n    InputFileResolver.createInputFile = function (path, descriptor) {\r\n        var inputFile = _.assign({ path: path }, DEFAULT_INPUT_FILE_PROPERTIES, descriptor);\r\n        delete inputFile['pattern'];\r\n        return inputFile;\r\n    };\r\n    InputFileResolver.resolveFileGlob = function (expression) {\r\n        var _this = this;\r\n        return fileUtils_1.glob(expression).then(function (files) {\r\n            if (files.length === 0) {\r\n                _this.reportEmptyGlobbingExpression(expression);\r\n            }\r\n            fileUtils_1.normalize(files);\r\n            return files;\r\n        });\r\n    };\r\n    return InputFileResolver;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = InputFileResolver;\r\n//# sourceMappingURL=InputFileResolver.js.map"},{"path":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","content":"\"use strict\";\r\nvar __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar test_runner_1 = require('stryker-api/test_runner');\r\nvar child_process_1 = require('child_process');\r\nvar _ = require('lodash');\r\nvar log4js = require('log4js');\r\nvar events_1 = require('events');\r\nvar objectUtils_1 = require('../utils/objectUtils');\r\nvar log = log4js.getLogger('IsolatedTestRunnerAdapter');\r\nvar MAX_WAIT_FOR_DISPOSE = 2000;\r\n/**\r\n * Runs the given test runner in a child process and forwards reports about test results\r\n * Also implements timeout-mechanisme (on timeout, restart the child runner and report timeout)\r\n */\r\nvar TestRunnerChildProcessAdapter = (function (_super) {\r\n    __extends(TestRunnerChildProcessAdapter, _super);\r\n    function TestRunnerChildProcessAdapter(realTestRunnerName, options) {\r\n        _super.call(this);\r\n        this.realTestRunnerName = realTestRunnerName;\r\n        this.options = options;\r\n        this.startWorker();\r\n    }\r\n    TestRunnerChildProcessAdapter.prototype.startWorker = function () {\r\n        // Remove --debug-brk from process arguments. \r\n        // When debugging, it will try to reuse the same debug port, which will be taken by the main process.\r\n        var execArgv = _.clone(process.execArgv);\r\n        _.remove(execArgv, function (arg) { return arg.substr(0, 11) === '--debug-brk'; });\r\n        this.workerProcess = child_process_1.fork(__dirname + \"/IsolatedTestRunnerAdapterWorker\", [], { silent: true, execArgv: execArgv });\r\n        this.sendStartCommand();\r\n        this.listenToWorkerProcess();\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.listenToWorkerProcess = function () {\r\n        var _this = this;\r\n        if (this.workerProcess.stdout) {\r\n            var traceEnabled_1 = log.isTraceEnabled();\r\n            this.workerProcess.stdout.on('data', function (data) {\r\n                if (traceEnabled_1) {\r\n                    log.trace(data.toString());\r\n                }\r\n            });\r\n        }\r\n        if (this.workerProcess.stderr) {\r\n            this.workerProcess.stderr.on('data', function (data) {\r\n                log.error(data.toString());\r\n            });\r\n        }\r\n        this.workerProcess.on('message', function (message) {\r\n            _this.clearCurrentTimer();\r\n            switch (message.kind) {\r\n                case 'result':\r\n                    if (!_this.isDisposing) {\r\n                        _this.runPromiseFulfillmentCallback(message.result);\r\n                    }\r\n                    break;\r\n                case 'initDone':\r\n                    _this.initPromiseFulfillmentCallback();\r\n                    break;\r\n                case 'disposeDone':\r\n                    _this.disposePromiseFulfillmentCallback();\r\n                    break;\r\n                default:\r\n                    _this.logReceivedMessageWarning(message);\r\n                    break;\r\n            }\r\n        });\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.logReceivedMessageWarning = function (message) {\r\n        log.error(\"Retrieved unrecognized message from child process: \" + JSON.stringify(message));\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.init = function () {\r\n        var _this = this;\r\n        this.initPromise = new Promise(function (resolve) { return _this.initPromiseFulfillmentCallback = resolve; });\r\n        this.sendInitCommand();\r\n        return this.initPromise;\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.run = function (options) {\r\n        var _this = this;\r\n        this.clearCurrentTimer();\r\n        if (options.timeout) {\r\n            this.markNoResultTimeout(options.timeout);\r\n        }\r\n        this.runPromise = new Promise(function (resolve) {\r\n            _this.runPromiseFulfillmentCallback = resolve;\r\n            _this.sendRunCommand(options);\r\n            _this.currentRunStartedTimestamp = new Date();\r\n        });\r\n        return this.runPromise;\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.dispose = function () {\r\n        var _this = this;\r\n        if (this.isDisposing) {\r\n            return this.disposingPromise;\r\n        }\r\n        else {\r\n            this.isDisposing = true;\r\n            this.disposingPromise = new Promise(function (resolve) { return _this.disposePromiseFulfillmentCallback = resolve; })\r\n                .then(function () {\r\n                clearTimeout(timer_1);\r\n                _this.workerProcess.kill();\r\n                _this.isDisposing = false;\r\n            });\r\n            this.clearCurrentTimer();\r\n            this.sendDisposeCommand();\r\n            var timer_1 = setTimeout(this.disposePromiseFulfillmentCallback, MAX_WAIT_FOR_DISPOSE);\r\n            return this.disposingPromise;\r\n        }\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.sendRunCommand = function (options) {\r\n        this.send({\r\n            kind: 'run',\r\n            runOptions: options\r\n        });\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.send = function (message) {\r\n        // Serialize message before sending to preserve all javascript, including regexes and functions\r\n        // See https://github.com/stryker-mutator/stryker/issues/143\r\n        this.workerProcess.send(objectUtils_1.serialize(message));\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.sendStartCommand = function () {\r\n        this.send({\r\n            kind: 'start',\r\n            runnerName: this.realTestRunnerName,\r\n            runnerOptions: this.options\r\n        });\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.sendInitCommand = function () {\r\n        this.send({ kind: 'init' });\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.sendDisposeCommand = function () {\r\n        this.send({ kind: 'dispose' });\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.clearCurrentTimer = function () {\r\n        if (this.currentTimeoutTimer) {\r\n            clearTimeout(this.currentTimeoutTimer);\r\n        }\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.markNoResultTimeout = function (timeoutMs) {\r\n        var _this = this;\r\n        this.currentTimeoutTimer = setTimeout(function () {\r\n            _this.handleTimeout();\r\n        }, timeoutMs);\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.handleTimeout = function () {\r\n        var _this = this;\r\n        this.dispose()\r\n            .then(function () { return _this.startWorker(); })\r\n            .then(function () { return _this.init(); })\r\n            .then(function () { return _this.runPromiseFulfillmentCallback({ status: test_runner_1.RunStatus.Timeout, tests: [] }); });\r\n    };\r\n    return TestRunnerChildProcessAdapter;\r\n}(events_1.EventEmitter));\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = TestRunnerChildProcessAdapter;\r\n//# sourceMappingURL=IsolatedTestRunnerAdapter.js.map"},{"path":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterFactory.js","content":"\"use strict\";\r\nvar IsolatedTestRunnerAdapter_1 = require('./IsolatedTestRunnerAdapter');\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = {\r\n    create: function (settings) {\r\n        return new IsolatedTestRunnerAdapter_1.default(settings.strykerOptions.testRunner, settings);\r\n    }\r\n};\r\n//# sourceMappingURL=IsolatedTestRunnerAdapterFactory.js.map"},{"path":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","content":"\"use strict\";\r\nvar test_runner_1 = require('stryker-api/test_runner');\r\nvar PluginLoader_1 = require('../PluginLoader');\r\nvar log4js = require('log4js');\r\nvar objectUtils_1 = require('../utils/objectUtils');\r\nvar log = log4js.getLogger('IsolatedTestRunnerAdapterWorker');\r\nvar IsolatedTestRunnerAdapterWorker = (function () {\r\n    function IsolatedTestRunnerAdapterWorker() {\r\n        this.listenToMessages();\r\n    }\r\n    IsolatedTestRunnerAdapterWorker.prototype.listenToMessages = function () {\r\n        var _this = this;\r\n        process.on('message', function (serializedMessage) {\r\n            var message = objectUtils_1.deserialize(serializedMessage);\r\n            switch (message.kind) {\r\n                case 'start':\r\n                    _this.start(message);\r\n                    break;\r\n                case 'run':\r\n                    _this.run(message);\r\n                    break;\r\n                case 'init':\r\n                    _this.init();\r\n                    break;\r\n                case 'dispose':\r\n                    _this.dispose();\r\n                    break;\r\n                default:\r\n                    _this.logReceivedMessageWarning(message);\r\n            }\r\n        });\r\n    };\r\n    IsolatedTestRunnerAdapterWorker.prototype.logReceivedMessageWarning = function (message) {\r\n        log.warn('Received unsupported message: {}', JSON.stringify(message));\r\n    };\r\n    IsolatedTestRunnerAdapterWorker.prototype.start = function (message) {\r\n        this.loadPlugins(message.runnerOptions.strykerOptions.plugins);\r\n        this.underlyingTestRunner = test_runner_1.TestRunnerFactory.instance().create(message.runnerName, message.runnerOptions);\r\n    };\r\n    IsolatedTestRunnerAdapterWorker.prototype.init = function () {\r\n        var initPromise = void 0;\r\n        if (this.underlyingTestRunner.init) {\r\n            initPromise = this.underlyingTestRunner.init();\r\n        }\r\n        if (objectUtils_1.isPromise(initPromise)) {\r\n            initPromise.then(this.sendInitDone);\r\n        }\r\n        else {\r\n            this.sendInitDone();\r\n        }\r\n    };\r\n    IsolatedTestRunnerAdapterWorker.prototype.sendInitDone = function () {\r\n        var message = { kind: 'initDone' };\r\n        process.send(message);\r\n    };\r\n    IsolatedTestRunnerAdapterWorker.prototype.dispose = function () {\r\n        var disposePromise = void 0;\r\n        if (this.underlyingTestRunner.dispose) {\r\n            disposePromise = this.underlyingTestRunner.dispose();\r\n        }\r\n        if (objectUtils_1.isPromise(disposePromise)) {\r\n            disposePromise.then(this.sendDisposeDone);\r\n        }\r\n        else {\r\n            this.sendDisposeDone();\r\n        }\r\n    };\r\n    IsolatedTestRunnerAdapterWorker.prototype.sendDisposeDone = function () {\r\n        this.send({ kind: 'disposeDone' });\r\n    };\r\n    IsolatedTestRunnerAdapterWorker.prototype.run = function (body) {\r\n        var _this = this;\r\n        this.underlyingTestRunner.run(body.runOptions).then(function (res) { return _this.reportResult(res); }, function (error) { return _this.reportErrorResult(error); });\r\n    };\r\n    IsolatedTestRunnerAdapterWorker.prototype.send = function (message) {\r\n        process.send(message);\r\n    };\r\n    IsolatedTestRunnerAdapterWorker.prototype.loadPlugins = function (plugins) {\r\n        new PluginLoader_1.default(plugins).load();\r\n    };\r\n    IsolatedTestRunnerAdapterWorker.prototype.reportResult = function (result) {\r\n        // If the test runner didn't report on coverage, let's try to do it ourselves.\r\n        if (!result.coverage) {\r\n            result.coverage = (Function('return this'))().__coverage__;\r\n        }\r\n        if (result.errorMessages) {\r\n            // errorMessages should be a string[]\r\n            // Just in case the test runner implementer forgot to convert `Error`s to string, we will do it here\r\n            // https://github.com/stryker-mutator/stryker/issues/141\r\n            result.errorMessages = result.errorMessages.map(function (error) {\r\n                if (error instanceof Error) {\r\n                    return error.name + \": \" + error.message + \"\\n\" + error.stack.toString();\r\n                }\r\n                else {\r\n                    return error.toString();\r\n                }\r\n            });\r\n        }\r\n        this.send({\r\n            kind: 'result',\r\n            result: result\r\n        });\r\n    };\r\n    IsolatedTestRunnerAdapterWorker.prototype.reportErrorResult = function (error) {\r\n        var runResult = {\r\n            tests: [],\r\n            status: test_runner_1.RunStatus.Error,\r\n        };\r\n        if (error) {\r\n            if (Array.isArray(error)) {\r\n                runResult.errorMessages = error.map(function (e) { return e; });\r\n            }\r\n            else {\r\n                runResult.errorMessages = [error];\r\n            }\r\n        }\r\n        this.reportResult(runResult);\r\n    };\r\n    return IsolatedTestRunnerAdapterWorker;\r\n}());\r\nnew IsolatedTestRunnerAdapterWorker();\r\n//# sourceMappingURL=IsolatedTestRunnerAdapterWorker.js.map"},{"path":"/stryker/src/isolated-runner/MessageProtocol.js","content":"\"use strict\";\r\n//# sourceMappingURL=MessageProtocol.js.map"},{"path":"/stryker/src/Mutant.js","content":"\"use strict\";\r\nvar StrykerTempFolder_1 = require('./utils/StrykerTempFolder');\r\n/**\r\n * Represents a mutation which has been applied to a file.\r\n */\r\nvar Mutant = (function () {\r\n    /**\r\n     * @param mutatorName - The name of the Mutator which created this mutant.\r\n     * @param filename - The name of the file which was mutated, including the path.\r\n     * @param originalCode - The original content of the file which has not been mutated.\r\n     * @param replacement - The mutated code which will replace a part of the originalCode.\r\n     * @param location - The location of the code to be mutated - line and column based\r\n     * @param range - The location of the code to be mutated - index based\r\n     */\r\n    function Mutant(mutatorName, filename, originalCode, replacement, location, range) {\r\n        this.mutatorName = mutatorName;\r\n        this.filename = filename;\r\n        this.originalCode = originalCode;\r\n        this.replacement = replacement;\r\n        this.location = location;\r\n        this.range = range;\r\n        this._scopedTestIds = [];\r\n        this.specsRan = [];\r\n        this._timeSpentScopedTests = 0;\r\n    }\r\n    Object.defineProperty(Mutant.prototype, \"scopedTestIds\", {\r\n        get: function () {\r\n            return this._scopedTestIds;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Mutant.prototype, \"timeSpentScopedTests\", {\r\n        get: function () {\r\n            return this._timeSpentScopedTests;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Mutant.prototype.addTestResult = function (index, testResult) {\r\n        this._scopedTestIds.push(index);\r\n        this._timeSpentScopedTests += testResult.timeSpentMs;\r\n    };\r\n    Mutant.prototype.isNewLine = function (index) {\r\n        var char = this.originalCode[index];\r\n        return char === '\\n' || char === '\\r';\r\n    };\r\n    Mutant.prototype.getMutationLineIndexes = function () {\r\n        var startIndexLines = this.range[0], endIndexLines = this.range[1];\r\n        while (startIndexLines > 0 && !this.isNewLine(startIndexLines - 1)) {\r\n            startIndexLines--;\r\n        }\r\n        while (endIndexLines < this.originalCode.length && !this.isNewLine(endIndexLines)) {\r\n            endIndexLines++;\r\n        }\r\n        return [startIndexLines, endIndexLines];\r\n    };\r\n    Object.defineProperty(Mutant.prototype, \"originalLines\", {\r\n        get: function () {\r\n            var _a = this.getMutationLineIndexes(), startIndex = _a[0], endIndex = _a[1];\r\n            return this.originalCode.substring(startIndex, endIndex);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Mutant.prototype, \"mutatedLines\", {\r\n        get: function () {\r\n            var _a = this.getMutationLineIndexes(), startIndex = _a[0], endIndex = _a[1];\r\n            return this.originalCode.substring(startIndex, this.range[0]) + this.replacement + this.originalCode.substring(this.range[1], endIndex);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Mutant.prototype, \"mutatedCode\", {\r\n        get: function () {\r\n            return this.originalCode.substr(0, this.range[0]) + this.replacement + this.originalCode.substr(this.range[1]);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Saves the mutated code in a mutated file.\r\n     * @function\r\n     */\r\n    Mutant.prototype.save = function (filename) {\r\n        return StrykerTempFolder_1.default.writeFile(filename, this.mutatedCode);\r\n    };\r\n    ;\r\n    /**\r\n     * Removes the mutated file.\r\n     * @function\r\n     */\r\n    Mutant.prototype.reset = function (filename) {\r\n        return StrykerTempFolder_1.default.writeFile(filename, this.originalCode);\r\n    };\r\n    ;\r\n    return Mutant;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = Mutant;\r\n//# sourceMappingURL=Mutant.js.map"},{"path":"/stryker/src/MutantTestMatcher.js","content":"\"use strict\";\r\nvar MutantTestMatcher = (function () {\r\n    function MutantTestMatcher(mutants, initialRunResult, statementMaps, options) {\r\n        this.mutants = mutants;\r\n        this.initialRunResult = initialRunResult;\r\n        this.statementMaps = statementMaps;\r\n        this.options = options;\r\n    }\r\n    MutantTestMatcher.prototype.matchWithMutants = function () {\r\n        var _this = this;\r\n        this.mutants.forEach(function (mutant) {\r\n            var statementMap = _this.statementMaps[mutant.filename];\r\n            var smallestStatement = _this.findSmallestCoveringStatement(mutant, statementMap);\r\n            _this.initialRunResult.tests.forEach(function (testResult, id) {\r\n                var covered = false;\r\n                var coverageCollection = _this.findCoverageCollectionForTest(id);\r\n                if (coverageCollection && smallestStatement) {\r\n                    var coveredFile = coverageCollection[mutant.filename];\r\n                    if (coveredFile) {\r\n                        covered = coveredFile.s[smallestStatement] > 0;\r\n                    }\r\n                }\r\n                else {\r\n                    // If there is no coverage data we have to assume that the test covers the mutant\r\n                    covered = true;\r\n                }\r\n                if (covered) {\r\n                    mutant.addTestResult(id, testResult);\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Finds the smallest statement that covers a mutant.\r\n     * @param mutant The mutant.\r\n     * @param statementMap of the covering file.\r\n     * @returns The index of the coveredFile which contains the smallest statement surrounding the mutant.\r\n     */\r\n    MutantTestMatcher.prototype.findSmallestCoveringStatement = function (mutant, statementMap) {\r\n        var _this = this;\r\n        var smallestStatement = null;\r\n        if (statementMap) {\r\n            Object.keys(statementMap).forEach(function (statementId) {\r\n                var location = statementMap[statementId];\r\n                if (_this.statementCoversMutant(mutant.location, location) && _this.isNewSmallestStatement(statementMap[smallestStatement], location)) {\r\n                    smallestStatement = statementId;\r\n                }\r\n            });\r\n        }\r\n        return smallestStatement;\r\n    };\r\n    /**\r\n     * Indicates whether a statement is the smallest statement of the two statements provided.\r\n     * @param originalLocation The area which may cover a bigger area than the newLocation.\r\n     * @param newLocation The area which may cover a smaller area than the originalLocation.\r\n     * @returns true if the newLocation covers a smaller area than the originalLocation, making it the smaller statement.\r\n     */\r\n    MutantTestMatcher.prototype.isNewSmallestStatement = function (originalLocation, newLocation) {\r\n        var statementIsSmallestStatement = false;\r\n        if (!originalLocation) {\r\n            statementIsSmallestStatement = true;\r\n        }\r\n        else {\r\n            var lineDifference = (originalLocation.end.line - originalLocation.start.line) - (newLocation.end.line - newLocation.start.line);\r\n            var coversLessLines = lineDifference > 0;\r\n            var coversLessColumns = lineDifference === 0 && (newLocation.start.column - originalLocation.start.column) + (originalLocation.end.column - newLocation.end.column) > 0;\r\n            if (coversLessLines || coversLessColumns) {\r\n                statementIsSmallestStatement = true;\r\n            }\r\n        }\r\n        return statementIsSmallestStatement;\r\n    };\r\n    /**\r\n     * Indicates whether a statement covers a mutant.\r\n     * @param mutantLocation The location of the mutant.\r\n     * @param statementLocation The location of the statement.\r\n     * @returns true if the statment covers the mutant.\r\n     */\r\n    MutantTestMatcher.prototype.statementCoversMutant = function (mutantLocation, statementLocation) {\r\n        var mutantIsAfterStart = mutantLocation.start.line > statementLocation.start.line ||\r\n            (mutantLocation.start.line === statementLocation.start.line && mutantLocation.start.column >= statementLocation.start.column);\r\n        var mutantIsBeforeEnd = mutantLocation.end.line < statementLocation.end.line ||\r\n            (mutantLocation.end.line === statementLocation.end.line && mutantLocation.end.column <= statementLocation.end.column);\r\n        return mutantIsAfterStart && mutantIsBeforeEnd;\r\n    };\r\n    MutantTestMatcher.prototype.findCoverageCollectionForTest = function (testId) {\r\n        if (this.initialRunResult.coverage) {\r\n            if (this.isCoverageCollectionPerTest(this.initialRunResult.coverage)) {\r\n                return this.initialRunResult.coverage[testId];\r\n            }\r\n            else {\r\n                return this.initialRunResult.coverage;\r\n            }\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    };\r\n    MutantTestMatcher.prototype.isCoverageCollectionPerTest = function (coverage) {\r\n        return this.options.coverageAnalysis === 'perTest';\r\n    };\r\n    return MutantTestMatcher;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = MutantTestMatcher;\r\n//# sourceMappingURL=MutantTestMatcher.js.map"},{"path":"/stryker/src/MutatorOrchestrator.js","content":"\"use strict\";\r\nvar BinaryOperatorMutator_1 = require('./mutators/BinaryOperatorMutator');\r\nvar BlockStatementMutator_1 = require('./mutators/BlockStatementMutator');\r\nvar LogicalOperatorMutator_1 = require('./mutators/LogicalOperatorMutator');\r\nvar RemoveConditionalsMutator_1 = require('./mutators/RemoveConditionalsMutator');\r\nvar UnaryOperatorMutator_1 = require('./mutators/UnaryOperatorMutator');\r\nvar UpdateOperatorMutator_1 = require('./mutators/UpdateOperatorMutator');\r\nvar mutant_1 = require('stryker-api/mutant');\r\nvar fileUtils = require('./utils/fileUtils');\r\nvar Mutant_1 = require('./Mutant');\r\nvar parserUtils = require('./utils/parserUtils');\r\nvar log4js = require('log4js');\r\nvar objectUtils_1 = require('./utils/objectUtils');\r\nvar log = log4js.getLogger('Mutator');\r\n/**\r\n * Class capable of finding spots to mutate in files.\r\n */\r\nvar MutatorOrchestrator = (function () {\r\n    /**\r\n     * @param reporter - The reporter to report read input files to\r\n     */\r\n    function MutatorOrchestrator(reporter) {\r\n        var _this = this;\r\n        this.reporter = reporter;\r\n        this.mutators = [];\r\n        this.registerDefaultMutators();\r\n        var mutatorFactory = mutant_1.MutatorFactory.instance();\r\n        mutatorFactory.knownNames().forEach(function (name) { return _this.mutators.push(mutatorFactory.create(name, null)); });\r\n    }\r\n    /**\r\n     * Mutates source files. Mutated code is not writen to disk.\r\n     * @function\r\n     * @param sourceFiles - The list of files which should be mutated.\r\n     * @returns {Mutant[]} The generated Mutants.\r\n     */\r\n    MutatorOrchestrator.prototype.generateMutants = function (sourceFiles) {\r\n        var _this = this;\r\n        var mutants = [];\r\n        this.sourceFiles = [];\r\n        sourceFiles.forEach(function (sourceFile) {\r\n            try {\r\n                var fileContent = fileUtils.readFile(sourceFile);\r\n                _this.reportFileRead(sourceFile, fileContent);\r\n                var abstractSyntaxTree = parserUtils.parse(fileContent);\r\n                var nodes = parserUtils.collectFrozenNodes(abstractSyntaxTree);\r\n                var newMutants = _this.findMutants(sourceFile, fileContent, abstractSyntaxTree, nodes);\r\n                mutants = mutants.concat(newMutants);\r\n            }\r\n            catch (err) {\r\n                switch (err.code) {\r\n                    case 'ENOENT':\r\n                        log.info(\"Skipping file \" + err.path + \" because it does not exist\");\r\n                        break;\r\n                    default:\r\n                        console.log(err);\r\n                        throw err;\r\n                }\r\n            }\r\n        });\r\n        this.reportAllFilesRead();\r\n        return mutants;\r\n    };\r\n    ;\r\n    MutatorOrchestrator.prototype.reportFileRead = function (path, content) {\r\n        var fileToReport = { path: path, content: content };\r\n        objectUtils_1.freezeRecursively(fileToReport);\r\n        this.sourceFiles.push(fileToReport);\r\n        this.reporter.onSourceFileRead(fileToReport);\r\n    };\r\n    MutatorOrchestrator.prototype.reportAllFilesRead = function () {\r\n        objectUtils_1.freezeRecursively(this.sourceFiles);\r\n        this.reporter.onAllSourceFilesRead(this.sourceFiles);\r\n    };\r\n    MutatorOrchestrator.prototype.registerDefaultMutators = function () {\r\n        var mutatorFactory = mutant_1.MutatorFactory.instance();\r\n        mutatorFactory.register('BinaryOperator', BinaryOperatorMutator_1.default);\r\n        mutatorFactory.register('BlockStatement', BlockStatementMutator_1.default);\r\n        mutatorFactory.register('LogicalOperator', LogicalOperatorMutator_1.default);\r\n        mutatorFactory.register('RemoveConditionals', RemoveConditionalsMutator_1.default);\r\n        mutatorFactory.register('UnaryOperator', UnaryOperatorMutator_1.default);\r\n        mutatorFactory.register('UpdateOperator', UpdateOperatorMutator_1.default);\r\n    };\r\n    /**\r\n     * Finds all mutants for a given set of nodes.\r\n     * @function\r\n     * @param {String} sourceFile - The name source file.\r\n     * @param {String} originalCode - The original content of the file which has not been mutated.\r\n     * @param {Object} ast - The original abstract syntax tree which is used for reference when generating code.\r\n     * @param {AbstractSyntaxTreeNode[]} nodes - The nodes which could be used by mutations to generate mutants.\r\n     * @returns {Mutant[]} All possible Mutants for the given set of nodes.\r\n     */\r\n    MutatorOrchestrator.prototype.findMutants = function (sourceFile, originalCode, ast, nodes) {\r\n        var _this = this;\r\n        var mutants = [];\r\n        nodes.forEach(function (astnode) {\r\n            if (astnode.type) {\r\n                Object.freeze(astnode);\r\n                _this.mutators.forEach(function (mutator) {\r\n                    try {\r\n                        var mutatedNodes = mutator.applyMutations(astnode, objectUtils_1.copy);\r\n                        if (mutatedNodes) {\r\n                            if (!Array.isArray(mutatedNodes)) {\r\n                                mutatedNodes = [mutatedNodes];\r\n                            }\r\n                            if (mutatedNodes.length > 0) {\r\n                                log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);\r\n                            }\r\n                            mutatedNodes.forEach(function (mutatedNode) {\r\n                                var mutatedCode = parserUtils.generate(mutatedNode);\r\n                                var originalNode = nodes[mutatedNode.nodeID];\r\n                                mutants.push(new Mutant_1.default(mutator.name, sourceFile, originalCode, mutatedCode, originalNode.loc, originalNode.range));\r\n                            });\r\n                        }\r\n                    }\r\n                    catch (error) {\r\n                        throw new Error(\"The mutator named '\" + mutator.name + \"' caused an error: \" + error);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n        return mutants;\r\n    };\r\n    ;\r\n    return MutatorOrchestrator;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = MutatorOrchestrator;\r\n//# sourceMappingURL=MutatorOrchestrator.js.map"},{"path":"/stryker/src/mutators/BinaryOperatorMutator.js","content":"\"use strict\";\r\nvar esprima_1 = require('esprima');\r\nvar BinaryOperatorMutator = (function () {\r\n    function BinaryOperatorMutator() {\r\n        this.name = 'BinaryOperator';\r\n        this.operators = {\r\n            '+': '-',\r\n            '-': '+',\r\n            '*': '/',\r\n            '/': '*',\r\n            '%': '*',\r\n            '<': ['<=', '>='],\r\n            '<=': ['<', '>'],\r\n            '>': ['>=', '<='],\r\n            '>=': ['>', '<'],\r\n            '==': '!=',\r\n            '!=': '==',\r\n            '===': '!==',\r\n            '!==': '==='\r\n        };\r\n    }\r\n    BinaryOperatorMutator.prototype.applyMutations = function (node, copy) {\r\n        var nodes = [];\r\n        if (node.type === esprima_1.Syntax.BinaryExpression && this.operators[node.operator]) {\r\n            var binaryNode_1 = node;\r\n            var mutatedOperators = this.operators[node.operator];\r\n            if (typeof mutatedOperators === 'string') {\r\n                mutatedOperators = [mutatedOperators];\r\n            }\r\n            mutatedOperators.forEach(function (operator) {\r\n                var mutatedNode = copy(binaryNode_1);\r\n                mutatedNode.operator = operator;\r\n                nodes.push(mutatedNode);\r\n            });\r\n        }\r\n        return nodes;\r\n    };\r\n    return BinaryOperatorMutator;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = BinaryOperatorMutator;\r\n//# sourceMappingURL=BinaryOperatorMutator.js.map"},{"path":"/stryker/src/mutators/BlockStatementMutator.js","content":"\"use strict\";\r\nvar esprima_1 = require('esprima');\r\n/**\r\n * Represents a mutator which can remove the content of a BlockStatement.\r\n */\r\nvar BlockStatementMutator = (function () {\r\n    function BlockStatementMutator() {\r\n        this.name = 'BlockStatement';\r\n        this.type = esprima_1.Syntax.BlockStatement;\r\n    }\r\n    BlockStatementMutator.prototype.applyMutations = function (node, copy) {\r\n        if (node.type === esprima_1.Syntax.BlockStatement && node.body.length > 0) {\r\n            var mutatedNode = copy(node);\r\n            mutatedNode.body = [];\r\n            return mutatedNode;\r\n        }\r\n    };\r\n    return BlockStatementMutator;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = BlockStatementMutator;\r\n//# sourceMappingURL=BlockStatementMutator.js.map"},{"path":"/stryker/src/mutators/LogicalOperatorMutator.js","content":"\"use strict\";\r\nvar esprima_1 = require('esprima');\r\nvar LogicalOperatorMutator = (function () {\r\n    function LogicalOperatorMutator() {\r\n        this.name = 'LogicalOperator';\r\n        this.type = esprima_1.Syntax.LogicalExpression;\r\n        this.operators = {\r\n            '&&': '||',\r\n            '||': '&&'\r\n        };\r\n    }\r\n    LogicalOperatorMutator.prototype.applyMutations = function (node, copy) {\r\n        var nodes = [];\r\n        if (node.type === esprima_1.Syntax.LogicalExpression && this.operators[node.operator]) {\r\n            var mutatedNode = copy(node);\r\n            mutatedNode.operator = this.operators[node.operator];\r\n            nodes.push(mutatedNode);\r\n        }\r\n        return nodes;\r\n    };\r\n    return LogicalOperatorMutator;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = LogicalOperatorMutator;\r\n//# sourceMappingURL=LogicalOperatorMutator.js.map"},{"path":"/stryker/src/mutators/RemoveConditionalsMutator.js","content":"\"use strict\";\r\nvar esprima_1 = require('esprima');\r\n/**\r\n * Represents a mutator which can remove the conditional clause from statements.\r\n */\r\nvar RemoveConditionalsMutator = (function () {\r\n    function RemoveConditionalsMutator() {\r\n        this.name = 'RemoveConditionals';\r\n        this.types = [esprima_1.Syntax.DoWhileStatement, esprima_1.Syntax.IfStatement, esprima_1.Syntax.ForStatement, esprima_1.Syntax.WhileStatement, esprima_1.Syntax.ConditionalExpression];\r\n    }\r\n    RemoveConditionalsMutator.prototype.applyMutations = function (node, copy) {\r\n        if (this.canMutate(node)) {\r\n            var nodes = [];\r\n            nodes.push(this.booleanLiteralNode(node.test.nodeID, false));\r\n            if (node.type === esprima_1.Syntax.IfStatement || node.type === esprima_1.Syntax.ConditionalExpression) {\r\n                nodes.push(this.booleanLiteralNode(node.test.nodeID, true));\r\n            }\r\n            return nodes;\r\n        }\r\n    };\r\n    RemoveConditionalsMutator.prototype.booleanLiteralNode = function (nodeID, value) {\r\n        return {\r\n            nodeID: nodeID,\r\n            type: esprima_1.Syntax.Literal,\r\n            value: value,\r\n            raw: value.toString()\r\n        };\r\n    };\r\n    RemoveConditionalsMutator.prototype.canMutate = function (node) {\r\n        return this.types.indexOf(node.type) >= 0;\r\n    };\r\n    ;\r\n    return RemoveConditionalsMutator;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = RemoveConditionalsMutator;\r\n//# sourceMappingURL=RemoveConditionalsMutator.js.map"},{"path":"/stryker/src/mutators/UnaryOperatorMutator.js","content":"\"use strict\";\r\nvar esprima_1 = require('esprima');\r\nvar UnaryOperatorMutator = (function () {\r\n    function UnaryOperatorMutator() {\r\n        this.name = 'UnaryOperator';\r\n        this.type = esprima_1.Syntax.UnaryExpression;\r\n        this.operators = {\r\n            '+': '-',\r\n            '-': '+'\r\n        };\r\n    }\r\n    UnaryOperatorMutator.prototype.applyMutations = function (node, copy) {\r\n        var nodes = [];\r\n        if (node.type === esprima_1.Syntax.UnaryExpression && this.operators[node.operator]) {\r\n            var mutatedNode = copy(node);\r\n            mutatedNode.operator = this.operators[node.operator];\r\n            nodes.push(mutatedNode);\r\n        }\r\n        return nodes;\r\n    };\r\n    return UnaryOperatorMutator;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = UnaryOperatorMutator;\r\n//# sourceMappingURL=UnaryOperatorMutator.js.map"},{"path":"/stryker/src/mutators/UpdateOperatorMutator.js","content":"\"use strict\";\r\nvar esprima_1 = require('esprima');\r\nvar UpdateOperatorMutator = (function () {\r\n    function UpdateOperatorMutator() {\r\n        this.name = 'UpdateOperator';\r\n        this.type = esprima_1.Syntax.UpdateExpression;\r\n        this.operators = {\r\n            '++': '--',\r\n            '--': '++'\r\n        };\r\n    }\r\n    UpdateOperatorMutator.prototype.applyMutations = function (node, copy) {\r\n        var nodes = [];\r\n        if (node.type === esprima_1.Syntax.UpdateExpression && this.operators[node.operator]) {\r\n            var mutatedNode = copy(node);\r\n            mutatedNode.operator = this.operators[node.operator];\r\n            nodes.push(mutatedNode);\r\n        }\r\n        return nodes;\r\n    };\r\n    return UpdateOperatorMutator;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = UpdateOperatorMutator;\r\n//# sourceMappingURL=UpdateOperatorMutator.js.map"},{"path":"/stryker/src/PluginLoader.js","content":"\"use strict\";\r\nvar fs = require('fs');\r\nvar path = require('path');\r\nvar log4js = require('log4js');\r\nvar _ = require('lodash');\r\nvar fileUtils_1 = require('./utils/fileUtils');\r\nvar log = log4js.getLogger('PluginLoader');\r\nvar IGNORED_PACKAGES = ['stryker-cli', 'stryker-api'];\r\nvar PluginLoader = (function () {\r\n    function PluginLoader(plugins) {\r\n        this.plugins = plugins;\r\n    }\r\n    PluginLoader.prototype.load = function () {\r\n        this.getModules().forEach(this.requirePlugin);\r\n    };\r\n    PluginLoader.prototype.getModules = function () {\r\n        var modules = [];\r\n        this.plugins.forEach(function (pluginExpression) {\r\n            if (_.isString(pluginExpression)) {\r\n                if (pluginExpression.indexOf('*') !== -1) {\r\n                    // Plugin directory is the node_modules folder of the module that installed stryker\r\n                    // So if current __dirname is './stryker/src' than the plugin directory should be 2 directories above\r\n                    var pluginDirectory_1 = path.normalize(__dirname + '/../..');\r\n                    var regexp_1 = new RegExp('^' + pluginExpression.replace('*', '.*'));\r\n                    log.debug('Loading %s from %s', pluginExpression, pluginDirectory_1);\r\n                    var plugins = fs.readdirSync(pluginDirectory_1)\r\n                        .filter(function (pluginName) { return IGNORED_PACKAGES.indexOf(pluginName) === -1 && regexp_1.test(pluginName); })\r\n                        .map(function (pluginName) { return pluginDirectory_1 + '/' + pluginName; });\r\n                    if (plugins.length === 0) {\r\n                        log.debug('Expression %s not resulted in plugins to load', pluginExpression);\r\n                    }\r\n                    plugins\r\n                        .map(function (plugin) { return path.basename(plugin); })\r\n                        .map(function (plugin) {\r\n                        log.debug('Loading plugins %s (matched with expression %s)', plugin, pluginExpression);\r\n                        return plugin;\r\n                    })\r\n                        .forEach(function (p) { return modules.push(p); });\r\n                }\r\n                else {\r\n                    modules.push(pluginExpression);\r\n                }\r\n            }\r\n            else {\r\n                log.warn('Ignoring plugin %s, as its not a string type', pluginExpression);\r\n            }\r\n        });\r\n        return modules;\r\n    };\r\n    PluginLoader.prototype.requirePlugin = function (name) {\r\n        log.debug(\"Loading plugins \" + name);\r\n        try {\r\n            fileUtils_1.importModule(name);\r\n        }\r\n        catch (e) {\r\n            if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(name) !== -1) {\r\n                log.warn('Cannot find plugin \"%s\".\\n  Did you forget to install it ?\\n' +\r\n                    '  npm install %s --save-dev', name, name);\r\n            }\r\n            else {\r\n                log.warn('Error during loading \"%s\" plugin:\\n  %s', name, e.message);\r\n            }\r\n        }\r\n    };\r\n    return PluginLoader;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = PluginLoader;\r\n//# sourceMappingURL=PluginLoader.js.map"},{"path":"/stryker/src/ReporterOrchestrator.js","content":"\"use strict\";\r\nvar report_1 = require('stryker-api/report');\r\nvar ClearTextReporter_1 = require('./reporters/ClearTextReporter');\r\nvar ProgressReporter_1 = require('./reporters/ProgressReporter');\r\nvar EventRecorderReporter_1 = require('./reporters/EventRecorderReporter');\r\nvar BroadcastReporter_1 = require('./reporters/BroadcastReporter');\r\nvar log4js = require('log4js');\r\nvar log = log4js.getLogger('ReporterOrchestrator');\r\nvar ReporterOrchestrator = (function () {\r\n    function ReporterOrchestrator(options) {\r\n        this.options = options;\r\n        this.registerDefaultReporters();\r\n    }\r\n    ReporterOrchestrator.prototype.createBroadcastReporter = function () {\r\n        var _this = this;\r\n        var reporters = [];\r\n        var reporterOption = this.options.reporter;\r\n        if (reporterOption) {\r\n            if (Array.isArray(reporterOption)) {\r\n                reporterOption.forEach(function (reporterName) { return reporters.push({ name: reporterName, reporter: report_1.ReporterFactory.instance().create(reporterName, _this.options) }); });\r\n            }\r\n            else {\r\n                reporters.push({ name: reporterOption, reporter: report_1.ReporterFactory.instance().create(reporterOption, this.options) });\r\n            }\r\n        }\r\n        else {\r\n            log.warn(\"No reporter configured. Please configure one or more reporters in the (for example: reporter: 'progress')\");\r\n            this.logPossibleReporters();\r\n        }\r\n        return new BroadcastReporter_1.default(reporters);\r\n    };\r\n    ReporterOrchestrator.prototype.logPossibleReporters = function () {\r\n        var possibleReportersCsv = '';\r\n        report_1.ReporterFactory.instance().knownNames().forEach(function (name) {\r\n            if (possibleReportersCsv.length) {\r\n                possibleReportersCsv += ', ';\r\n            }\r\n            possibleReportersCsv += name;\r\n        });\r\n        log.warn(\"Possible reporters: \" + possibleReportersCsv);\r\n    };\r\n    ReporterOrchestrator.prototype.registerDefaultReporters = function () {\r\n        report_1.ReporterFactory.instance().register('progress', ProgressReporter_1.default);\r\n        report_1.ReporterFactory.instance().register('clear-text', ClearTextReporter_1.default);\r\n        report_1.ReporterFactory.instance().register('event-recorder', EventRecorderReporter_1.default);\r\n    };\r\n    return ReporterOrchestrator;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = ReporterOrchestrator;\r\n//# sourceMappingURL=ReporterOrchestrator.js.map"},{"path":"/stryker/src/reporters/BroadcastReporter.js","content":"\"use strict\";\r\nvar log4js = require('log4js');\r\nvar objectUtils_1 = require('../utils/objectUtils');\r\nvar log = log4js.getLogger('BroadcastReporter');\r\nexports.ALL_EVENT_METHOD_NAMES = ['onSourceFileRead', 'onAllSourceFilesRead', 'onMutantTested', 'onAllMutantsTested', 'onConfigRead'];\r\nvar BroadcastReporter = (function () {\r\n    function BroadcastReporter(reporters) {\r\n        var _this = this;\r\n        this.reporters = reporters;\r\n        exports.ALL_EVENT_METHOD_NAMES.concat('wrapUp').forEach(function (method) {\r\n            _this[method] = function (arg) {\r\n                return _this.broadcast(method, arg);\r\n            };\r\n        });\r\n    }\r\n    BroadcastReporter.prototype.broadcast = function (methodName, eventArgs) {\r\n        var _this = this;\r\n        var allPromises = [];\r\n        this.reporters.forEach(function (namedReporter) {\r\n            var reporter = namedReporter.reporter;\r\n            if (reporter[methodName] && typeof reporter[methodName] === 'function') {\r\n                try {\r\n                    var maybePromise = reporter[methodName](eventArgs);\r\n                    if (objectUtils_1.isPromise(maybePromise)) {\r\n                        allPromises.push(maybePromise.catch(function (error) {\r\n                            _this.handleError(error, methodName, namedReporter.name);\r\n                        }));\r\n                    }\r\n                }\r\n                catch (error) {\r\n                    _this.handleError(error, methodName, namedReporter.name);\r\n                }\r\n            }\r\n        });\r\n        if (allPromises.length) {\r\n            return Promise.all(allPromises);\r\n        }\r\n    };\r\n    BroadcastReporter.prototype.handleError = function (error, methodName, reporterName) {\r\n        log.error(\"An error occurred during '\" + methodName + \"' on reporter '\" + reporterName + \"'. Error is: \" + error);\r\n    };\r\n    return BroadcastReporter;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = BroadcastReporter;\r\n//# sourceMappingURL=BroadcastReporter.js.map"},{"path":"/stryker/src/reporters/ClearTextReporter.js","content":"\"use strict\";\r\nvar chalk = require('chalk');\r\nvar log4js = require('log4js');\r\nvar report_1 = require('stryker-api/report');\r\nvar log = log4js.getLogger('ClearTextReporter');\r\nvar ClearTextReporter = (function () {\r\n    function ClearTextReporter(options) {\r\n        this.options = options;\r\n        this.out = process.stdout;\r\n    }\r\n    ClearTextReporter.prototype.writeLine = function (output) {\r\n        this.out.write((output || '') + \"\\n\");\r\n    };\r\n    ClearTextReporter.prototype.onAllMutantsTested = function (mutantResults) {\r\n        var _this = this;\r\n        this.writeLine();\r\n        var totalTests = 0;\r\n        var mutantsKilled = 0;\r\n        var mutantsTimedOut = 0;\r\n        var mutantsNoCoverage = 0;\r\n        var mutantsSurvived = 0;\r\n        // use these fn's in order to preserve the 'this` pointer\r\n        var logDebugFn = function (input) { return log.debug(input); };\r\n        var writeLineFn = function (input) { return _this.writeLine(input); };\r\n        mutantResults.forEach(function (result) {\r\n            if (result.testsRan) {\r\n                totalTests += result.testsRan.length;\r\n            }\r\n            switch (result.status) {\r\n                case report_1.MutantStatus.Killed:\r\n                    mutantsKilled++;\r\n                    log.debug(chalk.bold.green('Mutant killed!'));\r\n                    _this.logMutantResult(result, logDebugFn);\r\n                    break;\r\n                case report_1.MutantStatus.TimedOut:\r\n                    mutantsTimedOut++;\r\n                    log.debug(chalk.bold.yellow('Mutant timed out!'));\r\n                    _this.logMutantResult(result, logDebugFn);\r\n                    break;\r\n                case report_1.MutantStatus.Survived:\r\n                    mutantsSurvived++;\r\n                    _this.writeLine(chalk.bold.red('Mutant survived!'));\r\n                    _this.logMutantResult(result, writeLineFn);\r\n                    break;\r\n                case report_1.MutantStatus.NoCoverage:\r\n                    mutantsNoCoverage++;\r\n                    _this.writeLine(chalk.bold.yellow('Mutant survived! (not covered'));\r\n                    _this.logMutantResult(result, writeLineFn);\r\n                    break;\r\n            }\r\n        });\r\n        var mutationScoreCodebase = (((mutantsKilled + mutantsTimedOut) / mutantResults.length) * 100).toFixed(2);\r\n        var mutationScoreCodeCoverage = (((mutantsKilled + mutantsTimedOut) / ((mutantResults.length - mutantsNoCoverage) || 1)) * 100).toFixed(2);\r\n        var codebaseColor = this.getColorForMutationScore(+mutationScoreCodebase);\r\n        var codecoverageColor = this.getColorForMutationScore(+mutationScoreCodeCoverage);\r\n        this.writeLine(mutantResults.length + \" total mutants.\");\r\n        this.writeLine((mutantsSurvived + mutantsNoCoverage) + ' mutants survived.');\r\n        if (mutantsNoCoverage > 0) {\r\n            this.writeLine(\"  of which \" + mutantsNoCoverage + \" were not covered by the tests.\");\r\n        }\r\n        this.writeLine(mutantsTimedOut + ' mutants timed out.');\r\n        this.writeLine(mutantsKilled + ' mutants killed.');\r\n        this.writeLine(\"Ran \" + (totalTests / mutantResults.length).toFixed(2) + \" tests per mutant on average.\");\r\n        if (this.options.coverageAnalysis === 'off') {\r\n            this.writeLine(\"Mutation score based on covered code: n/a\");\r\n        }\r\n        else {\r\n            this.writeLine(\"Mutation score based on covered code: \" + codecoverageColor(mutationScoreCodeCoverage + '%'));\r\n        }\r\n        this.writeLine(\"Mutation score based on all code: \" + codebaseColor(mutationScoreCodebase + '%'));\r\n    };\r\n    ClearTextReporter.prototype.logMutantResult = function (result, logImplementation) {\r\n        logImplementation(result.sourceFilePath + ': line ' + result.location.start.line + ':' + result.location.start.column);\r\n        logImplementation('Mutator: ' + result.mutatorName);\r\n        result.originalLines.split('\\n').forEach(function (line) {\r\n            logImplementation(chalk.red('-   ' + line));\r\n        });\r\n        result.mutatedLines.split('\\n').forEach(function (line) {\r\n            logImplementation(chalk.green('+   ' + line));\r\n        });\r\n        logImplementation('');\r\n        if (this.options.coverageAnalysis === 'perTest') {\r\n            if (result.testsRan && result.testsRan.length > 0) {\r\n                logImplementation('Tests ran: ');\r\n                result.testsRan.forEach(function (spec) { return logImplementation('    ' + spec); });\r\n                logImplementation('');\r\n            }\r\n        }\r\n        else if (result.testsRan && result.testsRan.length > 0) {\r\n            logImplementation('Ran all tests for this mutant.');\r\n        }\r\n    };\r\n    /**\r\n     * Gets the color associated with a mutation score.\r\n     * @function\r\n     * @param score - The mutation score.\r\n     * @returns {Function} The function which can give the mutation score the right color.\r\n     */\r\n    ClearTextReporter.prototype.getColorForMutationScore = function (score) {\r\n        var color;\r\n        if (score > 80) {\r\n            color = chalk.green;\r\n        }\r\n        else if (score > 50) {\r\n            color = chalk.yellow;\r\n        }\r\n        else {\r\n            color = chalk.red;\r\n        }\r\n        return color;\r\n    };\r\n    return ClearTextReporter;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = ClearTextReporter;\r\n//# sourceMappingURL=ClearTextReporter.js.map"},{"path":"/stryker/src/reporters/EventRecorderReporter.js","content":"\"use strict\";\r\nvar BroadcastReporter_1 = require('./BroadcastReporter');\r\nvar fileUtils = require('../utils/fileUtils');\r\nvar log4js = require('log4js');\r\nvar path = require('path');\r\nvar log = log4js.getLogger('EventRecorderReporter');\r\nvar DEFAULT_BASE_FOLDER = 'reports/mutation/events';\r\nvar EventRecorderReporter = (function () {\r\n    function EventRecorderReporter(options) {\r\n        var _this = this;\r\n        this.options = options;\r\n        this.allWork = [];\r\n        var index = 0;\r\n        this.createBaseFolderTask = fileUtils.cleanFolder(this.baseFolder);\r\n        BroadcastReporter_1.ALL_EVENT_METHOD_NAMES.forEach(function (method) {\r\n            _this[method] = function (data) {\r\n                _this.allWork.push(_this.createBaseFolderTask.then(function () { return _this.writeToFile(index++, method, data); }));\r\n            };\r\n        });\r\n    }\r\n    Object.defineProperty(EventRecorderReporter.prototype, \"baseFolder\", {\r\n        get: function () {\r\n            if (!this._baseFolder) {\r\n                if (this.options['eventReporter'] && this.options['eventReporter']['baseDir']) {\r\n                    this._baseFolder = this.options['eventReporter']['baseDir'];\r\n                    log.debug(\"Using configured output folder \" + this._baseFolder);\r\n                }\r\n                else {\r\n                    log.debug(\"No base folder configuration found (using configuration: eventReporter: { baseDir: 'output/folder' }), using default \" + DEFAULT_BASE_FOLDER);\r\n                    this._baseFolder = DEFAULT_BASE_FOLDER;\r\n                }\r\n            }\r\n            return this._baseFolder;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    EventRecorderReporter.prototype.writeToFile = function (index, methodName, data) {\r\n        var filename = path.join(this.baseFolder, this.format(index) + \"-\" + methodName + \".json\");\r\n        log.debug(\"Writing event \" + methodName + \" to file \" + filename);\r\n        return fileUtils.writeFile(filename, JSON.stringify(data));\r\n    };\r\n    EventRecorderReporter.prototype.format = function (input) {\r\n        var str = input.toString();\r\n        for (var i = 10000; i > 1; i = i / 10) {\r\n            if (i > input) {\r\n                str = '0' + str;\r\n            }\r\n        }\r\n        return str;\r\n    };\r\n    EventRecorderReporter.prototype.wrapUp = function () {\r\n        var _this = this;\r\n        return this.createBaseFolderTask.then(function () { return Promise.all(_this.allWork); });\r\n    };\r\n    return EventRecorderReporter;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = EventRecorderReporter;\r\n//# sourceMappingURL=EventRecorderReporter.js.map"},{"path":"/stryker/src/reporters/ProgressReporter.js","content":"\"use strict\";\r\nvar report_1 = require('stryker-api/report');\r\nvar chalk = require('chalk');\r\nvar ProgressReporter = (function () {\r\n    function ProgressReporter() {\r\n    }\r\n    ProgressReporter.prototype.onMutantTested = function (result) {\r\n        var toLog;\r\n        switch (result.status) {\r\n            case report_1.MutantStatus.Killed:\r\n                toLog = '.';\r\n                break;\r\n            case report_1.MutantStatus.TimedOut:\r\n                toLog = chalk.yellow('T');\r\n                break;\r\n            case report_1.MutantStatus.Survived:\r\n                toLog = chalk.bold.red('S');\r\n                break;\r\n            default:\r\n                toLog = '';\r\n                break;\r\n        }\r\n        process.stdout.write(toLog);\r\n    };\r\n    return ProgressReporter;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = ProgressReporter;\r\n//# sourceMappingURL=ProgressReporter.js.map"},{"path":"/stryker/src/Sandbox.js","content":"\"use strict\";\r\nvar path = require('path');\r\nvar log4js = require('log4js');\r\nvar _ = require('lodash');\r\nvar objectUtils_1 = require('./utils/objectUtils');\r\nvar IsolatedTestRunnerAdapterFactory_1 = require('./isolated-runner/IsolatedTestRunnerAdapterFactory');\r\nvar StrykerTempFolder_1 = require('./utils/StrykerTempFolder');\r\nvar log = log4js.getLogger('Sandbox');\r\nvar Sandbox = (function () {\r\n    function Sandbox(options, index, files, testFramework, coverageInstrumenter) {\r\n        this.options = options;\r\n        this.index = index;\r\n        this.files = files;\r\n        this.testFramework = testFramework;\r\n        this.coverageInstrumenter = coverageInstrumenter;\r\n        this.workingFolder = StrykerTempFolder_1.default.createRandomFolder('sandbox');\r\n        log.debug('Creating a sandbox for files in %s', this.workingFolder);\r\n        this.testHooksFile = path.join(this.workingFolder, '___testHooksForStryker.js');\r\n    }\r\n    Sandbox.prototype.initialize = function () {\r\n        var _this = this;\r\n        return this.fillSandbox()\r\n            .then(function () { return _this.initializeTestRunner(); });\r\n    };\r\n    Sandbox.prototype.run = function (timeout) {\r\n        return this.testRunner.run({ timeout: timeout });\r\n    };\r\n    Sandbox.prototype.dispose = function () {\r\n        return this.testRunner.dispose();\r\n    };\r\n    Sandbox.prototype.runMutant = function (mutant) {\r\n        var _this = this;\r\n        var targetedFile = this.fileMap[mutant.filename];\r\n        return Promise.all([mutant.save(targetedFile), this.filterTests(mutant)])\r\n            .then(function () { return _this.run(_this.calculateTimeout(mutant)); })\r\n            .then(function (runResult) { return mutant.reset(targetedFile).then(function () { return runResult; }); });\r\n    };\r\n    Sandbox.prototype.fillSandbox = function () {\r\n        var _this = this;\r\n        this.fileMap = Object.create(null);\r\n        var copyPromises = this.files\r\n            .map(function (file) { return _this.copyFile(file); });\r\n        if (this.coverageInstrumenter) {\r\n            copyPromises.push(StrykerTempFolder_1.default.writeFile(this.testHooksFile, this.coverageInstrumenter.hooksForTestRun()));\r\n        }\r\n        else {\r\n            copyPromises.push(StrykerTempFolder_1.default.writeFile(this.testHooksFile, ''));\r\n        }\r\n        return Promise.all(copyPromises);\r\n    };\r\n    Sandbox.prototype.copyFile = function (file) {\r\n        var cwd = process.cwd();\r\n        var relativePath = file.path.substr(cwd.length);\r\n        var folderName = StrykerTempFolder_1.default.ensureFolderExists(this.workingFolder + path.dirname(relativePath));\r\n        var targetFile = path.join(folderName, path.basename(relativePath));\r\n        this.fileMap[file.path] = targetFile;\r\n        var instrumentingStream = this.coverageInstrumenter ?\r\n            this.coverageInstrumenter.instrumenterStreamForFile(file) : null;\r\n        return StrykerTempFolder_1.default.copyFile(file.path, targetFile, instrumentingStream);\r\n    };\r\n    Sandbox.prototype.initializeTestRunner = function () {\r\n        var _this = this;\r\n        var files = this.files.map(function (originalFile) { return _.assign(_.cloneDeep(originalFile), { path: _this.fileMap[originalFile.path] }); });\r\n        files.unshift({ path: this.testHooksFile, mutated: false, included: true });\r\n        var settings = {\r\n            files: files,\r\n            strykerOptions: this.options,\r\n            port: this.options.port + this.index\r\n        };\r\n        log.debug(\"Creating test runner %s using settings {port: %s}\", this.index, settings.port);\r\n        this.testRunner = IsolatedTestRunnerAdapterFactory_1.default.create(settings);\r\n        return this.testRunner.init();\r\n    };\r\n    Sandbox.prototype.calculateTimeout = function (mutant) {\r\n        var baseTimeout = mutant.timeSpentScopedTests;\r\n        return (this.options.timeoutFactor * baseTimeout) + this.options.timeoutMs;\r\n    };\r\n    Sandbox.prototype.filterTests = function (mutant) {\r\n        if (this.testFramework) {\r\n            var fileContent = objectUtils_1.wrapInClosure(this.testFramework.filter(mutant.scopedTestIds));\r\n            return StrykerTempFolder_1.default.writeFile(this.testHooksFile, fileContent);\r\n        }\r\n        else {\r\n            return Promise.resolve(void 0);\r\n        }\r\n    };\r\n    return Sandbox;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = Sandbox;\r\n//# sourceMappingURL=Sandbox.js.map"},{"path":"/stryker/src/SandboxCoordinator.js","content":"\"use strict\";\r\nvar log4js = require('log4js');\r\nvar os = require('os');\r\nvar _ = require('lodash');\r\nvar test_runner_1 = require('stryker-api/test_runner');\r\nvar report_1 = require('stryker-api/report');\r\nvar objectUtils_1 = require('./utils/objectUtils');\r\nvar Sandbox_1 = require('./Sandbox');\r\nvar PromisePool = require('es6-promise-pool');\r\nvar log = log4js.getLogger('SandboxCoordinator');\r\n// The initial run might take a while.\r\n// For example: angular-bootstrap takes up to 45 seconds.\r\n// Lets take 5 minutes just to be sure \r\nvar INITIAL_RUN_TIMEOUT = 60 * 1000 * 5;\r\nvar SandboxCoordinator = (function () {\r\n    function SandboxCoordinator(options, files, testFramework, reporter) {\r\n        this.options = options;\r\n        this.files = files;\r\n        this.testFramework = testFramework;\r\n        this.reporter = reporter;\r\n    }\r\n    SandboxCoordinator.prototype.initialRun = function (coverageInstrumenter) {\r\n        log.info(\"Starting initial test run. This may take a while.\");\r\n        var sandbox = new Sandbox_1.default(this.options, 0, this.files, this.testFramework, coverageInstrumenter);\r\n        return sandbox\r\n            .initialize()\r\n            .then(function () { return sandbox.run(INITIAL_RUN_TIMEOUT); })\r\n            .then(function (runResult) { return sandbox.dispose().then(function () { return runResult; }); });\r\n    };\r\n    SandboxCoordinator.prototype.runMutants = function (mutants) {\r\n        var _this = this;\r\n        mutants = _.clone(mutants); // work with a copy because we're changing state (pop'ing values)\r\n        var results = [];\r\n        return this.createSandboxes().then(function (sandboxes) {\r\n            var promiseProducer = function () {\r\n                if (mutants.length === 0) {\r\n                    return null; // we're done\r\n                }\r\n                else {\r\n                    var mutant_1 = mutants.shift();\r\n                    if (mutant_1.scopedTestIds.length > 0) {\r\n                        var sandbox_1 = sandboxes.shift();\r\n                        return sandbox_1.runMutant(mutant_1)\r\n                            .then(function (runResult) { return _this.reportMutantTested(mutant_1, runResult, results); })\r\n                            .then(function () { return sandboxes.push(sandbox_1); }); // mark the sandbox as available again\r\n                    }\r\n                    else {\r\n                        _this.reportMutantTested(mutant_1, null, results);\r\n                        return Promise.resolve();\r\n                    }\r\n                }\r\n            };\r\n            return new PromisePool(promiseProducer, sandboxes.length)\r\n                .start()\r\n                .then(function () { return _this.reportAllMutantsTested(results); })\r\n                .then(function () { return Promise.all(sandboxes.map(function (sandbox) { return sandbox.dispose(); })); })\r\n                .then(function () { return results; });\r\n        });\r\n    };\r\n    SandboxCoordinator.prototype.createSandboxes = function () {\r\n        var cpuCount = os.cpus().length;\r\n        var sandboxes = [];\r\n        for (var i = 0; i < cpuCount; i++) {\r\n            sandboxes.push(new Sandbox_1.default(this.options, i, this.files, this.testFramework, null));\r\n        }\r\n        log.info(\"Creating \" + cpuCount + \" test runners (based on cpu count)\");\r\n        return Promise.all(sandboxes.map(function (s) { return s.initialize(); }))\r\n            .then(function () { return sandboxes; });\r\n    };\r\n    SandboxCoordinator.prototype.reportMutantTested = function (mutant, runResult, results) {\r\n        var result = this.collectFrozenMutantResult(mutant, runResult);\r\n        results.push(result);\r\n        this.reporter.onMutantTested(result);\r\n    };\r\n    SandboxCoordinator.prototype.collectFrozenMutantResult = function (mutant, runResult) {\r\n        var status;\r\n        var testNames;\r\n        if (runResult) {\r\n            switch (runResult.status) {\r\n                case test_runner_1.RunStatus.Timeout:\r\n                    status = report_1.MutantStatus.TimedOut;\r\n                    break;\r\n                case test_runner_1.RunStatus.Error:\r\n                    log.debug('Converting a test result `error` to mutant status `killed`.');\r\n                    status = report_1.MutantStatus.Killed;\r\n                    break;\r\n                case test_runner_1.RunStatus.Complete:\r\n                    if (runResult.tests.some(function (t) { return t.status === test_runner_1.TestStatus.Failed; })) {\r\n                        status = report_1.MutantStatus.Killed;\r\n                    }\r\n                    else {\r\n                        status = report_1.MutantStatus.Survived;\r\n                    }\r\n                    break;\r\n            }\r\n            testNames = runResult.tests\r\n                .filter(function (t) { return t.status !== test_runner_1.TestStatus.Skipped; })\r\n                .map(function (t) { return t.name; });\r\n        }\r\n        else {\r\n            testNames = [];\r\n            status = report_1.MutantStatus.NoCoverage;\r\n        }\r\n        var result = {\r\n            sourceFilePath: mutant.filename,\r\n            mutatorName: mutant.mutatorName,\r\n            status: status,\r\n            replacement: mutant.replacement,\r\n            location: mutant.location,\r\n            range: mutant.range,\r\n            testsRan: testNames,\r\n            originalLines: mutant.originalLines,\r\n            mutatedLines: mutant.mutatedLines,\r\n        };\r\n        objectUtils_1.freezeRecursively(result);\r\n        return result;\r\n    };\r\n    SandboxCoordinator.prototype.reportAllMutantsTested = function (results) {\r\n        objectUtils_1.freezeRecursively(results);\r\n        this.reporter.onAllMutantsTested(results);\r\n    };\r\n    return SandboxCoordinator;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = SandboxCoordinator;\r\n//# sourceMappingURL=SandboxCoordinator.js.map"},{"path":"/stryker/src/stryker-cli.js","content":"\"use strict\";\r\nvar program = require('commander');\r\nvar ConfigReader_1 = require('./ConfigReader');\r\nvar Stryker_1 = require('./Stryker');\r\nvar log4js = require('log4js');\r\nvar log = log4js.getLogger('stryker-cli');\r\nfunction list(val) {\r\n    return val.split(',');\r\n}\r\nprogram\r\n    .usage('-f <files> -m <filesToMutate> -c <configFileLocation> [other options]')\r\n    .description('Starts the stryker mutation testing process. Required arguments are --files, --testFramework and --testRunner. You can use globbing expressions to target multiple files. See https://github.com/isaacs/node-glob#glob-primer for more information about the globbing syntax.')\r\n    .option('-m, --mutate <filesToMutate>', \"A comma seperated list of globbing expression used for selecting the files that should be mutated.\\n  Example: src/**/*.js,a.js\", list)\r\n    .option('-f, --files <allFiles>', \"A comma seperated list of globbing expression used for selecting all files needed to run the tests. These include library files, test files and files to mutate, but should NOT include test framework files (for example jasmine). For a more detailed way of selecting inputfiles, please use a configFile.\\n  Example: node_modules/a-lib/**/*.js,src/**/*.js,a.js,test/**/*.js\", list)\r\n    .option('--coverageAnalysis <perTest|all|off>', \"The coverage analysis strategy you want to use. Default value: \\\"perTest\\\"\\n  * \\\"off\\\": Stryker will not determine the covered code during the initial test run fase. All tests are always tested for each mutant during the mutation testing fase.\\n  * \\\"all\\\": Stryker will determine the covered code of all tests during the initial test run fase. Only mutants that are actually covered by your test suite are tested during the mutation testing fase.\\n  * \\\"perTest\\\": Stryker will determine the covered code per executed test during the initial test run fase. Only mutants that are actually covered by your test suite are tested during the mutation testing fase. Only those tests that cover the mutant are tested per mutant.\")\r\n    .option('--testFramework <name>', \"The name of the test framework you want to use.\")\r\n    .option('--testRunner <name>', \"The name of the test runner you want to use\")\r\n    .option('--reporter <name>', 'A comma separated list of the names of the reporter(s) you want to use', list)\r\n    .option('--port <n>', 'A free port for the test runner to use (if it needs to). Any additional test runners will be spawned using n+1, n+2, etc', parseInt)\r\n    .option('--timeoutMs <number>', 'Tweak the absolute timeout used to wait for a test runner to complete', parseInt)\r\n    .option('--timeoutFactor <number>', 'Tweak the standard deviation relative to the normal test run of a mutated test', parseFloat)\r\n    .option('--plugins <listOfPlugins>', 'A list of plugins you want stryker to load (`require`).', list)\r\n    .option('-c, --configFile <configFileLocation>', 'A location to a config file. That file should export a function which accepts a \"config\" object\\n' +\r\n    ConfigReader_1.CONFIG_SYNTAX_HELP)\r\n    .option('--logLevel <level>', 'Set the log4js loglevel. Possible values: fatal, error, warn, info, debug, trace, all and off. Default is \"info\"')\r\n    .parse(process.argv);\r\nlog4js.setGlobalLogLevel(program['logLevel'] || 'info');\r\n// Cleanup commander state\r\ndelete program.options;\r\ndelete program.rawArgs;\r\ndelete program.args;\r\ndelete program.commands;\r\nfor (var i in program) {\r\n    if (i.charAt(0) === '_') {\r\n        delete program[i];\r\n    }\r\n}\r\nnew Stryker_1.default(program).runMutationTest()\r\n    .catch(function (err) { return log.error(\"an error occurred\", err); });\r\n//# sourceMappingURL=stryker-cli.js.map"},{"path":"/stryker/src/Stryker.js","content":"'use strict';\r\nvar MutatorOrchestrator_1 = require('./MutatorOrchestrator');\r\nvar config_1 = require('stryker-api/config');\r\nvar SandboxCoordinator_1 = require('./SandboxCoordinator');\r\nvar ReporterOrchestrator_1 = require('./ReporterOrchestrator');\r\nvar test_runner_1 = require('stryker-api/test_runner');\r\nvar TestFrameworkOrchestrator_1 = require('./TestFrameworkOrchestrator');\r\nvar MutantTestMatcher_1 = require('./MutantTestMatcher');\r\nvar InputFileResolver_1 = require('./InputFileResolver');\r\nvar ConfigReader_1 = require('./ConfigReader');\r\nvar PluginLoader_1 = require('./PluginLoader');\r\nvar CoverageInstrumenter_1 = require('./coverage/CoverageInstrumenter');\r\nvar objectUtils_1 = require('./utils/objectUtils');\r\nvar StrykerTempFolder_1 = require('./utils/StrykerTempFolder');\r\nvar log4js = require('log4js');\r\nvar Timer_1 = require('./utils/Timer');\r\nvar log = log4js.getLogger('Stryker');\r\nvar humanReadableTestState = function (testState) {\r\n    switch (testState) {\r\n        case test_runner_1.TestStatus.Success:\r\n            return 'SUCCESS';\r\n        case test_runner_1.TestStatus.Failed:\r\n            return 'FAILED';\r\n        case test_runner_1.TestStatus.Skipped:\r\n            return 'SKIPPED';\r\n    }\r\n};\r\nvar Stryker = (function () {\r\n    /**\r\n     * The Stryker mutation tester.\r\n     * @constructor\r\n     * @param {String[]} mutateFilePatterns - A comma seperated list of globbing expression used for selecting the files that should be mutated\r\n     * @param {String[]} allFilePatterns - A comma seperated list of globbing expression used for selecting all files needed to run the tests. These include library files, test files and files to mutate, but should NOT include test framework files (for example jasmine)\r\n     * @param {Object} [options] - Optional options.\r\n     */\r\n    function Stryker(options) {\r\n        this.timer = new Timer_1.default();\r\n        var configReader = new ConfigReader_1.default(options);\r\n        this.config = configReader.readConfig();\r\n        this.setGlobalLogLevel(); // loglevel could be changed\r\n        this.loadPlugins();\r\n        this.applyConfigWriters();\r\n        this.setGlobalLogLevel(); // loglevel could be changed\r\n        this.freezeConfig();\r\n        this.reporter = new ReporterOrchestrator_1.default(this.config).createBroadcastReporter();\r\n        this.testFramework = new TestFrameworkOrchestrator_1.default(this.config).determineTestFramework();\r\n        this.coverageInstrumenter = new CoverageInstrumenter_1.default(this.config.coverageAnalysis, this.testFramework);\r\n        this.verify();\r\n    }\r\n    /**\r\n     * Runs mutation testing. This may take a while.\r\n     * @function\r\n     */\r\n    Stryker.prototype.runMutationTest = function () {\r\n        var _this = this;\r\n        this.timer.reset();\r\n        return new InputFileResolver_1.default(this.config.mutate, this.config.files).resolve()\r\n            .then(function (inputFiles) { return _this.initialTestRun(inputFiles); })\r\n            .then(function (_a) {\r\n            var runResult = _a.runResult, inputFiles = _a.inputFiles, sandboxCoordinator = _a.sandboxCoordinator;\r\n            return _this.generateAndRunMutations(inputFiles, runResult, sandboxCoordinator);\r\n        })\r\n            .then(function (mutantResults) { return _this.wrapUpReporter()\r\n            .then(StrykerTempFolder_1.default.clean)\r\n            .then(function () { return _this.logDone(); })\r\n            .then(function () { return mutantResults; }); });\r\n    };\r\n    Stryker.prototype.filterOutFailedTests = function (runResult) {\r\n        return runResult.tests.filter(function (testResult) { return testResult.status === test_runner_1.TestStatus.Failed; });\r\n    };\r\n    Stryker.prototype.loadPlugins = function () {\r\n        if (this.config.plugins) {\r\n            new PluginLoader_1.default(this.config.plugins).load();\r\n        }\r\n    };\r\n    Stryker.prototype.verify = function () {\r\n        if (this.config.coverageAnalysis === 'perTest' && !this.testFramework) {\r\n            log.fatal('Configured coverage analysis \"perTest\" requires there to be a testFramework configured. Either configure a testFramework or set coverageAnalysis to \"all\" or \"off\".');\r\n            process.exit(1);\r\n        }\r\n    };\r\n    Stryker.prototype.initialTestRun = function (inputFiles) {\r\n        var _this = this;\r\n        var sandboxCoordinator = new SandboxCoordinator_1.default(this.config, inputFiles, this.testFramework, this.reporter);\r\n        return sandboxCoordinator.initialRun(this.coverageInstrumenter)\r\n            .then(function (runResult) {\r\n            switch (runResult.status) {\r\n                case test_runner_1.RunStatus.Complete:\r\n                    var failedTests = _this.filterOutFailedTests(runResult);\r\n                    if (failedTests.length) {\r\n                        _this.logFailedTestsInInitialRun(failedTests);\r\n                        throw new Error('There were failed tests in the initial test run:');\r\n                    }\r\n                    else {\r\n                        _this.logInitialTestRunSucceeded(runResult.tests);\r\n                        return { runResult: runResult, inputFiles: inputFiles, sandboxCoordinator: sandboxCoordinator };\r\n                    }\r\n                case test_runner_1.RunStatus.Error:\r\n                    _this.logErrorredInitialRun(runResult);\r\n                    break;\r\n                case test_runner_1.RunStatus.Timeout:\r\n                    _this.logTimeoutInitialRun(runResult);\r\n                    break;\r\n            }\r\n        });\r\n    };\r\n    Stryker.prototype.generateAndRunMutations = function (inputFiles, initialRunResult, sandboxCoordinator) {\r\n        var mutants = this.generateMutants(inputFiles, initialRunResult);\r\n        if (mutants.length) {\r\n            return sandboxCoordinator.runMutants(mutants);\r\n        }\r\n        else {\r\n            log.info('It\\'s a mutant-free world, nothing to test.');\r\n            return Promise.resolve([]);\r\n        }\r\n    };\r\n    Stryker.prototype.generateMutants = function (inputFiles, runResult) {\r\n        var mutatorOrchestrator = new MutatorOrchestrator_1.default(this.reporter);\r\n        var mutants = mutatorOrchestrator.generateMutants(inputFiles\r\n            .filter(function (inputFile) { return inputFile.mutated; })\r\n            .map(function (file) { return file.path; }));\r\n        log.info(mutants.length + \" Mutant(s) generated\");\r\n        var mutantRunResultMatcher = new MutantTestMatcher_1.default(mutants, runResult, this.coverageInstrumenter.retrieveStatementMapsPerFile(), this.config);\r\n        mutantRunResultMatcher.matchWithMutants();\r\n        return mutants;\r\n    };\r\n    Stryker.prototype.wrapUpReporter = function () {\r\n        var maybePromise = this.reporter.wrapUp();\r\n        if (objectUtils_1.isPromise(maybePromise)) {\r\n            return maybePromise;\r\n        }\r\n        else {\r\n            return Promise.resolve();\r\n        }\r\n    };\r\n    Stryker.prototype.applyConfigWriters = function () {\r\n        var _this = this;\r\n        config_1.ConfigWriterFactory.instance().knownNames().forEach(function (configWriterName) {\r\n            config_1.ConfigWriterFactory.instance().create(configWriterName, undefined).write(_this.config);\r\n        });\r\n    };\r\n    Stryker.prototype.freezeConfig = function () {\r\n        objectUtils_1.freezeRecursively(this.config);\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(\"Using config: \" + JSON.stringify(this.config));\r\n        }\r\n    };\r\n    Stryker.prototype.logInitialTestRunSucceeded = function (tests) {\r\n        log.info('Initial test run succeeded. Ran %s tests in %s.', tests.length, this.timer.humanReadableElapsed());\r\n    };\r\n    Stryker.prototype.logDone = function () {\r\n        log.info('Done in %s.', this.timer.humanReadableElapsed());\r\n    };\r\n    Stryker.prototype.setGlobalLogLevel = function () {\r\n        log4js.setGlobalLogLevel(this.config.logLevel);\r\n    };\r\n    Stryker.prototype.logFailedTestsInInitialRun = function (failedTests) {\r\n        var message = 'One or more tests failed in the initial test run:';\r\n        failedTests.forEach(function (test) {\r\n            message += \"\\n\\t\" + test.name;\r\n            if (test.failureMessages && test.failureMessages.length) {\r\n                message += \"\\n\\t\" + test.failureMessages.join('\\n\\t');\r\n            }\r\n        });\r\n        log.error(message);\r\n    };\r\n    Stryker.prototype.logErrorredInitialRun = function (runResult) {\r\n        var message = 'One or more tests errored in the initial test run:';\r\n        if (runResult.errorMessages && runResult.errorMessages.length) {\r\n            runResult.errorMessages.forEach(function (error) { return message += \"\\n\\t\" + error; });\r\n        }\r\n        log.error(message);\r\n    };\r\n    Stryker.prototype.logTimeoutInitialRun = function (runResult) {\r\n        var message = 'Initial run timed out! Ran following tests before timeout:';\r\n        runResult.tests.forEach(function (test) { return (\"\\n\\t\" + test.name + \" \" + humanReadableTestState(test.status)); });\r\n        log.error(message);\r\n    };\r\n    return Stryker;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = Stryker;\r\n//# sourceMappingURL=Stryker.js.map"},{"path":"/stryker/src/TestFrameworkOrchestrator.js","content":"\"use strict\";\r\nvar test_framework_1 = require('stryker-api/test_framework');\r\nvar log4js = require('log4js');\r\nvar log = log4js.getLogger('TestFrameworkOrchestrator');\r\nvar TestFrameworkOrchestrator = (function () {\r\n    function TestFrameworkOrchestrator(options) {\r\n        this.options = options;\r\n    }\r\n    TestFrameworkOrchestrator.prototype.determineTestFramework = function () {\r\n        if (this.options.coverageAnalysis !== 'perTest') {\r\n            log.debug('The `coverageAnalysis` setting is \"%s\", not hooking into the test framework to achieve performance benefits.', this.options.coverageAnalysis);\r\n            return null;\r\n        }\r\n        else {\r\n            return this.determineFrameworkWithCoverageAnalysis();\r\n        }\r\n    };\r\n    TestFrameworkOrchestrator.prototype.determineFrameworkWithCoverageAnalysis = function () {\r\n        var testFramework = null;\r\n        if (this.options.testFramework) {\r\n            if (this.testFrameworkExists(this.options.testFramework)) {\r\n                log.debug(\"Using testFramework \" + this.options.testFramework + \" based on `testFramework` setting\");\r\n                testFramework = this.createTestFramework(this.options.testFramework);\r\n            }\r\n            else {\r\n                log.warn(\"Could not find test framework `\" + this.options.testFramework + \"`. \" + this.informAboutKnownTestFrameworks());\r\n            }\r\n        }\r\n        else {\r\n            log.warn('Missing config settings `testFramework`. Set `coverageAnalysis` option explicitly to \"off\" to ignore this warning.');\r\n        }\r\n        return testFramework;\r\n    };\r\n    TestFrameworkOrchestrator.prototype.informAboutKnownTestFrameworks = function () {\r\n        return \"Did you forget to load a plugin? Known test frameworks: \" + JSON.stringify(test_framework_1.TestFrameworkFactory.instance().knownNames()) + \".\";\r\n    };\r\n    TestFrameworkOrchestrator.prototype.createTestFramework = function (name) {\r\n        return test_framework_1.TestFrameworkFactory.instance().create(name, { options: this.options });\r\n    };\r\n    TestFrameworkOrchestrator.prototype.testFrameworkExists = function (maybeFramework) {\r\n        return test_framework_1.TestFrameworkFactory.instance().knownNames().indexOf(maybeFramework) > -1;\r\n    };\r\n    return TestFrameworkOrchestrator;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = TestFrameworkOrchestrator;\r\n//# sourceMappingURL=TestFrameworkOrchestrator.js.map"},{"path":"/stryker/src/utils/fileUtils.js","content":"'use strict';\r\nvar _ = require('lodash');\r\nvar fs = require('fs');\r\nvar path = require('path');\r\nvar nodeGlob = require('glob');\r\nvar mkdirp = require('mkdirp');\r\n/**\r\n * Checks if a file or folder exists.\r\n * @function\r\n * @param path - The path to the file or folder.\r\n * @returns True if the file exists.\r\n */\r\nfunction fileOrFolderExistsSync(path) {\r\n    try {\r\n        fs.lstatSync(path);\r\n        return true;\r\n    }\r\n    catch (error) {\r\n        return false;\r\n    }\r\n}\r\nexports.fileOrFolderExistsSync = fileOrFolderExistsSync;\r\n;\r\nfunction fileOrFolderExists(path) {\r\n    return new Promise(function (resolve) {\r\n        fs.lstat(path, function (error, stats) {\r\n            resolve(!error);\r\n        });\r\n    });\r\n}\r\nexports.fileOrFolderExists = fileOrFolderExists;\r\n/**\r\n * Reads a file.\r\n * @function\r\n * @param filename - The name of the file.\r\n * @returns The content of the file.\r\n */\r\nfunction readFile(filename) {\r\n    return fs.readFileSync(filename, 'utf8');\r\n}\r\nexports.readFile = readFile;\r\n;\r\n/**\r\n   * Normalizes the paths of a list of filenames.\r\n   * @param files - The list of filenames which have to be normalized.\r\n   */\r\nfunction normalize(files) {\r\n    _.forEach(files, function (file, key) {\r\n        files[key] = path.resolve(path.normalize(file));\r\n    });\r\n}\r\nexports.normalize = normalize;\r\n;\r\nfunction glob(expression) {\r\n    return new Promise(function (resolve, reject) {\r\n        nodeGlob(expression, function (error, matches) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve(matches);\r\n            }\r\n        });\r\n    });\r\n}\r\nexports.glob = glob;\r\nfunction readdir(path) {\r\n    return new Promise(function (resolve, reject) {\r\n        fs.readdir(path, function (error, files) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve(files);\r\n            }\r\n        });\r\n    });\r\n}\r\nexports.readdir = readdir;\r\nfunction stats(path) {\r\n    return new Promise(function (resolve, reject) {\r\n        fs.stat(path, function (error, stats) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve(stats);\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction rmFile(path) {\r\n    return new Promise(function (fileResolve, fileReject) {\r\n        fs.unlink(path, function (error) {\r\n            if (error) {\r\n                fileReject(error);\r\n            }\r\n            else {\r\n                fileResolve();\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction rmdir(dirToDelete) {\r\n    return new Promise(function (resolve, reject) {\r\n        fs.rmdir(dirToDelete, function (error) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve();\r\n            }\r\n        });\r\n    });\r\n}\r\n/**\r\n * Deletes a directory recursively\r\n */\r\nfunction deleteDir(dirToDelete) {\r\n    return fileOrFolderExists(dirToDelete).then(function (exists) {\r\n        if (exists) {\r\n            return readdir(dirToDelete).then(function (files) {\r\n                var promisses = files.map(function (file) {\r\n                    var currentPath = path.join(dirToDelete, file);\r\n                    return stats(currentPath).then(function (stats) {\r\n                        if (stats.isDirectory()) {\r\n                            // recursive\r\n                            return deleteDir(currentPath);\r\n                        }\r\n                        else {\r\n                            // delete file\r\n                            return rmFile(currentPath);\r\n                        }\r\n                    });\r\n                });\r\n                // delete dir\r\n                return Promise.all(promisses).then(function () { return rmdir(dirToDelete); });\r\n            });\r\n        }\r\n    });\r\n}\r\nexports.deleteDir = deleteDir;\r\nfunction cleanFolder(folderName) {\r\n    return fileOrFolderExists(folderName)\r\n        .then(function (exists) {\r\n        if (exists) {\r\n            return deleteDir(folderName)\r\n                .then(function () { return mkdirRecursive(folderName); });\r\n        }\r\n        else {\r\n            return mkdirRecursive(folderName);\r\n        }\r\n    });\r\n}\r\nexports.cleanFolder = cleanFolder;\r\nfunction writeFile(fileName, content) {\r\n    return new Promise(function (resolve, reject) {\r\n        fs.writeFile(fileName, content, function (err) {\r\n            if (err) {\r\n                reject(err);\r\n            }\r\n            else {\r\n                resolve();\r\n            }\r\n        });\r\n    });\r\n}\r\nexports.writeFile = writeFile;\r\nfunction mkdirRecursive(folderName) {\r\n    if (!fileOrFolderExistsSync(folderName)) {\r\n        mkdirp.sync(folderName);\r\n    }\r\n}\r\nexports.mkdirRecursive = mkdirRecursive;\r\n/**\r\n * Wrapper around the 'require' function (for testability)\r\n */\r\nfunction importModule(moduleName) {\r\n    require(moduleName);\r\n}\r\nexports.importModule = importModule;\r\n//# sourceMappingURL=fileUtils.js.map"},{"path":"/stryker/src/utils/objectUtils.js","content":"\"use strict\";\r\nvar _ = require('lodash');\r\n// Don't use JSON.parse, as it does not allow for regexes or functions, etc\r\nexports.serialize = require('serialize-javascript');\r\nfunction freezeRecursively(target) {\r\n    Object.freeze(target);\r\n    Object.keys(target).forEach(function (key) {\r\n        if (_.isObject(target[key])) {\r\n            freezeRecursively(target[key]);\r\n        }\r\n    });\r\n}\r\nexports.freezeRecursively = freezeRecursively;\r\nfunction isPromise(input) {\r\n    return input && typeof input['then'] === 'function';\r\n}\r\nexports.isPromise = isPromise;\r\nfunction deserialize(serializedJavascript) {\r\n    // Don't use JSON.parse, as it does not allow for regexes or functions, etc\r\n    // tslint:disable\r\n    return eval(\"(\" + serializedJavascript + \")\");\r\n    // tslint:enable\r\n}\r\nexports.deserialize = deserialize;\r\nfunction copy(obj, deep) {\r\n    if (deep) {\r\n        return _.cloneDeep(obj);\r\n    }\r\n    else {\r\n        return _.clone(obj);\r\n    }\r\n}\r\nexports.copy = copy;\r\nfunction wrapInClosure(codeFragment) {\r\n    return \"\\n    (function (window) {\\n      \" + codeFragment + \"\\n    })((Function('return this'))());\";\r\n}\r\nexports.wrapInClosure = wrapInClosure;\r\n//# sourceMappingURL=objectUtils.js.map"},{"path":"/stryker/src/utils/parserUtils.js","content":"\"use strict\";\r\nvar _ = require('lodash');\r\nvar esprima = require('esprima');\r\nvar escodegen = require('escodegen');\r\n/**\r\n * Utility class for parsing and generating code.\r\n * @constructor\r\n */\r\nvar esprimaOptions = {\r\n    comment: true,\r\n    loc: true,\r\n    range: true,\r\n    tokens: true,\r\n};\r\n/**\r\n * Parses code to generate an Abstract Syntax Tree.\r\n * @function\r\n * @param code - The code which has to be parsed.\r\n * @returns {Object} The generated Abstract Syntax Tree.\r\n */\r\nfunction parse(code) {\r\n    if (code === undefined) {\r\n        throw new Error('Code parameter cannot be undefined');\r\n    }\r\n    var abstractSyntaxTree = esprima.parse(code, esprimaOptions);\r\n    return abstractSyntaxTree;\r\n}\r\nexports.parse = parse;\r\n;\r\n/**\r\n * Finds all nodes which have a 'type' property and freezes them.\r\n * @function\r\n * @param abstractSyntaxTree - The current part of the abstract syntax tree which will be investigated.\r\n * @returns  All nodes with a type.\r\n */\r\nfunction collectFrozenNodes(abstractSyntaxTree, nodes) {\r\n    nodes = nodes || [];\r\n    if (!_.isArray(abstractSyntaxTree) && _.isObject(abstractSyntaxTree) && abstractSyntaxTree.type && _.isUndefined(abstractSyntaxTree.nodeID)) {\r\n        abstractSyntaxTree.nodeID = nodes.length;\r\n        nodes.push(abstractSyntaxTree);\r\n    }\r\n    Object.freeze(abstractSyntaxTree);\r\n    _.forOwn(abstractSyntaxTree, function (childNode, i) {\r\n        if (childNode instanceof Object && !(childNode instanceof Array)) {\r\n            collectFrozenNodes(childNode, nodes);\r\n        }\r\n        else if (childNode instanceof Array) {\r\n            _.forEach(childNode, function (arrayChild) {\r\n                if (arrayChild instanceof Object && !(arrayChild instanceof Array)) {\r\n                    collectFrozenNodes(arrayChild, nodes);\r\n                }\r\n            });\r\n        }\r\n    });\r\n    return nodes;\r\n}\r\nexports.collectFrozenNodes = collectFrozenNodes;\r\n;\r\n/**\r\n   * Parses a Node to generate code.\r\n   * @param The Node which has to be transformed into code.\r\n   * @returns The generated code.\r\n   */\r\nfunction generate(node) {\r\n    return escodegen.generate(node);\r\n}\r\nexports.generate = generate;\r\n;\r\n//# sourceMappingURL=parserUtils.js.map"},{"path":"/stryker/src/utils/StrykerTempFolder.js","content":"\"use strict\";\r\nvar fs = require('fs');\r\nvar path = require('path');\r\nvar mkdirp = require('mkdirp');\r\nvar fileUtils = require('./fileUtils');\r\nvar log4js = require('log4js');\r\nvar log = log4js.getLogger('fileUtils');\r\nvar baseTempFolder = path.join(process.cwd(), '.stryker-tmp');\r\nvar tempFolder = path.join(baseTempFolder, random().toString());\r\nensureFolderExists(baseTempFolder);\r\nensureFolderExists(tempFolder);\r\n/**\r\n * Creates a new random folder with the specified prefix.\r\n * @param prefix The prefix.\r\n * @returns The path to the folder.\r\n */\r\nfunction createRandomFolder(prefix) {\r\n    return ensureFolderExists(tempFolder + path.sep + prefix + random());\r\n}\r\n/**\r\n * Creates a random integer number.\r\n * @returns A random integer.\r\n */\r\nfunction random() {\r\n    return Math.ceil(Math.random() * 10000000);\r\n}\r\n/**\r\n * Creates a folder at the specified path if it doesn't already exist.\r\n * @param path The path to check.\r\n * @returns The path of the folder.\r\n */\r\nfunction ensureFolderExists(path) {\r\n    if (!fileOrFolderExists(path)) {\r\n        mkdirp.sync(path);\r\n    }\r\n    return path;\r\n}\r\n/**\r\n * Checks if a file or folder exists.\r\n * @param path The path to the file or folder.\r\n * @returns True if the file exists.\r\n */\r\nfunction fileOrFolderExists(path) {\r\n    try {\r\n        fs.lstatSync(path);\r\n        return true;\r\n    }\r\n    catch (error) {\r\n        return false;\r\n    }\r\n}\r\n/**\r\n * Writes data to a specified file.\r\n * @param filename The path to the file.\r\n * @param data The content of the file.\r\n * @returns A promise to eventually save the file.\r\n */\r\nfunction writeFile(filename, data) {\r\n    return new Promise(function (resolve, reject) {\r\n        fs.writeFile(filename, data, { encoding: 'utf8' }, function (error) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve();\r\n            }\r\n        });\r\n    });\r\n}\r\n/**\r\n * Copies a file.\r\n * @param fromFilename The path to the existing file.\r\n * @param toFilename The path to copy the file to.\r\n * @param instrumenter An optional additional intrumenter to stream the file through\r\n * @returns A promise to eventually copy the file.\r\n */\r\nfunction copyFile(fromFilename, toFilename, instrumenter) {\r\n    return new Promise(function (resolve, reject) {\r\n        var readStream = fs.createReadStream(fromFilename, { encoding: 'utf8' });\r\n        var writeStream = fs.createWriteStream(toFilename, { encoding: 'utf8' });\r\n        readStream.on('error', reject);\r\n        writeStream.on('error', reject);\r\n        if (instrumenter) {\r\n            readStream = readStream.pipe(instrumenter);\r\n        }\r\n        readStream.pipe(writeStream);\r\n        readStream.on('end', function () { return resolve(); });\r\n    });\r\n}\r\n/**\r\n * Deletes the Stryker-temp folder\r\n */\r\nfunction clean() {\r\n    log.debug(\"Cleaning stryker temp folder \" + baseTempFolder);\r\n    return fileUtils.deleteDir(baseTempFolder);\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = {\r\n    createRandomFolder: createRandomFolder,\r\n    writeFile: writeFile,\r\n    copyFile: copyFile,\r\n    ensureFolderExists: ensureFolderExists,\r\n    clean: clean\r\n};\r\n//# sourceMappingURL=StrykerTempFolder.js.map"},{"path":"/stryker/src/utils/Timer.js","content":"\"use strict\";\r\nvar Timer = (function () {\r\n    function Timer() {\r\n        this.reset();\r\n    }\r\n    Timer.prototype.reset = function () {\r\n        this.start = new Date();\r\n    };\r\n    Timer.prototype.humanReadableElapsed = function () {\r\n        var elapsedMs = new Date().getTime() - this.start.getTime();\r\n        var elapsedSeconds = Math.floor(elapsedMs / 1000);\r\n        return Timer.humanReadableElapsedMinutes(elapsedSeconds) + Timer.humanReadableElapsedSeconds(elapsedSeconds);\r\n    };\r\n    Timer.humanReadableElapsedSeconds = function (elapsedSeconds) {\r\n        var restSeconds = elapsedSeconds % 60;\r\n        if (restSeconds === 1) {\r\n            return restSeconds + \" second\";\r\n        }\r\n        else {\r\n            return restSeconds + \" seconds\";\r\n        }\r\n    };\r\n    Timer.humanReadableElapsedMinutes = function (elapsedSeconds) {\r\n        var elapsedMinutes = Math.floor(elapsedSeconds / 60);\r\n        if (elapsedMinutes > 1) {\r\n            return elapsedMinutes + \" minutes \";\r\n        }\r\n        else if (elapsedMinutes > 0) {\r\n            return elapsedMinutes + \" minute \";\r\n        }\r\n        else {\r\n            return '';\r\n        }\r\n    };\r\n    return Timer;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = Timer;\r\n//# sourceMappingURL=Timer.js.map"}]