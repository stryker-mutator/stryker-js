[{"path":"/stryker/src/ConfigReader.js","content":"\"use strict\";\r\nvar config_1 = require('stryker-api/config');\r\nvar log4js = require('log4js');\r\nvar _ = require('lodash');\r\nexports.CONFIG_SYNTAX_HELP = '  module.exports = function(config) {\\n' +\r\n    '    config.set({\\n' +\r\n    '      // your config\\n' +\r\n    '    });\\n' +\r\n    '  };\\n';\r\nvar log = log4js.getLogger('ConfigReader');\r\nvar ConfigReader = (function () {\r\n    function ConfigReader(options) {\r\n        this.options = options;\r\n    }\r\n    ConfigReader.prototype.readConfig = function () {\r\n        var configModule = this.loadConfigModule();\r\n        var config = new config_1.Config();\r\n        try {\r\n            configModule(config);\r\n        }\r\n        catch (e) {\r\n            log.fatal('Error in config file!\\n', e);\r\n            process.exit(1);\r\n        }\r\n        // merge the config from config file and cliOptions (precedence)\r\n        config.set(this.options);\r\n        return config;\r\n    };\r\n    ConfigReader.prototype.loadConfigModule = function () {\r\n        var configModule;\r\n        if (this.options.configFile) {\r\n            log.debug('Loading config %s', this.options.configFile);\r\n            try {\r\n                configModule = require(process.cwd() + \"/\" + this.options.configFile);\r\n            }\r\n            catch (e) {\r\n                if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(this.options.configFile) !== -1) {\r\n                    log.fatal('File %s does not exist!', this.options.configFile);\r\n                    log.fatal(e);\r\n                }\r\n                else {\r\n                    log.fatal('Invalid config file!\\n  ' + e.stack);\r\n                }\r\n                process.exit(1);\r\n            }\r\n            if (!_.isFunction(configModule)) {\r\n                log.fatal('Config file must export a function!\\n' + exports.CONFIG_SYNTAX_HELP);\r\n                process.exit(1);\r\n            }\r\n        }\r\n        else {\r\n            log.debug('No config file specified.');\r\n            // if no config file path is passed, we define a dummy config module.\r\n            configModule = function () { };\r\n        }\r\n        return configModule;\r\n    };\r\n    return ConfigReader;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = ConfigReader;\r\n//# sourceMappingURL=ConfigReader.js.map"},{"path":"/stryker/src/InputFileResolver.js","content":"\"use strict\";\r\nvar fileUtils_1 = require('./utils/fileUtils');\r\nvar _ = require('lodash');\r\nvar log4js = require('log4js');\r\nvar log = log4js.getLogger('InputFileResolver');\r\nvar InputFileResolver = (function () {\r\n    function InputFileResolver(mutateFileExpressions, allFileExpressions) {\r\n        this.mutateFileExpressions = mutateFileExpressions;\r\n        this.allFileExpressions = allFileExpressions;\r\n    }\r\n    InputFileResolver.prototype.resolve = function () {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            var errors = [];\r\n            Promise.all([InputFileResolver.resolveFileGlobs(_this.mutateFileExpressions), InputFileResolver.resolveFileGlobs(_this.allFileExpressions)])\r\n                .then(function (files) {\r\n                var mutateFiles = files[0];\r\n                var allFiles = files[1];\r\n                fileUtils_1.normalize(allFiles);\r\n                fileUtils_1.normalize(mutateFiles);\r\n                mutateFiles.forEach(function (mutateFile) {\r\n                    if (allFiles.indexOf(mutateFile) < 0) {\r\n                        errors.push(\"Could not find mutate file \\\"\" + mutateFile + \"\\\" in list of files.\");\r\n                    }\r\n                });\r\n                if (errors.length > 0) {\r\n                    reject(errors);\r\n                }\r\n                else {\r\n                    resolve(allFiles.map(function (file) { return { path: file, shouldMutate: mutateFiles.some(function (mutateFile) { return mutateFile === file; }) }; }));\r\n                }\r\n            }, function (error) { return reject(error); });\r\n        });\r\n    };\r\n    InputFileResolver.reportEmptyGlobbingExpression = function (expression) {\r\n        log.warn(\"Globbing expression \\\"\" + expression + \"\\\" did not result in any files.\");\r\n    };\r\n    InputFileResolver.resolveFileGlobs = function (sourceExpressions) {\r\n        var _this = this;\r\n        return Promise.all(sourceExpressions.map(function (expression) { return fileUtils_1.glob(expression).then(function (files) {\r\n            if (files.length === 0) {\r\n                _this.reportEmptyGlobbingExpression(expression);\r\n            }\r\n            return files;\r\n        }); })).then(function (files) { return _.flatten(files); });\r\n    };\r\n    return InputFileResolver;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = InputFileResolver;\r\n//# sourceMappingURL=InputFileResolver.js.map"},{"path":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","content":"\"use strict\";\r\nvar test_runner_1 = require('stryker-api/test_runner');\r\nvar child_process_1 = require('child_process');\r\nvar Message_1 = require('./Message');\r\nvar _ = require('lodash');\r\nvar log4js = require('log4js');\r\nvar log = log4js.getLogger('IsolatedTestRunnerAdapter');\r\n/**\r\n * Runs the given test runner in a child process and forwards reports about test results\r\n * Also implements timeout-mechanisme (on timeout, restart the child runner and report timeout)\r\n */\r\nvar TestRunnerChildProcessAdapter = (function () {\r\n    function TestRunnerChildProcessAdapter(realTestRunnerName, options) {\r\n        this.realTestRunnerName = realTestRunnerName;\r\n        this.options = options;\r\n        this.startWorker();\r\n    }\r\n    TestRunnerChildProcessAdapter.prototype.startWorker = function () {\r\n        // Remove --debug-brk from process arguments. \r\n        // When debugging, it will try to reuse the same debug port, which will be taken by the main process.\r\n        var execArgv = _.clone(process.execArgv);\r\n        _.remove(execArgv, function (arg) { return arg.substr(0, 11) === '--debug-brk'; });\r\n        this.workerProcess = child_process_1.fork(__dirname + \"/IsolatedTestRunnerAdapterWorker\", [], { silent: true, execArgv: execArgv });\r\n        this.sendStartCommand();\r\n        this.listenToWorkerProcess();\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.listenToWorkerProcess = function () {\r\n        var _this = this;\r\n        if (this.workerProcess.stdout) {\r\n            var traceEnabled_1 = log.isTraceEnabled();\r\n            this.workerProcess.stdout.on('data', function (data) {\r\n                if (traceEnabled_1) {\r\n                    log.trace(data.toString());\r\n                }\r\n            });\r\n        }\r\n        if (this.workerProcess.stderr) {\r\n            this.workerProcess.stderr.on('data', function (data) {\r\n                log.error(data.toString());\r\n            });\r\n        }\r\n        this.workerProcess.on('message', function (message) {\r\n            _this.clearCurrentTimer();\r\n            switch (message.type) {\r\n                case Message_1.MessageType.Result:\r\n                    _this.handleResultMessage(message);\r\n                    break;\r\n                default:\r\n                    log.error(\"Retrieved unrecognized message from child process: \" + JSON.stringify(message));\r\n                    break;\r\n            }\r\n        });\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.run = function (options) {\r\n        var _this = this;\r\n        this.clearCurrentTimer();\r\n        if (options.timeout) {\r\n            this.markNoResultTimeout(options.timeout);\r\n        }\r\n        this.currentPromise = new Promise(function (resolve) {\r\n            _this.currentPromiseFulfillmentCallback = resolve;\r\n            _this.sendRunCommand(options);\r\n            _this.currentRunStartedTimestamp = new Date();\r\n        });\r\n        return this.currentPromise;\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.dispose = function () {\r\n        this.clearCurrentTimer();\r\n        this.workerProcess.kill();\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.sendRunCommand = function (options) {\r\n        var message = {\r\n            type: Message_1.MessageType.Run,\r\n            body: {\r\n                runOptions: options\r\n            }\r\n        };\r\n        this.workerProcess.send(message);\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.sendStartCommand = function () {\r\n        var startMessage = {\r\n            type: Message_1.MessageType.Start,\r\n            body: {\r\n                runnerName: this.realTestRunnerName,\r\n                runnerOptions: this.options\r\n            }\r\n        };\r\n        this.workerProcess.send(startMessage);\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.handleResultMessage = function (message) {\r\n        message.body.result.timeSpent = (new Date().getTime() - this.currentRunStartedTimestamp.getTime());\r\n        this.currentPromiseFulfillmentCallback(message.body.result);\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.clearCurrentTimer = function () {\r\n        if (this.currentTimeoutTimer) {\r\n            clearTimeout(this.currentTimeoutTimer);\r\n        }\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.markNoResultTimeout = function (timeoutMs) {\r\n        var _this = this;\r\n        this.currentTimeoutTimer = setTimeout(function () {\r\n            _this.handleTimeout();\r\n        }, timeoutMs);\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.handleTimeout = function () {\r\n        this.workerProcess.kill();\r\n        this.startWorker();\r\n        this.currentPromiseFulfillmentCallback({ result: test_runner_1.TestResult.Timeout });\r\n    };\r\n    return TestRunnerChildProcessAdapter;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = TestRunnerChildProcessAdapter;\r\n//# sourceMappingURL=IsolatedTestRunnerAdapter.js.map"},{"path":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterFactory.js","content":"\"use strict\";\r\nvar IsolatedTestRunnerAdapter_1 = require('./IsolatedTestRunnerAdapter');\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = {\r\n    create: function (settings) {\r\n        return new IsolatedTestRunnerAdapter_1.default(settings.strykerOptions.testRunner, settings);\r\n    }\r\n};\r\n//# sourceMappingURL=IsolatedTestRunnerAdapterFactory.js.map"},{"path":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","content":"\"use strict\";\r\nvar Message_1 = require('./Message');\r\nvar test_runner_1 = require('stryker-api/test_runner');\r\nvar PluginLoader_1 = require('../PluginLoader');\r\nvar log4js = require('log4js');\r\nvar TestRunnerChildProcessAdapterWorker = (function () {\r\n    function TestRunnerChildProcessAdapterWorker() {\r\n        this.listenToMessages();\r\n    }\r\n    TestRunnerChildProcessAdapterWorker.prototype.listenToMessages = function () {\r\n        var _this = this;\r\n        process.on('message', function (message) {\r\n            switch (message.type) {\r\n                case Message_1.MessageType.Start:\r\n                    _this.start(message.body);\r\n                    break;\r\n                case Message_1.MessageType.Run:\r\n                    _this.run(message.body);\r\n                    break;\r\n            }\r\n        });\r\n    };\r\n    TestRunnerChildProcessAdapterWorker.prototype.start = function (body) {\r\n        log4js.setGlobalLogLevel(body.runnerOptions.strykerOptions.logLevel);\r\n        this.loadPlugins(body.runnerOptions.strykerOptions.plugins);\r\n        this.underlyingTestRunner = test_runner_1.TestRunnerFactory.instance().create(body.runnerName, body.runnerOptions);\r\n    };\r\n    TestRunnerChildProcessAdapterWorker.prototype.run = function (body) {\r\n        this.underlyingTestRunner.run(body.runOptions).then(this.reportResult, this.reportErrorResult);\r\n    };\r\n    TestRunnerChildProcessAdapterWorker.prototype.loadPlugins = function (plugins) {\r\n        new PluginLoader_1.default(plugins).load();\r\n    };\r\n    TestRunnerChildProcessAdapterWorker.prototype.reportResult = function (result) {\r\n        var message = {\r\n            type: Message_1.MessageType.Result,\r\n            body: { result: result }\r\n        };\r\n        process.send(message);\r\n    };\r\n    TestRunnerChildProcessAdapterWorker.prototype.reportErrorResult = function (error) {\r\n        var message = {\r\n            type: Message_1.MessageType.Result,\r\n            body: {\r\n                result: {\r\n                    testNames: [],\r\n                    result: test_runner_1.TestResult.Error,\r\n                }\r\n            }\r\n        };\r\n        process.send(message);\r\n    };\r\n    return TestRunnerChildProcessAdapterWorker;\r\n}());\r\nnew TestRunnerChildProcessAdapterWorker();\r\n//# sourceMappingURL=IsolatedTestRunnerAdapterWorker.js.map"},{"path":"/stryker/src/isolated-runner/Message.js","content":"\"use strict\";\r\n(function (MessageType) {\r\n    MessageType[MessageType[\"Start\"] = 0] = \"Start\";\r\n    MessageType[MessageType[\"Run\"] = 1] = \"Run\";\r\n    MessageType[MessageType[\"Result\"] = 2] = \"Result\";\r\n})(exports.MessageType || (exports.MessageType = {}));\r\nvar MessageType = exports.MessageType;\r\n//# sourceMappingURL=Message.js.map"},{"path":"/stryker/src/isolated-runner/ResultMessageBody.js","content":"\"use strict\";\r\n//# sourceMappingURL=ResultMessageBody.js.map"},{"path":"/stryker/src/isolated-runner/RunMessageBody.js","content":"\"use strict\";\r\n//# sourceMappingURL=RunMessageBody.js.map"},{"path":"/stryker/src/isolated-runner/StartMessageBody.js","content":"\"use strict\";\r\n//# sourceMappingURL=StartMessageBody.js.map"},{"path":"/stryker/src/jasmine_test_selector/JasmineTestSelector.js","content":"\"use strict\";\r\nvar test_selector_1 = require('stryker-api/test_selector');\r\nvar INTERCEPTOR_CODE = \"(function(global){\\n    var realIt = global.it, count = 0;\\n    var scoped = %IDS_PLACEHOLDER%;\\n    global.it = function(){\\n        if(scoped && scoped.indexOf(count) >= 0){\\n            var spec = realIt.apply(global, arguments);\\n        }\\n        count ++;\\n    }\\n})(window || global);\";\r\nvar JasmineTestSelector = (function () {\r\n    function JasmineTestSelector(settings) {\r\n        this.settings = settings;\r\n    }\r\n    JasmineTestSelector.prototype.select = function (ids) {\r\n        return INTERCEPTOR_CODE.replace('%IDS_PLACEHOLDER%', JSON.stringify(ids));\r\n    };\r\n    return JasmineTestSelector;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = JasmineTestSelector;\r\ntest_selector_1.TestSelectorFactory.instance().register('jasmine', JasmineTestSelector);\r\n//# sourceMappingURL=JasmineTestSelector.js.map"},{"path":"/stryker/src/Mutant.js","content":"\"use strict\";\r\nvar StrykerTempFolder_1 = require('./utils/StrykerTempFolder');\r\n/**\r\n * Represents a mutation which has been applied to a file.\r\n */\r\nvar Mutant = (function () {\r\n    /**\r\n     * @param mutatorName - The name of the Mutator which created this mutant.\r\n     * @param filename - The name of the file which was mutated, including the path.\r\n     * @param originalCode - The original content of the file which has not been mutated.\r\n     * @param replacement - The mutated code which will replace a part of the originalCode.\r\n     * @param location - The location of the code to be mutated - line and column based\r\n     * @param range - The location of the code to be mutated - index based\r\n     */\r\n    function Mutant(mutatorName, filename, originalCode, replacement, location, range) {\r\n        this.mutatorName = mutatorName;\r\n        this.filename = filename;\r\n        this.originalCode = originalCode;\r\n        this.replacement = replacement;\r\n        this.location = location;\r\n        this.range = range;\r\n        this.scopedTestsById = [];\r\n        this._scopedTestIds = [];\r\n        this.specsRan = [];\r\n        this._timeSpentScopedTests = 0;\r\n    }\r\n    Object.defineProperty(Mutant.prototype, \"scopedTestIds\", {\r\n        get: function () {\r\n            return this._scopedTestIds;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Mutant.prototype, \"timeSpentScopedTests\", {\r\n        get: function () {\r\n            return this._timeSpentScopedTests;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Mutant.prototype.addRunResultForTest = function (index, runResult) {\r\n        this._scopedTestIds.push(index);\r\n        this._timeSpentScopedTests += runResult.timeSpent;\r\n        this.scopedTestsById[index] = runResult;\r\n    };\r\n    Mutant.prototype.isNewLine = function (index) {\r\n        var char = this.originalCode[index];\r\n        return char === '\\n' || char === '\\r';\r\n    };\r\n    Mutant.prototype.getMutationLineIndexes = function () {\r\n        var startIndexLines = this.range[0], endIndexLines = this.range[1];\r\n        while (startIndexLines > 0 && !this.isNewLine(startIndexLines - 1)) {\r\n            startIndexLines--;\r\n        }\r\n        while (endIndexLines < this.originalCode.length && !this.isNewLine(endIndexLines)) {\r\n            endIndexLines++;\r\n        }\r\n        return [startIndexLines, endIndexLines];\r\n    };\r\n    Object.defineProperty(Mutant.prototype, \"originalLines\", {\r\n        get: function () {\r\n            var _a = this.getMutationLineIndexes(), startIndex = _a[0], endIndex = _a[1];\r\n            return this.originalCode.substring(startIndex, endIndex);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Mutant.prototype, \"mutatedLines\", {\r\n        get: function () {\r\n            var _a = this.getMutationLineIndexes(), startIndex = _a[0], endIndex = _a[1];\r\n            return this.originalCode.substring(startIndex, this.range[0]) + this.replacement + this.originalCode.substring(this.range[1], endIndex);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Mutant.prototype, \"mutatedCode\", {\r\n        get: function () {\r\n            return this.originalCode.substr(0, this.range[0]) + this.replacement + this.originalCode.substr(this.range[1]);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Saves the mutated code in a mutated file.\r\n     * @function\r\n     */\r\n    Mutant.prototype.save = function (filename) {\r\n        return StrykerTempFolder_1.default.writeFile(filename, this.mutatedCode);\r\n    };\r\n    ;\r\n    /**\r\n     * Removes the mutated file.\r\n     * @function\r\n     */\r\n    Mutant.prototype.reset = function (filename) {\r\n        return StrykerTempFolder_1.default.writeFile(filename, this.originalCode);\r\n    };\r\n    ;\r\n    return Mutant;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = Mutant;\r\n//# sourceMappingURL=Mutant.js.map"},{"path":"/stryker/src/MutantRunResultMatcher.js","content":"\"use strict\";\r\nvar MutantRunResultMatcher = (function () {\r\n    function MutantRunResultMatcher(mutants, runResultsByTestId) {\r\n        this.mutants = mutants;\r\n        this.runResultsByTestId = runResultsByTestId;\r\n    }\r\n    MutantRunResultMatcher.prototype.matchWithMutants = function () {\r\n        var _this = this;\r\n        this.mutants.forEach(function (mutant) {\r\n            var smallestStatement;\r\n            _this.runResultsByTestId.forEach(function (testResult, id) {\r\n                var covered = false;\r\n                if (testResult.coverage) {\r\n                    var coveredFile = testResult.coverage[mutant.filename];\r\n                    if (coveredFile) {\r\n                        // Statement map should change between test run results.\r\n                        // We should be able to safely reuse the smallest statement found in first run.\r\n                        if (!smallestStatement) {\r\n                            smallestStatement = _this.findSmallestCoveringStatement(mutant, coveredFile);\r\n                        }\r\n                        covered = coveredFile.s[smallestStatement] > 0;\r\n                    }\r\n                }\r\n                else {\r\n                    // If there is no coverage result we have to assume the source code is covered\r\n                    covered = true;\r\n                }\r\n                if (covered) {\r\n                    mutant.addRunResultForTest(id, testResult);\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Finds the smallest statement that covers a mutant.\r\n     * @param mutant The mutant.\r\n     * @param coveredFile The CoverageResult.\r\n     * @returns The index of the coveredFile which contains the smallest statement surrounding the mutant.\r\n     */\r\n    MutantRunResultMatcher.prototype.findSmallestCoveringStatement = function (mutant, coveredFile) {\r\n        var _this = this;\r\n        var smallestStatement;\r\n        Object.keys(coveredFile.statementMap).forEach(function (statementId) {\r\n            var location = coveredFile.statementMap[statementId];\r\n            if (_this.statementCoversMutant(mutant, location) && _this.isNewSmallestStatement(coveredFile.statementMap[smallestStatement], location)) {\r\n                smallestStatement = statementId;\r\n            }\r\n        });\r\n        return smallestStatement;\r\n    };\r\n    /**\r\n     * Indicates whether a statement is the smallest statement of the two statements provided.\r\n     * @param originalLocation The area which may cover a bigger area than the newLocation.\r\n     * @param newLocation The area which may cover a smaller area than the originalLocation.\r\n     * @returns true if the newLocation covers a smaller area than the originalLocation, making it the smaller statement.\r\n     */\r\n    MutantRunResultMatcher.prototype.isNewSmallestStatement = function (originalLocation, newLocation) {\r\n        var statementIsSmallestStatement = false;\r\n        if (!originalLocation) {\r\n            statementIsSmallestStatement = true;\r\n        }\r\n        else {\r\n            var lineDifference = (originalLocation.end.line - originalLocation.start.line) - (newLocation.end.line - newLocation.start.line);\r\n            var coversLessLines = lineDifference > 0;\r\n            var coversLessColumns = lineDifference === 0 && (newLocation.start.column - originalLocation.start.column) + (originalLocation.end.column - newLocation.end.column) > 0;\r\n            if (coversLessLines || coversLessColumns) {\r\n                statementIsSmallestStatement = true;\r\n            }\r\n        }\r\n        return statementIsSmallestStatement;\r\n    };\r\n    /**\r\n     * Indicates whether a statement covers a mutant.\r\n     * @param mutant The mutant.\r\n     * @param location The location which may cover the mutant.\r\n     * @returns true if the statment covers the mutant.\r\n     */\r\n    MutantRunResultMatcher.prototype.statementCoversMutant = function (mutant, location) {\r\n        var mutantIsAfterStart = mutant.location.end.line > location.start.line ||\r\n            (mutant.location.end.line === location.start.line && mutant.location.end.column >= location.start.column);\r\n        var mutantIsBeforeEnd = mutant.location.start.line < location.end.line ||\r\n            (mutant.location.start.line === location.end.line && mutant.location.start.column <= location.end.column);\r\n        return mutantIsAfterStart && mutantIsBeforeEnd;\r\n    };\r\n    return MutantRunResultMatcher;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = MutantRunResultMatcher;\r\n//# sourceMappingURL=MutantRunResultMatcher.js.map"},{"path":"/stryker/src/MutatorOrchestrator.js","content":"\"use strict\";\r\nvar _ = require('lodash');\r\nvar BlockStatementMutator_1 = require('./mutators/BlockStatementMutator');\r\nvar ConditionalBoundaryMutator_1 = require('./mutators/ConditionalBoundaryMutator');\r\nvar MathMutator_1 = require('./mutators/MathMutator');\r\nvar RemoveConditionalsMutator_1 = require('./mutators/RemoveConditionalsMutator');\r\nvar ReverseConditionalMutator_1 = require('./mutators/ReverseConditionalMutator');\r\nvar UnaryOperatorMutator_1 = require('./mutators/UnaryOperatorMutator');\r\nvar mutant_1 = require('stryker-api/mutant');\r\nvar fileUtils = require('./utils/fileUtils');\r\nvar Mutant_1 = require('./Mutant');\r\nvar parserUtils = require('./utils/parserUtils');\r\nvar log4js = require('log4js');\r\nvar objectUtils_1 = require('./utils/objectUtils');\r\nvar log = log4js.getLogger('Mutator');\r\n/**\r\n * Class capable of finding spots to mutate in files.\r\n */\r\nvar MutatorOrchestrator = (function () {\r\n    /**\r\n     * @param reporter - The reporter to report read input files to\r\n     */\r\n    function MutatorOrchestrator(reporter) {\r\n        var _this = this;\r\n        this.reporter = reporter;\r\n        this.mutators = [];\r\n        this.registerDefaultMutators();\r\n        var mutatorFactory = mutant_1.MutatorFactory.instance();\r\n        mutatorFactory.knownNames().forEach(function (name) { return _this.mutators.push(mutatorFactory.create(name, null)); });\r\n    }\r\n    /**\r\n     * Mutates source files. Mutated code is not writen to disk.\r\n     * @function\r\n     * @param sourceFiles - The list of files which should be mutated.\r\n     * @returns {Mutant[]} The generated Mutants.\r\n     */\r\n    MutatorOrchestrator.prototype.generateMutants = function (sourceFiles) {\r\n        var _this = this;\r\n        var mutants = [];\r\n        this.sourceFiles = [];\r\n        sourceFiles.forEach(function (sourceFile) {\r\n            try {\r\n                var fileContent = fileUtils.readFile(sourceFile);\r\n                _this.reportFileRead(sourceFile, fileContent);\r\n                var abstractSyntaxTree = parserUtils.parse(fileContent);\r\n                var nodes = parserUtils.collectFrozenNodes(abstractSyntaxTree);\r\n                var newMutants = _this.findMutants(sourceFile, fileContent, abstractSyntaxTree, nodes);\r\n                mutants = mutants.concat(newMutants);\r\n            }\r\n            catch (err) {\r\n                switch (err.code) {\r\n                    case 'ENOENT':\r\n                        log.info(\"Skipping file \" + err.path + \" because it does not exist\");\r\n                        break;\r\n                    default:\r\n                        console.log(err);\r\n                        throw err;\r\n                }\r\n            }\r\n        });\r\n        this.reportAllFilesRead();\r\n        return mutants;\r\n    };\r\n    ;\r\n    MutatorOrchestrator.prototype.reportFileRead = function (path, content) {\r\n        var fileToReport = { path: path, content: content };\r\n        objectUtils_1.freezeRecursively(fileToReport);\r\n        this.sourceFiles.push(fileToReport);\r\n        this.reporter.onSourceFileRead(fileToReport);\r\n    };\r\n    MutatorOrchestrator.prototype.reportAllFilesRead = function () {\r\n        objectUtils_1.freezeRecursively(this.sourceFiles);\r\n        this.reporter.onAllSourceFilesRead(this.sourceFiles);\r\n    };\r\n    MutatorOrchestrator.prototype.registerDefaultMutators = function () {\r\n        var mutatorFactory = mutant_1.MutatorFactory.instance();\r\n        mutatorFactory.register('BlockStatement', BlockStatementMutator_1.default);\r\n        mutatorFactory.register('ConditionalBoundary', ConditionalBoundaryMutator_1.default);\r\n        mutatorFactory.register('Math', MathMutator_1.default);\r\n        mutatorFactory.register('RemoveConditionals', RemoveConditionalsMutator_1.default);\r\n        mutatorFactory.register('ReverseConditional', ReverseConditionalMutator_1.default);\r\n        mutatorFactory.register('UnaryOperator', UnaryOperatorMutator_1.default);\r\n    };\r\n    /**\r\n     * Finds all mutants for a given set of nodes.\r\n     * @function\r\n     * @param {String} sourceFile - The name source file.\r\n     * @param {String} originalCode - The original content of the file which has not been mutated.\r\n     * @param {Object} ast - The original abstract syntax tree which is used for reference when generating code.\r\n     * @param {AbstractSyntaxTreeNode[]} nodes - The nodes which could be used by mutations to generate mutants.\r\n     * @returns {Mutant[]} All possible Mutants for the given set of nodes.\r\n     */\r\n    MutatorOrchestrator.prototype.findMutants = function (sourceFile, originalCode, ast, nodes) {\r\n        var _this = this;\r\n        var mutants = [];\r\n        nodes.forEach(function (astnode) {\r\n            if (astnode.type) {\r\n                Object.freeze(astnode);\r\n                _this.mutators.forEach(function (mutator) {\r\n                    try {\r\n                        var mutatedNodes = mutator.applyMutations(astnode, function (node, deepClone) {\r\n                            return deepClone ? _.cloneDeep(node) : _.clone(node);\r\n                        });\r\n                        if (mutatedNodes.length > 0) {\r\n                            log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);\r\n                        }\r\n                        mutatedNodes.forEach(function (mutatedNode) {\r\n                            var mutatedCode = parserUtils.generate(mutatedNode);\r\n                            var originalNode = nodes[mutatedNode.nodeID];\r\n                            mutants.push(new Mutant_1.default(mutator.name, sourceFile, originalCode, mutatedCode, originalNode.loc, originalNode.range));\r\n                        });\r\n                    }\r\n                    catch (error) {\r\n                        throw new Error(\"The mutator named '\" + mutator.name + \"' caused an error: \" + error);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n        return mutants;\r\n    };\r\n    ;\r\n    return MutatorOrchestrator;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = MutatorOrchestrator;\r\n//# sourceMappingURL=MutatorOrchestrator.js.map"},{"path":"/stryker/src/mutators/BlockStatementMutator.js","content":"\"use strict\";\r\nvar esprima_1 = require('esprima');\r\n/**\r\n * Represents a mutator which can remove the content of a BlockStatement.\r\n */\r\nvar BlockStatementMutator = (function () {\r\n    function BlockStatementMutator() {\r\n        this.name = 'BlockStatement';\r\n        this.types = [esprima_1.Syntax.BlockStatement];\r\n    }\r\n    BlockStatementMutator.prototype.applyMutations = function (node, copy) {\r\n        var nodes = [];\r\n        if (this.canMutate(node)) {\r\n            var mutatedNode = copy(node);\r\n            mutatedNode.body = [];\r\n            nodes.push(mutatedNode);\r\n        }\r\n        return nodes;\r\n    };\r\n    BlockStatementMutator.prototype.canMutate = function (node) {\r\n        return !!(node && this.types.indexOf(node.type) >= 0);\r\n    };\r\n    ;\r\n    return BlockStatementMutator;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = BlockStatementMutator;\r\n//# sourceMappingURL=BlockStatementMutator.js.map"},{"path":"/stryker/src/mutators/ConditionalBoundaryMutator.js","content":"\"use strict\";\r\nvar __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar esprima_1 = require('esprima');\r\nvar OperatorMutator_1 = require('./OperatorMutator');\r\nvar ConditionalBoundayMutator = (function (_super) {\r\n    __extends(ConditionalBoundayMutator, _super);\r\n    function ConditionalBoundayMutator() {\r\n        _super.call(this, 'ConditionalBoundary', [esprima_1.Syntax.BinaryExpression], {\r\n            '<': '<=',\r\n            '<=': '<',\r\n            '>': '>=',\r\n            '>=': '>'\r\n        });\r\n    }\r\n    return ConditionalBoundayMutator;\r\n}(OperatorMutator_1.default));\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = ConditionalBoundayMutator;\r\n//# sourceMappingURL=ConditionalBoundaryMutator.js.map"},{"path":"/stryker/src/mutators/MathMutator.js","content":"\"use strict\";\r\nvar __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar esprima_1 = require('esprima');\r\nvar OperatorMutator_1 = require('./OperatorMutator');\r\nvar MathMutator = (function (_super) {\r\n    __extends(MathMutator, _super);\r\n    function MathMutator() {\r\n        _super.call(this, 'Math', [esprima_1.Syntax.BinaryExpression], {\r\n            '+': '-',\r\n            '-': '+',\r\n            '*': '/',\r\n            '/': '*',\r\n            '%': '*' });\r\n    }\r\n    return MathMutator;\r\n}(OperatorMutator_1.default));\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = MathMutator;\r\n//# sourceMappingURL=MathMutator.js.map"},{"path":"/stryker/src/mutators/OperatorMutator.js","content":"\"use strict\";\r\nvar OperatorMutator = (function () {\r\n    /**\r\n     * Represents a base class for all operator based mutations.\r\n     * @param name The name of the mutator.\r\n     * @param types The type of operators which should be mutated.\r\n     * @param operators The object containing a map for targeted operators and their mutated values.\r\n     */\r\n    function OperatorMutator(name, types, operators) {\r\n        this.name = name;\r\n        this.types = types;\r\n        this.operators = operators;\r\n    }\r\n    OperatorMutator.prototype.applyMutations = function (node, copy) {\r\n        var nodes = [];\r\n        if (this.canMutate(node)) {\r\n            var mutatedNode = copy(node);\r\n            mutatedNode.operator = this.getOperator(node.operator);\r\n            nodes.push(mutatedNode);\r\n        }\r\n        return nodes;\r\n    };\r\n    OperatorMutator.prototype.canMutate = function (node) {\r\n        return !!(node && this.types.indexOf(node.type) >= 0 && this.getOperator(node.operator));\r\n    };\r\n    /**\r\n     * Gets the mutated operator based on an unmutated operator.\r\n     * @function\r\n     * @param {String} operator - An umutated operator.\r\n     * @returns {String} The mutated operator.\r\n     */\r\n    OperatorMutator.prototype.getOperator = function (operator) {\r\n        return this.operators[operator];\r\n    };\r\n    return OperatorMutator;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = OperatorMutator;\r\n//# sourceMappingURL=OperatorMutator.js.map"},{"path":"/stryker/src/mutators/OperatorMutatorMap.js","content":"\"use strict\";\r\n//# sourceMappingURL=OperatorMutatorMap.js.map"},{"path":"/stryker/src/mutators/RemoveConditionalsMutator.js","content":"\"use strict\";\r\nvar esprima_1 = require('esprima');\r\n/**\r\n * Represents a mutator which can remove the conditional clause from statements.\r\n */\r\nvar RemoveConditionalsMutator = (function () {\r\n    function RemoveConditionalsMutator() {\r\n        this.name = 'RemoveConditionals';\r\n        this.types = [esprima_1.Syntax.DoWhileStatement, esprima_1.Syntax.IfStatement, esprima_1.Syntax.ForStatement, esprima_1.Syntax.WhileStatement];\r\n    }\r\n    RemoveConditionalsMutator.prototype.applyMutations = function (node, copy) {\r\n        var nodes = [];\r\n        if (this.canMutate(node)) {\r\n            var mutatedFalseNode = copy(node.test);\r\n            this.mutateTestExpression(mutatedFalseNode, false);\r\n            nodes.push(mutatedFalseNode);\r\n            if (node.type === esprima_1.Syntax.IfStatement) {\r\n                var mutatedTrueNode = copy(node.test);\r\n                this.mutateTestExpression(mutatedTrueNode, true);\r\n                nodes.push(mutatedTrueNode);\r\n            }\r\n        }\r\n        return nodes;\r\n    };\r\n    RemoveConditionalsMutator.prototype.mutateTestExpression = function (node, newValue) {\r\n        node.type = esprima_1.Syntax.Literal;\r\n        node.value = newValue;\r\n    };\r\n    RemoveConditionalsMutator.prototype.canMutate = function (node) {\r\n        return !!(node && this.types.indexOf(node.type) >= 0);\r\n    };\r\n    ;\r\n    RemoveConditionalsMutator.prototype.copyNode = function (node) {\r\n        return JSON.parse(JSON.stringify(node));\r\n    };\r\n    return RemoveConditionalsMutator;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = RemoveConditionalsMutator;\r\n//# sourceMappingURL=RemoveConditionalsMutator.js.map"},{"path":"/stryker/src/mutators/ReverseConditionalMutator.js","content":"\"use strict\";\r\nvar __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar esprima_1 = require('esprima');\r\nvar OperatorMutator_1 = require('./OperatorMutator');\r\nvar ReverseConditionalMutator = (function (_super) {\r\n    __extends(ReverseConditionalMutator, _super);\r\n    function ReverseConditionalMutator() {\r\n        _super.call(this, 'ReverseConditional', [esprima_1.Syntax.BinaryExpression, esprima_1.Syntax.LogicalExpression], {\r\n            '==': '!=',\r\n            '!=': '==',\r\n            '===': '!==',\r\n            '!==': '===',\r\n            '<=': '>',\r\n            '>=': '<',\r\n            '<': '>=',\r\n            '>': '<=',\r\n            '&&': '||',\r\n            '||': '&&' });\r\n    }\r\n    return ReverseConditionalMutator;\r\n}(OperatorMutator_1.default));\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = ReverseConditionalMutator;\r\n//# sourceMappingURL=ReverseConditionalMutator.js.map"},{"path":"/stryker/src/mutators/UnaryOperatorMutator.js","content":"\"use strict\";\r\nvar __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar esprima_1 = require('esprima');\r\nvar OperatorMutator_1 = require('./OperatorMutator');\r\nvar UnaryOperatorMutator = (function (_super) {\r\n    __extends(UnaryOperatorMutator, _super);\r\n    function UnaryOperatorMutator() {\r\n        _super.call(this, 'UnaryOperator', [esprima_1.Syntax.UpdateExpression, esprima_1.Syntax.UnaryExpression], {\r\n            '++': '--',\r\n            '--': '++',\r\n            '-': '+',\r\n            '+': '-' });\r\n    }\r\n    return UnaryOperatorMutator;\r\n}(OperatorMutator_1.default));\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = UnaryOperatorMutator;\r\n//# sourceMappingURL=UnaryOperatorMutator.js.map"},{"path":"/stryker/src/PluginLoader.js","content":"\"use strict\";\r\nvar fs = require('fs');\r\nvar path = require('path');\r\nvar log4js = require('log4js');\r\nvar _ = require('lodash');\r\nvar fileUtils_1 = require('./utils/fileUtils');\r\nvar log = log4js.getLogger('PluginLoader');\r\nvar IGNORED_PACKAGES = ['stryker-cli', 'stryker-api'];\r\nvar PluginLoader = (function () {\r\n    function PluginLoader(plugins) {\r\n        this.plugins = plugins;\r\n    }\r\n    PluginLoader.prototype.load = function () {\r\n        this.getModules().forEach(this.requirePlugin);\r\n    };\r\n    PluginLoader.prototype.getModules = function () {\r\n        var modules = [];\r\n        this.plugins.forEach(function (pluginExpression) {\r\n            if (_.isString(pluginExpression)) {\r\n                if (pluginExpression.indexOf('*') !== -1) {\r\n                    // Plugin directory is the node_modules folder of the module that installed stryker\r\n                    // So if current __dirname is './stryker/src' than the plugin directory should be 2 directories above\r\n                    var pluginDirectory = path.normalize(__dirname + '/../..');\r\n                    var regexp = new RegExp('^' + pluginExpression.replace('*', '.*'));\r\n                    log.debug('Loading %s from %s', pluginExpression, pluginDirectory);\r\n                    var plugins = fs.readdirSync(pluginDirectory)\r\n                        .filter(function (pluginName) { return IGNORED_PACKAGES.indexOf(pluginName) === -1 && regexp.test(pluginName); })\r\n                        .map(function (pluginName) { return pluginDirectory + '/' + pluginName; });\r\n                    if (plugins.length === 0) {\r\n                        log.debug('Expression %s not resulted in plugins to load', pluginExpression);\r\n                    }\r\n                    plugins\r\n                        .map(function (plugin) { return path.basename(plugin); })\r\n                        .map(function (plugin) {\r\n                        log.debug('Loading plugins %s (matched with expression %s)', plugin, pluginExpression);\r\n                        return plugin;\r\n                    })\r\n                        .forEach(function (p) { return modules.push(p); });\r\n                }\r\n                else {\r\n                    modules.push(pluginExpression);\r\n                }\r\n            }\r\n            else {\r\n                log.warn('Ignoring plugin %s, as its not a string type', pluginExpression);\r\n            }\r\n        });\r\n        return modules;\r\n    };\r\n    PluginLoader.prototype.requirePlugin = function (name) {\r\n        log.debug(\"Loading plugins \" + name);\r\n        try {\r\n            fileUtils_1.importModule(name);\r\n        }\r\n        catch (e) {\r\n            if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(name) !== -1) {\r\n                log.warn('Cannot find plugin \"%s\".\\n  Did you forget to install it ?\\n' +\r\n                    '  npm install %s --save-dev', name, name);\r\n            }\r\n            else {\r\n                log.warn('Error during loading \"%s\" plugin:\\n  %s', name, e.message);\r\n            }\r\n        }\r\n    };\r\n    return PluginLoader;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = PluginLoader;\r\n//# sourceMappingURL=PluginLoader.js.map"},{"path":"/stryker/src/ReporterOrchestrator.js","content":"\"use strict\";\r\nvar report_1 = require('stryker-api/report');\r\nvar ClearTextReporter_1 = require('./reporters/ClearTextReporter');\r\nvar ProgressReporter_1 = require('./reporters/ProgressReporter');\r\nvar EventReporter_1 = require('./reporters/EventReporter');\r\nvar BroadcastReporter_1 = require('./reporters/BroadcastReporter');\r\nvar log4js = require('log4js');\r\nvar log = log4js.getLogger('ReporterOrchestrator');\r\nvar ReporterOrchestrator = (function () {\r\n    function ReporterOrchestrator(options) {\r\n        this.options = options;\r\n        this.registerDefaultReporters();\r\n    }\r\n    ReporterOrchestrator.prototype.createBroadcastReporter = function () {\r\n        var _this = this;\r\n        var reporters = [];\r\n        var reporterOption = this.options.reporter;\r\n        if (reporterOption) {\r\n            if (Array.isArray(reporterOption)) {\r\n                reporterOption.forEach(function (reporterName) { return reporters.push({ name: reporterName, reporter: report_1.ReporterFactory.instance().create(reporterName, _this.options) }); });\r\n            }\r\n            else {\r\n                reporters.push({ name: reporterOption, reporter: report_1.ReporterFactory.instance().create(reporterOption, this.options) });\r\n            }\r\n        }\r\n        else {\r\n            log.warn(\"No reporter configured. Please configure one or more reporters in the (for example: reporter: 'progress')\");\r\n            this.logPossibleReporters();\r\n        }\r\n        return new BroadcastReporter_1.default(reporters);\r\n    };\r\n    ReporterOrchestrator.prototype.logPossibleReporters = function () {\r\n        var possibleReportersCsv = '';\r\n        report_1.ReporterFactory.instance().knownNames().forEach(function (name) {\r\n            if (possibleReportersCsv.length) {\r\n                possibleReportersCsv += ', ';\r\n            }\r\n            possibleReportersCsv += name;\r\n        });\r\n        log.warn(\"Possible reporters: \" + possibleReportersCsv);\r\n    };\r\n    ReporterOrchestrator.prototype.registerDefaultReporters = function () {\r\n        report_1.ReporterFactory.instance().register('progress', ProgressReporter_1.default);\r\n        report_1.ReporterFactory.instance().register('clear-text', ClearTextReporter_1.default);\r\n        report_1.ReporterFactory.instance().register('event', EventReporter_1.default);\r\n    };\r\n    return ReporterOrchestrator;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = ReporterOrchestrator;\r\n//# sourceMappingURL=ReporterOrchestrator.js.map"},{"path":"/stryker/src/reporters/BroadcastReporter.js","content":"\"use strict\";\r\nvar log4js = require('log4js');\r\nvar objectUtils_1 = require('../utils/objectUtils');\r\nvar log = log4js.getLogger('BroadcastReporter');\r\nexports.ALL_EVENT_METHOD_NAMES = ['onSourceFileRead', 'onAllSourceFilesRead', 'onMutantTested', 'onAllMutantsTested', 'onConfigRead'];\r\nvar BroadcastReporter = (function () {\r\n    function BroadcastReporter(reporters) {\r\n        var _this = this;\r\n        this.reporters = reporters;\r\n        exports.ALL_EVENT_METHOD_NAMES.concat('wrapUp').forEach(function (method) {\r\n            _this[method] = function (arg) {\r\n                return _this.broadcast(method, arg);\r\n            };\r\n        });\r\n    }\r\n    BroadcastReporter.prototype.broadcast = function (methodName, eventArgs) {\r\n        var _this = this;\r\n        var allPromises = [];\r\n        this.reporters.forEach(function (namedReporter) {\r\n            var reporter = namedReporter.reporter;\r\n            if (reporter[methodName] && typeof reporter[methodName] === 'function') {\r\n                try {\r\n                    var maybePromise = reporter[methodName](eventArgs);\r\n                    if (objectUtils_1.isPromise(maybePromise)) {\r\n                        allPromises.push(maybePromise.catch(function (error) {\r\n                            _this.handleError(error, methodName, namedReporter.name);\r\n                        }));\r\n                    }\r\n                }\r\n                catch (error) {\r\n                    _this.handleError(error, methodName, namedReporter.name);\r\n                }\r\n            }\r\n        });\r\n        if (allPromises.length) {\r\n            return Promise.all(allPromises);\r\n        }\r\n    };\r\n    BroadcastReporter.prototype.handleError = function (error, methodName, reporterName) {\r\n        log.error(\"An error occurred during '\" + methodName + \"' on reporter '\" + reporterName + \"'. Error is: \" + error);\r\n    };\r\n    return BroadcastReporter;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = BroadcastReporter;\r\n//# sourceMappingURL=BroadcastReporter.js.map"},{"path":"/stryker/src/reporters/ClearTextReporter.js","content":"\"use strict\";\r\nvar report_1 = require('stryker-api/report');\r\nvar chalk = require('chalk');\r\nvar _ = require('lodash');\r\nvar ClearTextReporter = (function () {\r\n    function ClearTextReporter() {\r\n        this.out = process.stdout;\r\n    }\r\n    ClearTextReporter.prototype.writeLine = function (output) {\r\n        this.out.write((output || '') + \"\\n\");\r\n    };\r\n    ClearTextReporter.prototype.onAllMutantsTested = function (mutantResults) {\r\n        var _this = this;\r\n        this.writeLine();\r\n        var mutantsKilled = 0;\r\n        var mutantsTimedOut = 0;\r\n        var mutantsUntested = 0;\r\n        mutantResults.forEach(function (result) {\r\n            switch (result.status) {\r\n                case report_1.MutantStatus.KILLED:\r\n                    mutantsKilled++;\r\n                    break;\r\n                case report_1.MutantStatus.TIMEDOUT:\r\n                    mutantsTimedOut++;\r\n                    break;\r\n                case report_1.MutantStatus.SURVIVED:\r\n                    _this.writeLine(chalk.bold.red('Mutant survived!'));\r\n                    _this.writeLine(result.sourceFilePath + ': line ' + result.location.start.line + ':' + result.location.start.column);\r\n                    _this.writeLine('Mutator: ' + result.mutatorName);\r\n                    _this.writeLine(chalk.red('-   ' + result.originalLines));\r\n                    _this.writeLine(chalk.green('+   ' + result.mutatedLines));\r\n                    _this.writeLine('\\n');\r\n                    _this.writeLine('Tests ran: ');\r\n                    _.forEach(result.testsRan, function (spec) {\r\n                        _this.writeLine('    ' + spec);\r\n                    });\r\n                    _this.writeLine('\\n');\r\n                    break;\r\n                case report_1.MutantStatus.UNTESTED:\r\n                    mutantsUntested++;\r\n                    break;\r\n            }\r\n        });\r\n        var mutationScoreCodebase = (((mutantsKilled + mutantsTimedOut) / mutantResults.length) * 100).toFixed(2);\r\n        var mutationScoreCodeCoverage = (((mutantsKilled + mutantsTimedOut) / ((mutantResults.length - mutantsUntested) || 1)) * 100).toFixed(2);\r\n        var codebaseColor = this.getColorForMutationScore(+mutationScoreCodebase);\r\n        var codecoverageColor = this.getColorForMutationScore(+mutationScoreCodeCoverage);\r\n        this.writeLine((mutantResults.length - mutantsUntested) + ' mutants tested.');\r\n        this.writeLine(mutantsUntested + ' mutants untested.');\r\n        this.writeLine(mutantsTimedOut + ' mutants timed out.');\r\n        this.writeLine(mutantsKilled + ' mutants killed.');\r\n        this.writeLine('Mutation score based on covered code: ' + codecoverageColor(mutationScoreCodeCoverage + '%'));\r\n        this.writeLine('Mutation score based on all code: ' + codebaseColor(mutationScoreCodebase + '%'));\r\n    };\r\n    /**\r\n     * Gets the color associated with a mutation score.\r\n     * @function\r\n     * @param score - The mutation score.\r\n     * @returns {Function} The function which can give the mutation score the right color.\r\n     */\r\n    ClearTextReporter.prototype.getColorForMutationScore = function (score) {\r\n        var color;\r\n        if (score > 80) {\r\n            color = chalk.green;\r\n        }\r\n        else if (score > 50) {\r\n            color = chalk.yellow;\r\n        }\r\n        else {\r\n            color = chalk.red;\r\n        }\r\n        return color;\r\n    };\r\n    return ClearTextReporter;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = ClearTextReporter;\r\n//# sourceMappingURL=ClearTextReporter.js.map"},{"path":"/stryker/src/reporters/EventReporter.js","content":"\"use strict\";\r\nvar BroadcastReporter_1 = require('./BroadcastReporter');\r\nvar fileUtils = require('../utils/fileUtils');\r\nvar log4js = require('log4js');\r\nvar path = require('path');\r\nvar log = log4js.getLogger('EventReporter');\r\nvar DEFAULT_BASE_FOLDER = 'reports/mutation/events';\r\nvar EventReporter = (function () {\r\n    function EventReporter(options) {\r\n        var _this = this;\r\n        this.options = options;\r\n        this.allWork = [];\r\n        var index = 0;\r\n        this.createBaseFolderTask = fileUtils.cleanFolder(this.baseFolder);\r\n        BroadcastReporter_1.ALL_EVENT_METHOD_NAMES.forEach(function (method) {\r\n            _this[method] = function (data) {\r\n                _this.allWork.push(_this.createBaseFolderTask.then(function () { return _this.writeToFile(index++, method, data); }));\r\n            };\r\n        });\r\n    }\r\n    Object.defineProperty(EventReporter.prototype, \"baseFolder\", {\r\n        get: function () {\r\n            if (!this._baseFolder) {\r\n                if (this.options['eventReporter'] && this.options['eventReporter']['baseDir']) {\r\n                    this._baseFolder = this.options['eventReporter']['baseDir'];\r\n                    log.debug(\"Using configured output folder \" + this._baseFolder);\r\n                }\r\n                else {\r\n                    log.debug(\"No base folder configuration found (using configuration: eventReporter: { baseDir: 'output/folder' }), using default \" + DEFAULT_BASE_FOLDER);\r\n                    this._baseFolder = DEFAULT_BASE_FOLDER;\r\n                }\r\n            }\r\n            return this._baseFolder;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    EventReporter.prototype.writeToFile = function (index, methodName, data) {\r\n        return fileUtils.writeFile(path.join(this.baseFolder, this.format(index) + \"-\" + methodName + \".json\"), JSON.stringify(data));\r\n    };\r\n    EventReporter.prototype.format = function (input) {\r\n        var str = input.toString();\r\n        for (var i = 10000; i > 1; i = i / 10) {\r\n            if (i > input) {\r\n                str = '0' + str;\r\n            }\r\n        }\r\n        return str;\r\n    };\r\n    EventReporter.prototype.wrapUp = function () {\r\n        return Promise.all(this.allWork);\r\n    };\r\n    return EventReporter;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = EventReporter;\r\n//# sourceMappingURL=EventReporter.js.map"},{"path":"/stryker/src/reporters/ProgressReporter.js","content":"\"use strict\";\r\nvar report_1 = require('stryker-api/report');\r\nvar chalk = require('chalk');\r\nvar ProgressReporter = (function () {\r\n    function ProgressReporter() {\r\n    }\r\n    ProgressReporter.prototype.onMutantTested = function (result) {\r\n        var toLog;\r\n        switch (result.status) {\r\n            case report_1.MutantStatus.KILLED:\r\n                toLog = '.';\r\n                break;\r\n            case report_1.MutantStatus.TIMEDOUT:\r\n                toLog = chalk.yellow('T');\r\n                break;\r\n            case report_1.MutantStatus.SURVIVED:\r\n                toLog = chalk.bold.red('S');\r\n                break;\r\n            default:\r\n                toLog = '';\r\n                break;\r\n        }\r\n        process.stdout.write(toLog);\r\n    };\r\n    return ProgressReporter;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = ProgressReporter;\r\n//# sourceMappingURL=ProgressReporter.js.map"},{"path":"/stryker/src/Stryker.js","content":"'use strict';\r\nvar _ = require('lodash');\r\nvar MutatorOrchestrator_1 = require('./MutatorOrchestrator');\r\nvar config_1 = require('stryker-api/config');\r\nvar TestRunnerOrchestrator_1 = require('./TestRunnerOrchestrator');\r\nvar ReporterOrchestrator_1 = require('./ReporterOrchestrator');\r\nrequire('./jasmine_test_selector/JasmineTestSelector');\r\nvar test_runner_1 = require('stryker-api/test_runner');\r\nvar TestSelectorOrchestrator_1 = require('./TestSelectorOrchestrator');\r\nvar MutantRunResultMatcher_1 = require('./MutantRunResultMatcher');\r\nvar InputFileResolver_1 = require('./InputFileResolver');\r\nvar ConfigReader_1 = require('./ConfigReader');\r\nvar PluginLoader_1 = require('./PluginLoader');\r\nvar objectUtils_1 = require('./utils/objectUtils');\r\nvar log4js = require('log4js');\r\nvar log = log4js.getLogger('Stryker');\r\nvar Stryker = (function () {\r\n    /**\r\n     * The Stryker mutation tester.\r\n     * @constructor\r\n     * @param {String[]} mutateFilePatterns - A comma seperated list of globbing expression used for selecting the files that should be mutated\r\n     * @param {String[]} allFilePatterns - A comma seperated list of globbing expression used for selecting all files needed to run the tests. These include library files, test files and files to mutate, but should NOT include test framework files (for example jasmine)\r\n     * @param {Object} [options] - Optional options.\r\n     */\r\n    function Stryker(options) {\r\n        var configReader = new ConfigReader_1.default(options);\r\n        this.config = configReader.readConfig();\r\n        this.setGlobalLogLevel(); // loglevel could be changed\r\n        this.loadPlugins();\r\n        this.applyConfigWriters();\r\n        this.setGlobalLogLevel(); // loglevel could be changed\r\n        this.freezeConfig();\r\n    }\r\n    /**\r\n     * Runs mutation testing. This may take a while.\r\n     * @function\r\n     */\r\n    Stryker.prototype.runMutationTest = function () {\r\n        var _this = this;\r\n        var reporter = new ReporterOrchestrator_1.default(this.config).createBroadcastReporter();\r\n        var testSelector = new TestSelectorOrchestrator_1.default(this.config).determineTestSelector();\r\n        return new InputFileResolver_1.default(this.config.mutate, this.config.files).resolve()\r\n            .then(function (inputFiles) {\r\n            var testRunnerOrchestrator = new TestRunnerOrchestrator_1.default(_this.config, inputFiles, testSelector, reporter);\r\n            return testRunnerOrchestrator.initialRun().then(function (runResults) { return ({ runResults: runResults, inputFiles: inputFiles, testRunnerOrchestrator: testRunnerOrchestrator }); });\r\n        })\r\n            .then(function (tuple) {\r\n            var runResults = tuple.runResults;\r\n            var inputFiles = tuple.inputFiles;\r\n            var testRunnerOrchestrator = tuple.testRunnerOrchestrator;\r\n            var unsuccessfulTests = _this.filterOutUnsuccesfulResults(runResults);\r\n            if (unsuccessfulTests.length === 0) {\r\n                _this.logInitialTestRunSucceeded(runResults);\r\n                var mutatorOrchestrator = new MutatorOrchestrator_1.default(reporter);\r\n                var mutants = mutatorOrchestrator.generateMutants(inputFiles\r\n                    .filter(function (inputFile) { return inputFile.shouldMutate; })\r\n                    .map(function (file) { return file.path; }));\r\n                log.info(mutants.length + \" Mutant(s) generated\");\r\n                var mutantRunResultMatcher = new MutantRunResultMatcher_1.default(mutants, runResults);\r\n                mutantRunResultMatcher.matchWithMutants();\r\n                return testRunnerOrchestrator.runMutations(mutants);\r\n            }\r\n            else {\r\n                _this.logFailedTests(unsuccessfulTests);\r\n                throw new Error('There were failed tests in the initial test run');\r\n            }\r\n        }).then(function (mutantResults) {\r\n            var maybePromise = reporter.wrapUp();\r\n            if (objectUtils_1.isPromise(maybePromise)) {\r\n                return maybePromise.then(function () { return mutantResults; });\r\n            }\r\n            else {\r\n                return mutantResults;\r\n            }\r\n        });\r\n    };\r\n    Stryker.prototype.filterOutUnsuccesfulResults = function (runResults) {\r\n        return runResults.filter(function (runResult) { return !(!runResult.failed && runResult.result === test_runner_1.TestResult.Complete); });\r\n    };\r\n    Stryker.prototype.loadPlugins = function () {\r\n        if (this.config.plugins) {\r\n            new PluginLoader_1.default(this.config.plugins).load();\r\n        }\r\n    };\r\n    Stryker.prototype.applyConfigWriters = function () {\r\n        var _this = this;\r\n        config_1.ConfigWriterFactory.instance().knownNames().forEach(function (configWriterName) {\r\n            config_1.ConfigWriterFactory.instance().create(configWriterName, undefined).write(_this.config);\r\n        });\r\n    };\r\n    Stryker.prototype.freezeConfig = function () {\r\n        objectUtils_1.freezeRecursively(this.config);\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(\"Using config: \" + JSON.stringify(this.config));\r\n        }\r\n    };\r\n    Stryker.prototype.logInitialTestRunSucceeded = function (runResults) {\r\n        var totalAmountOfTests = 0;\r\n        runResults.forEach(function (result) {\r\n            if (result.succeeded) {\r\n                totalAmountOfTests += result.succeeded;\r\n            }\r\n        });\r\n        log.info('Initial test run succeeded. Ran %s tests.', totalAmountOfTests);\r\n    };\r\n    Stryker.prototype.setGlobalLogLevel = function () {\r\n        log4js.setGlobalLogLevel(this.config.logLevel);\r\n    };\r\n    /**\r\n     * Looks through a list of RunResults to see if all tests have passed.\r\n     * @function\r\n     * @param {RunResult[]} runResults - The list of RunResults.\r\n     * @returns {Boolean} True if all tests passed.\r\n     */\r\n    Stryker.prototype.logFailedTests = function (unsuccessfulTests) {\r\n        var failedSpecNames = _.uniq(_.flatten(unsuccessfulTests\r\n            .filter(function (runResult) { return runResult.result === test_runner_1.TestResult.Complete; })\r\n            .map(function (runResult) { return runResult.testNames; })))\r\n            .sort();\r\n        if (failedSpecNames.length > 0) {\r\n            var message_1 = 'One or more tests failed in the inial test run:';\r\n            failedSpecNames.forEach(function (filename) { return message_1 += \"\\n\\t\" + filename; });\r\n            log.error(message_1);\r\n        }\r\n        var errors = _.flatten(unsuccessfulTests\r\n            .filter(function (runResult) { return runResult.result === test_runner_1.TestResult.Error; })\r\n            .map(function (runResult) { return runResult.errorMessages; }))\r\n            .sort();\r\n        if (errors.length > 0) {\r\n            var message_2 = 'One or more tests errored in the initial test run:';\r\n            errors.forEach(function (error) { return message_2 += \"\\n\\t\" + error; });\r\n            log.error(message_2);\r\n        }\r\n    };\r\n    return Stryker;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = Stryker;\r\n//# sourceMappingURL=Stryker.js.map"},{"path":"/stryker/src/TestRunnerOrchestrator.js","content":"\"use strict\";\r\nvar test_runner_1 = require('stryker-api/test_runner');\r\nvar StrykerTempFolder_1 = require('./utils/StrykerTempFolder');\r\nvar IsolatedTestRunnerAdapterFactory_1 = require('./isolated-runner/IsolatedTestRunnerAdapterFactory');\r\nvar path = require('path');\r\nvar os = require('os');\r\nvar _ = require('lodash');\r\nvar report_1 = require('stryker-api/report');\r\nvar log4js = require('log4js');\r\nvar objectUtils_1 = require('./utils/objectUtils');\r\nvar PromisePool = require('es6-promise-pool');\r\nvar log = log4js.getLogger('TestRunnerOrchestrator');\r\nvar TestRunnerOrchestrator = (function () {\r\n    function TestRunnerOrchestrator(options, files, testSelector, reporter) {\r\n        this.options = options;\r\n        this.files = files;\r\n        this.testSelector = testSelector;\r\n        this.reporter = reporter;\r\n    }\r\n    TestRunnerOrchestrator.prototype.initialRun = function () {\r\n        if (this.testSelector) {\r\n            return this.initialRunWithTestSelector();\r\n        }\r\n        else {\r\n            return this.initalRunWithoutTestSelector();\r\n        }\r\n    };\r\n    TestRunnerOrchestrator.prototype.initalRunWithoutTestSelector = function () {\r\n        var testRunner = this.createTestRunner(this.files, true);\r\n        return testRunner.run({ timeout: 10000 }).then(function (testResults) {\r\n            testRunner.dispose();\r\n            return [testResults];\r\n        });\r\n    };\r\n    TestRunnerOrchestrator.prototype.initialRunWithTestSelector = function () {\r\n        var testSelectionFilePath = this.createTestSelectorFileName(this.createTempFolder());\r\n        var runnerAdapter = this.createTestRunner(this.files, true, testSelectionFilePath);\r\n        var sandbox = {\r\n            runnerAdapter: runnerAdapter,\r\n            fileMap: null,\r\n            testSelectionFilePath: testSelectionFilePath,\r\n            index: 0\r\n        };\r\n        return this.runSingleTestsRecursive(sandbox, [], 0).then(function (testResults) {\r\n            runnerAdapter.dispose();\r\n            return testResults;\r\n        });\r\n    };\r\n    TestRunnerOrchestrator.prototype.runMutations = function (mutants) {\r\n        var _this = this;\r\n        mutants = _.clone(mutants); // work with a copy because we're changing state (pop'ing values)\r\n        var results = [];\r\n        return this.createTestRunnerSandboxes().then(function (sandboxes) {\r\n            var promiseProducer = function () {\r\n                if (mutants.length === 0) {\r\n                    return null; // we're done\r\n                }\r\n                else {\r\n                    var mutant = mutants.pop();\r\n                    if (mutant.scopedTestIds.length > 0) {\r\n                        var sandbox_1 = sandboxes.pop();\r\n                        var sourceFileCopy_1 = sandbox_1.fileMap[mutant.filename];\r\n                        return Promise.all([mutant.save(sourceFileCopy_1), _this.selectTestsIfPossible(sandbox_1, mutant.scopedTestIds)])\r\n                            .then(function () { return sandbox_1.runnerAdapter.run({ timeout: _this.calculateTimeout(mutant.timeSpentScopedTests) }); })\r\n                            .then(function (runResult) {\r\n                            var result = _this.collectFrozenMutantResult(mutant, runResult);\r\n                            results.push(result);\r\n                            _this.reporter.onMutantTested(result);\r\n                            return mutant.reset(sourceFileCopy_1);\r\n                        })\r\n                            .then(function () { return sandboxes.push(sandbox_1); }); // mark the runner as available again\r\n                    }\r\n                    else {\r\n                        var result = _this.collectFrozenMutantResult(mutant);\r\n                        results.push(result);\r\n                        return Promise.resolve(_this.reporter.onMutantTested(result));\r\n                    }\r\n                }\r\n            };\r\n            return new PromisePool(promiseProducer, sandboxes.length)\r\n                .start()\r\n                .then(function () { return sandboxes.forEach(function (testRunner) { return testRunner.runnerAdapter.dispose(); }); })\r\n                .then(function () { return _this.reportAllMutantsTested(results); })\r\n                .then(function () { return results; });\r\n        });\r\n    };\r\n    TestRunnerOrchestrator.prototype.reportAllMutantsTested = function (results) {\r\n        objectUtils_1.freezeRecursively(results);\r\n        this.reporter.onAllMutantsTested(results);\r\n    };\r\n    TestRunnerOrchestrator.prototype.calculateTimeout = function (baseTimeout) {\r\n        return (this.options.timeoutFactor * baseTimeout) + this.options.timeoutMs;\r\n    };\r\n    TestRunnerOrchestrator.prototype.collectFrozenMutantResult = function (mutant, runResult) {\r\n        var status;\r\n        var testNames;\r\n        if (runResult) {\r\n            switch (runResult.result) {\r\n                case test_runner_1.TestResult.Timeout:\r\n                    status = report_1.MutantStatus.TIMEDOUT;\r\n                    break;\r\n                case test_runner_1.TestResult.Error:\r\n                    log.debug('Converting a test result `error` to mutant status `killed`.');\r\n                    status = report_1.MutantStatus.KILLED;\r\n                    break;\r\n                case test_runner_1.TestResult.Complete:\r\n                    if (runResult.failed > 0) {\r\n                        status = report_1.MutantStatus.KILLED;\r\n                    }\r\n                    else {\r\n                        status = report_1.MutantStatus.SURVIVED;\r\n                    }\r\n                    break;\r\n            }\r\n            testNames = runResult.testNames;\r\n        }\r\n        else {\r\n            testNames = [];\r\n            status = report_1.MutantStatus.UNTESTED;\r\n        }\r\n        var result = {\r\n            sourceFilePath: mutant.filename,\r\n            mutatorName: mutant.mutatorName,\r\n            status: status,\r\n            replacement: mutant.replacement,\r\n            location: mutant.location,\r\n            range: mutant.range,\r\n            testsRan: testNames,\r\n            originalLines: mutant.originalLines,\r\n            mutatedLines: mutant.mutatedLines,\r\n        };\r\n        objectUtils_1.freezeRecursively(result);\r\n        return result;\r\n    };\r\n    TestRunnerOrchestrator.prototype.runSingleTestsRecursive = function (sandbox, runResults, currentTestIndex) {\r\n        var _this = this;\r\n        return new Promise(function (resolve) {\r\n            _this.selectTestsIfPossible(sandbox, [currentTestIndex])\r\n                .then(function () { return sandbox.runnerAdapter.run({ timeout: 10000 }); })\r\n                .then(function (runResult) {\r\n                if (runResult.result === test_runner_1.TestResult.Complete && runResult.succeeded > 0 || runResult.failed > 0) {\r\n                    runResults[currentTestIndex] = runResult;\r\n                    resolve(_this.runSingleTestsRecursive(sandbox, runResults, currentTestIndex + 1));\r\n                }\r\n                else {\r\n                    if (runResult.result !== test_runner_1.TestResult.Complete) {\r\n                        // If this was iteration n+1 (n = number of tests), the runResult.result will be Complete, so we don't record it\r\n                        runResults[currentTestIndex] = runResult;\r\n                    }\r\n                    sandbox.runnerAdapter.dispose();\r\n                    resolve(runResults);\r\n                }\r\n            });\r\n        });\r\n    };\r\n    TestRunnerOrchestrator.prototype.createTestRunnerSandboxes = function () {\r\n        var cpuCount = os.cpus().length;\r\n        var testRunnerSandboxes = [];\r\n        var allPromises = [];\r\n        log.info(\"Creating \" + cpuCount + \" test runners (based on cpu count)\");\r\n        for (var i = 0; i < cpuCount; i++) {\r\n            allPromises.push(this.createSandbox(i).then(function (sandbox) { return testRunnerSandboxes.push(sandbox); }));\r\n        }\r\n        return Promise.all(allPromises).then(function () { return testRunnerSandboxes; });\r\n    };\r\n    TestRunnerOrchestrator.prototype.selectTestsIfPossible = function (sandbox, ids) {\r\n        if (this.testSelector) {\r\n            var fileContent = this.testSelector.select(ids);\r\n            return StrykerTempFolder_1.default.writeFile(sandbox.testSelectionFilePath, fileContent);\r\n        }\r\n        else {\r\n            return Promise.resolve(void 0);\r\n        }\r\n    };\r\n    TestRunnerOrchestrator.prototype.createSandbox = function (index) {\r\n        var _this = this;\r\n        var tempFolder = this.createTempFolder();\r\n        return this.copyAllFilesToFolder(tempFolder).then(function (fileMap) {\r\n            var runnerFiles = [];\r\n            var testSelectionFilePath = null;\r\n            if (_this.testSelector) {\r\n                testSelectionFilePath = _this.createTestSelectorFileName(tempFolder);\r\n            }\r\n            _this.files.forEach(function (originalFile) { return runnerFiles.push({ path: fileMap[originalFile.path], shouldMutate: originalFile.shouldMutate }); });\r\n            return {\r\n                index: index,\r\n                fileMap: fileMap,\r\n                runnerAdapter: _this.createTestRunner(runnerFiles, false, testSelectionFilePath, index),\r\n                testSelectionFilePath: testSelectionFilePath\r\n            };\r\n        });\r\n    };\r\n    TestRunnerOrchestrator.prototype.createTempFolder = function () {\r\n        var tempFolder = StrykerTempFolder_1.default.createRandomFolder('test-runner-files');\r\n        log.debug('Creating a sandbox for files in %s', tempFolder);\r\n        return tempFolder;\r\n    };\r\n    TestRunnerOrchestrator.prototype.createTestSelectorFileName = function (folder) {\r\n        return path.join(folder, '___testSelection.js');\r\n    };\r\n    TestRunnerOrchestrator.prototype.copyAllFilesToFolder = function (folder) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            var fileMap = Object.create(null);\r\n            var cwd = process.cwd();\r\n            var copyPromises = _this.files.map(function (file) {\r\n                var relativePath = file.path.substr(cwd.length);\r\n                var folderName = StrykerTempFolder_1.default.ensureFolderExists(folder + path.dirname(relativePath));\r\n                var targetFile = path.join(folderName, path.basename(relativePath));\r\n                fileMap[file.path] = targetFile;\r\n                return StrykerTempFolder_1.default.copyFile(file.path, targetFile);\r\n            });\r\n            Promise.all(copyPromises).then(function () { resolve(fileMap); }, reject);\r\n        });\r\n    };\r\n    TestRunnerOrchestrator.prototype.createTestRunner = function (files, coverageEnabled, testSelectionFilePath, index) {\r\n        if (index === void 0) { index = 0; }\r\n        if (testSelectionFilePath) {\r\n            files = [{ path: testSelectionFilePath, shouldMutate: false }].concat(files);\r\n        }\r\n        var settings = {\r\n            coverageEnabled: coverageEnabled,\r\n            files: files,\r\n            strykerOptions: this.options,\r\n            port: this.options.port + index\r\n        };\r\n        log.debug(\"Creating test runner %s using settings {port: %s, coverageEnabled: %s}\", index, settings.port, settings.coverageEnabled);\r\n        return IsolatedTestRunnerAdapterFactory_1.default.create(settings);\r\n    };\r\n    return TestRunnerOrchestrator;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = TestRunnerOrchestrator;\r\n//# sourceMappingURL=TestRunnerOrchestrator.js.map"},{"path":"/stryker/src/TestSelectorOrchestrator.js","content":"\"use strict\";\r\nvar test_selector_1 = require('stryker-api/test_selector');\r\nvar log4js = require('log4js');\r\nvar WARNING_RUNNING_WITHOUT_SELECTOR = 'Stryker will continue without the ability to select individual tests, thus running all test for every generated mutant.';\r\nvar IGNORE_WARNING = 'Set `testSelector` option explicitly to `null` to ignore this warning.';\r\nvar log = log4js.getLogger('TestSelectorOrchestrator');\r\nvar TestSelectorOrchestrator = (function () {\r\n    function TestSelectorOrchestrator(options) {\r\n        this.options = options;\r\n    }\r\n    TestSelectorOrchestrator.prototype.determineTestSelector = function () {\r\n        var testSelector = null;\r\n        if (this.options.testSelector && this.options.testSelector !== 'null') {\r\n            testSelector = this.determineTestSelectorBasedOnTestSelectorSetting();\r\n        }\r\n        else if (this.options.testSelector === null || this.options.testSelector === 'null') {\r\n            log.debug('Running without testSelector (testSelector was null).');\r\n        }\r\n        else {\r\n            if (this.options.testFramework) {\r\n                testSelector = this.determineTestSelectorBasedOnTestFrameworkSetting();\r\n            }\r\n            else {\r\n                log.warn(\"Missing config settings `testFramework` or `testSelector`. \" + WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + IGNORE_WARNING);\r\n            }\r\n        }\r\n        return testSelector;\r\n    };\r\n    TestSelectorOrchestrator.prototype.determineTestSelectorBasedOnTestSelectorSetting = function () {\r\n        if (this.testSelectorExists(this.options.testSelector)) {\r\n            log.debug(\"Using testSelector \" + this.options.testSelector + \" based on `testSelector` setting\");\r\n            return this.createTestSelector(this.options.testSelector);\r\n        }\r\n        else {\r\n            log.warn(\"Could not find test selector `\" + this.options.testSelector + \"`. \" + WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + this.informAboutKnownTestSelectors());\r\n            return null;\r\n        }\r\n    };\r\n    TestSelectorOrchestrator.prototype.determineTestSelectorBasedOnTestFrameworkSetting = function () {\r\n        if (this.testSelectorExists(this.options.testFramework)) {\r\n            log.debug(\"Using testSelector \" + this.options.testFramework + \" based on `testFramework` setting\");\r\n            return this.createTestSelector(this.options.testFramework);\r\n        }\r\n        else {\r\n            log.warn(\"Could not find test selector `\" + this.options.testFramework + \"` (based on the configured testFramework). \" + WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + IGNORE_WARNING + \" \" + this.informAboutKnownTestSelectors());\r\n            return null;\r\n        }\r\n    };\r\n    TestSelectorOrchestrator.prototype.informAboutKnownTestSelectors = function () {\r\n        return \"Did you forget to load a plugin? Known test selectors: \" + JSON.stringify(test_selector_1.TestSelectorFactory.instance().knownNames()) + \".\";\r\n    };\r\n    TestSelectorOrchestrator.prototype.createTestSelector = function (name) {\r\n        return test_selector_1.TestSelectorFactory.instance().create(name, this.createSettings());\r\n    };\r\n    TestSelectorOrchestrator.prototype.testSelectorExists = function (maybeSelector) {\r\n        return test_selector_1.TestSelectorFactory.instance().knownNames().indexOf(maybeSelector) > -1;\r\n    };\r\n    TestSelectorOrchestrator.prototype.createSettings = function () {\r\n        return { options: this.options };\r\n    };\r\n    return TestSelectorOrchestrator;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = TestSelectorOrchestrator;\r\n//# sourceMappingURL=TestSelectorOrchestrator.js.map"},{"path":"/stryker/src/utils/fileUtils.js","content":"'use strict';\r\nvar _ = require('lodash');\r\nvar fs = require('fs');\r\nvar path = require('path');\r\nvar nodeGlob = require('glob');\r\nvar mkdirp = require('mkdirp');\r\n/**\r\n * Checks if a file or folder exists.\r\n * @function\r\n * @param path - The path to the file or folder.\r\n * @returns True if the file exists.\r\n */\r\nfunction fileOrFolderExistsSync(path) {\r\n    try {\r\n        var stats = fs.lstatSync(path);\r\n        return true;\r\n    }\r\n    catch (errror) {\r\n        return false;\r\n    }\r\n}\r\nexports.fileOrFolderExistsSync = fileOrFolderExistsSync;\r\n;\r\nfunction fileOrFolderExists(path) {\r\n    return new Promise(function (resolve) {\r\n        fs.lstat(path, function (error, stats) {\r\n            resolve(!error);\r\n        });\r\n    });\r\n}\r\nexports.fileOrFolderExists = fileOrFolderExists;\r\n/**\r\n * Reads a file.\r\n * @function\r\n * @param filename - The name of the file.\r\n * @returns The content of the file.\r\n */\r\nfunction readFile(filename) {\r\n    return fs.readFileSync(filename, 'utf8');\r\n}\r\nexports.readFile = readFile;\r\n;\r\n/**\r\n   * Normalizes the paths of a list of filenames.\r\n   * @param files - The list of filenames which have to be normalized.\r\n   */\r\nfunction normalize(files) {\r\n    _.forEach(files, function (file, key) {\r\n        files[key] = path.resolve(path.normalize(file));\r\n    });\r\n}\r\nexports.normalize = normalize;\r\n;\r\nfunction glob(expression) {\r\n    return new Promise(function (resolve, reject) {\r\n        nodeGlob(expression, function (error, matches) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve(matches);\r\n            }\r\n        });\r\n    });\r\n}\r\nexports.glob = glob;\r\nfunction readdir(path) {\r\n    return new Promise(function (resolve, reject) {\r\n        fs.readdir(path, function (error, files) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve(files);\r\n            }\r\n        });\r\n    });\r\n}\r\nexports.readdir = readdir;\r\nfunction stats(path) {\r\n    return new Promise(function (resolve, reject) {\r\n        fs.stat(path, function (error, stats) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve(stats);\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction rmFile(path) {\r\n    return new Promise(function (fileResolve, fileReject) {\r\n        fs.unlink(path, function (error) {\r\n            if (error) {\r\n                fileReject(error);\r\n            }\r\n            else {\r\n                fileResolve();\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction deleteDir(dirToDelete) {\r\n    return new Promise(function (resolve, reject) {\r\n        fileOrFolderExists(dirToDelete).then(function (exists) {\r\n            if (exists) {\r\n                readdir(dirToDelete).then(function (files) {\r\n                    var promisses = [];\r\n                    files.forEach(function (file) {\r\n                        var currentPath = path.join(dirToDelete, file);\r\n                        promisses.push(stats(currentPath).then(function (stats) {\r\n                            if (stats.isDirectory()) {\r\n                                // recurse\r\n                                return deleteDir(currentPath);\r\n                            }\r\n                            else {\r\n                                // delete file\r\n                                return rmFile(currentPath);\r\n                            }\r\n                        }));\r\n                    });\r\n                    Promise.all(promisses).then(function () { return resolve(); });\r\n                });\r\n            }\r\n            else {\r\n                resolve();\r\n            }\r\n        });\r\n    });\r\n}\r\nexports.deleteDir = deleteDir;\r\nfunction cleanFolder(folderName) {\r\n    return fileOrFolderExists(folderName)\r\n        .then(function (exists) {\r\n        if (exists) {\r\n            return deleteDir(folderName)\r\n                .then(function () { return mkdirRecursive(folderName); });\r\n        }\r\n        else {\r\n            return mkdirRecursive(folderName);\r\n        }\r\n    });\r\n}\r\nexports.cleanFolder = cleanFolder;\r\nfunction writeFile(fileName, content) {\r\n    return new Promise(function (resolve, reject) {\r\n        fs.writeFile(fileName, content, function (err) {\r\n            if (err) {\r\n                reject(err);\r\n            }\r\n            else {\r\n                resolve();\r\n            }\r\n        });\r\n    });\r\n}\r\nexports.writeFile = writeFile;\r\nfunction mkdirRecursive(folderName) {\r\n    if (!fileOrFolderExistsSync(folderName)) {\r\n        mkdirp.sync(folderName);\r\n    }\r\n}\r\nexports.mkdirRecursive = mkdirRecursive;\r\n/**\r\n * Wrapper around the 'require' function (for testability)\r\n */\r\nfunction importModule(moduleName) {\r\n    require(moduleName);\r\n}\r\nexports.importModule = importModule;\r\n//# sourceMappingURL=fileUtils.js.map"},{"path":"/stryker/src/utils/objectUtils.js","content":"\"use strict\";\r\nvar _ = require('lodash');\r\nfunction freezeRecursively(target) {\r\n    Object.freeze(target);\r\n    Object.keys(target).forEach(function (key) {\r\n        if (_.isObject(target[key])) {\r\n            freezeRecursively(target[key]);\r\n        }\r\n    });\r\n}\r\nexports.freezeRecursively = freezeRecursively;\r\nfunction isPromise(input) {\r\n    return input && typeof input['then'] === 'function';\r\n}\r\nexports.isPromise = isPromise;\r\n//# sourceMappingURL=objectUtils.js.map"},{"path":"/stryker/src/utils/parserUtils.js","content":"\"use strict\";\r\nvar _ = require('lodash');\r\nvar esprima = require('esprima');\r\nvar escodegen = require('escodegen');\r\n/**\r\n * Utility class for parsing and generating code.\r\n * @constructor\r\n */\r\nvar esprimaOptions = {\r\n    comment: true,\r\n    loc: true,\r\n    range: true,\r\n    tokens: true,\r\n};\r\n/**\r\n * Parses code to generate an Abstract Syntax Tree.\r\n * @function\r\n * @param code - The code which has to be parsed.\r\n * @returns {Object} The generated Abstract Syntax Tree.\r\n */\r\nfunction parse(code) {\r\n    if (code === undefined) {\r\n        throw new Error('Code parameter cannot be undefined');\r\n    }\r\n    if (code === '') {\r\n        return {};\r\n    }\r\n    var abstractSyntaxTree = esprima.parse(code, esprimaOptions);\r\n    return abstractSyntaxTree;\r\n}\r\nexports.parse = parse;\r\n;\r\n/**\r\n * Finds all nodes which have a 'type' property and freezes them.\r\n * @function\r\n * @param abstractSyntaxTree - The current part of the abstract syntax tree which will be investigated.\r\n * @returns  All nodes with a type.\r\n */\r\nfunction collectFrozenNodes(abstractSyntaxTree, nodes) {\r\n    nodes = nodes || [];\r\n    if (!_.isArray(abstractSyntaxTree) && _.isObject(abstractSyntaxTree) && abstractSyntaxTree.type && _.isUndefined(abstractSyntaxTree.nodeID)) {\r\n        abstractSyntaxTree.nodeID = nodes.length;\r\n        nodes.push(abstractSyntaxTree);\r\n    }\r\n    Object.freeze(abstractSyntaxTree);\r\n    _.forOwn(abstractSyntaxTree, function (childNode, i) {\r\n        if (childNode instanceof Object && !(childNode instanceof Array)) {\r\n            collectFrozenNodes(childNode, nodes);\r\n        }\r\n        else if (childNode instanceof Array) {\r\n            _.forEach(childNode, function (arrayChild) {\r\n                if (arrayChild instanceof Object && !(arrayChild instanceof Array)) {\r\n                    collectFrozenNodes(arrayChild, nodes);\r\n                }\r\n            });\r\n        }\r\n    });\r\n    return nodes;\r\n}\r\nexports.collectFrozenNodes = collectFrozenNodes;\r\n;\r\n/**\r\n   * Parses a Node to generate code.\r\n   * @param The Node which has to be transformed into code.\r\n   * @returns The generated code.\r\n   */\r\nfunction generate(node) {\r\n    return escodegen.generate(node);\r\n}\r\nexports.generate = generate;\r\n;\r\n//# sourceMappingURL=parserUtils.js.map"},{"path":"/stryker/src/utils/StrykerTempFolder.js","content":"\"use strict\";\r\nvar fs = require('fs');\r\nvar path = require('path');\r\nvar mkdirp = require('mkdirp');\r\nvar baseTempFolder = path.join(process.cwd(), '.stryker-tmp');\r\nvar tempFolder = path.join(baseTempFolder, random().toString());\r\nensureFolderExists(baseTempFolder);\r\nensureFolderExists(tempFolder);\r\n/**\r\n * Creates a new random folder with the specified prefix.\r\n * @param prefix The prefix.\r\n * @returns The path to the folder.\r\n */\r\nfunction createRandomFolder(prefix) {\r\n    return ensureFolderExists(tempFolder + path.sep + prefix + random());\r\n}\r\n/**\r\n * Creates a random integer number.\r\n * @returns A random integer.\r\n */\r\nfunction random() {\r\n    return Math.ceil(Math.random() * 10000000);\r\n}\r\n/**\r\n * Creates a folder at the specified path if it doesn't already exist.\r\n * @param path The path to check.\r\n * @returns The path of the folder.\r\n */\r\nfunction ensureFolderExists(path) {\r\n    if (!fileOrFolderExists(path)) {\r\n        mkdirp.sync(path);\r\n    }\r\n    return path;\r\n}\r\n/**\r\n * Checks if a file or folder exists.\r\n * @param path The path to the file or folder.\r\n * @returns True if the file exists.\r\n */\r\nfunction fileOrFolderExists(path) {\r\n    try {\r\n        var stats = fs.lstatSync(path);\r\n        return true;\r\n    }\r\n    catch (error) {\r\n        return false;\r\n    }\r\n}\r\n/**\r\n * Writes data to a specified file.\r\n * @param filename The path to the file.\r\n * @param data The content of the file.\r\n * @returns A promise to eventually save the file.\r\n */\r\nfunction writeFile(filename, data) {\r\n    return new Promise(function (resolve, reject) {\r\n        fs.writeFile(filename, data, { encoding: 'utf8' }, function (error) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve();\r\n            }\r\n        });\r\n    });\r\n}\r\n/**\r\n * Copies a file.\r\n * @param fromFilename The path to the existing file.\r\n * @param toFilename The path to copy the file to.\r\n * @returns A promise to eventually copy the file.\r\n */\r\nfunction copyFile(fromFilename, toFilename) {\r\n    return new Promise(function (resolve, reject) {\r\n        var readStream = fs.createReadStream(fromFilename, { encoding: 'utf8' });\r\n        var writeStream = fs.createWriteStream(toFilename, { encoding: 'utf8' });\r\n        readStream.on('error', reject);\r\n        writeStream.on('error', reject);\r\n        readStream.pipe(writeStream);\r\n        readStream.on('end', function () { return resolve(); });\r\n    });\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = {\r\n    createRandomFolder: createRandomFolder,\r\n    writeFile: writeFile,\r\n    copyFile: copyFile,\r\n    ensureFolderExists: ensureFolderExists\r\n};\r\n//# sourceMappingURL=StrykerTempFolder.js.map"}]