{"sourceFilePath":"c:\\z\\github\\stryker-mutator\\stryker\\src\\TestSelectorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":7,"column":44},"end":{"line":62,"column":1}},"range":[469,3509],"testsRan":[" Uncaught error outside test suite","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should resolve the promise in a Timeout","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker \"before each\" hook for \"should use the config writer to override config\"","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 4 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 4 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 4 mutants should have ran mutant 2 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 4 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 4 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 4 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined \"before each\" hook for \"should retrieve the test selector\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null \"before each\" hook for \"should not retrieve a testSelector\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" \"before each\" hook for \"should not retrieve a testSelector\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" \"before each\" hook for \"should retrieve the test selector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set \"before each\" hook for \"should log a warning for the missing setting\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` \"before each\" hook for \"should not log a warning for the missing setting\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" \"before each\" hook for \"should use the value of \"overrideTestSelector\"\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" \"before each\" hook for \"should log a warning and retrieve `null`\"","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" \"before each\" hook for \"should log a warning and retrieve `null`\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"var TestSelectorOrchestrator = (function () {\r\n    function TestSelectorOrchestrator(options) {\r\n        this.options = options;\r\n    }\r\n    TestSelectorOrchestrator.prototype.determineTestSelector = function () {\r\n        var testSelector = null;\r\n        if (this.options.testSelector && this.options.testSelector !== 'null') {\r\n            testSelector = this.determineTestSelectorBasedOnTestSelectorSetting();\r\n        }\r\n        else if (this.options.testSelector === null || this.options.testSelector === 'null') {\r\n            log.debug('Running without testSelector (testSelector was null).');\r\n        }\r\n        else {\r\n            if (this.options.testFramework) {\r\n                testSelector = this.determineTestSelectorBasedOnTestFrameworkSetting();\r\n            }\r\n            else {\r\n                log.warn(\"Missing config settings `testFramework` or `testSelector`. \" + WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + IGNORE_WARNING);\r\n            }\r\n        }\r\n        return testSelector;\r\n    };\r\n    TestSelectorOrchestrator.prototype.determineTestSelectorBasedOnTestSelectorSetting = function () {\r\n        if (this.testSelectorExists(this.options.testSelector)) {\r\n            log.debug(\"Using testSelector \" + this.options.testSelector + \" based on `testSelector` setting\");\r\n            return this.createTestSelector(this.options.testSelector);\r\n        }\r\n        else {\r\n            log.warn(\"Could not find test selector `\" + this.options.testSelector + \"`. \" + WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + this.informAboutKnownTestSelectors());\r\n            return null;\r\n        }\r\n    };\r\n    TestSelectorOrchestrator.prototype.determineTestSelectorBasedOnTestFrameworkSetting = function () {\r\n        if (this.testSelectorExists(this.options.testFramework)) {\r\n            log.debug(\"Using testSelector \" + this.options.testFramework + \" based on `testFramework` setting\");\r\n            return this.createTestSelector(this.options.testFramework);\r\n        }\r\n        else {\r\n            log.warn(\"Could not find test selector `\" + this.options.testFramework + \"` (based on the configured testFramework). \" + WARNING_RUNNING_WITHOUT_SELECTOR + \" \" + IGNORE_WARNING + \" \" + this.informAboutKnownTestSelectors());\r\n            return null;\r\n        }\r\n    };\r\n    TestSelectorOrchestrator.prototype.informAboutKnownTestSelectors = function () {\r\n        return \"Did you forget to load a plugin? Known test selectors: \" + JSON.stringify(test_selector_1.TestSelectorFactory.instance().knownNames()) + \".\";\r\n    };\r\n    TestSelectorOrchestrator.prototype.createTestSelector = function (name) {\r\n        return test_selector_1.TestSelectorFactory.instance().create(name, this.createSettings());\r\n    };\r\n    TestSelectorOrchestrator.prototype.testSelectorExists = function (maybeSelector) {\r\n        return test_selector_1.TestSelectorFactory.instance().knownNames().indexOf(maybeSelector) > -1;\r\n    };\r\n    TestSelectorOrchestrator.prototype.createSettings = function () {\r\n        return { options: this.options };\r\n    };\r\n    return TestSelectorOrchestrator;\r\n}());","mutatedLines":"var TestSelectorOrchestrator = (function () {\n}());"}