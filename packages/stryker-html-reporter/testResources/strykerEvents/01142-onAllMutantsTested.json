[{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":19,"column":12},"end":{"line":21,"column":9}},"range":[679,726],"testsRan":[],"originalLines":"        try {\r\n            configModule(config);\r\n        }","mutatedLines":"        try {\n}"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":22,"column":18},"end":{"line":25,"column":9}},"range":[746,842],"testsRan":[],"originalLines":"        catch (e) {\r\n            log.fatal('Error in config file!\\n', e);\r\n            process.exit(1);\r\n        }","mutatedLines":"        catch (e) {\n}"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":12,"column":32},"end":{"line":72,"column":1}},"range":[433,3283],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker \"before each\" hook for \"should exit the process\""],"originalLines":"var ConfigReader = (function () {\r\n    function ConfigReader(options) {\r\n        this.options = options;\r\n    }\r\n    ConfigReader.prototype.readConfig = function () {\r\n        var configModule = this.loadConfigModule();\r\n        var config = new config_1.Config();\r\n        try {\r\n            configModule(config);\r\n        }\r\n        catch (e) {\r\n            log.fatal('Error in config file!\\n', e);\r\n            process.exit(1);\r\n        }\r\n        // merge the config from config file and cliOptions (precedence)\r\n        config.set(this.options);\r\n        this.validate(config);\r\n        return config;\r\n    };\r\n    ConfigReader.prototype.loadConfigModule = function () {\r\n        var configModule;\r\n        if (this.options.configFile) {\r\n            log.debug('Loading config %s', this.options.configFile);\r\n            try {\r\n                configModule = require(process.cwd() + \"/\" + this.options.configFile);\r\n            }\r\n            catch (e) {\r\n                if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(this.options.configFile) !== -1) {\r\n                    log.fatal('File %s does not exist!', this.options.configFile);\r\n                    log.fatal(e);\r\n                }\r\n                else {\r\n                    log.fatal('Invalid config file!\\n  ' + e.stack);\r\n                }\r\n                process.exit(1);\r\n            }\r\n            if (!_.isFunction(configModule)) {\r\n                log.fatal('Config file must export a function!\\n' + exports.CONFIG_SYNTAX_HELP);\r\n                process.exit(1);\r\n            }\r\n        }\r\n        else {\r\n            log.debug('No config file specified.');\r\n            // if no config file path is passed, we define a dummy config module.\r\n            configModule = function () { };\r\n        }\r\n        return configModule;\r\n    };\r\n    ConfigReader.prototype.validate = function (options) {\r\n        if (VALID_COVERAGE_ANALYSIS_VALUES.indexOf(options.coverageAnalysis) < 0) {\r\n            log.fatal(\"Value \\\"\" + options.coverageAnalysis + \"\\\" is invalid for `coverageAnalysis`. Expected one of the folowing: \" + VALID_COVERAGE_ANALYSIS_VALUES.map(function (v) { return (\"\\\"\" + v + \"\\\"\"); }).join(', '));\r\n            process.exit(1);\r\n        }\r\n        if (options.coverageAnalysis === 'perTest' && !options.testFramework) {\r\n            var validCoverageAnalysisSettingsExceptPerTest = VALID_COVERAGE_ANALYSIS_VALUES.filter(function (v) { return v !== 'perTest'; }).map(function (v) { return (\"\\\"\" + v + \"\\\"\"); }).join(', ');\r\n            log.fatal(\"Configured coverage analysis 'perTest' requires a test framework to be configured. Either configure your test framework (for example testFramework: 'jasmine') or set coverageAnalysis setting to one of the following: \" + validCoverageAnalysisSettingsExceptPerTest);\r\n            process.exit(1);\r\n        }\r\n    };\r\n    return ConfigReader;\r\n}());","mutatedLines":"var ConfigReader = (function () {\n}());"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"RemoveConditionals","status":0,"replacement":"false","location":{"start":{"line":33,"column":12},"end":{"line":33,"column":35}},"range":[1117,1140],"testsRan":[],"originalLines":"        if (this.options.configFile) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"RemoveConditionals","status":0,"replacement":"true","location":{"start":{"line":33,"column":12},"end":{"line":33,"column":35}},"range":[1117,1140],"testsRan":[],"originalLines":"        if (this.options.configFile) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":33,"column":37},"end":{"line":52,"column":9}},"range":[1142,1973],"testsRan":[],"originalLines":"        if (this.options.configFile) {\r\n            log.debug('Loading config %s', this.options.configFile);\r\n            try {\r\n                configModule = require(process.cwd() + \"/\" + this.options.configFile);\r\n            }\r\n            catch (e) {\r\n                if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(this.options.configFile) !== -1) {\r\n                    log.fatal('File %s does not exist!', this.options.configFile);\r\n                    log.fatal(e);\r\n                }\r\n                else {\r\n                    log.fatal('Invalid config file!\\n  ' + e.stack);\r\n                }\r\n                process.exit(1);\r\n            }\r\n            if (!_.isFunction(configModule)) {\r\n                log.fatal('Config file must export a function!\\n' + exports.CONFIG_SYNTAX_HELP);\r\n                process.exit(1);\r\n            }\r\n        }","mutatedLines":"        if (this.options.configFile) {\n}"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":35,"column":16},"end":{"line":37,"column":13}},"range":[1231,1335],"testsRan":[],"originalLines":"            try {\r\n                configModule = require(process.cwd() + \"/\" + this.options.configFile);\r\n            }","mutatedLines":"            try {\n}"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BinaryOperator","status":0,"replacement":"process.cwd() + '/' - this.options.configFile","location":{"start":{"line":36,"column":39},"end":{"line":36,"column":84}},"range":[1273,1318],"testsRan":[],"originalLines":"                configModule = require(process.cwd() + \"/\" + this.options.configFile);","mutatedLines":"                configModule = require(process.cwd() + '/' - this.options.configFile);"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BinaryOperator","status":0,"replacement":"process.cwd() - '/'","location":{"start":{"line":36,"column":39},"end":{"line":36,"column":58}},"range":[1273,1292],"testsRan":[],"originalLines":"                configModule = require(process.cwd() + \"/\" + this.options.configFile);","mutatedLines":"                configModule = require(process.cwd() - '/' + this.options.configFile);"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":38,"column":22},"end":{"line":47,"column":13}},"range":[1359,1767],"testsRan":[],"originalLines":"            catch (e) {\r\n                if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(this.options.configFile) !== -1) {\r\n                    log.fatal('File %s does not exist!', this.options.configFile);\r\n                    log.fatal(e);\r\n                }\r\n                else {\r\n                    log.fatal('Invalid config file!\\n  ' + e.stack);\r\n                }\r\n                process.exit(1);\r\n            }","mutatedLines":"            catch (e) {\n}"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"RemoveConditionals","status":0,"replacement":"false","location":{"start":{"line":39,"column":20},"end":{"line":39,"column":102}},"range":[1382,1464],"testsRan":[],"originalLines":"                if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(this.options.configFile) !== -1) {","mutatedLines":"                if (false) {"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"RemoveConditionals","status":0,"replacement":"true","location":{"start":{"line":39,"column":20},"end":{"line":39,"column":102}},"range":[1382,1464],"testsRan":[],"originalLines":"                if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(this.options.configFile) !== -1) {","mutatedLines":"                if (true) {"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"LogicalOperator","status":0,"replacement":"e.code === 'MODULE_NOT_FOUND' || e.message.indexOf(this.options.configFile) !== -1","location":{"start":{"line":39,"column":20},"end":{"line":39,"column":102}},"range":[1382,1464],"testsRan":[],"originalLines":"                if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(this.options.configFile) !== -1) {","mutatedLines":"                if (e.code === 'MODULE_NOT_FOUND' || e.message.indexOf(this.options.configFile) !== -1) {"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BinaryOperator","status":0,"replacement":"e.code !== 'MODULE_NOT_FOUND'","location":{"start":{"line":39,"column":20},"end":{"line":39,"column":49}},"range":[1382,1411],"testsRan":[],"originalLines":"                if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(this.options.configFile) !== -1) {","mutatedLines":"                if (e.code !== 'MODULE_NOT_FOUND' && e.message.indexOf(this.options.configFile) !== -1) {"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BinaryOperator","status":0,"replacement":"e.message.indexOf(this.options.configFile) === -1","location":{"start":{"line":39,"column":53},"end":{"line":39,"column":102}},"range":[1415,1464],"testsRan":[],"originalLines":"                if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(this.options.configFile) !== -1) {","mutatedLines":"                if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(this.options.configFile) === -1) {"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"UnaryOperator","status":0,"replacement":"+1","location":{"start":{"line":39,"column":100},"end":{"line":39,"column":102}},"range":[1462,1464],"testsRan":[],"originalLines":"                if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(this.options.configFile) !== -1) {","mutatedLines":"                if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(this.options.configFile) !== +1) {"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":39,"column":104},"end":{"line":42,"column":17}},"range":[1466,1605],"testsRan":[],"originalLines":"                if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(this.options.configFile) !== -1) {\r\n                    log.fatal('File %s does not exist!', this.options.configFile);\r\n                    log.fatal(e);\r\n                }","mutatedLines":"                if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(this.options.configFile) !== -1) {\n}"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":43,"column":21},"end":{"line":45,"column":17}},"range":[1628,1718],"testsRan":[],"originalLines":"                else {\r\n                    log.fatal('Invalid config file!\\n  ' + e.stack);\r\n                }","mutatedLines":"                else {\n}"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BinaryOperator","status":0,"replacement":"'Invalid config file!\\n  ' - e.stack","location":{"start":{"line":44,"column":30},"end":{"line":44,"column":66}},"range":[1661,1697],"testsRan":[],"originalLines":"                    log.fatal('Invalid config file!\\n  ' + e.stack);","mutatedLines":"                    log.fatal('Invalid config file!\\n  ' - e.stack);"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"RemoveConditionals","status":0,"replacement":"false","location":{"start":{"line":48,"column":16},"end":{"line":48,"column":43}},"range":[1785,1812],"testsRan":[],"originalLines":"            if (!_.isFunction(configModule)) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"RemoveConditionals","status":0,"replacement":"true","location":{"start":{"line":48,"column":16},"end":{"line":48,"column":43}},"range":[1785,1812],"testsRan":[],"originalLines":"            if (!_.isFunction(configModule)) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":48,"column":45},"end":{"line":51,"column":13}},"range":[1814,1962],"testsRan":[],"originalLines":"            if (!_.isFunction(configModule)) {\r\n                log.fatal('Config file must export a function!\\n' + exports.CONFIG_SYNTAX_HELP);\r\n                process.exit(1);\r\n            }","mutatedLines":"            if (!_.isFunction(configModule)) {\n}"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BinaryOperator","status":0,"replacement":"'Config file must export a function!\\n' - exports.CONFIG_SYNTAX_HELP","location":{"start":{"line":49,"column":26},"end":{"line":49,"column":94}},"range":[1843,1911],"testsRan":[],"originalLines":"                log.fatal('Config file must export a function!\\n' + exports.CONFIG_SYNTAX_HELP);","mutatedLines":"                log.fatal('Config file must export a function!\\n' - exports.CONFIG_SYNTAX_HELP);"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":53,"column":13},"end":{"line":57,"column":9}},"range":[1988,2181],"testsRan":[],"originalLines":"        else {\r\n            log.debug('No config file specified.');\r\n            // if no config file path is passed, we define a dummy config module.\r\n            configModule = function () { };\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BinaryOperator","status":2,"replacement":"'  module.exports = function(config) {\\n' - '    config.set({\\n'","location":{"start":{"line":6,"column":29},"end":{"line":7,"column":24}},"range":[217,286],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"exports.CONFIG_SYNTAX_HELP = '  module.exports = function(config) {\\n' +\r\n    '    config.set({\\n' +","mutatedLines":"exports.CONFIG_SYNTAX_HELP = '  module.exports = function(config) {\\n' - '    config.set({\\n' +"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"RemoveConditionals","status":0,"replacement":"false","location":{"start":{"line":61,"column":12},"end":{"line":61,"column":80}},"range":[2293,2361],"testsRan":[],"originalLines":"        if (VALID_COVERAGE_ANALYSIS_VALUES.indexOf(options.coverageAnalysis) < 0) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"RemoveConditionals","status":0,"replacement":"true","location":{"start":{"line":61,"column":12},"end":{"line":61,"column":80}},"range":[2293,2361],"testsRan":[],"originalLines":"        if (VALID_COVERAGE_ANALYSIS_VALUES.indexOf(options.coverageAnalysis) < 0) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BinaryOperator","status":0,"replacement":"VALID_COVERAGE_ANALYSIS_VALUES.indexOf(options.coverageAnalysis) <= 0","location":{"start":{"line":61,"column":12},"end":{"line":61,"column":80}},"range":[2293,2361],"testsRan":[],"originalLines":"        if (VALID_COVERAGE_ANALYSIS_VALUES.indexOf(options.coverageAnalysis) < 0) {","mutatedLines":"        if (VALID_COVERAGE_ANALYSIS_VALUES.indexOf(options.coverageAnalysis) <= 0) {"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BinaryOperator","status":0,"replacement":"VALID_COVERAGE_ANALYSIS_VALUES.indexOf(options.coverageAnalysis) >= 0","location":{"start":{"line":61,"column":12},"end":{"line":61,"column":80}},"range":[2293,2361],"testsRan":[],"originalLines":"        if (VALID_COVERAGE_ANALYSIS_VALUES.indexOf(options.coverageAnalysis) < 0) {","mutatedLines":"        if (VALID_COVERAGE_ANALYSIS_VALUES.indexOf(options.coverageAnalysis) >= 0) {"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":61,"column":82},"end":{"line":64,"column":9}},"range":[2363,2633],"testsRan":[],"originalLines":"        if (VALID_COVERAGE_ANALYSIS_VALUES.indexOf(options.coverageAnalysis) < 0) {\r\n            log.fatal(\"Value \\\"\" + options.coverageAnalysis + \"\\\" is invalid for `coverageAnalysis`. Expected one of the folowing: \" + VALID_COVERAGE_ANALYSIS_VALUES.map(function (v) { return (\"\\\"\" + v + \"\\\"\"); }).join(', '));\r\n            process.exit(1);\r\n        }","mutatedLines":"        if (VALID_COVERAGE_ANALYSIS_VALUES.indexOf(options.coverageAnalysis) < 0) {\n}"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BinaryOperator","status":0,"replacement":"'Value \"' + options.coverageAnalysis + '\" is invalid for `coverageAnalysis`. Expected one of the folowing: ' - VALID_COVERAGE_ANALYSIS_VALUES.map(function (v) {\n    return '\"' + v + '\"';\n}).join(', ')","location":{"start":{"line":62,"column":22},"end":{"line":62,"column":224}},"range":[2388,2590],"testsRan":[],"originalLines":"            log.fatal(\"Value \\\"\" + options.coverageAnalysis + \"\\\" is invalid for `coverageAnalysis`. Expected one of the folowing: \" + VALID_COVERAGE_ANALYSIS_VALUES.map(function (v) { return (\"\\\"\" + v + \"\\\"\"); }).join(', '));","mutatedLines":"            log.fatal('Value \"' + options.coverageAnalysis + '\" is invalid for `coverageAnalysis`. Expected one of the folowing: ' - VALID_COVERAGE_ANALYSIS_VALUES.map(function (v) {\n    return '\"' + v + '\"';\n}).join(', '));"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BinaryOperator","status":0,"replacement":"'Value \"' + options.coverageAnalysis - '\" is invalid for `coverageAnalysis`. Expected one of the folowing: '","location":{"start":{"line":62,"column":22},"end":{"line":62,"column":132}},"range":[2388,2498],"testsRan":[],"originalLines":"            log.fatal(\"Value \\\"\" + options.coverageAnalysis + \"\\\" is invalid for `coverageAnalysis`. Expected one of the folowing: \" + VALID_COVERAGE_ANALYSIS_VALUES.map(function (v) { return (\"\\\"\" + v + \"\\\"\"); }).join(', '));","mutatedLines":"            log.fatal('Value \"' + options.coverageAnalysis - '\" is invalid for `coverageAnalysis`. Expected one of the folowing: ' + VALID_COVERAGE_ANALYSIS_VALUES.map(function (v) { return (\"\\\"\" + v + \"\\\"\"); }).join(', '));"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BinaryOperator","status":0,"replacement":"'Value \"' - options.coverageAnalysis","location":{"start":{"line":62,"column":22},"end":{"line":62,"column":59}},"range":[2388,2425],"testsRan":[],"originalLines":"            log.fatal(\"Value \\\"\" + options.coverageAnalysis + \"\\\" is invalid for `coverageAnalysis`. Expected one of the folowing: \" + VALID_COVERAGE_ANALYSIS_VALUES.map(function (v) { return (\"\\\"\" + v + \"\\\"\"); }).join(', '));","mutatedLines":"            log.fatal('Value \"' - options.coverageAnalysis + \"\\\" is invalid for `coverageAnalysis`. Expected one of the folowing: \" + VALID_COVERAGE_ANALYSIS_VALUES.map(function (v) { return (\"\\\"\" + v + \"\\\"\"); }).join(', '));"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":62,"column":183},"end":{"line":62,"column":212}},"range":[2549,2578],"testsRan":[],"originalLines":"            log.fatal(\"Value \\\"\" + options.coverageAnalysis + \"\\\" is invalid for `coverageAnalysis`. Expected one of the folowing: \" + VALID_COVERAGE_ANALYSIS_VALUES.map(function (v) { return (\"\\\"\" + v + \"\\\"\"); }).join(', '));","mutatedLines":"            log.fatal(\"Value \\\"\" + options.coverageAnalysis + \"\\\" is invalid for `coverageAnalysis`. Expected one of the folowing: \" + VALID_COVERAGE_ANALYSIS_VALUES.map(function (v) {\n}).join(', '));"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BinaryOperator","status":0,"replacement":"'\"' + v - '\"'","location":{"start":{"line":62,"column":193},"end":{"line":62,"column":208}},"range":[2559,2574],"testsRan":[],"originalLines":"            log.fatal(\"Value \\\"\" + options.coverageAnalysis + \"\\\" is invalid for `coverageAnalysis`. Expected one of the folowing: \" + VALID_COVERAGE_ANALYSIS_VALUES.map(function (v) { return (\"\\\"\" + v + \"\\\"\"); }).join(', '));","mutatedLines":"            log.fatal(\"Value \\\"\" + options.coverageAnalysis + \"\\\" is invalid for `coverageAnalysis`. Expected one of the folowing: \" + VALID_COVERAGE_ANALYSIS_VALUES.map(function (v) { return ('\"' + v - '\"'); }).join(', '));"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BinaryOperator","status":0,"replacement":"'\"' - v","location":{"start":{"line":62,"column":193},"end":{"line":62,"column":201}},"range":[2559,2567],"testsRan":[],"originalLines":"            log.fatal(\"Value \\\"\" + options.coverageAnalysis + \"\\\" is invalid for `coverageAnalysis`. Expected one of the folowing: \" + VALID_COVERAGE_ANALYSIS_VALUES.map(function (v) { return (\"\\\"\" + v + \"\\\"\"); }).join(', '));","mutatedLines":"            log.fatal(\"Value \\\"\" + options.coverageAnalysis + \"\\\" is invalid for `coverageAnalysis`. Expected one of the folowing: \" + VALID_COVERAGE_ANALYSIS_VALUES.map(function (v) { return ('\"' - v + \"\\\"\"); }).join(', '));"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"RemoveConditionals","status":0,"replacement":"false","location":{"start":{"line":65,"column":12},"end":{"line":65,"column":76}},"range":[2647,2711],"testsRan":[],"originalLines":"        if (options.coverageAnalysis === 'perTest' && !options.testFramework) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"RemoveConditionals","status":0,"replacement":"true","location":{"start":{"line":65,"column":12},"end":{"line":65,"column":76}},"range":[2647,2711],"testsRan":[],"originalLines":"        if (options.coverageAnalysis === 'perTest' && !options.testFramework) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"LogicalOperator","status":0,"replacement":"options.coverageAnalysis === 'perTest' || !options.testFramework","location":{"start":{"line":65,"column":12},"end":{"line":65,"column":76}},"range":[2647,2711],"testsRan":[],"originalLines":"        if (options.coverageAnalysis === 'perTest' && !options.testFramework) {","mutatedLines":"        if (options.coverageAnalysis === 'perTest' || !options.testFramework) {"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BinaryOperator","status":0,"replacement":"options.coverageAnalysis !== 'perTest'","location":{"start":{"line":65,"column":12},"end":{"line":65,"column":50}},"range":[2647,2685],"testsRan":[],"originalLines":"        if (options.coverageAnalysis === 'perTest' && !options.testFramework) {","mutatedLines":"        if (options.coverageAnalysis !== 'perTest' && !options.testFramework) {"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":65,"column":78},"end":{"line":69,"column":9}},"range":[2713,3246],"testsRan":[],"originalLines":"        if (options.coverageAnalysis === 'perTest' && !options.testFramework) {\r\n            var validCoverageAnalysisSettingsExceptPerTest = VALID_COVERAGE_ANALYSIS_VALUES.filter(function (v) { return v !== 'perTest'; }).map(function (v) { return (\"\\\"\" + v + \"\\\"\"); }).join(', ');\r\n            log.fatal(\"Configured coverage analysis 'perTest' requires a test framework to be configured. Either configure your test framework (for example testFramework: 'jasmine') or set coverageAnalysis setting to one of the following: \" + validCoverageAnalysisSettingsExceptPerTest);\r\n            process.exit(1);\r\n        }","mutatedLines":"        if (options.coverageAnalysis === 'perTest' && !options.testFramework) {\n}"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":66,"column":112},"end":{"line":66,"column":139}},"range":[2828,2855],"testsRan":[],"originalLines":"            var validCoverageAnalysisSettingsExceptPerTest = VALID_COVERAGE_ANALYSIS_VALUES.filter(function (v) { return v !== 'perTest'; }).map(function (v) { return (\"\\\"\" + v + \"\\\"\"); }).join(', ');","mutatedLines":"            var validCoverageAnalysisSettingsExceptPerTest = VALID_COVERAGE_ANALYSIS_VALUES.filter(function (v) {\n}).map(function (v) { return (\"\\\"\" + v + \"\\\"\"); }).join(', ');"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BinaryOperator","status":0,"replacement":"v === 'perTest'","location":{"start":{"line":66,"column":121},"end":{"line":66,"column":136}},"range":[2837,2852],"testsRan":[],"originalLines":"            var validCoverageAnalysisSettingsExceptPerTest = VALID_COVERAGE_ANALYSIS_VALUES.filter(function (v) { return v !== 'perTest'; }).map(function (v) { return (\"\\\"\" + v + \"\\\"\"); }).join(', ');","mutatedLines":"            var validCoverageAnalysisSettingsExceptPerTest = VALID_COVERAGE_ANALYSIS_VALUES.filter(function (v) { return v === 'perTest'; }).map(function (v) { return (\"\\\"\" + v + \"\\\"\"); }).join(', ');"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":66,"column":158},"end":{"line":66,"column":187}},"range":[2874,2903],"testsRan":[],"originalLines":"            var validCoverageAnalysisSettingsExceptPerTest = VALID_COVERAGE_ANALYSIS_VALUES.filter(function (v) { return v !== 'perTest'; }).map(function (v) { return (\"\\\"\" + v + \"\\\"\"); }).join(', ');","mutatedLines":"            var validCoverageAnalysisSettingsExceptPerTest = VALID_COVERAGE_ANALYSIS_VALUES.filter(function (v) { return v !== 'perTest'; }).map(function (v) {\n}).join(', ');"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BinaryOperator","status":0,"replacement":"'\"' + v - '\"'","location":{"start":{"line":66,"column":168},"end":{"line":66,"column":183}},"range":[2884,2899],"testsRan":[],"originalLines":"            var validCoverageAnalysisSettingsExceptPerTest = VALID_COVERAGE_ANALYSIS_VALUES.filter(function (v) { return v !== 'perTest'; }).map(function (v) { return (\"\\\"\" + v + \"\\\"\"); }).join(', ');","mutatedLines":"            var validCoverageAnalysisSettingsExceptPerTest = VALID_COVERAGE_ANALYSIS_VALUES.filter(function (v) { return v !== 'perTest'; }).map(function (v) { return ('\"' + v - '\"'); }).join(', ');"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BinaryOperator","status":0,"replacement":"'\"' - v","location":{"start":{"line":66,"column":168},"end":{"line":66,"column":176}},"range":[2884,2892],"testsRan":[],"originalLines":"            var validCoverageAnalysisSettingsExceptPerTest = VALID_COVERAGE_ANALYSIS_VALUES.filter(function (v) { return v !== 'perTest'; }).map(function (v) { return (\"\\\"\" + v + \"\\\"\"); }).join(', ');","mutatedLines":"            var validCoverageAnalysisSettingsExceptPerTest = VALID_COVERAGE_ANALYSIS_VALUES.filter(function (v) { return v !== 'perTest'; }).map(function (v) { return ('\"' - v + \"\\\"\"); }).join(', ');"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BinaryOperator","status":0,"replacement":"'Configured coverage analysis \\'perTest\\' requires a test framework to be configured. Either configure your test framework (for example testFramework: \\'jasmine\\') or set coverageAnalysis setting to one of the following: ' - validCoverageAnalysisSettingsExceptPerTest","location":{"start":{"line":67,"column":22},"end":{"line":67,"column":285}},"range":[2940,3203],"testsRan":[],"originalLines":"            log.fatal(\"Configured coverage analysis 'perTest' requires a test framework to be configured. Either configure your test framework (for example testFramework: 'jasmine') or set coverageAnalysis setting to one of the following: \" + validCoverageAnalysisSettingsExceptPerTest);","mutatedLines":"            log.fatal('Configured coverage analysis \\'perTest\\' requires a test framework to be configured. Either configure your test framework (for example testFramework: \\'jasmine\\') or set coverageAnalysis setting to one of the following: ' - validCoverageAnalysisSettingsExceptPerTest);"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":31,"column":58},"end":{"line":59,"column":5}},"range":[1075,2218],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    ConfigReader.prototype.loadConfigModule = function () {\r\n        var configModule;\r\n        if (this.options.configFile) {\r\n            log.debug('Loading config %s', this.options.configFile);\r\n            try {\r\n                configModule = require(process.cwd() + \"/\" + this.options.configFile);\r\n            }\r\n            catch (e) {\r\n                if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(this.options.configFile) !== -1) {\r\n                    log.fatal('File %s does not exist!', this.options.configFile);\r\n                    log.fatal(e);\r\n                }\r\n                else {\r\n                    log.fatal('Invalid config file!\\n  ' + e.stack);\r\n                }\r\n                process.exit(1);\r\n            }\r\n            if (!_.isFunction(configModule)) {\r\n                log.fatal('Config file must export a function!\\n' + exports.CONFIG_SYNTAX_HELP);\r\n                process.exit(1);\r\n            }\r\n        }\r\n        else {\r\n            log.debug('No config file specified.');\r\n            // if no config file path is passed, we define a dummy config module.\r\n            configModule = function () { };\r\n        }\r\n        return configModule;\r\n    };","mutatedLines":"    ConfigReader.prototype.loadConfigModule = function () {\n};"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BinaryOperator","status":2,"replacement":"'  module.exports = function(config) {\\n' + '    config.set({\\n' + '      // your config\\n' + '    });\\n' - '  };\\n'","location":{"start":{"line":6,"column":29},"end":{"line":10,"column":12}},"range":[217,353],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"exports.CONFIG_SYNTAX_HELP = '  module.exports = function(config) {\\n' +\r\n    '    config.set({\\n' +\r\n    '      // your config\\n' +\r\n    '    });\\n' +\r\n    '  };\\n';","mutatedLines":"exports.CONFIG_SYNTAX_HELP = '  module.exports = function(config) {\\n' + '    config.set({\\n' + '      // your config\\n' + '    });\\n' - '  };\\n';"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BinaryOperator","status":2,"replacement":"'  module.exports = function(config) {\\n' + '    config.set({\\n' - '      // your config\\n'","location":{"start":{"line":6,"column":29},"end":{"line":8,"column":28}},"range":[217,318],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"exports.CONFIG_SYNTAX_HELP = '  module.exports = function(config) {\\n' +\r\n    '    config.set({\\n' +\r\n    '      // your config\\n' +","mutatedLines":"exports.CONFIG_SYNTAX_HELP = '  module.exports = function(config) {\\n' + '    config.set({\\n' - '      // your config\\n' +"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":16,"column":52},"end":{"line":30,"column":5}},"range":[566,1014],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    ConfigReader.prototype.readConfig = function () {\r\n        var configModule = this.loadConfigModule();\r\n        var config = new config_1.Config();\r\n        try {\r\n            configModule(config);\r\n        }\r\n        catch (e) {\r\n            log.fatal('Error in config file!\\n', e);\r\n            process.exit(1);\r\n        }\r\n        // merge the config from config file and cliOptions (precedence)\r\n        config.set(this.options);\r\n        this.validate(config);\r\n        return config;\r\n    };","mutatedLines":"    ConfigReader.prototype.readConfig = function () {\n};"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BinaryOperator","status":2,"replacement":"'  module.exports = function(config) {\\n' + '    config.set({\\n' + '      // your config\\n' - '    });\\n'","location":{"start":{"line":6,"column":29},"end":{"line":9,"column":15}},"range":[217,337],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"exports.CONFIG_SYNTAX_HELP = '  module.exports = function(config) {\\n' +\r\n    '    config.set({\\n' +\r\n    '      // your config\\n' +\r\n    '    });\\n' +","mutatedLines":"exports.CONFIG_SYNTAX_HELP = '  module.exports = function(config) {\\n' + '    config.set({\\n' + '      // your config\\n' - '    });\\n' +"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":13,"column":40},"end":{"line":62,"column":1}},"range":[610,3392],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" \"before each\" hook for \"should return the perTest hooks\""],"originalLines":"var CoverageInstrumenter = (function () {\r\n    function CoverageInstrumenter(coverageAnalysis, testFramework) {\r\n        this.coverageAnalysis = coverageAnalysis;\r\n        this.testFramework = testFramework;\r\n        this.coverageInstrumenterStreamPerFile = Object.create(null);\r\n    }\r\n    CoverageInstrumenter.prototype.instrumenterStreamForFile = function (file) {\r\n        if (file.mutated) {\r\n            /*\r\n            Coverage variable *must* have the name '__coverage__'. Only that variable\r\n            is reported back to the TestRunner process when using one of the karma\r\n            test framework adapters (karma-jasmine, karma-mocha, ...).\r\n      \r\n            However, when coverageAnalysis is 'perTest' we don't choose that variable name right away,\r\n            because we need that variable to hold all coverage results per test. Instead, we use __strykerCoverageCurrentTest__\r\n            and after each test copy over the value of that current test to the global coverage object __coverage__\r\n             */\r\n            switch (this.coverageAnalysis) {\r\n                case 'all':\r\n                    return this.createStreamForFile('__coverage__', file.path);\r\n                case 'perTest':\r\n                    return this.createStreamForFile(COVERAGE_CURRENT_TEST_VARIABLE_NAME, file.path);\r\n            }\r\n        }\r\n        // By default, do not instrument for code coverage\r\n        return new stream_1.PassThrough();\r\n    };\r\n    CoverageInstrumenter.prototype.hooksForTestRun = function () {\r\n        if (this.coverageAnalysis === 'perTest') {\r\n            log.debug(\"Adding test hooks file for coverageAnalysis \\\"perTest\\\"\");\r\n            return objectUtils_1.wrapInClosure(\"\\n          var id = 0, coverageStateAtStart;\\n          window.__coverage__ = globalCoverage = {};\\n\\n          \" + this.testFramework.beforeEach(beforeEachFragmentPerTest) + \"\\n          \" + this.testFramework.afterEach(afterEachFragmentPerTest) + \"\\n          \" + cloneFunctionFragment + \";\\n      \");\r\n        }\r\n        else {\r\n            return '';\r\n        }\r\n    };\r\n    CoverageInstrumenter.prototype.retrieveStatementMapsPerFile = function () {\r\n        var _this = this;\r\n        var statementMapsPerFile = Object.create(null);\r\n        Object.keys(this.coverageInstrumenterStreamPerFile)\r\n            .forEach(function (key) { return statementMapsPerFile[key] = _this.coverageInstrumenterStreamPerFile[key].statementMap; });\r\n        return statementMapsPerFile;\r\n    };\r\n    CoverageInstrumenter.prototype.createStreamForFile = function (coverageVariable, fileName) {\r\n        var stream = new CoverageInstrumenterStream_1.default(coverageVariable, fileName);\r\n        this.coverageInstrumenterStreamPerFile[fileName] = stream;\r\n        return stream;\r\n    };\r\n    return CoverageInstrumenter;\r\n}());","mutatedLines":"var CoverageInstrumenter = (function () {\n}());"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":14,"column":67},"end":{"line":18,"column":5}},"range":[680,855],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks"],"originalLines":"    function CoverageInstrumenter(coverageAnalysis, testFramework) {\r\n        this.coverageAnalysis = coverageAnalysis;\r\n        this.testFramework = testFramework;\r\n        this.coverageInstrumenterStreamPerFile = Object.create(null);\r\n    }","mutatedLines":"    function CoverageInstrumenter(coverageAnalysis, testFramework) {\n}"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":13,"column":35},"end":{"line":15,"column":5}},"range":[471,512],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    function ConfigReader(options) {\r\n        this.options = options;\r\n    }","mutatedLines":"    function ConfigReader(options) {\n}"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":20,"column":12},"end":{"line":20,"column":24}},"range":[951,963],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files"],"originalLines":"        if (file.mutated) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":20,"column":12},"end":{"line":20,"column":24}},"range":[951,963],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files"],"originalLines":"        if (file.mutated) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":40,"column":65},"end":{"line":48,"column":5}},"range":[2096,2655],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks"],"originalLines":"    CoverageInstrumenter.prototype.hooksForTestRun = function () {\r\n        if (this.coverageAnalysis === 'perTest') {\r\n            log.debug(\"Adding test hooks file for coverageAnalysis \\\"perTest\\\"\");\r\n            return objectUtils_1.wrapInClosure(\"\\n          var id = 0, coverageStateAtStart;\\n          window.__coverage__ = globalCoverage = {};\\n\\n          \" + this.testFramework.beforeEach(beforeEachFragmentPerTest) + \"\\n          \" + this.testFramework.afterEach(afterEachFragmentPerTest) + \"\\n          \" + cloneFunctionFragment + \";\\n      \");\r\n        }\r\n        else {\r\n            return '';\r\n        }\r\n    };","mutatedLines":"    CoverageInstrumenter.prototype.hooksForTestRun = function () {\n};"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":19,"column":79},"end":{"line":39,"column":5}},"range":[936,2028],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files"],"originalLines":"    CoverageInstrumenter.prototype.instrumenterStreamForFile = function (file) {\r\n        if (file.mutated) {\r\n            /*\r\n            Coverage variable *must* have the name '__coverage__'. Only that variable\r\n            is reported back to the TestRunner process when using one of the karma\r\n            test framework adapters (karma-jasmine, karma-mocha, ...).\r\n      \r\n            However, when coverageAnalysis is 'perTest' we don't choose that variable name right away,\r\n            because we need that variable to hold all coverage results per test. Instead, we use __strykerCoverageCurrentTest__\r\n            and after each test copy over the value of that current test to the global coverage object __coverage__\r\n             */\r\n            switch (this.coverageAnalysis) {\r\n                case 'all':\r\n                    return this.createStreamForFile('__coverage__', file.path);\r\n                case 'perTest':\r\n                    return this.createStreamForFile(COVERAGE_CURRENT_TEST_VARIABLE_NAME, file.path);\r\n            }\r\n        }\r\n        // By default, do not instrument for code coverage\r\n        return new stream_1.PassThrough();\r\n    };","mutatedLines":"    CoverageInstrumenter.prototype.instrumenterStreamForFile = function (file) {\n};"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":41,"column":12},"end":{"line":41,"column":47}},"range":[2111,2146],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks"],"originalLines":"        if (this.coverageAnalysis === 'perTest') {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":20,"column":26},"end":{"line":36,"column":9}},"range":[965,1917],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files"],"originalLines":"        if (file.mutated) {\r\n            /*\r\n            Coverage variable *must* have the name '__coverage__'. Only that variable\r\n            is reported back to the TestRunner process when using one of the karma\r\n            test framework adapters (karma-jasmine, karma-mocha, ...).\r\n      \r\n            However, when coverageAnalysis is 'perTest' we don't choose that variable name right away,\r\n            because we need that variable to hold all coverage results per test. Instead, we use __strykerCoverageCurrentTest__\r\n            and after each test copy over the value of that current test to the global coverage object __coverage__\r\n             */\r\n            switch (this.coverageAnalysis) {\r\n                case 'all':\r\n                    return this.createStreamForFile('__coverage__', file.path);\r\n                case 'perTest':\r\n                    return this.createStreamForFile(COVERAGE_CURRENT_TEST_VARIABLE_NAME, file.path);\r\n            }\r\n        }","mutatedLines":"        if (file.mutated) {\n}"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":41,"column":12},"end":{"line":41,"column":47}},"range":[2111,2146],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string"],"originalLines":"        if (this.coverageAnalysis === 'perTest') {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenter.js","mutatorName":"BinaryOperator","status":1,"replacement":"this.coverageAnalysis !== 'perTest'","location":{"start":{"line":41,"column":12},"end":{"line":41,"column":47}},"range":[2111,2146],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks"],"originalLines":"        if (this.coverageAnalysis === 'perTest') {","mutatedLines":"        if (this.coverageAnalysis !== 'perTest') {"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenter.js","mutatorName":"BinaryOperator","status":1,"replacement":"'\\n          var id = 0, coverageStateAtStart;\\n          window.__coverage__ = globalCoverage = {};\\n\\n          ' + this.testFramework.beforeEach(beforeEachFragmentPerTest) + '\\n          ' + this.testFramework.afterEach(afterEachFragmentPerTest) + '\\n          ' + cloneFunctionFragment - ';\\n      '","location":{"start":{"line":43,"column":47},"end":{"line":43,"column":350}},"range":[2281,2584],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks"],"originalLines":"            return objectUtils_1.wrapInClosure(\"\\n          var id = 0, coverageStateAtStart;\\n          window.__coverage__ = globalCoverage = {};\\n\\n          \" + this.testFramework.beforeEach(beforeEachFragmentPerTest) + \"\\n          \" + this.testFramework.afterEach(afterEachFragmentPerTest) + \"\\n          \" + cloneFunctionFragment + \";\\n      \");","mutatedLines":"            return objectUtils_1.wrapInClosure('\\n          var id = 0, coverageStateAtStart;\\n          window.__coverage__ = globalCoverage = {};\\n\\n          ' + this.testFramework.beforeEach(beforeEachFragmentPerTest) + '\\n          ' + this.testFramework.afterEach(afterEachFragmentPerTest) + '\\n          ' + cloneFunctionFragment - ';\\n      ');"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":41,"column":49},"end":{"line":44,"column":9}},"range":[2148,2597],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks"],"originalLines":"        if (this.coverageAnalysis === 'perTest') {\r\n            log.debug(\"Adding test hooks file for coverageAnalysis \\\"perTest\\\"\");\r\n            return objectUtils_1.wrapInClosure(\"\\n          var id = 0, coverageStateAtStart;\\n          window.__coverage__ = globalCoverage = {};\\n\\n          \" + this.testFramework.beforeEach(beforeEachFragmentPerTest) + \"\\n          \" + this.testFramework.afterEach(afterEachFragmentPerTest) + \"\\n          \" + cloneFunctionFragment + \";\\n      \");\r\n        }","mutatedLines":"        if (this.coverageAnalysis === 'perTest') {\n}"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenter.js","mutatorName":"BinaryOperator","status":1,"replacement":"'\\n          var id = 0, coverageStateAtStart;\\n          window.__coverage__ = globalCoverage = {};\\n\\n          ' + this.testFramework.beforeEach(beforeEachFragmentPerTest) + '\\n          ' + this.testFramework.afterEach(afterEachFragmentPerTest) - '\\n          '","location":{"start":{"line":43,"column":47},"end":{"line":43,"column":312}},"range":[2281,2546],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks"],"originalLines":"            return objectUtils_1.wrapInClosure(\"\\n          var id = 0, coverageStateAtStart;\\n          window.__coverage__ = globalCoverage = {};\\n\\n          \" + this.testFramework.beforeEach(beforeEachFragmentPerTest) + \"\\n          \" + this.testFramework.afterEach(afterEachFragmentPerTest) + \"\\n          \" + cloneFunctionFragment + \";\\n      \");","mutatedLines":"            return objectUtils_1.wrapInClosure('\\n          var id = 0, coverageStateAtStart;\\n          window.__coverage__ = globalCoverage = {};\\n\\n          ' + this.testFramework.beforeEach(beforeEachFragmentPerTest) + '\\n          ' + this.testFramework.afterEach(afterEachFragmentPerTest) - '\\n          ' + cloneFunctionFragment + \";\\n      \");"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenter.js","mutatorName":"BinaryOperator","status":1,"replacement":"'\\n          var id = 0, coverageStateAtStart;\\n          window.__coverage__ = globalCoverage = {};\\n\\n          ' + this.testFramework.beforeEach(beforeEachFragmentPerTest) + '\\n          ' + this.testFramework.afterEach(afterEachFragmentPerTest) + '\\n          ' - cloneFunctionFragment","location":{"start":{"line":43,"column":47},"end":{"line":43,"column":336}},"range":[2281,2570],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks"],"originalLines":"            return objectUtils_1.wrapInClosure(\"\\n          var id = 0, coverageStateAtStart;\\n          window.__coverage__ = globalCoverage = {};\\n\\n          \" + this.testFramework.beforeEach(beforeEachFragmentPerTest) + \"\\n          \" + this.testFramework.afterEach(afterEachFragmentPerTest) + \"\\n          \" + cloneFunctionFragment + \";\\n      \");","mutatedLines":"            return objectUtils_1.wrapInClosure('\\n          var id = 0, coverageStateAtStart;\\n          window.__coverage__ = globalCoverage = {};\\n\\n          ' + this.testFramework.beforeEach(beforeEachFragmentPerTest) + '\\n          ' + this.testFramework.afterEach(afterEachFragmentPerTest) + '\\n          ' - cloneFunctionFragment + \";\\n      \");"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenter.js","mutatorName":"BinaryOperator","status":1,"replacement":"'\\n          var id = 0, coverageStateAtStart;\\n          window.__coverage__ = globalCoverage = {};\\n\\n          ' + this.testFramework.beforeEach(beforeEachFragmentPerTest) + '\\n          ' - this.testFramework.afterEach(afterEachFragmentPerTest)","location":{"start":{"line":43,"column":47},"end":{"line":43,"column":295}},"range":[2281,2529],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks"],"originalLines":"            return objectUtils_1.wrapInClosure(\"\\n          var id = 0, coverageStateAtStart;\\n          window.__coverage__ = globalCoverage = {};\\n\\n          \" + this.testFramework.beforeEach(beforeEachFragmentPerTest) + \"\\n          \" + this.testFramework.afterEach(afterEachFragmentPerTest) + \"\\n          \" + cloneFunctionFragment + \";\\n      \");","mutatedLines":"            return objectUtils_1.wrapInClosure('\\n          var id = 0, coverageStateAtStart;\\n          window.__coverage__ = globalCoverage = {};\\n\\n          ' + this.testFramework.beforeEach(beforeEachFragmentPerTest) + '\\n          ' - this.testFramework.afterEach(afterEachFragmentPerTest) + \"\\n          \" + cloneFunctionFragment + \";\\n      \");"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenter.js","mutatorName":"BinaryOperator","status":1,"replacement":"'\\n          var id = 0, coverageStateAtStart;\\n          window.__coverage__ = globalCoverage = {};\\n\\n          ' + this.testFramework.beforeEach(beforeEachFragmentPerTest) - '\\n          '","location":{"start":{"line":43,"column":47},"end":{"line":43,"column":238}},"range":[2281,2472],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks"],"originalLines":"            return objectUtils_1.wrapInClosure(\"\\n          var id = 0, coverageStateAtStart;\\n          window.__coverage__ = globalCoverage = {};\\n\\n          \" + this.testFramework.beforeEach(beforeEachFragmentPerTest) + \"\\n          \" + this.testFramework.afterEach(afterEachFragmentPerTest) + \"\\n          \" + cloneFunctionFragment + \";\\n      \");","mutatedLines":"            return objectUtils_1.wrapInClosure('\\n          var id = 0, coverageStateAtStart;\\n          window.__coverage__ = globalCoverage = {};\\n\\n          ' + this.testFramework.beforeEach(beforeEachFragmentPerTest) - '\\n          ' + this.testFramework.afterEach(afterEachFragmentPerTest) + \"\\n          \" + cloneFunctionFragment + \";\\n      \");"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenter.js","mutatorName":"BinaryOperator","status":1,"replacement":"'\\n          var id = 0, coverageStateAtStart;\\n          window.__coverage__ = globalCoverage = {};\\n\\n          ' - this.testFramework.beforeEach(beforeEachFragmentPerTest)","location":{"start":{"line":43,"column":47},"end":{"line":43,"column":221}},"range":[2281,2455],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks"],"originalLines":"            return objectUtils_1.wrapInClosure(\"\\n          var id = 0, coverageStateAtStart;\\n          window.__coverage__ = globalCoverage = {};\\n\\n          \" + this.testFramework.beforeEach(beforeEachFragmentPerTest) + \"\\n          \" + this.testFramework.afterEach(afterEachFragmentPerTest) + \"\\n          \" + cloneFunctionFragment + \";\\n      \");","mutatedLines":"            return objectUtils_1.wrapInClosure('\\n          var id = 0, coverageStateAtStart;\\n          window.__coverage__ = globalCoverage = {};\\n\\n          ' - this.testFramework.beforeEach(beforeEachFragmentPerTest) + \"\\n          \" + this.testFramework.afterEach(afterEachFragmentPerTest) + \"\\n          \" + cloneFunctionFragment + \";\\n      \");"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":49,"column":78},"end":{"line":55,"column":5}},"range":[2736,3064],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps"],"originalLines":"    CoverageInstrumenter.prototype.retrieveStatementMapsPerFile = function () {\r\n        var _this = this;\r\n        var statementMapsPerFile = Object.create(null);\r\n        Object.keys(this.coverageInstrumenterStreamPerFile)\r\n            .forEach(function (key) { return statementMapsPerFile[key] = _this.coverageInstrumenterStreamPerFile[key].statementMap; });\r\n        return statementMapsPerFile;\r\n    };","mutatedLines":"    CoverageInstrumenter.prototype.retrieveStatementMapsPerFile = function () {\n};"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":45,"column":13},"end":{"line":47,"column":9}},"range":[2612,2648],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string"],"originalLines":"        else {\r\n            return '';\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":53,"column":36},"end":{"line":53,"column":133}},"range":[2920,3017],"testsRan":["CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps"],"originalLines":"            .forEach(function (key) { return statementMapsPerFile[key] = _this.coverageInstrumenterStreamPerFile[key].statementMap; });","mutatedLines":"            .forEach(function (key) {\n});"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":56,"column":95},"end":{"line":60,"column":5}},"range":[3162,3354],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files"],"originalLines":"    CoverageInstrumenter.prototype.createStreamForFile = function (coverageVariable, fileName) {\r\n        var stream = new CoverageInstrumenterStream_1.default(coverageVariable, fileName);\r\n        this.coverageInstrumenterStreamPerFile[fileName] = stream;\r\n        return stream;\r\n    };","mutatedLines":"    CoverageInstrumenter.prototype.createStreamForFile = function (coverageVariable, fileName) {\n};"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenterStream.js","mutatorName":"LogicalOperator","status":1,"replacement":"this && this.__extends && function (d, b) {\n    for (var p in b)\n        if (b.hasOwnProperty(p))\n            d[p] = b[p];\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}","location":{"start":{"line":2,"column":16},"end":{"line":6,"column":1}},"range":[31,275],"testsRan":[],"originalLines":"var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};","mutatedLines":"var __extends = this && this.__extends && function (d, b) {\n    for (var p in b)\n        if (b.hasOwnProperty(p))\n            d[p] = b[p];\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenterStream.js","mutatorName":"LogicalOperator","status":1,"replacement":"this || this.__extends","location":{"start":{"line":2,"column":17},"end":{"line":2,"column":39}},"range":[32,54],"testsRan":[],"originalLines":"var __extends = (this && this.__extends) || function (d, b) {","mutatedLines":"var __extends = (this || this.__extends) || function (d, b) {"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenterStream.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":2,"column":60},"end":{"line":6,"column":1}},"range":[75,275],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams \"before each\" hook for \"should retrieve 2 statement maps\""],"originalLines":"var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};","mutatedLines":"var __extends = (this && this.__extends) || function (d, b) {\n};"},{"sourceFilePath":"/stryker/src/ConfigReader.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":60,"column":57},"end":{"line":70,"column":5}},"range":[2278,3253],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    ConfigReader.prototype.validate = function (options) {\r\n        if (VALID_COVERAGE_ANALYSIS_VALUES.indexOf(options.coverageAnalysis) < 0) {\r\n            log.fatal(\"Value \\\"\" + options.coverageAnalysis + \"\\\" is invalid for `coverageAnalysis`. Expected one of the folowing: \" + VALID_COVERAGE_ANALYSIS_VALUES.map(function (v) { return (\"\\\"\" + v + \"\\\"\"); }).join(', '));\r\n            process.exit(1);\r\n        }\r\n        if (options.coverageAnalysis === 'perTest' && !options.testFramework) {\r\n            var validCoverageAnalysisSettingsExceptPerTest = VALID_COVERAGE_ANALYSIS_VALUES.filter(function (v) { return v !== 'perTest'; }).map(function (v) { return (\"\\\"\" + v + \"\\\"\"); }).join(', ');\r\n            log.fatal(\"Configured coverage analysis 'perTest' requires a test framework to be configured. Either configure your test framework (for example testFramework: 'jasmine') or set coverageAnalysis setting to one of the following: \" + validCoverageAnalysisSettingsExceptPerTest);\r\n            process.exit(1);\r\n        }\r\n    };","mutatedLines":"    ConfigReader.prototype.validate = function (options) {\n};"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenter.js","mutatorName":"BinaryOperator","status":2,"replacement":"'\\nif (!coverageStateAtStart) {\\n  coverageStateAtStart = clone(window.' + COVERAGE_CURRENT_TEST_VARIABLE_NAME - ');\\n}'","location":{"start":{"line":66,"column":32},"end":{"line":66,"column":152}},"range":[4072,4192],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"var beforeEachFragmentPerTest = \"\\nif (!coverageStateAtStart) {\\n  coverageStateAtStart = clone(window.\" + COVERAGE_CURRENT_TEST_VARIABLE_NAME + \");\\n}\";","mutatedLines":"var beforeEachFragmentPerTest = '\\nif (!coverageStateAtStart) {\\n  coverageStateAtStart = clone(window.' + COVERAGE_CURRENT_TEST_VARIABLE_NAME - ');\\n}';"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenter.js","mutatorName":"BinaryOperator","status":2,"replacement":"'\\n       globalCoverage[id] = coverageResult = {};\\n      id++;\\n           var coveragePerTest = window.' + COVERAGE_CURRENT_TEST_VARIABLE_NAME - ';\\n            Object.keys(coveragePerTest).forEach(function (file) {\\n                var coverage = coveragePerTest[file];\\n                coverageResult[file] = { s: coverage.s };\\n                coverage.s = clone(coverageStateAtStart[file].s);\\n            });'","location":{"start":{"line":67,"column":31},"end":{"line":67,"column":448}},"range":[4226,4643],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"var afterEachFragmentPerTest = \"\\n       globalCoverage[id] = coverageResult = {};\\n      id++;\\n           var coveragePerTest = window.\" + COVERAGE_CURRENT_TEST_VARIABLE_NAME + \";\\n            Object.keys(coveragePerTest).forEach(function (file) {\\n                var coverage = coveragePerTest[file];\\n                coverageResult[file] = { s: coverage.s };\\n                coverage.s = clone(coverageStateAtStart[file].s);\\n            });\";","mutatedLines":"var afterEachFragmentPerTest = '\\n       globalCoverage[id] = coverageResult = {};\\n      id++;\\n           var coveragePerTest = window.' + COVERAGE_CURRENT_TEST_VARIABLE_NAME - ';\\n            Object.keys(coveragePerTest).forEach(function (file) {\\n                var coverage = coveragePerTest[file];\\n                coverageResult[file] = { s: coverage.s };\\n                coverage.s = clone(coverageStateAtStart[file].s);\\n            });';"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenter.js","mutatorName":"BinaryOperator","status":2,"replacement":"'\\n       globalCoverage[id] = coverageResult = {};\\n      id++;\\n           var coveragePerTest = window.' - COVERAGE_CURRENT_TEST_VARIABLE_NAME","location":{"start":{"line":67,"column":31},"end":{"line":67,"column":176}},"range":[4226,4371],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"var afterEachFragmentPerTest = \"\\n       globalCoverage[id] = coverageResult = {};\\n      id++;\\n           var coveragePerTest = window.\" + COVERAGE_CURRENT_TEST_VARIABLE_NAME + \";\\n            Object.keys(coveragePerTest).forEach(function (file) {\\n                var coverage = coveragePerTest[file];\\n                coverageResult[file] = { s: coverage.s };\\n                coverage.s = clone(coverageStateAtStart[file].s);\\n            });\";","mutatedLines":"var afterEachFragmentPerTest = '\\n       globalCoverage[id] = coverageResult = {};\\n      id++;\\n           var coveragePerTest = window.' - COVERAGE_CURRENT_TEST_VARIABLE_NAME + \";\\n            Object.keys(coveragePerTest).forEach(function (file) {\\n                var coverage = coveragePerTest[file];\\n                coverageResult[file] = { s: coverage.s };\\n                coverage.s = clone(coverageStateAtStart[file].s);\\n            });\";"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenterStream.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":5,"column":18},"end":{"line":5,"column":28}},"range":[201,211],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams \"before each\" hook for \"should retrieve 2 statement maps\""],"originalLines":"    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());","mutatedLines":"    d.prototype = true ? Object.create(b) : (__.prototype = b.prototype, new __());"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenter.js","mutatorName":"BinaryOperator","status":2,"replacement":"'\\nif (!coverageStateAtStart) {\\n  coverageStateAtStart = clone(window.' - COVERAGE_CURRENT_TEST_VARIABLE_NAME","location":{"start":{"line":66,"column":32},"end":{"line":66,"column":142}},"range":[4072,4182],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"var beforeEachFragmentPerTest = \"\\nif (!coverageStateAtStart) {\\n  coverageStateAtStart = clone(window.\" + COVERAGE_CURRENT_TEST_VARIABLE_NAME + \");\\n}\";","mutatedLines":"var beforeEachFragmentPerTest = '\\nif (!coverageStateAtStart) {\\n  coverageStateAtStart = clone(window.' - COVERAGE_CURRENT_TEST_VARIABLE_NAME + \");\\n}\";"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenterStream.js","mutatorName":"RemoveConditionals","status":2,"replacement":"false","location":{"start":{"line":3,"column":25},"end":{"line":3,"column":44}},"range":[103,122],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];","mutatedLines":"    for (var p in b) if (false) d[p] = b[p];"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenterStream.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":3,"column":25},"end":{"line":3,"column":44}},"range":[103,122],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];","mutatedLines":"    for (var p in b) if (true) d[p] = b[p];"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenterStream.js","mutatorName":"BinaryOperator","status":1,"replacement":"b !== null","location":{"start":{"line":5,"column":18},"end":{"line":5,"column":28}},"range":[201,211],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams \"before each\" hook for \"should retrieve 2 statement maps\""],"originalLines":"    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());","mutatedLines":"    d.prototype = b !== null ? Object.create(b) : (__.prototype = b.prototype, new __());"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenterStream.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":16,"column":52},"end":{"line":52,"column":1}},"range":[732,2215],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files"],"originalLines":"var CoverageInstrumenterStream = (function (_super) {\r\n    __extends(CoverageInstrumenterStream, _super);\r\n    function CoverageInstrumenterStream(coverageVariable, filename, opts) {\r\n        _super.call(this, opts);\r\n        this.coverageVariable = coverageVariable;\r\n        this.filename = filename;\r\n        this.opts = opts;\r\n        this.source = '';\r\n    }\r\n    CoverageInstrumenterStream.prototype._transform = function (chunk, encoding, callback) {\r\n        if (typeof chunk === 'string') {\r\n            this.source += chunk;\r\n        }\r\n        else {\r\n            this.source += chunk.toString();\r\n        }\r\n        callback();\r\n    };\r\n    CoverageInstrumenterStream.prototype._flush = function (callback) {\r\n        try {\r\n            var instrumenter = new istanbul_1.Instrumenter({ coverageVariable: this.coverageVariable });\r\n            var instrumentedCode = instrumenter.instrumentSync(this.source, this.filename);\r\n            coverageObjRegex.lastIndex = 0;\r\n            var coverageObjectMatch = coverageObjRegex.exec(instrumentedCode).toString();\r\n            var coverageObj = JSON.parse(coverageObjectMatch);\r\n            this.statementMap = coverageObj.statementMap;\r\n            this.push(instrumentedCode);\r\n        }\r\n        catch (err) {\r\n            var error = \"Error while instrumenting file \\\"\" + this.filename + \"\\\", error was: \" + err.toString();\r\n            log.error(error);\r\n            this.push(this.source);\r\n        }\r\n        callback();\r\n    };\r\n    return CoverageInstrumenterStream;\r\n}(stream_1.Transform));","mutatedLines":"var CoverageInstrumenterStream = (function (_super) {\n}(stream_1.Transform));"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenterStream.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":4,"column":18},"end":{"line":4,"column":43}},"range":[156,181],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    function __() { this.constructor = d; }","mutatedLines":"    function __() {\n}"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenterStream.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":18,"column":74},"end":{"line":24,"column":5}},"range":[861,1043],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files"],"originalLines":"    function CoverageInstrumenterStream(coverageVariable, filename, opts) {\r\n        _super.call(this, opts);\r\n        this.coverageVariable = coverageVariable;\r\n        this.filename = filename;\r\n        this.opts = opts;\r\n        this.source = '';\r\n    }","mutatedLines":"    function CoverageInstrumenterStream(coverageVariable, filename, opts) {\n}"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenterStream.js","mutatorName":"RemoveConditionals","status":2,"replacement":"false","location":{"start":{"line":26,"column":12},"end":{"line":26,"column":37}},"range":[1151,1176],"testsRan":["CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error"],"originalLines":"        if (typeof chunk === 'string') {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenterStream.js","mutatorName":"BinaryOperator","status":2,"replacement":"typeof chunk !== 'string'","location":{"start":{"line":26,"column":12},"end":{"line":26,"column":37}},"range":[1151,1176],"testsRan":["CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error"],"originalLines":"        if (typeof chunk === 'string') {","mutatedLines":"        if (typeof chunk !== 'string') {"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenterStream.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":26,"column":12},"end":{"line":26,"column":37}},"range":[1151,1176],"testsRan":["CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error"],"originalLines":"        if (typeof chunk === 'string') {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenterStream.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":26,"column":39},"end":{"line":28,"column":9}},"range":[1178,1225],"testsRan":["CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error"],"originalLines":"        if (typeof chunk === 'string') {\r\n            this.source += chunk;\r\n        }","mutatedLines":"        if (typeof chunk === 'string') {\n}"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenterStream.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":29,"column":13},"end":{"line":31,"column":9}},"range":[1240,1298],"testsRan":["CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input"],"originalLines":"        else {\r\n            this.source += chunk.toString();\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenterStream.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":35,"column":12},"end":{"line":43,"column":9}},"range":[1414,1926],"testsRan":["CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps"],"originalLines":"        try {\r\n            var instrumenter = new istanbul_1.Instrumenter({ coverageVariable: this.coverageVariable });\r\n            var instrumentedCode = instrumenter.instrumentSync(this.source, this.filename);\r\n            coverageObjRegex.lastIndex = 0;\r\n            var coverageObjectMatch = coverageObjRegex.exec(instrumentedCode).toString();\r\n            var coverageObj = JSON.parse(coverageObjectMatch);\r\n            this.statementMap = coverageObj.statementMap;\r\n            this.push(instrumentedCode);\r\n        }","mutatedLines":"        try {\n}"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenterStream.js","mutatorName":"RemoveConditionals","status":2,"replacement":"false","location":{"start":{"line":5,"column":18},"end":{"line":5,"column":28}},"range":[201,211],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());","mutatedLines":"    d.prototype = false ? Object.create(b) : (__.prototype = b.prototype, new __());"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenterStream.js","mutatorName":"BinaryOperator","status":1,"replacement":"'Error while instrumenting file \"' + this.filename + '\", error was: ' - err.toString()","location":{"start":{"line":45,"column":24},"end":{"line":45,"column":112}},"range":[1975,2063],"testsRan":["CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error"],"originalLines":"            var error = \"Error while instrumenting file \\\"\" + this.filename + \"\\\", error was: \" + err.toString();","mutatedLines":"            var error = 'Error while instrumenting file \"' + this.filename + '\", error was: ' - err.toString();"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenterStream.js","mutatorName":"BinaryOperator","status":1,"replacement":"'Error while instrumenting file \"' + this.filename - '\", error was: '","location":{"start":{"line":45,"column":24},"end":{"line":45,"column":95}},"range":[1975,2046],"testsRan":["CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error"],"originalLines":"            var error = \"Error while instrumenting file \\\"\" + this.filename + \"\\\", error was: \" + err.toString();","mutatedLines":"            var error = 'Error while instrumenting file \"' + this.filename - '\", error was: ' + err.toString();"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenterStream.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":44,"column":20},"end":{"line":48,"column":9}},"range":[1948,2143],"testsRan":["CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input"],"originalLines":"        catch (err) {\r\n            var error = \"Error while instrumenting file \\\"\" + this.filename + \"\\\", error was: \" + err.toString();\r\n            log.error(error);\r\n            this.push(this.source);\r\n        }","mutatedLines":"        catch (err) {\n}"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenterStream.js","mutatorName":"BinaryOperator","status":1,"replacement":"'Error while instrumenting file \"' - this.filename","location":{"start":{"line":45,"column":24},"end":{"line":45,"column":75}},"range":[1975,2026],"testsRan":["CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error"],"originalLines":"            var error = \"Error while instrumenting file \\\"\" + this.filename + \"\\\", error was: \" + err.toString();","mutatedLines":"            var error = 'Error while instrumenting file \"' - this.filename + \"\\\", error was: \" + err.toString();"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":7,"column":37},"end":{"line":88,"column":1}},"range":[285,4451],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files \"before each\" hook for \"should result in the expected input files\""],"originalLines":"var InputFileResolver = (function () {\r\n    function InputFileResolver(mutate, allFileExpressions) {\r\n        this.mutateFileExpressions = mutate || [];\r\n        this.inputFileDescriptors = allFileExpressions.map(function (maybePattern) {\r\n            if (InputFileResolver.isInputFileDescriptor(maybePattern)) {\r\n                return maybePattern;\r\n            }\r\n            else {\r\n                return _.assign({ pattern: maybePattern }, DEFAULT_INPUT_FILE_PROPERTIES);\r\n            }\r\n        });\r\n    }\r\n    InputFileResolver.prototype.resolve = function () {\r\n        var mutateFilePromise = this.resolveMutateFileGlobs();\r\n        return this.resolveInputFileGlobs().then(function (allInputFiles) { return mutateFilePromise.then(function (additionalMutateFiles) {\r\n            InputFileResolver.markAdditionalFilesToMutate(allInputFiles, additionalMutateFiles);\r\n            InputFileResolver.warnAboutNoFilesToMutate(allInputFiles);\r\n            return allInputFiles;\r\n        }); });\r\n    };\r\n    InputFileResolver.markAdditionalFilesToMutate = function (allInputFiles, additionalMutateFiles) {\r\n        var errors = [];\r\n        additionalMutateFiles.forEach(function (mutateFile) {\r\n            if (!allInputFiles.filter(function (inputFile) { return inputFile.path === mutateFile; }).length) {\r\n                errors.push(\"Could not find mutate file \\\"\" + mutateFile + \"\\\" in list of files.\");\r\n            }\r\n        });\r\n        if (errors.length > 0) {\r\n            throw new Error(errors.join(' '));\r\n        }\r\n        allInputFiles.forEach(function (file) { return file.mutated = additionalMutateFiles.some(function (mutateFile) { return mutateFile === file.path; }) || file.mutated; });\r\n    };\r\n    InputFileResolver.warnAboutNoFilesToMutate = function (allInputFiles) {\r\n        var mutateFiles = allInputFiles.filter(function (file) { return file.mutated; });\r\n        if (mutateFiles.length) {\r\n            log.info(\"Found \" + mutateFiles.length + \" file(s) to be mutated.\");\r\n        }\r\n        else {\r\n            log.warn(\"No files marked to be mutated, stryker will perform a dry-run without actually mutating anything.\");\r\n        }\r\n    };\r\n    InputFileResolver.reportEmptyGlobbingExpression = function (expression) {\r\n        log.warn(\"Globbing expression \\\"\" + expression + \"\\\" did not result in any files.\");\r\n    };\r\n    InputFileResolver.isInputFileDescriptor = function (maybeInputFileDescriptor) {\r\n        if (_.isObject(maybeInputFileDescriptor)) {\r\n            if (Object.keys(maybeInputFileDescriptor).indexOf('pattern') > -1) {\r\n                return true;\r\n            }\r\n            else {\r\n                throw Error(\"File descriptor \" + JSON.stringify(maybeInputFileDescriptor) + \" is missing mandatory property 'pattern'.\");\r\n            }\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    };\r\n    InputFileResolver.prototype.resolveMutateFileGlobs = function () {\r\n        return Promise.all(this.mutateFileExpressions.map(InputFileResolver.resolveFileGlob))\r\n            .then(function (files) { return _.flatten(files); });\r\n    };\r\n    InputFileResolver.prototype.resolveInputFileGlobs = function () {\r\n        return Promise.all(this.inputFileDescriptors.map(function (descriptor) { return InputFileResolver.resolveFileGlob(descriptor.pattern)\r\n            .then(function (sourceFiles) { return sourceFiles.map(function (sourceFile) { return InputFileResolver.createInputFile(sourceFile, descriptor); }); }); })).then(function (promises) { return _.flatten(promises); });\r\n    };\r\n    InputFileResolver.createInputFile = function (path, descriptor) {\r\n        var inputFile = _.assign({ path: path }, DEFAULT_INPUT_FILE_PROPERTIES, descriptor);\r\n        delete inputFile['pattern'];\r\n        return inputFile;\r\n    };\r\n    InputFileResolver.resolveFileGlob = function (expression) {\r\n        var _this = this;\r\n        return fileUtils_1.glob(expression).then(function (files) {\r\n            if (files.length === 0) {\r\n                _this.reportEmptyGlobbingExpression(expression);\r\n            }\r\n            fileUtils_1.normalize(files);\r\n            return files;\r\n        });\r\n    };\r\n    return InputFileResolver;\r\n}());","mutatedLines":"var InputFileResolver = (function () {\n}());"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"LogicalOperator","status":1,"replacement":"mutate && []","location":{"start":{"line":9,"column":37},"end":{"line":9,"column":49}},"range":[387,399],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files"],"originalLines":"        this.mutateFileExpressions = mutate || [];","mutatedLines":"        this.mutateFileExpressions = mutate && [];"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":10,"column":83},"end":{"line":17,"column":9}},"range":[485,751],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called \"before each\" hook for \"should result in the expected input files\""],"originalLines":"        this.inputFileDescriptors = allFileExpressions.map(function (maybePattern) {\r\n            if (InputFileResolver.isInputFileDescriptor(maybePattern)) {\r\n                return maybePattern;\r\n            }\r\n            else {\r\n                return _.assign({ pattern: maybePattern }, DEFAULT_INPUT_FILE_PROPERTIES);\r\n            }\r\n        });","mutatedLines":"        this.inputFileDescriptors = allFileExpressions.map(function (maybePattern) {\n});"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":11,"column":16},"end":{"line":11,"column":69}},"range":[504,557],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error"],"originalLines":"            if (InputFileResolver.isInputFileDescriptor(maybePattern)) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":8,"column":59},"end":{"line":18,"column":5}},"range":[347,760],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called \"before each\" hook for \"should result in the expected input files\""],"originalLines":"    function InputFileResolver(mutate, allFileExpressions) {\r\n        this.mutateFileExpressions = mutate || [];\r\n        this.inputFileDescriptors = allFileExpressions.map(function (maybePattern) {\r\n            if (InputFileResolver.isInputFileDescriptor(maybePattern)) {\r\n                return maybePattern;\r\n            }\r\n            else {\r\n                return _.assign({ pattern: maybePattern }, DEFAULT_INPUT_FILE_PROPERTIES);\r\n            }\r\n        });\r\n    }","mutatedLines":"    function InputFileResolver(mutate, allFileExpressions) {\n}"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":11,"column":16},"end":{"line":11,"column":69}},"range":[504,557],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called \"before each\" hook for \"should result in the expected input files\""],"originalLines":"            if (InputFileResolver.isInputFileDescriptor(maybePattern)) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":14,"column":17},"end":{"line":16,"column":13}},"range":[632,740],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called \"before each\" hook for \"should result in the expected input files\""],"originalLines":"            else {\r\n                return _.assign({ pattern: maybePattern }, DEFAULT_INPUT_FILE_PROPERTIES);\r\n            }","mutatedLines":"            else {\n}"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":11,"column":71},"end":{"line":13,"column":13}},"range":[559,613],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files \"before each\" hook for \"should result in the expected input files\""],"originalLines":"            if (InputFileResolver.isInputFileDescriptor(maybePattern)) {\r\n                return maybePattern;\r\n            }","mutatedLines":"            if (InputFileResolver.isInputFileDescriptor(maybePattern)) {\n}"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":21,"column":139},"end":{"line":25,"column":9}},"range":[1022,1239],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files"],"originalLines":"        return this.resolveInputFileGlobs().then(function (allInputFiles) { return mutateFilePromise.then(function (additionalMutateFiles) {\r\n            InputFileResolver.markAdditionalFilesToMutate(allInputFiles, additionalMutateFiles);\r\n            InputFileResolver.warnAboutNoFilesToMutate(allInputFiles);\r\n            return allInputFiles;\r\n        }); });","mutatedLines":"        return this.resolveInputFileGlobs().then(function (allInputFiles) { return mutateFilePromise.then(function (additionalMutateFiles) {\n}); });"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":21,"column":74},"end":{"line":25,"column":13}},"range":[957,1243],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files"],"originalLines":"        return this.resolveInputFileGlobs().then(function (allInputFiles) { return mutateFilePromise.then(function (additionalMutateFiles) {\r\n            InputFileResolver.markAdditionalFilesToMutate(allInputFiles, additionalMutateFiles);\r\n            InputFileResolver.warnAboutNoFilesToMutate(allInputFiles);\r\n            return allInputFiles;\r\n        }); });","mutatedLines":"        return this.resolveInputFileGlobs().then(function (allInputFiles) {\n});"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":19,"column":54},"end":{"line":26,"column":5}},"range":[816,1252],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called \"before each\" hook for \"should result in the expected input files\""],"originalLines":"    InputFileResolver.prototype.resolve = function () {\r\n        var mutateFilePromise = this.resolveMutateFileGlobs();\r\n        return this.resolveInputFileGlobs().then(function (allInputFiles) { return mutateFilePromise.then(function (additionalMutateFiles) {\r\n            InputFileResolver.markAdditionalFilesToMutate(allInputFiles, additionalMutateFiles);\r\n            InputFileResolver.warnAboutNoFilesToMutate(allInputFiles);\r\n            return allInputFiles;\r\n        }); });\r\n    };","mutatedLines":"    InputFileResolver.prototype.resolve = function () {\n};"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":27,"column":100},"end":{"line":38,"column":5}},"range":[1355,1966],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files"],"originalLines":"    InputFileResolver.markAdditionalFilesToMutate = function (allInputFiles, additionalMutateFiles) {\r\n        var errors = [];\r\n        additionalMutateFiles.forEach(function (mutateFile) {\r\n            if (!allInputFiles.filter(function (inputFile) { return inputFile.path === mutateFile; }).length) {\r\n                errors.push(\"Could not find mutate file \\\"\" + mutateFile + \"\\\" in list of files.\");\r\n            }\r\n        });\r\n        if (errors.length > 0) {\r\n            throw new Error(errors.join(' '));\r\n        }\r\n        allInputFiles.forEach(function (file) { return file.mutated = additionalMutateFiles.some(function (mutateFile) { return mutateFile === file.path; }) || file.mutated; });\r\n    };","mutatedLines":"    InputFileResolver.markAdditionalFilesToMutate = function (allInputFiles, additionalMutateFiles) {\n};"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":30,"column":16},"end":{"line":30,"column":108}},"range":[1463,1555],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called \"before each\" hook for \"should result in the expected input files\""],"originalLines":"            if (!allInputFiles.filter(function (inputFile) { return inputFile.path === mutateFile; }).length) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":30,"column":16},"end":{"line":30,"column":108}},"range":[1463,1555],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result"],"originalLines":"            if (!allInputFiles.filter(function (inputFile) { return inputFile.path === mutateFile; }).length) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":30,"column":59},"end":{"line":30,"column":100}},"range":[1506,1547],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called \"before each\" hook for \"should result in the expected input files\""],"originalLines":"            if (!allInputFiles.filter(function (inputFile) { return inputFile.path === mutateFile; }).length) {","mutatedLines":"            if (!allInputFiles.filter(function (inputFile) {\n}).length) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":29,"column":60},"end":{"line":33,"column":9}},"range":[1444,1685],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result"],"originalLines":"        additionalMutateFiles.forEach(function (mutateFile) {\r\n            if (!allInputFiles.filter(function (inputFile) { return inputFile.path === mutateFile; }).length) {\r\n                errors.push(\"Could not find mutate file \\\"\" + mutateFile + \"\\\" in list of files.\");\r\n            }\r\n        });","mutatedLines":"        additionalMutateFiles.forEach(function (mutateFile) {\n});"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BinaryOperator","status":1,"replacement":"inputFile.path !== mutateFile","location":{"start":{"line":30,"column":68},"end":{"line":30,"column":97}},"range":[1515,1544],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result"],"originalLines":"            if (!allInputFiles.filter(function (inputFile) { return inputFile.path === mutateFile; }).length) {","mutatedLines":"            if (!allInputFiles.filter(function (inputFile) { return inputFile.path !== mutateFile; }).length) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":30,"column":110},"end":{"line":32,"column":13}},"range":[1557,1674],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result"],"originalLines":"            if (!allInputFiles.filter(function (inputFile) { return inputFile.path === mutateFile; }).length) {\r\n                errors.push(\"Could not find mutate file \\\"\" + mutateFile + \"\\\" in list of files.\");\r\n            }","mutatedLines":"            if (!allInputFiles.filter(function (inputFile) { return inputFile.path === mutateFile; }).length) {\n}"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BinaryOperator","status":1,"replacement":"'Could not find mutate file \"' + mutateFile - '\" in list of files.'","location":{"start":{"line":31,"column":28},"end":{"line":31,"column":97}},"range":[1588,1657],"testsRan":["InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result"],"originalLines":"                errors.push(\"Could not find mutate file \\\"\" + mutateFile + \"\\\" in list of files.\");","mutatedLines":"                errors.push('Could not find mutate file \"' + mutateFile - '\" in list of files.');"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BinaryOperator","status":1,"replacement":"'Could not find mutate file \"' - mutateFile","location":{"start":{"line":31,"column":28},"end":{"line":31,"column":72}},"range":[1588,1632],"testsRan":["InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result"],"originalLines":"                errors.push(\"Could not find mutate file \\\"\" + mutateFile + \"\\\" in list of files.\");","mutatedLines":"                errors.push('Could not find mutate file \"' - mutateFile + \"\\\" in list of files.\");"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":34,"column":12},"end":{"line":34,"column":29}},"range":[1701,1718],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called \"before each\" hook for \"should result in the expected input files\""],"originalLines":"        if (errors.length > 0) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BinaryOperator","status":1,"replacement":"errors.length >= 0","location":{"start":{"line":34,"column":12},"end":{"line":34,"column":29}},"range":[1701,1718],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called \"before each\" hook for \"should result in the expected input files\""],"originalLines":"        if (errors.length > 0) {","mutatedLines":"        if (errors.length >= 0) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":34,"column":12},"end":{"line":34,"column":29}},"range":[1701,1718],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result"],"originalLines":"        if (errors.length > 0) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BinaryOperator","status":1,"replacement":"errors.length <= 0","location":{"start":{"line":34,"column":12},"end":{"line":34,"column":29}},"range":[1701,1718],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called \"before each\" hook for \"should result in the expected input files\""],"originalLines":"        if (errors.length > 0) {","mutatedLines":"        if (errors.length <= 0) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":37,"column":46},"end":{"line":37,"column":175}},"range":[1828,1957],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files"],"originalLines":"        allInputFiles.forEach(function (file) { return file.mutated = additionalMutateFiles.some(function (mutateFile) { return mutateFile === file.path; }) || file.mutated; });","mutatedLines":"        allInputFiles.forEach(function (file) {\n});"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":34,"column":31},"end":{"line":36,"column":9}},"range":[1720,1780],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result"],"originalLines":"        if (errors.length > 0) {\r\n            throw new Error(errors.join(' '));\r\n        }","mutatedLines":"        if (errors.length > 0) {\n}"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"LogicalOperator","status":1,"replacement":"additionalMutateFiles.some(function (mutateFile) {\n    return mutateFile === file.path;\n}) && file.mutated","location":{"start":{"line":37,"column":70},"end":{"line":37,"column":172}},"range":[1852,1954],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files"],"originalLines":"        allInputFiles.forEach(function (file) { return file.mutated = additionalMutateFiles.some(function (mutateFile) { return mutateFile === file.path; }) || file.mutated; });","mutatedLines":"        allInputFiles.forEach(function (file) { return file.mutated = additionalMutateFiles.some(function (mutateFile) {\n    return mutateFile === file.path;\n}) && file.mutated; });"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":37,"column":119},"end":{"line":37,"column":155}},"range":[1901,1937],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files"],"originalLines":"        allInputFiles.forEach(function (file) { return file.mutated = additionalMutateFiles.some(function (mutateFile) { return mutateFile === file.path; }) || file.mutated; });","mutatedLines":"        allInputFiles.forEach(function (file) { return file.mutated = additionalMutateFiles.some(function (mutateFile) {\n}) || file.mutated; });"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BinaryOperator","status":1,"replacement":"mutateFile !== file.path","location":{"start":{"line":37,"column":128},"end":{"line":37,"column":152}},"range":[1910,1934],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files"],"originalLines":"        allInputFiles.forEach(function (file) { return file.mutated = additionalMutateFiles.some(function (mutateFile) { return mutateFile === file.path; }) || file.mutated; });","mutatedLines":"        allInputFiles.forEach(function (file) { return file.mutated = additionalMutateFiles.some(function (mutateFile) { return mutateFile !== file.path; }) || file.mutated; });"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":39,"column":74},"end":{"line":47,"column":5}},"range":[2043,2421],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated"],"originalLines":"    InputFileResolver.warnAboutNoFilesToMutate = function (allInputFiles) {\r\n        var mutateFiles = allInputFiles.filter(function (file) { return file.mutated; });\r\n        if (mutateFiles.length) {\r\n            log.info(\"Found \" + mutateFiles.length + \" file(s) to be mutated.\");\r\n        }\r\n        else {\r\n            log.warn(\"No files marked to be mutated, stryker will perform a dry-run without actually mutating anything.\");\r\n        }\r\n    };","mutatedLines":"    InputFileResolver.warnAboutNoFilesToMutate = function (allInputFiles) {\n};"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":41,"column":12},"end":{"line":41,"column":30}},"range":[2149,2167],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated"],"originalLines":"        if (mutateFiles.length) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":40,"column":63},"end":{"line":40,"column":87}},"range":[2109,2133],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated"],"originalLines":"        var mutateFiles = allInputFiles.filter(function (file) { return file.mutated; });","mutatedLines":"        var mutateFiles = allInputFiles.filter(function (file) {\n});"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":41,"column":12},"end":{"line":41,"column":30}},"range":[2149,2167],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run"],"originalLines":"        if (mutateFiles.length) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":41,"column":32},"end":{"line":43,"column":9}},"range":[2169,2263],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated"],"originalLines":"        if (mutateFiles.length) {\r\n            log.info(\"Found \" + mutateFiles.length + \" file(s) to be mutated.\");\r\n        }","mutatedLines":"        if (mutateFiles.length) {\n}"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BinaryOperator","status":1,"replacement":"'Found ' + mutateFiles.length - ' file(s) to be mutated.'","location":{"start":{"line":42,"column":21},"end":{"line":42,"column":78}},"range":[2193,2250],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated"],"originalLines":"            log.info(\"Found \" + mutateFiles.length + \" file(s) to be mutated.\");","mutatedLines":"            log.info('Found ' + mutateFiles.length - ' file(s) to be mutated.');"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":44,"column":13},"end":{"line":46,"column":9}},"range":[2278,2414],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run"],"originalLines":"        else {\r\n            log.warn(\"No files marked to be mutated, stryker will perform a dry-run without actually mutating anything.\");\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BinaryOperator","status":1,"replacement":"'Found ' - mutateFiles.length","location":{"start":{"line":42,"column":21},"end":{"line":42,"column":50}},"range":[2193,2222],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated"],"originalLines":"            log.info(\"Found \" + mutateFiles.length + \" file(s) to be mutated.\");","mutatedLines":"            log.info('Found ' - mutateFiles.length + \" file(s) to be mutated.\");"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BinaryOperator","status":1,"replacement":"'Globbing expression \"' - expression","location":{"start":{"line":49,"column":17},"end":{"line":49,"column":54}},"range":[2520,2557],"testsRan":["InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning"],"originalLines":"        log.warn(\"Globbing expression \\\"\" + expression + \"\\\" did not result in any files.\");","mutatedLines":"        log.warn('Globbing expression \"' - expression + \"\\\" did not result in any files.\");"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BinaryOperator","status":1,"replacement":"'Globbing expression \"' + expression - '\" did not result in any files.'","location":{"start":{"line":49,"column":17},"end":{"line":49,"column":90}},"range":[2520,2593],"testsRan":["InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning"],"originalLines":"        log.warn(\"Globbing expression \\\"\" + expression + \"\\\" did not result in any files.\");","mutatedLines":"        log.warn('Globbing expression \"' + expression - '\" did not result in any files.');"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":48,"column":76},"end":{"line":50,"column":5}},"range":[2500,2602],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning"],"originalLines":"    InputFileResolver.reportEmptyGlobbingExpression = function (expression) {\r\n        log.warn(\"Globbing expression \\\"\" + expression + \"\\\" did not result in any files.\");\r\n    };","mutatedLines":"    InputFileResolver.reportEmptyGlobbingExpression = function (expression) {\n};"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":51,"column":82},"end":{"line":63,"column":5}},"range":[2687,3114],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error"],"originalLines":"    InputFileResolver.isInputFileDescriptor = function (maybeInputFileDescriptor) {\r\n        if (_.isObject(maybeInputFileDescriptor)) {\r\n            if (Object.keys(maybeInputFileDescriptor).indexOf('pattern') > -1) {\r\n                return true;\r\n            }\r\n            else {\r\n                throw Error(\"File descriptor \" + JSON.stringify(maybeInputFileDescriptor) + \" is missing mandatory property 'pattern'.\");\r\n            }\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    };","mutatedLines":"    InputFileResolver.isInputFileDescriptor = function (maybeInputFileDescriptor) {\n};"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":52,"column":12},"end":{"line":52,"column":48}},"range":[2702,2738],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files \"before each\" hook for \"should result in the expected input files\""],"originalLines":"        if (_.isObject(maybeInputFileDescriptor)) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":52,"column":12},"end":{"line":52,"column":48}},"range":[2702,2738],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error"],"originalLines":"        if (_.isObject(maybeInputFileDescriptor)) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":53,"column":16},"end":{"line":53,"column":77}},"range":[2759,2820],"testsRan":["InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files \"before each\" hook for \"should result in the expected input files\""],"originalLines":"            if (Object.keys(maybeInputFileDescriptor).indexOf('pattern') > -1) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":52,"column":50},"end":{"line":59,"column":9}},"range":[2740,3053],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error"],"originalLines":"        if (_.isObject(maybeInputFileDescriptor)) {\r\n            if (Object.keys(maybeInputFileDescriptor).indexOf('pattern') > -1) {\r\n                return true;\r\n            }\r\n            else {\r\n                throw Error(\"File descriptor \" + JSON.stringify(maybeInputFileDescriptor) + \" is missing mandatory property 'pattern'.\");\r\n            }\r\n        }","mutatedLines":"        if (_.isObject(maybeInputFileDescriptor)) {\n}"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":53,"column":16},"end":{"line":53,"column":77}},"range":[2759,2820],"testsRan":["InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error"],"originalLines":"            if (Object.keys(maybeInputFileDescriptor).indexOf('pattern') > -1) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BinaryOperator","status":1,"replacement":"Object.keys(maybeInputFileDescriptor).indexOf('pattern') >= -1","location":{"start":{"line":53,"column":16},"end":{"line":53,"column":77}},"range":[2759,2820],"testsRan":["InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error"],"originalLines":"            if (Object.keys(maybeInputFileDescriptor).indexOf('pattern') > -1) {","mutatedLines":"            if (Object.keys(maybeInputFileDescriptor).indexOf('pattern') >= -1) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BinaryOperator","status":1,"replacement":"Object.keys(maybeInputFileDescriptor).indexOf('pattern') <= -1","location":{"start":{"line":53,"column":16},"end":{"line":53,"column":77}},"range":[2759,2820],"testsRan":["InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error"],"originalLines":"            if (Object.keys(maybeInputFileDescriptor).indexOf('pattern') > -1) {","mutatedLines":"            if (Object.keys(maybeInputFileDescriptor).indexOf('pattern') <= -1) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"UnaryOperator","status":1,"replacement":"+1","location":{"start":{"line":53,"column":75},"end":{"line":53,"column":77}},"range":[2818,2820],"testsRan":["InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files \"before each\" hook for \"should result in the expected input files\""],"originalLines":"            if (Object.keys(maybeInputFileDescriptor).indexOf('pattern') > -1) {","mutatedLines":"            if (Object.keys(maybeInputFileDescriptor).indexOf('pattern') > +1) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":53,"column":79},"end":{"line":55,"column":13}},"range":[2822,2868],"testsRan":["InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files \"before each\" hook for \"should result in the expected input files\""],"originalLines":"            if (Object.keys(maybeInputFileDescriptor).indexOf('pattern') > -1) {\r\n                return true;\r\n            }","mutatedLines":"            if (Object.keys(maybeInputFileDescriptor).indexOf('pattern') > -1) {\n}"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":56,"column":17},"end":{"line":58,"column":13}},"range":[2887,3042],"testsRan":["InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error"],"originalLines":"            else {\r\n                throw Error(\"File descriptor \" + JSON.stringify(maybeInputFileDescriptor) + \" is missing mandatory property 'pattern'.\");\r\n            }","mutatedLines":"            else {\n}"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BinaryOperator","status":1,"replacement":"'File descriptor ' + JSON.stringify(maybeInputFileDescriptor) - ' is missing mandatory property \\'pattern\\'.'","location":{"start":{"line":57,"column":28},"end":{"line":57,"column":135}},"range":[2918,3025],"testsRan":["InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error"],"originalLines":"                throw Error(\"File descriptor \" + JSON.stringify(maybeInputFileDescriptor) + \" is missing mandatory property 'pattern'.\");","mutatedLines":"                throw Error('File descriptor ' + JSON.stringify(maybeInputFileDescriptor) - ' is missing mandatory property \\'pattern\\'.');"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BinaryOperator","status":1,"replacement":"'File descriptor ' - JSON.stringify(maybeInputFileDescriptor)","location":{"start":{"line":57,"column":28},"end":{"line":57,"column":89}},"range":[2918,2979],"testsRan":["InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error"],"originalLines":"                throw Error(\"File descriptor \" + JSON.stringify(maybeInputFileDescriptor) + \" is missing mandatory property 'pattern'.\");","mutatedLines":"                throw Error('File descriptor ' - JSON.stringify(maybeInputFileDescriptor) + \" is missing mandatory property 'pattern'.\");"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":64,"column":69},"end":{"line":67,"column":5}},"range":[3186,3356],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called \"before each\" hook for \"should result in the expected input files\""],"originalLines":"    InputFileResolver.prototype.resolveMutateFileGlobs = function () {\r\n        return Promise.all(this.mutateFileExpressions.map(InputFileResolver.resolveFileGlob))\r\n            .then(function (files) { return _.flatten(files); });\r\n    };","mutatedLines":"    InputFileResolver.prototype.resolveMutateFileGlobs = function () {\n};"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":60,"column":13},"end":{"line":62,"column":9}},"range":[3068,3107],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise"],"originalLines":"        else {\r\n            return false;\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":66,"column":35},"end":{"line":66,"column":63}},"range":[3319,3347],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called \"before each\" hook for \"should result in the expected input files\""],"originalLines":"            .then(function (files) { return _.flatten(files); });","mutatedLines":"            .then(function (files) {\n});"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":69,"column":79},"end":{"line":70,"column":165}},"range":[3509,3738],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called \"before each\" hook for \"should result in the expected input files\""],"originalLines":"        return Promise.all(this.inputFileDescriptors.map(function (descriptor) { return InputFileResolver.resolveFileGlob(descriptor.pattern)\r\n            .then(function (sourceFiles) { return sourceFiles.map(function (sourceFile) { return InputFileResolver.createInputFile(sourceFile, descriptor); }); }); })).then(function (promises) { return _.flatten(promises); });","mutatedLines":"        return Promise.all(this.inputFileDescriptors.map(function (descriptor) {\n})).then(function (promises) { return _.flatten(promises); });"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":68,"column":68},"end":{"line":71,"column":5}},"range":[3427,3806],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called \"before each\" hook for \"should result in the expected input files\""],"originalLines":"    InputFileResolver.prototype.resolveInputFileGlobs = function () {\r\n        return Promise.all(this.inputFileDescriptors.map(function (descriptor) { return InputFileResolver.resolveFileGlob(descriptor.pattern)\r\n            .then(function (sourceFiles) { return sourceFiles.map(function (sourceFile) { return InputFileResolver.createInputFile(sourceFile, descriptor); }); }); })).then(function (promises) { return _.flatten(promises); });\r\n    };","mutatedLines":"    InputFileResolver.prototype.resolveInputFileGlobs = function () {\n};"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":70,"column":41},"end":{"line":70,"column":161}},"range":[3614,3734],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called \"before each\" hook for \"should result in the expected input files\""],"originalLines":"            .then(function (sourceFiles) { return sourceFiles.map(function (sourceFile) { return InputFileResolver.createInputFile(sourceFile, descriptor); }); }); })).then(function (promises) { return _.flatten(promises); });","mutatedLines":"            .then(function (sourceFiles) {\n}); })).then(function (promises) { return _.flatten(promises); });"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":70,"column":88},"end":{"line":70,"column":157}},"range":[3661,3730],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called \"before each\" hook for \"should result in the expected input files\""],"originalLines":"            .then(function (sourceFiles) { return sourceFiles.map(function (sourceFile) { return InputFileResolver.createInputFile(sourceFile, descriptor); }); }); })).then(function (promises) { return _.flatten(promises); });","mutatedLines":"            .then(function (sourceFiles) { return sourceFiles.map(function (sourceFile) {\n}); }); })).then(function (promises) { return _.flatten(promises); });"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":70,"column":193},"end":{"line":70,"column":224}},"range":[3766,3797],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called \"before each\" hook for \"should result in the expected input files\""],"originalLines":"            .then(function (sourceFiles) { return sourceFiles.map(function (sourceFile) { return InputFileResolver.createInputFile(sourceFile, descriptor); }); }); })).then(function (promises) { return _.flatten(promises); });","mutatedLines":"            .then(function (sourceFiles) { return sourceFiles.map(function (sourceFile) { return InputFileResolver.createInputFile(sourceFile, descriptor); }); }); })).then(function (promises) {\n});"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":72,"column":68},"end":{"line":76,"column":5}},"range":[3877,4044],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called \"before each\" hook for \"should result in the expected input files\""],"originalLines":"    InputFileResolver.createInputFile = function (path, descriptor) {\r\n        var inputFile = _.assign({ path: path }, DEFAULT_INPUT_FILE_PROPERTIES, descriptor);\r\n        delete inputFile['pattern'];\r\n        return inputFile;\r\n    };","mutatedLines":"    InputFileResolver.createInputFile = function (path, descriptor) {\n};"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":77,"column":62},"end":{"line":86,"column":5}},"range":[4109,4416],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called \"before each\" hook for \"should result in the expected input files\""],"originalLines":"    InputFileResolver.resolveFileGlob = function (expression) {\r\n        var _this = this;\r\n        return fileUtils_1.glob(expression).then(function (files) {\r\n            if (files.length === 0) {\r\n                _this.reportEmptyGlobbingExpression(expression);\r\n            }\r\n            fileUtils_1.normalize(files);\r\n            return files;\r\n        });\r\n    };","mutatedLines":"    InputFileResolver.resolveFileGlob = function (expression) {\n};"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":79,"column":66},"end":{"line":85,"column":9}},"range":[4205,4407],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called \"before each\" hook for \"should result in the expected input files\""],"originalLines":"        return fileUtils_1.glob(expression).then(function (files) {\r\n            if (files.length === 0) {\r\n                _this.reportEmptyGlobbingExpression(expression);\r\n            }\r\n            fileUtils_1.normalize(files);\r\n            return files;\r\n        });","mutatedLines":"        return fileUtils_1.glob(expression).then(function (files) {\n});"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"LogicalOperator","status":1,"replacement":"this && this.__extends && function (d, b) {\n    for (var p in b)\n        if (b.hasOwnProperty(p))\n            d[p] = b[p];\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}","location":{"start":{"line":2,"column":16},"end":{"line":6,"column":1}},"range":[31,275],"testsRan":[],"originalLines":"var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};","mutatedLines":"var __extends = this && this.__extends && function (d, b) {\n    for (var p in b)\n        if (b.hasOwnProperty(p))\n            d[p] = b[p];\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"LogicalOperator","status":1,"replacement":"this || this.__extends","location":{"start":{"line":2,"column":17},"end":{"line":2,"column":39}},"range":[32,54],"testsRan":[],"originalLines":"var __extends = (this && this.__extends) || function (d, b) {","mutatedLines":"var __extends = (this || this.__extends) || function (d, b) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":80,"column":16},"end":{"line":80,"column":34}},"range":[4224,4242],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning"],"originalLines":"            if (files.length === 0) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BinaryOperator","status":1,"replacement":"files.length !== 0","location":{"start":{"line":80,"column":16},"end":{"line":80,"column":34}},"range":[4224,4242],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called \"before each\" hook for \"should result in the expected input files\""],"originalLines":"            if (files.length === 0) {","mutatedLines":"            if (files.length !== 0) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":80,"column":16},"end":{"line":80,"column":34}},"range":[4224,4242],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called \"before each\" hook for \"should result in the expected input files\""],"originalLines":"            if (files.length === 0) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/InputFileResolver.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":80,"column":36},"end":{"line":82,"column":13}},"range":[4244,4326],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning"],"originalLines":"            if (files.length === 0) {\r\n                _this.reportEmptyGlobbingExpression(expression);\r\n            }","mutatedLines":"            if (files.length === 0) {\n}"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenterStream.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":25,"column":91},"end":{"line":33,"column":5}},"range":[1136,1326],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams \"before each\" hook for \"should retrieve 2 statement maps\""],"originalLines":"    CoverageInstrumenterStream.prototype._transform = function (chunk, encoding, callback) {\r\n        if (typeof chunk === 'string') {\r\n            this.source += chunk;\r\n        }\r\n        else {\r\n            this.source += chunk.toString();\r\n        }\r\n        callback();\r\n    };","mutatedLines":"    CoverageInstrumenterStream.prototype._transform = function (chunk, encoding, callback) {\n};"},{"sourceFilePath":"/stryker/src/coverage/CoverageInstrumenterStream.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":34,"column":70},"end":{"line":50,"column":5}},"range":[1399,2171],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams \"before each\" hook for \"should retrieve 2 statement maps\""],"originalLines":"    CoverageInstrumenterStream.prototype._flush = function (callback) {\r\n        try {\r\n            var instrumenter = new istanbul_1.Instrumenter({ coverageVariable: this.coverageVariable });\r\n            var instrumentedCode = instrumenter.instrumentSync(this.source, this.filename);\r\n            coverageObjRegex.lastIndex = 0;\r\n            var coverageObjectMatch = coverageObjRegex.exec(instrumentedCode).toString();\r\n            var coverageObj = JSON.parse(coverageObjectMatch);\r\n            this.statementMap = coverageObj.statementMap;\r\n            this.push(instrumentedCode);\r\n        }\r\n        catch (err) {\r\n            var error = \"Error while instrumenting file \\\"\" + this.filename + \"\\\", error was: \" + err.toString();\r\n            log.error(error);\r\n            this.push(this.source);\r\n        }\r\n        callback();\r\n    };","mutatedLines":"    CoverageInstrumenterStream.prototype._flush = function (callback) {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":19,"column":55},"end":{"line":155,"column":1}},"range":[878,6785],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed \"before each\" hook for \"should spawn a child process\""],"originalLines":"var TestRunnerChildProcessAdapter = (function (_super) {\r\n    __extends(TestRunnerChildProcessAdapter, _super);\r\n    function TestRunnerChildProcessAdapter(realTestRunnerName, options) {\r\n        _super.call(this);\r\n        this.realTestRunnerName = realTestRunnerName;\r\n        this.options = options;\r\n        this.startWorker();\r\n    }\r\n    TestRunnerChildProcessAdapter.prototype.startWorker = function () {\r\n        // Remove --debug-brk from process arguments. \r\n        // When debugging, it will try to reuse the same debug port, which will be taken by the main process.\r\n        var execArgv = _.clone(process.execArgv);\r\n        _.remove(execArgv, function (arg) { return arg.substr(0, 11) === '--debug-brk'; });\r\n        this.workerProcess = child_process_1.fork(__dirname + \"/IsolatedTestRunnerAdapterWorker\", [], { silent: true, execArgv: execArgv });\r\n        this.sendStartCommand();\r\n        this.listenToWorkerProcess();\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.listenToWorkerProcess = function () {\r\n        var _this = this;\r\n        if (this.workerProcess.stdout) {\r\n            var traceEnabled_1 = log.isTraceEnabled();\r\n            this.workerProcess.stdout.on('data', function (data) {\r\n                if (traceEnabled_1) {\r\n                    log.trace(data.toString());\r\n                }\r\n            });\r\n        }\r\n        if (this.workerProcess.stderr) {\r\n            this.workerProcess.stderr.on('data', function (data) {\r\n                log.error(data.toString());\r\n            });\r\n        }\r\n        this.workerProcess.on('message', function (message) {\r\n            _this.clearCurrentTimer();\r\n            switch (message.kind) {\r\n                case 'result':\r\n                    if (!_this.isDisposing) {\r\n                        _this.runPromiseFulfillmentCallback(message.result);\r\n                    }\r\n                    break;\r\n                case 'initDone':\r\n                    _this.initPromiseFulfillmentCallback();\r\n                    break;\r\n                case 'disposeDone':\r\n                    _this.disposePromiseFulfillmentCallback();\r\n                    break;\r\n                default:\r\n                    _this.logReceivedMessageWarning(message);\r\n                    break;\r\n            }\r\n        });\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.logReceivedMessageWarning = function (message) {\r\n        log.error(\"Retrieved unrecognized message from child process: \" + JSON.stringify(message));\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.init = function () {\r\n        var _this = this;\r\n        this.initPromise = new Promise(function (resolve) { return _this.initPromiseFulfillmentCallback = resolve; });\r\n        this.sendInitCommand();\r\n        return this.initPromise;\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.run = function (options) {\r\n        var _this = this;\r\n        this.clearCurrentTimer();\r\n        if (options.timeout) {\r\n            this.markNoResultTimeout(options.timeout);\r\n        }\r\n        this.runPromise = new Promise(function (resolve) {\r\n            _this.runPromiseFulfillmentCallback = resolve;\r\n            _this.sendRunCommand(options);\r\n            _this.currentRunStartedTimestamp = new Date();\r\n        });\r\n        return this.runPromise;\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.dispose = function () {\r\n        var _this = this;\r\n        if (this.isDisposing) {\r\n            return this.disposingPromise;\r\n        }\r\n        else {\r\n            this.isDisposing = true;\r\n            this.disposingPromise = new Promise(function (resolve) { return _this.disposePromiseFulfillmentCallback = resolve; })\r\n                .then(function () {\r\n                clearTimeout(timer_1);\r\n                _this.workerProcess.kill();\r\n                _this.isDisposing = false;\r\n            });\r\n            this.clearCurrentTimer();\r\n            this.sendDisposeCommand();\r\n            var timer_1 = setTimeout(this.disposePromiseFulfillmentCallback, MAX_WAIT_FOR_DISPOSE);\r\n            return this.disposingPromise;\r\n        }\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.sendRunCommand = function (options) {\r\n        this.send({\r\n            kind: 'run',\r\n            runOptions: options\r\n        });\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.send = function (message) {\r\n        // Serialize message before sending to preserve all javascript, including regexes and functions\r\n        // See https://github.com/stryker-mutator/stryker/issues/143\r\n        this.workerProcess.send(objectUtils_1.serialize(message));\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.sendStartCommand = function () {\r\n        this.send({\r\n            kind: 'start',\r\n            runnerName: this.realTestRunnerName,\r\n            runnerOptions: this.options\r\n        });\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.sendInitCommand = function () {\r\n        this.send({ kind: 'init' });\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.sendDisposeCommand = function () {\r\n        this.send({ kind: 'dispose' });\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.clearCurrentTimer = function () {\r\n        if (this.currentTimeoutTimer) {\r\n            clearTimeout(this.currentTimeoutTimer);\r\n        }\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.markNoResultTimeout = function (timeoutMs) {\r\n        var _this = this;\r\n        this.currentTimeoutTimer = setTimeout(function () {\r\n            _this.handleTimeout();\r\n        }, timeoutMs);\r\n    };\r\n    TestRunnerChildProcessAdapter.prototype.handleTimeout = function () {\r\n        var _this = this;\r\n        this.dispose()\r\n            .then(function () { return _this.startWorker(); })\r\n            .then(function () { return _this.init(); })\r\n            .then(function () { return _this.runPromiseFulfillmentCallback({ status: test_runner_1.RunStatus.Timeout, tests: [] }); });\r\n    };\r\n    return TestRunnerChildProcessAdapter;\r\n}(events_1.EventEmitter));","mutatedLines":"var TestRunnerChildProcessAdapter = (function (_super) {\n}(events_1.EventEmitter));"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":21,"column":72},"end":{"line":26,"column":5}},"range":[1008,1161],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process"],"originalLines":"    function TestRunnerChildProcessAdapter(realTestRunnerName, options) {\r\n        _super.call(this);\r\n        this.realTestRunnerName = realTestRunnerName;\r\n        this.options = options;\r\n        this.startWorker();\r\n    }","mutatedLines":"    function TestRunnerChildProcessAdapter(realTestRunnerName, options) {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"RemoveConditionals","status":2,"replacement":"false","location":{"start":{"line":3,"column":25},"end":{"line":3,"column":44}},"range":[103,122],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];","mutatedLines":"    for (var p in b) if (false) d[p] = b[p];"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":2,"column":60},"end":{"line":6,"column":1}},"range":[75,275],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};","mutatedLines":"var __extends = (this && this.__extends) || function (d, b) {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"RemoveConditionals","status":2,"replacement":"false","location":{"start":{"line":5,"column":18},"end":{"line":5,"column":28}},"range":[201,211],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());","mutatedLines":"    d.prototype = false ? Object.create(b) : (__.prototype = b.prototype, new __());"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":3,"column":25},"end":{"line":3,"column":44}},"range":[103,122],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];","mutatedLines":"    for (var p in b) if (true) d[p] = b[p];"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":4,"column":18},"end":{"line":4,"column":43}},"range":[156,181],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    function __() { this.constructor = d; }","mutatedLines":"    function __() {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":27,"column":70},"end":{"line":35,"column":5}},"range":[1233,1767],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process"],"originalLines":"    TestRunnerChildProcessAdapter.prototype.startWorker = function () {\r\n        // Remove --debug-brk from process arguments. \r\n        // When debugging, it will try to reuse the same debug port, which will be taken by the main process.\r\n        var execArgv = _.clone(process.execArgv);\r\n        _.remove(execArgv, function (arg) { return arg.substr(0, 11) === '--debug-brk'; });\r\n        this.workerProcess = child_process_1.fork(__dirname + \"/IsolatedTestRunnerAdapterWorker\", [], { silent: true, execArgv: execArgv });\r\n        this.sendStartCommand();\r\n        this.listenToWorkerProcess();\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapter.prototype.startWorker = function () {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":5,"column":18},"end":{"line":5,"column":28}},"range":[201,211],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());","mutatedLines":"    d.prototype = true ? Object.create(b) : (__.prototype = b.prototype, new __());"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":31,"column":42},"end":{"line":31,"column":89}},"range":[1496,1543],"testsRan":["IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout"],"originalLines":"        _.remove(execArgv, function (arg) { return arg.substr(0, 11) === '--debug-brk'; });","mutatedLines":"        _.remove(execArgv, function (arg) {\n});"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":40,"column":65},"end":{"line":44,"column":13}},"range":[2043,2166],"testsRan":[],"originalLines":"            this.workerProcess.stdout.on('data', function (data) {\r\n                if (traceEnabled_1) {\r\n                    log.trace(data.toString());\r\n                }\r\n            });","mutatedLines":"            this.workerProcess.stdout.on('data', function (data) {\n});"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"RemoveConditionals","status":0,"replacement":"false","location":{"start":{"line":41,"column":20},"end":{"line":41,"column":34}},"range":[2066,2080],"testsRan":[],"originalLines":"                if (traceEnabled_1) {","mutatedLines":"                if (false) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"RemoveConditionals","status":0,"replacement":"true","location":{"start":{"line":41,"column":20},"end":{"line":41,"column":34}},"range":[2066,2080],"testsRan":[],"originalLines":"                if (traceEnabled_1) {","mutatedLines":"                if (true) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":41,"column":36},"end":{"line":43,"column":17}},"range":[2082,2151],"testsRan":[],"originalLines":"                if (traceEnabled_1) {\r\n                    log.trace(data.toString());\r\n                }","mutatedLines":"                if (traceEnabled_1) {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BinaryOperator","status":1,"replacement":"arg.substr(0, 11) !== '--debug-brk'","location":{"start":{"line":31,"column":51},"end":{"line":31,"column":86}},"range":[1505,1540],"testsRan":["IsolatedTestRunnerAdapter when constructed should spawn a child process"],"originalLines":"        _.remove(execArgv, function (arg) { return arg.substr(0, 11) === '--debug-brk'; });","mutatedLines":"        _.remove(execArgv, function (arg) { return arg.substr(0, 11) !== '--debug-brk'; });"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BinaryOperator","status":1,"replacement":"__dirname - '/IsolatedTestRunnerAdapterWorker'","location":{"start":{"line":32,"column":50},"end":{"line":32,"column":96}},"range":[1597,1643],"testsRan":["IsolatedTestRunnerAdapter when constructed should spawn a child process"],"originalLines":"        this.workerProcess = child_process_1.fork(__dirname + \"/IsolatedTestRunnerAdapterWorker\", [], { silent: true, execArgv: execArgv });","mutatedLines":"        this.workerProcess = child_process_1.fork(__dirname - '/IsolatedTestRunnerAdapterWorker', [], { silent: true, execArgv: execArgv });"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":36,"column":80},"end":{"line":70,"column":5}},"range":[1850,3114],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process"],"originalLines":"    TestRunnerChildProcessAdapter.prototype.listenToWorkerProcess = function () {\r\n        var _this = this;\r\n        if (this.workerProcess.stdout) {\r\n            var traceEnabled_1 = log.isTraceEnabled();\r\n            this.workerProcess.stdout.on('data', function (data) {\r\n                if (traceEnabled_1) {\r\n                    log.trace(data.toString());\r\n                }\r\n            });\r\n        }\r\n        if (this.workerProcess.stderr) {\r\n            this.workerProcess.stderr.on('data', function (data) {\r\n                log.error(data.toString());\r\n            });\r\n        }\r\n        this.workerProcess.on('message', function (message) {\r\n            _this.clearCurrentTimer();\r\n            switch (message.kind) {\r\n                case 'result':\r\n                    if (!_this.isDisposing) {\r\n                        _this.runPromiseFulfillmentCallback(message.result);\r\n                    }\r\n                    break;\r\n                case 'initDone':\r\n                    _this.initPromiseFulfillmentCallback();\r\n                    break;\r\n                case 'disposeDone':\r\n                    _this.disposePromiseFulfillmentCallback();\r\n                    break;\r\n                default:\r\n                    _this.logReceivedMessageWarning(message);\r\n                    break;\r\n            }\r\n        });\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapter.prototype.listenToWorkerProcess = function () {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":47,"column":65},"end":{"line":49,"column":13}},"range":[2288,2349],"testsRan":[],"originalLines":"            this.workerProcess.stderr.on('data', function (data) {\r\n                log.error(data.toString());\r\n            });","mutatedLines":"            this.workerProcess.stderr.on('data', function (data) {\n});"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"RemoveConditionals","status":2,"replacement":"false","location":{"start":{"line":38,"column":12},"end":{"line":38,"column":37}},"range":[1892,1917],"testsRan":["IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout"],"originalLines":"        if (this.workerProcess.stdout) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":38,"column":12},"end":{"line":38,"column":37}},"range":[1892,1917],"testsRan":["IsolatedTestRunnerAdapter when constructed \"before each\" hook for \"should spawn a child process\""],"originalLines":"        if (this.workerProcess.stdout) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":38,"column":39},"end":{"line":45,"column":9}},"range":[1919,2179],"testsRan":["IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout"],"originalLines":"        if (this.workerProcess.stdout) {\r\n            var traceEnabled_1 = log.isTraceEnabled();\r\n            this.workerProcess.stdout.on('data', function (data) {\r\n                if (traceEnabled_1) {\r\n                    log.trace(data.toString());\r\n                }\r\n            });\r\n        }","mutatedLines":"        if (this.workerProcess.stdout) {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":46,"column":12},"end":{"line":46,"column":37}},"range":[2193,2218],"testsRan":["IsolatedTestRunnerAdapter when constructed \"before each\" hook for \"should spawn a child process\""],"originalLines":"        if (this.workerProcess.stderr) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"RemoveConditionals","status":2,"replacement":"false","location":{"start":{"line":46,"column":12},"end":{"line":46,"column":37}},"range":[2193,2218],"testsRan":["IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout"],"originalLines":"        if (this.workerProcess.stderr) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BinaryOperator","status":0,"replacement":"'Retrieved unrecognized message from child process: ' - JSON.stringify(message)","location":{"start":{"line":72,"column":18},"end":{"line":72,"column":97}},"range":[3229,3308],"testsRan":[],"originalLines":"        log.error(\"Retrieved unrecognized message from child process: \" + JSON.stringify(message));","mutatedLines":"        log.error('Retrieved unrecognized message from child process: ' - JSON.stringify(message));"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":46,"column":39},"end":{"line":50,"column":9}},"range":[2220,2362],"testsRan":["IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout"],"originalLines":"        if (this.workerProcess.stderr) {\r\n            this.workerProcess.stderr.on('data', function (data) {\r\n                log.error(data.toString());\r\n            });\r\n        }","mutatedLines":"        if (this.workerProcess.stderr) {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":55,"column":24},"end":{"line":55,"column":42}},"range":[2560,2578],"testsRan":["IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout"],"originalLines":"                    if (!_this.isDisposing) {","mutatedLines":"                    if (true) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":76,"column":58},"end":{"line":76,"column":116}},"range":[3471,3529],"testsRan":["IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init \"before each\" hook for \"should result in a `timeout` after the restart\""],"originalLines":"        this.initPromise = new Promise(function (resolve) { return _this.initPromiseFulfillmentCallback = resolve; });","mutatedLines":"        this.initPromise = new Promise(function (resolve) {\n});"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BinaryOperator","status":2,"replacement":"b !== null","location":{"start":{"line":5,"column":18},"end":{"line":5,"column":28}},"range":[201,211],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());","mutatedLines":"    d.prototype = b !== null ? Object.create(b) : (__.prototype = b.prototype, new __());"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":74,"column":63},"end":{"line":79,"column":5}},"range":[3383,3605],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init \"before each\" hook for \"should result in a `timeout` after the restart\""],"originalLines":"    TestRunnerChildProcessAdapter.prototype.init = function () {\r\n        var _this = this;\r\n        this.initPromise = new Promise(function (resolve) { return _this.initPromiseFulfillmentCallback = resolve; });\r\n        this.sendInitCommand();\r\n        return this.initPromise;\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapter.prototype.init = function () {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":80,"column":69},"end":{"line":92,"column":5}},"range":[3677,4116],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker"],"originalLines":"    TestRunnerChildProcessAdapter.prototype.run = function (options) {\r\n        var _this = this;\r\n        this.clearCurrentTimer();\r\n        if (options.timeout) {\r\n            this.markNoResultTimeout(options.timeout);\r\n        }\r\n        this.runPromise = new Promise(function (resolve) {\r\n            _this.runPromiseFulfillmentCallback = resolve;\r\n            _this.sendRunCommand(options);\r\n            _this.currentRunStartedTimestamp = new Date();\r\n        });\r\n        return this.runPromise;\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapter.prototype.run = function (options) {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":83,"column":12},"end":{"line":83,"column":27}},"range":[3754,3769],"testsRan":["IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process"],"originalLines":"        if (options.timeout) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":83,"column":12},"end":{"line":83,"column":27}},"range":[3754,3769],"testsRan":["IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout"],"originalLines":"        if (options.timeout) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":83,"column":29},"end":{"line":85,"column":9}},"range":[3771,3839],"testsRan":["IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process"],"originalLines":"        if (options.timeout) {\r\n            this.markNoResultTimeout(options.timeout);\r\n        }","mutatedLines":"        if (options.timeout) {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":86,"column":57},"end":{"line":90,"column":9}},"range":[3898,4074],"testsRan":["IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker"],"originalLines":"        this.runPromise = new Promise(function (resolve) {\r\n            _this.runPromiseFulfillmentCallback = resolve;\r\n            _this.sendRunCommand(options);\r\n            _this.currentRunStartedTimestamp = new Date();\r\n        });","mutatedLines":"        this.runPromise = new Promise(function (resolve) {\n});"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":95,"column":12},"end":{"line":95,"column":28}},"range":[4227,4243],"testsRan":["IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred \"before each\" hook for \"should send `dispose` to worker process\""],"originalLines":"        if (this.isDisposing) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":93,"column":66},"end":{"line":111,"column":5}},"range":[4185,4909],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred \"before each\" hook for \"should send `dispose` to worker process\""],"originalLines":"    TestRunnerChildProcessAdapter.prototype.dispose = function () {\r\n        var _this = this;\r\n        if (this.isDisposing) {\r\n            return this.disposingPromise;\r\n        }\r\n        else {\r\n            this.isDisposing = true;\r\n            this.disposingPromise = new Promise(function (resolve) { return _this.disposePromiseFulfillmentCallback = resolve; })\r\n                .then(function () {\r\n                clearTimeout(timer_1);\r\n                _this.workerProcess.kill();\r\n                _this.isDisposing = false;\r\n            });\r\n            this.clearCurrentTimer();\r\n            this.sendDisposeCommand();\r\n            var timer_1 = setTimeout(this.disposePromiseFulfillmentCallback, MAX_WAIT_FOR_DISPOSE);\r\n            return this.disposingPromise;\r\n        }\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapter.prototype.dispose = function () {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":95,"column":30},"end":{"line":97,"column":9}},"range":[4245,4300],"testsRan":["IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one"],"originalLines":"        if (this.isDisposing) {\r\n            return this.disposingPromise;\r\n        }","mutatedLines":"        if (this.isDisposing) {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":98,"column":13},"end":{"line":110,"column":9}},"range":[4315,4902],"testsRan":["IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred \"before each\" hook for \"should send `dispose` to worker process\""],"originalLines":"        else {\r\n            this.isDisposing = true;\r\n            this.disposingPromise = new Promise(function (resolve) { return _this.disposePromiseFulfillmentCallback = resolve; })\r\n                .then(function () {\r\n                clearTimeout(timer_1);\r\n                _this.workerProcess.kill();\r\n                _this.isDisposing = false;\r\n            });\r\n            this.clearCurrentTimer();\r\n            this.sendDisposeCommand();\r\n            var timer_1 = setTimeout(this.disposePromiseFulfillmentCallback, MAX_WAIT_FOR_DISPOSE);\r\n            return this.disposingPromise;\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":100,"column":67},"end":{"line":100,"column":128}},"range":[4423,4484],"testsRan":["IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred \"before each\" hook for \"should send `dispose` to worker process\""],"originalLines":"            this.disposingPromise = new Promise(function (resolve) { return _this.disposePromiseFulfillmentCallback = resolve; })","mutatedLines":"            this.disposingPromise = new Promise(function (resolve) {\n})"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":101,"column":34},"end":{"line":105,"column":13}},"range":[4521,4666],"testsRan":["IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one"],"originalLines":"                .then(function () {\r\n                clearTimeout(timer_1);\r\n                _this.workerProcess.kill();\r\n                _this.isDisposing = false;\r\n            });","mutatedLines":"                .then(function () {\n});"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":112,"column":80},"end":{"line":117,"column":5}},"range":[4992,5093],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker"],"originalLines":"    TestRunnerChildProcessAdapter.prototype.sendRunCommand = function (options) {\r\n        this.send({\r\n            kind: 'run',\r\n            runOptions: options\r\n        });\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapter.prototype.sendRunCommand = function (options) {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":118,"column":70},"end":{"line":122,"column":5}},"range":[5166,5417],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker"],"originalLines":"    TestRunnerChildProcessAdapter.prototype.send = function (message) {\r\n        // Serialize message before sending to preserve all javascript, including regexes and functions\r\n        // See https://github.com/stryker-mutator/stryker/issues/143\r\n        this.workerProcess.send(objectUtils_1.serialize(message));\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapter.prototype.send = function (message) {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":133,"column":77},"end":{"line":135,"column":5}},"range":[5859,5908],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process"],"originalLines":"    TestRunnerChildProcessAdapter.prototype.sendDisposeCommand = function () {\r\n        this.send({ kind: 'dispose' });\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapter.prototype.sendDisposeCommand = function () {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":71,"column":91},"end":{"line":73,"column":5}},"range":[3208,3317],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    TestRunnerChildProcessAdapter.prototype.logReceivedMessageWarning = function (message) {\r\n        log.error(\"Retrieved unrecognized message from child process: \" + JSON.stringify(message));\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapter.prototype.logReceivedMessageWarning = function (message) {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":123,"column":75},"end":{"line":129,"column":5}},"range":[5495,5656],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    TestRunnerChildProcessAdapter.prototype.sendStartCommand = function () {\r\n        this.send({\r\n            kind: 'start',\r\n            runnerName: this.realTestRunnerName,\r\n            runnerOptions: this.options\r\n        });\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapter.prototype.sendStartCommand = function () {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":130,"column":74},"end":{"line":132,"column":5}},"range":[5733,5779],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    TestRunnerChildProcessAdapter.prototype.sendInitCommand = function () {\r\n        this.send({ kind: 'init' });\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapter.prototype.sendInitCommand = function () {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":137,"column":12},"end":{"line":137,"column":36}},"range":[6002,6026],"testsRan":["IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout"],"originalLines":"        if (this.currentTimeoutTimer) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":141,"column":87},"end":{"line":146,"column":5}},"range":[6190,6346],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process"],"originalLines":"    TestRunnerChildProcessAdapter.prototype.markNoResultTimeout = function (timeoutMs) {\r\n        var _this = this;\r\n        this.currentTimeoutTimer = setTimeout(function () {\r\n            _this.handleTimeout();\r\n        }, timeoutMs);\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapter.prototype.markNoResultTimeout = function (timeoutMs) {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":143,"column":58},"end":{"line":145,"column":9}},"range":[6278,6326],"testsRan":["IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process"],"originalLines":"        this.currentTimeoutTimer = setTimeout(function () {\r\n            _this.handleTimeout();\r\n        }, timeoutMs);","mutatedLines":"        this.currentTimeoutTimer = setTimeout(function () {\n}, timeoutMs);"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":147,"column":72},"end":{"line":153,"column":5}},"range":[6421,6738],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process"],"originalLines":"    TestRunnerChildProcessAdapter.prototype.handleTimeout = function () {\r\n        var _this = this;\r\n        this.dispose()\r\n            .then(function () { return _this.startWorker(); })\r\n            .then(function () { return _this.init(); })\r\n            .then(function () { return _this.runPromiseFulfillmentCallback({ status: test_runner_1.RunStatus.Timeout, tests: [] }); });\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapter.prototype.handleTimeout = function () {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":150,"column":30},"end":{"line":150,"column":61}},"range":[6505,6536],"testsRan":["IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one"],"originalLines":"            .then(function () { return _this.startWorker(); })","mutatedLines":"            .then(function () {\n})"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":151,"column":30},"end":{"line":151,"column":54}},"range":[6569,6593],"testsRan":["IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init \"before each\" hook for \"should result in a `timeout` after the restart\""],"originalLines":"            .then(function () { return _this.init(); })","mutatedLines":"            .then(function () {\n})"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":51,"column":60},"end":{"line":69,"column":9}},"range":[2424,3105],"testsRan":["IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose \"before each\" hook for \"should kill the child process and start a new one\""],"originalLines":"        this.workerProcess.on('message', function (message) {\r\n            _this.clearCurrentTimer();\r\n            switch (message.kind) {\r\n                case 'result':\r\n                    if (!_this.isDisposing) {\r\n                        _this.runPromiseFulfillmentCallback(message.result);\r\n                    }\r\n                    break;\r\n                case 'initDone':\r\n                    _this.initPromiseFulfillmentCallback();\r\n                    break;\r\n                case 'disposeDone':\r\n                    _this.disposePromiseFulfillmentCallback();\r\n                    break;\r\n                default:\r\n                    _this.logReceivedMessageWarning(message);\r\n                    break;\r\n            }\r\n        });","mutatedLines":"        this.workerProcess.on('message', function (message) {\n});"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":55,"column":24},"end":{"line":55,"column":42}},"range":[2560,2578],"testsRan":["IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result"],"originalLines":"                    if (!_this.isDisposing) {","mutatedLines":"                    if (false) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":7,"column":51},"end":{"line":120,"column":1}},"range":[324,4923],"testsRan":[],"originalLines":"var IsolatedTestRunnerAdapterWorker = (function () {\r\n    function IsolatedTestRunnerAdapterWorker() {\r\n        this.listenToMessages();\r\n    }\r\n    IsolatedTestRunnerAdapterWorker.prototype.listenToMessages = function () {\r\n        var _this = this;\r\n        process.on('message', function (serializedMessage) {\r\n            var message = objectUtils_1.deserialize(serializedMessage);\r\n            switch (message.kind) {\r\n                case 'start':\r\n                    _this.start(message);\r\n                    break;\r\n                case 'run':\r\n                    _this.run(message);\r\n                    break;\r\n                case 'init':\r\n                    _this.init();\r\n                    break;\r\n                case 'dispose':\r\n                    _this.dispose();\r\n                    break;\r\n                default:\r\n                    _this.logReceivedMessageWarning(message);\r\n            }\r\n        });\r\n    };\r\n    IsolatedTestRunnerAdapterWorker.prototype.logReceivedMessageWarning = function (message) {\r\n        log.warn('Received unsupported message: {}', JSON.stringify(message));\r\n    };\r\n    IsolatedTestRunnerAdapterWorker.prototype.start = function (message) {\r\n        this.loadPlugins(message.runnerOptions.strykerOptions.plugins);\r\n        this.underlyingTestRunner = test_runner_1.TestRunnerFactory.instance().create(message.runnerName, message.runnerOptions);\r\n    };\r\n    IsolatedTestRunnerAdapterWorker.prototype.init = function () {\r\n        var initPromise = void 0;\r\n        if (this.underlyingTestRunner.init) {\r\n            initPromise = this.underlyingTestRunner.init();\r\n        }\r\n        if (objectUtils_1.isPromise(initPromise)) {\r\n            initPromise.then(this.sendInitDone);\r\n        }\r\n        else {\r\n            this.sendInitDone();\r\n        }\r\n    };\r\n    IsolatedTestRunnerAdapterWorker.prototype.sendInitDone = function () {\r\n        var message = { kind: 'initDone' };\r\n        process.send(message);\r\n    };\r\n    IsolatedTestRunnerAdapterWorker.prototype.dispose = function () {\r\n        var disposePromise = void 0;\r\n        if (this.underlyingTestRunner.dispose) {\r\n            disposePromise = this.underlyingTestRunner.dispose();\r\n        }\r\n        if (objectUtils_1.isPromise(disposePromise)) {\r\n            disposePromise.then(this.sendDisposeDone);\r\n        }\r\n        else {\r\n            this.sendDisposeDone();\r\n        }\r\n    };\r\n    IsolatedTestRunnerAdapterWorker.prototype.sendDisposeDone = function () {\r\n        this.send({ kind: 'disposeDone' });\r\n    };\r\n    IsolatedTestRunnerAdapterWorker.prototype.run = function (body) {\r\n        var _this = this;\r\n        this.underlyingTestRunner.run(body.runOptions).then(function (res) { return _this.reportResult(res); }, function (error) { return _this.reportErrorResult(error); });\r\n    };\r\n    IsolatedTestRunnerAdapterWorker.prototype.send = function (message) {\r\n        process.send(message);\r\n    };\r\n    IsolatedTestRunnerAdapterWorker.prototype.loadPlugins = function (plugins) {\r\n        new PluginLoader_1.default(plugins).load();\r\n    };\r\n    IsolatedTestRunnerAdapterWorker.prototype.reportResult = function (result) {\r\n        // If the test runner didn't report on coverage, let's try to do it ourselves.\r\n        if (!result.coverage) {\r\n            result.coverage = (Function('return this'))().__coverage__;\r\n        }\r\n        if (result.errorMessages) {\r\n            // errorMessages should be a string[]\r\n            // Just in case the test runner implementer forgot to convert `Error`s to string, we will do it here\r\n            // https://github.com/stryker-mutator/stryker/issues/141\r\n            result.errorMessages = result.errorMessages.map(function (error) {\r\n                if (error instanceof Error) {\r\n                    return error.name + \": \" + error.message + \"\\n\" + error.stack.toString();\r\n                }\r\n                else {\r\n                    return error.toString();\r\n                }\r\n            });\r\n        }\r\n        this.send({\r\n            kind: 'result',\r\n            result: result\r\n        });\r\n    };\r\n    IsolatedTestRunnerAdapterWorker.prototype.reportErrorResult = function (error) {\r\n        var runResult = {\r\n            tests: [],\r\n            status: test_runner_1.RunStatus.Error,\r\n        };\r\n        if (error) {\r\n            if (Array.isArray(error)) {\r\n                runResult.errorMessages = error.map(function (e) { return e; });\r\n            }\r\n            else {\r\n                runResult.errorMessages = [error];\r\n            }\r\n        }\r\n        this.reportResult(runResult);\r\n    };\r\n    return IsolatedTestRunnerAdapterWorker;\r\n}());","mutatedLines":"var IsolatedTestRunnerAdapterWorker = (function () {\n}());"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":8,"column":47},"end":{"line":10,"column":5}},"range":[374,416],"testsRan":[],"originalLines":"    function IsolatedTestRunnerAdapterWorker() {\r\n        this.listenToMessages();\r\n    }","mutatedLines":"    function IsolatedTestRunnerAdapterWorker() {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":11,"column":77},"end":{"line":32,"column":5}},"range":[495,1211],"testsRan":[],"originalLines":"    IsolatedTestRunnerAdapterWorker.prototype.listenToMessages = function () {\r\n        var _this = this;\r\n        process.on('message', function (serializedMessage) {\r\n            var message = objectUtils_1.deserialize(serializedMessage);\r\n            switch (message.kind) {\r\n                case 'start':\r\n                    _this.start(message);\r\n                    break;\r\n                case 'run':\r\n                    _this.run(message);\r\n                    break;\r\n                case 'init':\r\n                    _this.init();\r\n                    break;\r\n                case 'dispose':\r\n                    _this.dispose();\r\n                    break;\r\n                default:\r\n                    _this.logReceivedMessageWarning(message);\r\n            }\r\n        });\r\n    };","mutatedLines":"    IsolatedTestRunnerAdapterWorker.prototype.listenToMessages = function () {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":13,"column":59},"end":{"line":31,"column":9}},"range":[584,1202],"testsRan":[],"originalLines":"        process.on('message', function (serializedMessage) {\r\n            var message = objectUtils_1.deserialize(serializedMessage);\r\n            switch (message.kind) {\r\n                case 'start':\r\n                    _this.start(message);\r\n                    break;\r\n                case 'run':\r\n                    _this.run(message);\r\n                    break;\r\n                case 'init':\r\n                    _this.init();\r\n                    break;\r\n                case 'dispose':\r\n                    _this.dispose();\r\n                    break;\r\n                default:\r\n                    _this.logReceivedMessageWarning(message);\r\n            }\r\n        });","mutatedLines":"        process.on('message', function (serializedMessage) {\n});"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":33,"column":93},"end":{"line":35,"column":5}},"range":[1307,1395],"testsRan":[],"originalLines":"    IsolatedTestRunnerAdapterWorker.prototype.logReceivedMessageWarning = function (message) {\r\n        log.warn('Received unsupported message: {}', JSON.stringify(message));\r\n    };","mutatedLines":"    IsolatedTestRunnerAdapterWorker.prototype.logReceivedMessageWarning = function (message) {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":36,"column":73},"end":{"line":39,"column":5}},"range":[1471,1683],"testsRan":[],"originalLines":"    IsolatedTestRunnerAdapterWorker.prototype.start = function (message) {\r\n        this.loadPlugins(message.runnerOptions.strykerOptions.plugins);\r\n        this.underlyingTestRunner = test_runner_1.TestRunnerFactory.instance().create(message.runnerName, message.runnerOptions);\r\n    };","mutatedLines":"    IsolatedTestRunnerAdapterWorker.prototype.start = function (message) {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":40,"column":65},"end":{"line":51,"column":5}},"range":[1751,2088],"testsRan":[],"originalLines":"    IsolatedTestRunnerAdapterWorker.prototype.init = function () {\r\n        var initPromise = void 0;\r\n        if (this.underlyingTestRunner.init) {\r\n            initPromise = this.underlyingTestRunner.init();\r\n        }\r\n        if (objectUtils_1.isPromise(initPromise)) {\r\n            initPromise.then(this.sendInitDone);\r\n        }\r\n        else {\r\n            this.sendInitDone();\r\n        }\r\n    };","mutatedLines":"    IsolatedTestRunnerAdapterWorker.prototype.init = function () {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"RemoveConditionals","status":0,"replacement":"false","location":{"start":{"line":42,"column":12},"end":{"line":42,"column":42}},"range":[1801,1831],"testsRan":[],"originalLines":"        if (this.underlyingTestRunner.init) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"RemoveConditionals","status":0,"replacement":"true","location":{"start":{"line":42,"column":12},"end":{"line":42,"column":42}},"range":[1801,1831],"testsRan":[],"originalLines":"        if (this.underlyingTestRunner.init) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":42,"column":44},"end":{"line":44,"column":9}},"range":[1833,1906],"testsRan":[],"originalLines":"        if (this.underlyingTestRunner.init) {\r\n            initPromise = this.underlyingTestRunner.init();\r\n        }","mutatedLines":"        if (this.underlyingTestRunner.init) {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"RemoveConditionals","status":0,"replacement":"false","location":{"start":{"line":45,"column":12},"end":{"line":45,"column":48}},"range":[1920,1956],"testsRan":[],"originalLines":"        if (objectUtils_1.isPromise(initPromise)) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"RemoveConditionals","status":0,"replacement":"true","location":{"start":{"line":45,"column":12},"end":{"line":45,"column":48}},"range":[1920,1956],"testsRan":[],"originalLines":"        if (objectUtils_1.isPromise(initPromise)) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":45,"column":50},"end":{"line":47,"column":9}},"range":[1958,2020],"testsRan":[],"originalLines":"        if (objectUtils_1.isPromise(initPromise)) {\r\n            initPromise.then(this.sendInitDone);\r\n        }","mutatedLines":"        if (objectUtils_1.isPromise(initPromise)) {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":48,"column":13},"end":{"line":50,"column":9}},"range":[2035,2081],"testsRan":[],"originalLines":"        else {\r\n            this.sendInitDone();\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":52,"column":73},"end":{"line":55,"column":5}},"range":[2164,2249],"testsRan":[],"originalLines":"    IsolatedTestRunnerAdapterWorker.prototype.sendInitDone = function () {\r\n        var message = { kind: 'initDone' };\r\n        process.send(message);\r\n    };","mutatedLines":"    IsolatedTestRunnerAdapterWorker.prototype.sendInitDone = function () {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":56,"column":68},"end":{"line":67,"column":5}},"range":[2320,2681],"testsRan":[],"originalLines":"    IsolatedTestRunnerAdapterWorker.prototype.dispose = function () {\r\n        var disposePromise = void 0;\r\n        if (this.underlyingTestRunner.dispose) {\r\n            disposePromise = this.underlyingTestRunner.dispose();\r\n        }\r\n        if (objectUtils_1.isPromise(disposePromise)) {\r\n            disposePromise.then(this.sendDisposeDone);\r\n        }\r\n        else {\r\n            this.sendDisposeDone();\r\n        }\r\n    };","mutatedLines":"    IsolatedTestRunnerAdapterWorker.prototype.dispose = function () {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"RemoveConditionals","status":0,"replacement":"false","location":{"start":{"line":58,"column":12},"end":{"line":58,"column":45}},"range":[2373,2406],"testsRan":[],"originalLines":"        if (this.underlyingTestRunner.dispose) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"RemoveConditionals","status":0,"replacement":"true","location":{"start":{"line":58,"column":12},"end":{"line":58,"column":45}},"range":[2373,2406],"testsRan":[],"originalLines":"        if (this.underlyingTestRunner.dispose) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":58,"column":47},"end":{"line":60,"column":9}},"range":[2408,2487],"testsRan":[],"originalLines":"        if (this.underlyingTestRunner.dispose) {\r\n            disposePromise = this.underlyingTestRunner.dispose();\r\n        }","mutatedLines":"        if (this.underlyingTestRunner.dispose) {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"RemoveConditionals","status":0,"replacement":"false","location":{"start":{"line":61,"column":12},"end":{"line":61,"column":51}},"range":[2501,2540],"testsRan":[],"originalLines":"        if (objectUtils_1.isPromise(disposePromise)) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"RemoveConditionals","status":0,"replacement":"true","location":{"start":{"line":61,"column":12},"end":{"line":61,"column":51}},"range":[2501,2540],"testsRan":[],"originalLines":"        if (objectUtils_1.isPromise(disposePromise)) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":61,"column":53},"end":{"line":63,"column":9}},"range":[2542,2610],"testsRan":[],"originalLines":"        if (objectUtils_1.isPromise(disposePromise)) {\r\n            disposePromise.then(this.sendDisposeDone);\r\n        }","mutatedLines":"        if (objectUtils_1.isPromise(disposePromise)) {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":64,"column":13},"end":{"line":66,"column":9}},"range":[2625,2674],"testsRan":[],"originalLines":"        else {\r\n            this.sendDisposeDone();\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":68,"column":76},"end":{"line":70,"column":5}},"range":[2760,2813],"testsRan":[],"originalLines":"    IsolatedTestRunnerAdapterWorker.prototype.sendDisposeDone = function () {\r\n        this.send({ kind: 'disposeDone' });\r\n    };","mutatedLines":"    IsolatedTestRunnerAdapterWorker.prototype.sendDisposeDone = function () {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":71,"column":68},"end":{"line":74,"column":5}},"range":[2884,3094],"testsRan":[],"originalLines":"    IsolatedTestRunnerAdapterWorker.prototype.run = function (body) {\r\n        var _this = this;\r\n        this.underlyingTestRunner.run(body.runOptions).then(function (res) { return _this.reportResult(res); }, function (error) { return _this.reportErrorResult(error); });\r\n    };","mutatedLines":"    IsolatedTestRunnerAdapterWorker.prototype.run = function (body) {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":73,"column":75},"end":{"line":73,"column":110}},"range":[2989,3024],"testsRan":[],"originalLines":"        this.underlyingTestRunner.run(body.runOptions).then(function (res) { return _this.reportResult(res); }, function (error) { return _this.reportErrorResult(error); });","mutatedLines":"        this.underlyingTestRunner.run(body.runOptions).then(function (res) {\n}, function (error) { return _this.reportErrorResult(error); });"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":73,"column":129},"end":{"line":73,"column":171}},"range":[3043,3085],"testsRan":[],"originalLines":"        this.underlyingTestRunner.run(body.runOptions).then(function (res) { return _this.reportResult(res); }, function (error) { return _this.reportErrorResult(error); });","mutatedLines":"        this.underlyingTestRunner.run(body.runOptions).then(function (res) { return _this.reportResult(res); }, function (error) {\n});"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":75,"column":72},"end":{"line":77,"column":5}},"range":[3169,3209],"testsRan":[],"originalLines":"    IsolatedTestRunnerAdapterWorker.prototype.send = function (message) {\r\n        process.send(message);\r\n    };","mutatedLines":"    IsolatedTestRunnerAdapterWorker.prototype.send = function (message) {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":78,"column":79},"end":{"line":80,"column":5}},"range":[3291,3352],"testsRan":[],"originalLines":"    IsolatedTestRunnerAdapterWorker.prototype.loadPlugins = function (plugins) {\r\n        new PluginLoader_1.default(plugins).load();\r\n    };","mutatedLines":"    IsolatedTestRunnerAdapterWorker.prototype.loadPlugins = function (plugins) {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":81,"column":79},"end":{"line":103,"column":5}},"range":[3434,4368],"testsRan":[],"originalLines":"    IsolatedTestRunnerAdapterWorker.prototype.reportResult = function (result) {\r\n        // If the test runner didn't report on coverage, let's try to do it ourselves.\r\n        if (!result.coverage) {\r\n            result.coverage = (Function('return this'))().__coverage__;\r\n        }\r\n        if (result.errorMessages) {\r\n            // errorMessages should be a string[]\r\n            // Just in case the test runner implementer forgot to convert `Error`s to string, we will do it here\r\n            // https://github.com/stryker-mutator/stryker/issues/141\r\n            result.errorMessages = result.errorMessages.map(function (error) {\r\n                if (error instanceof Error) {\r\n                    return error.name + \": \" + error.message + \"\\n\" + error.stack.toString();\r\n                }\r\n                else {\r\n                    return error.toString();\r\n                }\r\n            });\r\n        }\r\n        this.send({\r\n            kind: 'result',\r\n            result: result\r\n        });\r\n    };","mutatedLines":"    IsolatedTestRunnerAdapterWorker.prototype.reportResult = function (result) {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"RemoveConditionals","status":0,"replacement":"false","location":{"start":{"line":83,"column":12},"end":{"line":83,"column":28}},"range":[3537,3553],"testsRan":[],"originalLines":"        if (!result.coverage) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"RemoveConditionals","status":0,"replacement":"true","location":{"start":{"line":83,"column":12},"end":{"line":83,"column":28}},"range":[3537,3553],"testsRan":[],"originalLines":"        if (!result.coverage) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":83,"column":30},"end":{"line":85,"column":9}},"range":[3555,3640],"testsRan":[],"originalLines":"        if (!result.coverage) {\r\n            result.coverage = (Function('return this'))().__coverage__;\r\n        }","mutatedLines":"        if (!result.coverage) {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"RemoveConditionals","status":0,"replacement":"false","location":{"start":{"line":86,"column":12},"end":{"line":86,"column":32}},"range":[3654,3674],"testsRan":[],"originalLines":"        if (result.errorMessages) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"RemoveConditionals","status":0,"replacement":"true","location":{"start":{"line":86,"column":12},"end":{"line":86,"column":32}},"range":[3654,3674],"testsRan":[],"originalLines":"        if (result.errorMessages) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":86,"column":34},"end":{"line":98,"column":9}},"range":[3676,4270],"testsRan":[],"originalLines":"        if (result.errorMessages) {\r\n            // errorMessages should be a string[]\r\n            // Just in case the test runner implementer forgot to convert `Error`s to string, we will do it here\r\n            // https://github.com/stryker-mutator/stryker/issues/141\r\n            result.errorMessages = result.errorMessages.map(function (error) {\r\n                if (error instanceof Error) {\r\n                    return error.name + \": \" + error.message + \"\\n\" + error.stack.toString();\r\n                }\r\n                else {\r\n                    return error.toString();\r\n                }\r\n            });\r\n        }","mutatedLines":"        if (result.errorMessages) {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":90,"column":77},"end":{"line":97,"column":13}},"range":[3991,4257],"testsRan":[],"originalLines":"            result.errorMessages = result.errorMessages.map(function (error) {\r\n                if (error instanceof Error) {\r\n                    return error.name + \": \" + error.message + \"\\n\" + error.stack.toString();\r\n                }\r\n                else {\r\n                    return error.toString();\r\n                }\r\n            });","mutatedLines":"            result.errorMessages = result.errorMessages.map(function (error) {\n});"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"RemoveConditionals","status":0,"replacement":"false","location":{"start":{"line":91,"column":20},"end":{"line":91,"column":42}},"range":[4014,4036],"testsRan":[],"originalLines":"                if (error instanceof Error) {","mutatedLines":"                if (false) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"RemoveConditionals","status":0,"replacement":"true","location":{"start":{"line":91,"column":20},"end":{"line":91,"column":42}},"range":[4014,4036],"testsRan":[],"originalLines":"                if (error instanceof Error) {","mutatedLines":"                if (true) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":91,"column":44},"end":{"line":93,"column":17}},"range":[4038,4153],"testsRan":[],"originalLines":"                if (error instanceof Error) {\r\n                    return error.name + \": \" + error.message + \"\\n\" + error.stack.toString();\r\n                }","mutatedLines":"                if (error instanceof Error) {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BinaryOperator","status":0,"replacement":"error.name + ': ' + error.message + '\\n' - error.stack.toString()","location":{"start":{"line":92,"column":27},"end":{"line":92,"column":92}},"range":[4068,4133],"testsRan":[],"originalLines":"                    return error.name + \": \" + error.message + \"\\n\" + error.stack.toString();","mutatedLines":"                    return error.name + ': ' + error.message + '\\n' - error.stack.toString();"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BinaryOperator","status":0,"replacement":"error.name + ': ' + error.message - '\\n'","location":{"start":{"line":92,"column":27},"end":{"line":92,"column":67}},"range":[4068,4108],"testsRan":[],"originalLines":"                    return error.name + \": \" + error.message + \"\\n\" + error.stack.toString();","mutatedLines":"                    return error.name + ': ' + error.message - '\\n' + error.stack.toString();"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BinaryOperator","status":0,"replacement":"error.name + ': ' - error.message","location":{"start":{"line":92,"column":27},"end":{"line":92,"column":60}},"range":[4068,4101],"testsRan":[],"originalLines":"                    return error.name + \": \" + error.message + \"\\n\" + error.stack.toString();","mutatedLines":"                    return error.name + ': ' - error.message + \"\\n\" + error.stack.toString();"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BinaryOperator","status":0,"replacement":"error.name - ': '","location":{"start":{"line":92,"column":27},"end":{"line":92,"column":44}},"range":[4068,4085],"testsRan":[],"originalLines":"                    return error.name + \": \" + error.message + \"\\n\" + error.stack.toString();","mutatedLines":"                    return error.name - ': ' + error.message + \"\\n\" + error.stack.toString();"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":94,"column":21},"end":{"line":96,"column":17}},"range":[4176,4242],"testsRan":[],"originalLines":"                else {\r\n                    return error.toString();\r\n                }","mutatedLines":"                else {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":104,"column":83},"end":{"line":118,"column":5}},"range":[4454,4874],"testsRan":[],"originalLines":"    IsolatedTestRunnerAdapterWorker.prototype.reportErrorResult = function (error) {\r\n        var runResult = {\r\n            tests: [],\r\n            status: test_runner_1.RunStatus.Error,\r\n        };\r\n        if (error) {\r\n            if (Array.isArray(error)) {\r\n                runResult.errorMessages = error.map(function (e) { return e; });\r\n            }\r\n            else {\r\n                runResult.errorMessages = [error];\r\n            }\r\n        }\r\n        this.reportResult(runResult);\r\n    };","mutatedLines":"    IsolatedTestRunnerAdapterWorker.prototype.reportErrorResult = function (error) {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"RemoveConditionals","status":0,"replacement":"false","location":{"start":{"line":109,"column":12},"end":{"line":109,"column":17}},"range":[4584,4589],"testsRan":[],"originalLines":"        if (error) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"RemoveConditionals","status":0,"replacement":"true","location":{"start":{"line":109,"column":12},"end":{"line":109,"column":17}},"range":[4584,4589],"testsRan":[],"originalLines":"        if (error) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":109,"column":19},"end":{"line":116,"column":9}},"range":[4591,4828],"testsRan":[],"originalLines":"        if (error) {\r\n            if (Array.isArray(error)) {\r\n                runResult.errorMessages = error.map(function (e) { return e; });\r\n            }\r\n            else {\r\n                runResult.errorMessages = [error];\r\n            }\r\n        }","mutatedLines":"        if (error) {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"RemoveConditionals","status":0,"replacement":"false","location":{"start":{"line":110,"column":16},"end":{"line":110,"column":36}},"range":[4610,4630],"testsRan":[],"originalLines":"            if (Array.isArray(error)) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"RemoveConditionals","status":0,"replacement":"true","location":{"start":{"line":110,"column":16},"end":{"line":110,"column":36}},"range":[4610,4630],"testsRan":[],"originalLines":"            if (Array.isArray(error)) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":110,"column":38},"end":{"line":112,"column":13}},"range":[4632,4730],"testsRan":[],"originalLines":"            if (Array.isArray(error)) {\r\n                runResult.errorMessages = error.map(function (e) { return e; });\r\n            }","mutatedLines":"            if (Array.isArray(error)) {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":111,"column":65},"end":{"line":111,"column":78}},"range":[4700,4713],"testsRan":[],"originalLines":"                runResult.errorMessages = error.map(function (e) { return e; });","mutatedLines":"                runResult.errorMessages = error.map(function (e) {\n});"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterWorker.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":113,"column":17},"end":{"line":115,"column":13}},"range":[4749,4817],"testsRan":[],"originalLines":"            else {\r\n                runResult.errorMessages = [error];\r\n            }","mutatedLines":"            else {\n}"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":55,"column":44},"end":{"line":57,"column":21}},"range":[2580,2682],"testsRan":["IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result"],"originalLines":"                    if (!_this.isDisposing) {\r\n                        _this.runPromiseFulfillmentCallback(message.result);\r\n                    }","mutatedLines":"                    if (!_this.isDisposing) {\n}"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":6,"column":26},"end":{"line":98,"column":1}},"range":[176,3866],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code \"before each\" hook for \"the filename\""],"originalLines":"var Mutant = (function () {\r\n    /**\r\n     * @param mutatorName - The name of the Mutator which created this mutant.\r\n     * @param filename - The name of the file which was mutated, including the path.\r\n     * @param originalCode - The original content of the file which has not been mutated.\r\n     * @param replacement - The mutated code which will replace a part of the originalCode.\r\n     * @param location - The location of the code to be mutated - line and column based\r\n     * @param range - The location of the code to be mutated - index based\r\n     */\r\n    function Mutant(mutatorName, filename, originalCode, replacement, location, range) {\r\n        this.mutatorName = mutatorName;\r\n        this.filename = filename;\r\n        this.originalCode = originalCode;\r\n        this.replacement = replacement;\r\n        this.location = location;\r\n        this.range = range;\r\n        this._scopedTestIds = [];\r\n        this.specsRan = [];\r\n        this._timeSpentScopedTests = 0;\r\n    }\r\n    Object.defineProperty(Mutant.prototype, \"scopedTestIds\", {\r\n        get: function () {\r\n            return this._scopedTestIds;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Mutant.prototype, \"timeSpentScopedTests\", {\r\n        get: function () {\r\n            return this._timeSpentScopedTests;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Mutant.prototype.addTestResult = function (index, testResult) {\r\n        this._scopedTestIds.push(index);\r\n        this._timeSpentScopedTests += testResult.timeSpentMs;\r\n    };\r\n    Mutant.prototype.isNewLine = function (index) {\r\n        var char = this.originalCode[index];\r\n        return char === '\\n' || char === '\\r';\r\n    };\r\n    Mutant.prototype.getMutationLineIndexes = function () {\r\n        var startIndexLines = this.range[0], endIndexLines = this.range[1];\r\n        while (startIndexLines > 0 && !this.isNewLine(startIndexLines - 1)) {\r\n            startIndexLines--;\r\n        }\r\n        while (endIndexLines < this.originalCode.length && !this.isNewLine(endIndexLines)) {\r\n            endIndexLines++;\r\n        }\r\n        return [startIndexLines, endIndexLines];\r\n    };\r\n    Object.defineProperty(Mutant.prototype, \"originalLines\", {\r\n        get: function () {\r\n            var _a = this.getMutationLineIndexes(), startIndex = _a[0], endIndex = _a[1];\r\n            return this.originalCode.substring(startIndex, endIndex);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Mutant.prototype, \"mutatedLines\", {\r\n        get: function () {\r\n            var _a = this.getMutationLineIndexes(), startIndex = _a[0], endIndex = _a[1];\r\n            return this.originalCode.substring(startIndex, this.range[0]) + this.replacement + this.originalCode.substring(this.range[1], endIndex);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Mutant.prototype, \"mutatedCode\", {\r\n        get: function () {\r\n            return this.originalCode.substr(0, this.range[0]) + this.replacement + this.originalCode.substr(this.range[1]);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Saves the mutated code in a mutated file.\r\n     * @function\r\n     */\r\n    Mutant.prototype.save = function (filename) {\r\n        return StrykerTempFolder_1.default.writeFile(filename, this.mutatedCode);\r\n    };\r\n    ;\r\n    /**\r\n     * Removes the mutated file.\r\n     * @function\r\n     */\r\n    Mutant.prototype.reset = function (filename) {\r\n        return StrykerTempFolder_1.default.writeFile(filename, this.originalCode);\r\n    };\r\n    ;\r\n    return Mutant;\r\n}());","mutatedLines":"var Mutant = (function () {\n}());"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":15,"column":87},"end":{"line":25,"column":5}},"range":[799,1136],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename"],"originalLines":"    function Mutant(mutatorName, filename, originalCode, replacement, location, range) {\r\n        this.mutatorName = mutatorName;\r\n        this.filename = filename;\r\n        this.originalCode = originalCode;\r\n        this.replacement = replacement;\r\n        this.location = location;\r\n        this.range = range;\r\n        this._scopedTestIds = [];\r\n        this.specsRan = [];\r\n        this._timeSpentScopedTests = 0;\r\n    }","mutatedLines":"    function Mutant(mutatorName, filename, originalCode, replacement, location, range) {\n}"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":27,"column":25},"end":{"line":29,"column":9}},"range":[1227,1280],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)"],"originalLines":"        get: function () {\r\n            return this._scopedTestIds;\r\n        },","mutatedLines":"        get: function () {\n},"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":95,"column":12},"end":{"line":95,"column":28}},"range":[4227,4243],"testsRan":["IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose \"before each\" hook for \"should kill the child process and start a new one\""],"originalLines":"        if (this.isDisposing) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":40,"column":66},"end":{"line":43,"column":5}},"range":[1636,1749],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)"],"originalLines":"    Mutant.prototype.addTestResult = function (index, testResult) {\r\n        this._scopedTestIds.push(index);\r\n        this._timeSpentScopedTests += testResult.timeSpentMs;\r\n    };","mutatedLines":"    Mutant.prototype.addTestResult = function (index, testResult) {\n};"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"LogicalOperator","status":1,"replacement":"char === '\\n' && char === '\\r'","location":{"start":{"line":46,"column":15},"end":{"line":46,"column":45}},"range":[1866,1896],"testsRan":["Mutant with multi-line substitude should set the correct originalLines"],"originalLines":"        return char === '\\n' || char === '\\r';","mutatedLines":"        return char === '\\n' && char === '\\r';"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":44,"column":50},"end":{"line":47,"column":5}},"range":[1802,1904],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines"],"originalLines":"    Mutant.prototype.isNewLine = function (index) {\r\n        var char = this.originalCode[index];\r\n        return char === '\\n' || char === '\\r';\r\n    };","mutatedLines":"    Mutant.prototype.isNewLine = function (index) {\n};"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BinaryOperator","status":1,"replacement":"char !== '\\n'","location":{"start":{"line":46,"column":15},"end":{"line":46,"column":28}},"range":[1866,1879],"testsRan":["Mutant with multi-line substitude should set the correct originalLines"],"originalLines":"        return char === '\\n' || char === '\\r';","mutatedLines":"        return char !== '\\n' || char === '\\r';"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BinaryOperator","status":1,"replacement":"char !== '\\r'","location":{"start":{"line":46,"column":32},"end":{"line":46,"column":45}},"range":[1883,1896],"testsRan":["Mutant with multi-line substitude should set the correct originalLines"],"originalLines":"        return char === '\\n' || char === '\\r';","mutatedLines":"        return char === '\\n' || char !== '\\r';"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":50,"column":15},"end":{"line":50,"column":74}},"range":[2060,2119],"testsRan":["Mutant with multi-line substitude should set the correct originalLines"],"originalLines":"        while (startIndexLines > 0 && !this.isNewLine(startIndexLines - 1)) {","mutatedLines":"        while (false) {"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":48,"column":58},"end":{"line":57,"column":5}},"range":[1965,2357],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines"],"originalLines":"    Mutant.prototype.getMutationLineIndexes = function () {\r\n        var startIndexLines = this.range[0], endIndexLines = this.range[1];\r\n        while (startIndexLines > 0 && !this.isNewLine(startIndexLines - 1)) {\r\n            startIndexLines--;\r\n        }\r\n        while (endIndexLines < this.originalCode.length && !this.isNewLine(endIndexLines)) {\r\n            endIndexLines++;\r\n        }\r\n        return [startIndexLines, endIndexLines];\r\n    };","mutatedLines":"    Mutant.prototype.getMutationLineIndexes = function () {\n};"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BinaryOperator","status":2,"replacement":"startIndexLines >= 0","location":{"start":{"line":50,"column":15},"end":{"line":50,"column":34}},"range":[2060,2079],"testsRan":["Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines"],"originalLines":"        while (startIndexLines > 0 && !this.isNewLine(startIndexLines - 1)) {","mutatedLines":"        while (startIndexLines >= 0 && !this.isNewLine(startIndexLines - 1)) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapterFactory.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":5,"column":32},"end":{"line":7,"column":5}},"range":[207,318],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    create: function (settings) {\r\n        return new IsolatedTestRunnerAdapter_1.default(settings.strykerOptions.testRunner, settings);\r\n    }","mutatedLines":"    create: function (settings) {\n}"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BinaryOperator","status":1,"replacement":"startIndexLines <= 0","location":{"start":{"line":50,"column":15},"end":{"line":50,"column":34}},"range":[2060,2079],"testsRan":["Mutant with multi-line substitude should set the correct originalLines"],"originalLines":"        while (startIndexLines > 0 && !this.isNewLine(startIndexLines - 1)) {","mutatedLines":"        while (startIndexLines <= 0 && !this.isNewLine(startIndexLines - 1)) {"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BinaryOperator","status":2,"replacement":"startIndexLines + 1","location":{"start":{"line":50,"column":54},"end":{"line":50,"column":73}},"range":[2099,2118],"testsRan":["Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines"],"originalLines":"        while (startIndexLines > 0 && !this.isNewLine(startIndexLines - 1)) {","mutatedLines":"        while (startIndexLines > 0 && !this.isNewLine(startIndexLines + 1)) {"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"UpdateOperator","status":1,"replacement":"startIndexLines++","location":{"start":{"line":51,"column":12},"end":{"line":51,"column":29}},"range":[2136,2153],"testsRan":["Mutant with multi-line substitude should set the correct originalLines"],"originalLines":"            startIndexLines--;","mutatedLines":"            startIndexLines++;"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":34,"column":25},"end":{"line":36,"column":9}},"range":[1443,1503],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"        get: function () {\r\n            return this._timeSpentScopedTests;\r\n        },","mutatedLines":"        get: function () {\n},"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":53,"column":15},"end":{"line":53,"column":89}},"range":[2182,2256],"testsRan":["Mutant with multi-line substitude should set the correct originalLines"],"originalLines":"        while (endIndexLines < this.originalCode.length && !this.isNewLine(endIndexLines)) {","mutatedLines":"        while (false) {"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BinaryOperator","status":2,"replacement":"endIndexLines <= this.originalCode.length","location":{"start":{"line":53,"column":15},"end":{"line":53,"column":55}},"range":[2182,2222],"testsRan":["Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines"],"originalLines":"        while (endIndexLines < this.originalCode.length && !this.isNewLine(endIndexLines)) {","mutatedLines":"        while (endIndexLines <= this.originalCode.length && !this.isNewLine(endIndexLines)) {"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BinaryOperator","status":1,"replacement":"endIndexLines >= this.originalCode.length","location":{"start":{"line":53,"column":15},"end":{"line":53,"column":55}},"range":[2182,2222],"testsRan":["Mutant with multi-line substitude should set the correct originalLines"],"originalLines":"        while (endIndexLines < this.originalCode.length && !this.isNewLine(endIndexLines)) {","mutatedLines":"        while (endIndexLines >= this.originalCode.length && !this.isNewLine(endIndexLines)) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":136,"column":76},"end":{"line":140,"column":5}},"range":[5987,6100],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout"],"originalLines":"    TestRunnerChildProcessAdapter.prototype.clearCurrentTimer = function () {\r\n        if (this.currentTimeoutTimer) {\r\n            clearTimeout(this.currentTimeoutTimer);\r\n        }\r\n    };","mutatedLines":"    TestRunnerChildProcessAdapter.prototype.clearCurrentTimer = function () {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":137,"column":12},"end":{"line":137,"column":36}},"range":[6002,6026],"testsRan":["IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout"],"originalLines":"        if (this.currentTimeoutTimer) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"UpdateOperator","status":1,"replacement":"endIndexLines--","location":{"start":{"line":54,"column":12},"end":{"line":54,"column":27}},"range":[2273,2288],"testsRan":["Mutant with multi-line substitude should set the correct originalLines"],"originalLines":"            endIndexLines++;","mutatedLines":"            endIndexLines--;"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":59,"column":25},"end":{"line":62,"column":9}},"range":[2449,2623],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines"],"originalLines":"        get: function () {\r\n            var _a = this.getMutationLineIndexes(), startIndex = _a[0], endIndex = _a[1];\r\n            return this.originalCode.substring(startIndex, endIndex);\r\n        },","mutatedLines":"        get: function () {\n},"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":67,"column":25},"end":{"line":70,"column":9}},"range":[2778,3031],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines"],"originalLines":"        get: function () {\r\n            var _a = this.getMutationLineIndexes(), startIndex = _a[0], endIndex = _a[1];\r\n            return this.originalCode.substring(startIndex, this.range[0]) + this.replacement + this.originalCode.substring(this.range[1], endIndex);\r\n        },","mutatedLines":"        get: function () {\n},"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BinaryOperator","status":1,"replacement":"this.originalCode.substring(startIndex, this.range[0]) + this.replacement - this.originalCode.substring(this.range[1], endIndex)","location":{"start":{"line":69,"column":19},"end":{"line":69,"column":147}},"range":[2891,3019],"testsRan":["Mutant with multi-line substitude should set the correct mutatedLines"],"originalLines":"            return this.originalCode.substring(startIndex, this.range[0]) + this.replacement + this.originalCode.substring(this.range[1], endIndex);","mutatedLines":"            return this.originalCode.substring(startIndex, this.range[0]) + this.replacement - this.originalCode.substring(this.range[1], endIndex);"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BinaryOperator","status":1,"replacement":"this.originalCode.substring(startIndex, this.range[0]) - this.replacement","location":{"start":{"line":69,"column":19},"end":{"line":69,"column":92}},"range":[2891,2964],"testsRan":["Mutant with multi-line substitude should set the correct mutatedLines"],"originalLines":"            return this.originalCode.substring(startIndex, this.range[0]) + this.replacement + this.originalCode.substring(this.range[1], endIndex);","mutatedLines":"            return this.originalCode.substring(startIndex, this.range[0]) - this.replacement + this.originalCode.substring(this.range[1], endIndex);"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BinaryOperator","status":1,"replacement":"this.originalCode.substr(0, this.range[0]) + this.replacement - this.originalCode.substr(this.range[1])","location":{"start":{"line":76,"column":19},"end":{"line":76,"column":122}},"range":[3207,3310],"testsRan":["Mutant with multi-line substitude should generate the correct mutated code"],"originalLines":"            return this.originalCode.substr(0, this.range[0]) + this.replacement + this.originalCode.substr(this.range[1]);","mutatedLines":"            return this.originalCode.substr(0, this.range[0]) + this.replacement - this.originalCode.substr(this.range[1]);"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BinaryOperator","status":1,"replacement":"this.originalCode.substr(0, this.range[0]) - this.replacement","location":{"start":{"line":76,"column":19},"end":{"line":76,"column":80}},"range":[3207,3268],"testsRan":["Mutant with multi-line substitude should generate the correct mutated code"],"originalLines":"            return this.originalCode.substr(0, this.range[0]) + this.replacement + this.originalCode.substr(this.range[1]);","mutatedLines":"            return this.originalCode.substr(0, this.range[0]) - this.replacement + this.originalCode.substr(this.range[1]);"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":75,"column":25},"end":{"line":77,"column":9}},"range":[3185,3322],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code"],"originalLines":"        get: function () {\r\n            return this.originalCode.substr(0, this.range[0]) + this.replacement + this.originalCode.substr(this.range[1]);\r\n        },","mutatedLines":"        get: function () {\n},"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":85,"column":48},"end":{"line":87,"column":5}},"range":[3523,3614],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code"],"originalLines":"    Mutant.prototype.save = function (filename) {\r\n        return StrykerTempFolder_1.default.writeFile(filename, this.mutatedCode);\r\n    };","mutatedLines":"    Mutant.prototype.save = function (filename) {\n};"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":137,"column":38},"end":{"line":139,"column":9}},"range":[6028,6093],"testsRan":["IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout"],"originalLines":"        if (this.currentTimeoutTimer) {\r\n            clearTimeout(this.currentTimeoutTimer);\r\n        }","mutatedLines":"        if (this.currentTimeoutTimer) {\n}"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":2,"column":37},"end":{"line":103,"column":1}},"range":[52,5114],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher \"before each\" hook for \"should add both tests to the mutants\""],"originalLines":"var MutantTestMatcher = (function () {\r\n    function MutantTestMatcher(mutants, initialRunResult, statementMaps, options) {\r\n        this.mutants = mutants;\r\n        this.initialRunResult = initialRunResult;\r\n        this.statementMaps = statementMaps;\r\n        this.options = options;\r\n    }\r\n    MutantTestMatcher.prototype.matchWithMutants = function () {\r\n        var _this = this;\r\n        this.mutants.forEach(function (mutant) {\r\n            var statementMap = _this.statementMaps[mutant.filename];\r\n            var smallestStatement = _this.findSmallestCoveringStatement(mutant, statementMap);\r\n            _this.initialRunResult.tests.forEach(function (testResult, id) {\r\n                var covered = false;\r\n                var coverageCollection = _this.findCoverageCollectionForTest(id);\r\n                if (coverageCollection && smallestStatement) {\r\n                    var coveredFile = coverageCollection[mutant.filename];\r\n                    if (coveredFile) {\r\n                        covered = coveredFile.s[smallestStatement] > 0;\r\n                    }\r\n                }\r\n                else {\r\n                    // If there is no coverage data we have to assume that the test covers the mutant\r\n                    covered = true;\r\n                }\r\n                if (covered) {\r\n                    mutant.addTestResult(id, testResult);\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Finds the smallest statement that covers a mutant.\r\n     * @param mutant The mutant.\r\n     * @param statementMap of the covering file.\r\n     * @returns The index of the coveredFile which contains the smallest statement surrounding the mutant.\r\n     */\r\n    MutantTestMatcher.prototype.findSmallestCoveringStatement = function (mutant, statementMap) {\r\n        var _this = this;\r\n        var smallestStatement = null;\r\n        if (statementMap) {\r\n            Object.keys(statementMap).forEach(function (statementId) {\r\n                var location = statementMap[statementId];\r\n                if (_this.statementCoversMutant(mutant.location, location) && _this.isNewSmallestStatement(statementMap[smallestStatement], location)) {\r\n                    smallestStatement = statementId;\r\n                }\r\n            });\r\n        }\r\n        return smallestStatement;\r\n    };\r\n    /**\r\n     * Indicates whether a statement is the smallest statement of the two statements provided.\r\n     * @param originalLocation The area which may cover a bigger area than the newLocation.\r\n     * @param newLocation The area which may cover a smaller area than the originalLocation.\r\n     * @returns true if the newLocation covers a smaller area than the originalLocation, making it the smaller statement.\r\n     */\r\n    MutantTestMatcher.prototype.isNewSmallestStatement = function (originalLocation, newLocation) {\r\n        var statementIsSmallestStatement = false;\r\n        if (!originalLocation) {\r\n            statementIsSmallestStatement = true;\r\n        }\r\n        else {\r\n            var lineDifference = (originalLocation.end.line - originalLocation.start.line) - (newLocation.end.line - newLocation.start.line);\r\n            var coversLessLines = lineDifference > 0;\r\n            var coversLessColumns = lineDifference === 0 && (newLocation.start.column - originalLocation.start.column) + (originalLocation.end.column - newLocation.end.column) > 0;\r\n            if (coversLessLines || coversLessColumns) {\r\n                statementIsSmallestStatement = true;\r\n            }\r\n        }\r\n        return statementIsSmallestStatement;\r\n    };\r\n    /**\r\n     * Indicates whether a statement covers a mutant.\r\n     * @param mutantLocation The location of the mutant.\r\n     * @param statementLocation The location of the statement.\r\n     * @returns true if the statment covers the mutant.\r\n     */\r\n    MutantTestMatcher.prototype.statementCoversMutant = function (mutantLocation, statementLocation) {\r\n        var mutantIsAfterStart = mutantLocation.start.line > statementLocation.start.line ||\r\n            (mutantLocation.start.line === statementLocation.start.line && mutantLocation.start.column >= statementLocation.start.column);\r\n        var mutantIsBeforeEnd = mutantLocation.end.line < statementLocation.end.line ||\r\n            (mutantLocation.end.line === statementLocation.end.line && mutantLocation.end.column <= statementLocation.end.column);\r\n        return mutantIsAfterStart && mutantIsBeforeEnd;\r\n    };\r\n    MutantTestMatcher.prototype.findCoverageCollectionForTest = function (testId) {\r\n        if (this.initialRunResult.coverage) {\r\n            if (this.isCoverageCollectionPerTest(this.initialRunResult.coverage)) {\r\n                return this.initialRunResult.coverage[testId];\r\n            }\r\n            else {\r\n                return this.initialRunResult.coverage;\r\n            }\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    };\r\n    MutantTestMatcher.prototype.isCoverageCollectionPerTest = function (coverage) {\r\n        return this.options.coverageAnalysis === 'perTest';\r\n    };\r\n    return MutantTestMatcher;\r\n}());","mutatedLines":"var MutantTestMatcher = (function () {\n}());"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":3,"column":82},"end":{"line":8,"column":5}},"range":[137,307],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info \"before each\" hook for \"should add both tests to the mutants\""],"originalLines":"    function MutantTestMatcher(mutants, initialRunResult, statementMaps, options) {\r\n        this.mutants = mutants;\r\n        this.initialRunResult = initialRunResult;\r\n        this.statementMaps = statementMaps;\r\n        this.options = options;\r\n    }","mutatedLines":"    function MutantTestMatcher(mutants, initialRunResult, statementMaps, options) {\n}"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":9,"column":63},"end":{"line":32,"column":5}},"range":[372,1440],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants"],"originalLines":"    MutantTestMatcher.prototype.matchWithMutants = function () {\r\n        var _this = this;\r\n        this.mutants.forEach(function (mutant) {\r\n            var statementMap = _this.statementMaps[mutant.filename];\r\n            var smallestStatement = _this.findSmallestCoveringStatement(mutant, statementMap);\r\n            _this.initialRunResult.tests.forEach(function (testResult, id) {\r\n                var covered = false;\r\n                var coverageCollection = _this.findCoverageCollectionForTest(id);\r\n                if (coverageCollection && smallestStatement) {\r\n                    var coveredFile = coverageCollection[mutant.filename];\r\n                    if (coveredFile) {\r\n                        covered = coveredFile.s[smallestStatement] > 0;\r\n                    }\r\n                }\r\n                else {\r\n                    // If there is no coverage data we have to assume that the test covers the mutant\r\n                    covered = true;\r\n                }\r\n                if (covered) {\r\n                    mutant.addTestResult(id, testResult);\r\n                }\r\n            });\r\n        });\r\n    };","mutatedLines":"    MutantTestMatcher.prototype.matchWithMutants = function () {\n};"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":11,"column":47},"end":{"line":31,"column":9}},"range":[449,1431],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants"],"originalLines":"        this.mutants.forEach(function (mutant) {\r\n            var statementMap = _this.statementMaps[mutant.filename];\r\n            var smallestStatement = _this.findSmallestCoveringStatement(mutant, statementMap);\r\n            _this.initialRunResult.tests.forEach(function (testResult, id) {\r\n                var covered = false;\r\n                var coverageCollection = _this.findCoverageCollectionForTest(id);\r\n                if (coverageCollection && smallestStatement) {\r\n                    var coveredFile = coverageCollection[mutant.filename];\r\n                    if (coveredFile) {\r\n                        covered = coveredFile.s[smallestStatement] > 0;\r\n                    }\r\n                }\r\n                else {\r\n                    // If there is no coverage data we have to assume that the test covers the mutant\r\n                    covered = true;\r\n                }\r\n                if (covered) {\r\n                    mutant.addTestResult(id, testResult);\r\n                }\r\n            });\r\n        });","mutatedLines":"        this.mutants.forEach(function (mutant) {\n});"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":14,"column":75},"end":{"line":30,"column":13}},"range":[693,1418],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants"],"originalLines":"            _this.initialRunResult.tests.forEach(function (testResult, id) {\r\n                var covered = false;\r\n                var coverageCollection = _this.findCoverageCollectionForTest(id);\r\n                if (coverageCollection && smallestStatement) {\r\n                    var coveredFile = coverageCollection[mutant.filename];\r\n                    if (coveredFile) {\r\n                        covered = coveredFile.s[smallestStatement] > 0;\r\n                    }\r\n                }\r\n                else {\r\n                    // If there is no coverage data we have to assume that the test covers the mutant\r\n                    covered = true;\r\n                }\r\n                if (covered) {\r\n                    mutant.addTestResult(id, testResult);\r\n                }\r\n            });","mutatedLines":"            _this.initialRunResult.tests.forEach(function (testResult, id) {\n});"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":17,"column":20},"end":{"line":17,"column":59}},"range":[837,876],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants"],"originalLines":"                if (coverageCollection && smallestStatement) {","mutatedLines":"                if (false) {"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":17,"column":20},"end":{"line":17,"column":59}},"range":[837,876],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info \"before each\" hook for \"should add both tests to the mutants\""],"originalLines":"                if (coverageCollection && smallestStatement) {","mutatedLines":"                if (true) {"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":17,"column":61},"end":{"line":22,"column":17}},"range":[878,1110],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants"],"originalLines":"                if (coverageCollection && smallestStatement) {\r\n                    var coveredFile = coverageCollection[mutant.filename];\r\n                    if (coveredFile) {\r\n                        covered = coveredFile.s[smallestStatement] > 0;\r\n                    }\r\n                }","mutatedLines":"                if (coverageCollection && smallestStatement) {\n}"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"LogicalOperator","status":2,"replacement":"coverageCollection || smallestStatement","location":{"start":{"line":17,"column":20},"end":{"line":17,"column":59}},"range":[837,876],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)"],"originalLines":"                if (coverageCollection && smallestStatement) {","mutatedLines":"                if (coverageCollection || smallestStatement) {"},{"sourceFilePath":"/stryker/src/isolated-runner/IsolatedTestRunnerAdapter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":152,"column":30},"end":{"line":152,"column":133}},"range":[6626,6729],"testsRan":["IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart"],"originalLines":"            .then(function () { return _this.runPromiseFulfillmentCallback({ status: test_runner_1.RunStatus.Timeout, tests: [] }); });","mutatedLines":"            .then(function () {\n});"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":19,"column":37},"end":{"line":21,"column":21}},"range":[994,1091],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants"],"originalLines":"                    if (coveredFile) {\r\n                        covered = coveredFile.s[smallestStatement] > 0;\r\n                    }","mutatedLines":"                    if (coveredFile) {\n}"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":19,"column":24},"end":{"line":19,"column":35}},"range":[981,992],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants \"before each\" hook for \"should not have added the run results to the mutants\""],"originalLines":"                    if (coveredFile) {","mutatedLines":"                    if (true) {"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":19,"column":24},"end":{"line":19,"column":35}},"range":[981,992],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants"],"originalLines":"                    if (coveredFile) {","mutatedLines":"                    if (false) {"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BinaryOperator","status":1,"replacement":"coveredFile.s[smallestStatement] >= 0","location":{"start":{"line":20,"column":34},"end":{"line":20,"column":70}},"range":[1031,1067],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants"],"originalLines":"                        covered = coveredFile.s[smallestStatement] > 0;","mutatedLines":"                        covered = coveredFile.s[smallestStatement] >= 0;"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BinaryOperator","status":1,"replacement":"coveredFile.s[smallestStatement] <= 0","location":{"start":{"line":20,"column":34},"end":{"line":20,"column":70}},"range":[1031,1067],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants"],"originalLines":"                        covered = coveredFile.s[smallestStatement] > 0;","mutatedLines":"                        covered = coveredFile.s[smallestStatement] <= 0;"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":23,"column":21},"end":{"line":26,"column":17}},"range":[1133,1293],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants"],"originalLines":"                else {\r\n                    // If there is no coverage data we have to assume that the test covers the mutant\r\n                    covered = true;\r\n                }","mutatedLines":"                else {\n}"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":27,"column":20},"end":{"line":27,"column":27}},"range":[1315,1322],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants"],"originalLines":"                if (covered) {","mutatedLines":"                if (false) {"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":27,"column":29},"end":{"line":29,"column":17}},"range":[1324,1403],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants"],"originalLines":"                if (covered) {\r\n                    mutant.addTestResult(id, testResult);\r\n                }","mutatedLines":"                if (covered) {\n}"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":27,"column":20},"end":{"line":27,"column":27}},"range":[1315,1322],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants"],"originalLines":"                if (covered) {","mutatedLines":"                if (true) {"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":42,"column":12},"end":{"line":42,"column":24}},"range":[1889,1901],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants"],"originalLines":"        if (statementMap) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":42,"column":12},"end":{"line":42,"column":24}},"range":[1889,1901],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info \"before each\" hook for \"should add both tests to the mutants\""],"originalLines":"        if (statementMap) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":42,"column":26},"end":{"line":49,"column":9}},"range":[1903,2290],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants"],"originalLines":"        if (statementMap) {\r\n            Object.keys(statementMap).forEach(function (statementId) {\r\n                var location = statementMap[statementId];\r\n                if (_this.statementCoversMutant(mutant.location, location) && _this.isNewSmallestStatement(statementMap[smallestStatement], location)) {\r\n                    smallestStatement = statementId;\r\n                }\r\n            });\r\n        }","mutatedLines":"        if (statementMap) {\n}"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":39,"column":96},"end":{"line":51,"column":5}},"range":[1808,2332],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants"],"originalLines":"    MutantTestMatcher.prototype.findSmallestCoveringStatement = function (mutant, statementMap) {\r\n        var _this = this;\r\n        var smallestStatement = null;\r\n        if (statementMap) {\r\n            Object.keys(statementMap).forEach(function (statementId) {\r\n                var location = statementMap[statementId];\r\n                if (_this.statementCoversMutant(mutant.location, location) && _this.isNewSmallestStatement(statementMap[smallestStatement], location)) {\r\n                    smallestStatement = statementId;\r\n                }\r\n            });\r\n        }\r\n        return smallestStatement;\r\n    };","mutatedLines":"    MutantTestMatcher.prototype.findSmallestCoveringStatement = function (mutant, statementMap) {\n};"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":43,"column":69},"end":{"line":48,"column":13}},"range":[1975,2277],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants"],"originalLines":"            Object.keys(statementMap).forEach(function (statementId) {\r\n                var location = statementMap[statementId];\r\n                if (_this.statementCoversMutant(mutant.location, location) && _this.isNewSmallestStatement(statementMap[smallestStatement], location)) {\r\n                    smallestStatement = statementId;\r\n                }\r\n            });","mutatedLines":"            Object.keys(statementMap).forEach(function (statementId) {\n});"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"LogicalOperator","status":1,"replacement":"_this.statementCoversMutant(mutant.location, location) || _this.isNewSmallestStatement(statementMap[smallestStatement], location)","location":{"start":{"line":45,"column":20},"end":{"line":45,"column":149}},"range":[2057,2186],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants"],"originalLines":"                if (_this.statementCoversMutant(mutant.location, location) && _this.isNewSmallestStatement(statementMap[smallestStatement], location)) {","mutatedLines":"                if (_this.statementCoversMutant(mutant.location, location) || _this.isNewSmallestStatement(statementMap[smallestStatement], location)) {"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":45,"column":20},"end":{"line":45,"column":149}},"range":[2057,2186],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants"],"originalLines":"                if (_this.statementCoversMutant(mutant.location, location) && _this.isNewSmallestStatement(statementMap[smallestStatement], location)) {","mutatedLines":"                if (true) {"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":45,"column":20},"end":{"line":45,"column":149}},"range":[2057,2186],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants"],"originalLines":"                if (_this.statementCoversMutant(mutant.location, location) && _this.isNewSmallestStatement(statementMap[smallestStatement], location)) {","mutatedLines":"                if (false) {"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":93,"column":49},"end":{"line":95,"column":5}},"range":[3743,3835],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    Mutant.prototype.reset = function (filename) {\r\n        return StrykerTempFolder_1.default.writeFile(filename, this.originalCode);\r\n    };","mutatedLines":"    Mutant.prototype.reset = function (filename) {\n};"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":45,"column":151},"end":{"line":47,"column":17}},"range":[2188,2262],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants"],"originalLines":"                if (_this.statementCoversMutant(mutant.location, location) && _this.isNewSmallestStatement(statementMap[smallestStatement], location)) {\r\n                    smallestStatement = statementId;\r\n                }","mutatedLines":"                if (_this.statementCoversMutant(mutant.location, location) && _this.isNewSmallestStatement(statementMap[smallestStatement], location)) {\n}"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":60,"column":12},"end":{"line":60,"column":29}},"range":[2923,2940],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants \"before each\" hook for \"should not have added the run results to the mutants\""],"originalLines":"        if (!originalLocation) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":60,"column":12},"end":{"line":60,"column":29}},"range":[2923,2940],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)"],"originalLines":"        if (!originalLocation) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":60,"column":31},"end":{"line":62,"column":9}},"range":[2942,3004],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants"],"originalLines":"        if (!originalLocation) {\r\n            statementIsSmallestStatement = true;\r\n        }","mutatedLines":"        if (!originalLocation) {\n}"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":63,"column":13},"end":{"line":70,"column":9}},"range":[3019,3537],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants"],"originalLines":"        else {\r\n            var lineDifference = (originalLocation.end.line - originalLocation.start.line) - (newLocation.end.line - newLocation.start.line);\r\n            var coversLessLines = lineDifference > 0;\r\n            var coversLessColumns = lineDifference === 0 && (newLocation.start.column - originalLocation.start.column) + (originalLocation.end.column - newLocation.end.column) > 0;\r\n            if (coversLessLines || coversLessColumns) {\r\n                statementIsSmallestStatement = true;\r\n            }\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":58,"column":98},"end":{"line":72,"column":5}},"range":[2857,3590],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants"],"originalLines":"    MutantTestMatcher.prototype.isNewSmallestStatement = function (originalLocation, newLocation) {\r\n        var statementIsSmallestStatement = false;\r\n        if (!originalLocation) {\r\n            statementIsSmallestStatement = true;\r\n        }\r\n        else {\r\n            var lineDifference = (originalLocation.end.line - originalLocation.start.line) - (newLocation.end.line - newLocation.start.line);\r\n            var coversLessLines = lineDifference > 0;\r\n            var coversLessColumns = lineDifference === 0 && (newLocation.start.column - originalLocation.start.column) + (originalLocation.end.column - newLocation.end.column) > 0;\r\n            if (coversLessLines || coversLessColumns) {\r\n                statementIsSmallestStatement = true;\r\n            }\r\n        }\r\n        return statementIsSmallestStatement;\r\n    };","mutatedLines":"    MutantTestMatcher.prototype.isNewSmallestStatement = function (originalLocation, newLocation) {\n};"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BinaryOperator","status":2,"replacement":"originalLocation.end.line - originalLocation.start.line + (newLocation.end.line - newLocation.start.line)","location":{"start":{"line":64,"column":33},"end":{"line":64,"column":140}},"range":[3055,3162],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)"],"originalLines":"            var lineDifference = (originalLocation.end.line - originalLocation.start.line) - (newLocation.end.line - newLocation.start.line);","mutatedLines":"            var lineDifference = originalLocation.end.line - originalLocation.start.line + (newLocation.end.line - newLocation.start.line);"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BinaryOperator","status":1,"replacement":"newLocation.end.line + newLocation.start.line","location":{"start":{"line":64,"column":94},"end":{"line":64,"column":139}},"range":[3116,3161],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants"],"originalLines":"            var lineDifference = (originalLocation.end.line - originalLocation.start.line) - (newLocation.end.line - newLocation.start.line);","mutatedLines":"            var lineDifference = (originalLocation.end.line - originalLocation.start.line) - (newLocation.end.line + newLocation.start.line);"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BinaryOperator","status":2,"replacement":"originalLocation.end.line + originalLocation.start.line","location":{"start":{"line":64,"column":34},"end":{"line":64,"column":89}},"range":[3056,3111],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)"],"originalLines":"            var lineDifference = (originalLocation.end.line - originalLocation.start.line) - (newLocation.end.line - newLocation.start.line);","mutatedLines":"            var lineDifference = (originalLocation.end.line + originalLocation.start.line) - (newLocation.end.line - newLocation.start.line);"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BinaryOperator","status":2,"replacement":"lineDifference >= 0","location":{"start":{"line":65,"column":34},"end":{"line":65,"column":52}},"range":[3199,3217],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)"],"originalLines":"            var coversLessLines = lineDifference > 0;","mutatedLines":"            var coversLessLines = lineDifference >= 0;"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BinaryOperator","status":1,"replacement":"lineDifference <= 0","location":{"start":{"line":65,"column":34},"end":{"line":65,"column":52}},"range":[3199,3217],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants"],"originalLines":"            var coversLessLines = lineDifference > 0;","mutatedLines":"            var coversLessLines = lineDifference <= 0;"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"LogicalOperator","status":2,"replacement":"lineDifference === 0 || newLocation.start.column - originalLocation.start.column + (originalLocation.end.column - newLocation.end.column) > 0","location":{"start":{"line":66,"column":36},"end":{"line":66,"column":179}},"range":[3256,3399],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)"],"originalLines":"            var coversLessColumns = lineDifference === 0 && (newLocation.start.column - originalLocation.start.column) + (originalLocation.end.column - newLocation.end.column) > 0;","mutatedLines":"            var coversLessColumns = lineDifference === 0 || newLocation.start.column - originalLocation.start.column + (originalLocation.end.column - newLocation.end.column) > 0;"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BinaryOperator","status":1,"replacement":"lineDifference !== 0","location":{"start":{"line":66,"column":36},"end":{"line":66,"column":56}},"range":[3256,3276],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants"],"originalLines":"            var coversLessColumns = lineDifference === 0 && (newLocation.start.column - originalLocation.start.column) + (originalLocation.end.column - newLocation.end.column) > 0;","mutatedLines":"            var coversLessColumns = lineDifference !== 0 && (newLocation.start.column - originalLocation.start.column) + (originalLocation.end.column - newLocation.end.column) > 0;"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BinaryOperator","status":2,"replacement":"newLocation.start.column - originalLocation.start.column + (originalLocation.end.column - newLocation.end.column) >= 0","location":{"start":{"line":66,"column":60},"end":{"line":66,"column":179}},"range":[3280,3399],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)"],"originalLines":"            var coversLessColumns = lineDifference === 0 && (newLocation.start.column - originalLocation.start.column) + (originalLocation.end.column - newLocation.end.column) > 0;","mutatedLines":"            var coversLessColumns = lineDifference === 0 && newLocation.start.column - originalLocation.start.column + (originalLocation.end.column - newLocation.end.column) >= 0;"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BinaryOperator","status":1,"replacement":"newLocation.start.column - originalLocation.start.column + (originalLocation.end.column - newLocation.end.column) <= 0","location":{"start":{"line":66,"column":60},"end":{"line":66,"column":179}},"range":[3280,3399],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants"],"originalLines":"            var coversLessColumns = lineDifference === 0 && (newLocation.start.column - originalLocation.start.column) + (originalLocation.end.column - newLocation.end.column) > 0;","mutatedLines":"            var coversLessColumns = lineDifference === 0 && newLocation.start.column - originalLocation.start.column + (originalLocation.end.column - newLocation.end.column) <= 0;"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BinaryOperator","status":2,"replacement":"newLocation.start.column - originalLocation.start.column - (originalLocation.end.column - newLocation.end.column)","location":{"start":{"line":66,"column":60},"end":{"line":66,"column":175}},"range":[3280,3395],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)"],"originalLines":"            var coversLessColumns = lineDifference === 0 && (newLocation.start.column - originalLocation.start.column) + (originalLocation.end.column - newLocation.end.column) > 0;","mutatedLines":"            var coversLessColumns = lineDifference === 0 && newLocation.start.column - originalLocation.start.column - (originalLocation.end.column - newLocation.end.column) > 0;"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BinaryOperator","status":2,"replacement":"newLocation.start.column + originalLocation.start.column","location":{"start":{"line":66,"column":61},"end":{"line":66,"column":117}},"range":[3281,3337],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)"],"originalLines":"            var coversLessColumns = lineDifference === 0 && (newLocation.start.column - originalLocation.start.column) + (originalLocation.end.column - newLocation.end.column) > 0;","mutatedLines":"            var coversLessColumns = lineDifference === 0 && (newLocation.start.column + originalLocation.start.column) + (originalLocation.end.column - newLocation.end.column) > 0;"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BinaryOperator","status":2,"replacement":"originalLocation.end.column + newLocation.end.column","location":{"start":{"line":66,"column":122},"end":{"line":66,"column":174}},"range":[3342,3394],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)"],"originalLines":"            var coversLessColumns = lineDifference === 0 && (newLocation.start.column - originalLocation.start.column) + (originalLocation.end.column - newLocation.end.column) > 0;","mutatedLines":"            var coversLessColumns = lineDifference === 0 && (newLocation.start.column - originalLocation.start.column) + (originalLocation.end.column + newLocation.end.column) > 0;"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":67,"column":16},"end":{"line":67,"column":52}},"range":[3418,3454],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants"],"originalLines":"            if (coversLessLines || coversLessColumns) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":67,"column":16},"end":{"line":67,"column":52}},"range":[3418,3454],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)"],"originalLines":"            if (coversLessLines || coversLessColumns) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"LogicalOperator","status":1,"replacement":"coversLessLines && coversLessColumns","location":{"start":{"line":67,"column":16},"end":{"line":67,"column":52}},"range":[3418,3454],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants"],"originalLines":"            if (coversLessLines || coversLessColumns) {","mutatedLines":"            if (coversLessLines && coversLessColumns) {"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":67,"column":54},"end":{"line":69,"column":13}},"range":[3456,3526],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants"],"originalLines":"            if (coversLessLines || coversLessColumns) {\r\n                statementIsSmallestStatement = true;\r\n            }","mutatedLines":"            if (coversLessLines || coversLessColumns) {\n}"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"LogicalOperator","status":1,"replacement":"mutantLocation.start.line > statementLocation.start.line && (mutantLocation.start.line === statementLocation.start.line && mutantLocation.start.column >= statementLocation.start.column)","location":{"start":{"line":80,"column":33},"end":{"line":81,"column":137}},"range":[3982,4180],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants"],"originalLines":"        var mutantIsAfterStart = mutantLocation.start.line > statementLocation.start.line ||\r\n            (mutantLocation.start.line === statementLocation.start.line && mutantLocation.start.column >= statementLocation.start.column);","mutatedLines":"        var mutantIsAfterStart = mutantLocation.start.line > statementLocation.start.line && (mutantLocation.start.line === statementLocation.start.line && mutantLocation.start.column >= statementLocation.start.column);"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BinaryOperator","status":1,"replacement":"mutantLocation.start.line >= statementLocation.start.line","location":{"start":{"line":80,"column":33},"end":{"line":80,"column":89}},"range":[3982,4038],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants"],"originalLines":"        var mutantIsAfterStart = mutantLocation.start.line > statementLocation.start.line ||","mutatedLines":"        var mutantIsAfterStart = mutantLocation.start.line >= statementLocation.start.line ||"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"LogicalOperator","status":1,"replacement":"mutantLocation.start.line === statementLocation.start.line || mutantLocation.start.column >= statementLocation.start.column","location":{"start":{"line":81,"column":13},"end":{"line":81,"column":136}},"range":[4056,4179],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants"],"originalLines":"            (mutantLocation.start.line === statementLocation.start.line && mutantLocation.start.column >= statementLocation.start.column);","mutatedLines":"            (mutantLocation.start.line === statementLocation.start.line || mutantLocation.start.column >= statementLocation.start.column);"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BinaryOperator","status":1,"replacement":"mutantLocation.start.line <= statementLocation.start.line","location":{"start":{"line":80,"column":33},"end":{"line":80,"column":89}},"range":[3982,4038],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants"],"originalLines":"        var mutantIsAfterStart = mutantLocation.start.line > statementLocation.start.line ||","mutatedLines":"        var mutantIsAfterStart = mutantLocation.start.line <= statementLocation.start.line ||"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BinaryOperator","status":1,"replacement":"mutantLocation.start.line !== statementLocation.start.line","location":{"start":{"line":81,"column":13},"end":{"line":81,"column":71}},"range":[4056,4114],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants"],"originalLines":"            (mutantLocation.start.line === statementLocation.start.line && mutantLocation.start.column >= statementLocation.start.column);","mutatedLines":"            (mutantLocation.start.line !== statementLocation.start.line && mutantLocation.start.column >= statementLocation.start.column);"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":79,"column":101},"end":{"line":85,"column":5}},"range":[3946,4466],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants"],"originalLines":"    MutantTestMatcher.prototype.statementCoversMutant = function (mutantLocation, statementLocation) {\r\n        var mutantIsAfterStart = mutantLocation.start.line > statementLocation.start.line ||\r\n            (mutantLocation.start.line === statementLocation.start.line && mutantLocation.start.column >= statementLocation.start.column);\r\n        var mutantIsBeforeEnd = mutantLocation.end.line < statementLocation.end.line ||\r\n            (mutantLocation.end.line === statementLocation.end.line && mutantLocation.end.column <= statementLocation.end.column);\r\n        return mutantIsAfterStart && mutantIsBeforeEnd;\r\n    };","mutatedLines":"    MutantTestMatcher.prototype.statementCoversMutant = function (mutantLocation, statementLocation) {\n};"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BinaryOperator","status":1,"replacement":"mutantLocation.start.column > statementLocation.start.column","location":{"start":{"line":81,"column":75},"end":{"line":81,"column":136}},"range":[4118,4179],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants"],"originalLines":"            (mutantLocation.start.line === statementLocation.start.line && mutantLocation.start.column >= statementLocation.start.column);","mutatedLines":"            (mutantLocation.start.line === statementLocation.start.line && mutantLocation.start.column > statementLocation.start.column);"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BinaryOperator","status":1,"replacement":"mutantLocation.start.column < statementLocation.start.column","location":{"start":{"line":81,"column":75},"end":{"line":81,"column":136}},"range":[4118,4179],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants"],"originalLines":"            (mutantLocation.start.line === statementLocation.start.line && mutantLocation.start.column >= statementLocation.start.column);","mutatedLines":"            (mutantLocation.start.line === statementLocation.start.line && mutantLocation.start.column < statementLocation.start.column);"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"LogicalOperator","status":1,"replacement":"mutantLocation.end.line < statementLocation.end.line && (mutantLocation.end.line === statementLocation.end.line && mutantLocation.end.column <= statementLocation.end.column)","location":{"start":{"line":82,"column":32},"end":{"line":83,"column":129}},"range":[4215,4401],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants"],"originalLines":"        var mutantIsBeforeEnd = mutantLocation.end.line < statementLocation.end.line ||\r\n            (mutantLocation.end.line === statementLocation.end.line && mutantLocation.end.column <= statementLocation.end.column);","mutatedLines":"        var mutantIsBeforeEnd = mutantLocation.end.line < statementLocation.end.line && (mutantLocation.end.line === statementLocation.end.line && mutantLocation.end.column <= statementLocation.end.column);"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BinaryOperator","status":2,"replacement":"mutantLocation.end.line <= statementLocation.end.line","location":{"start":{"line":82,"column":32},"end":{"line":82,"column":84}},"range":[4215,4267],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)"],"originalLines":"        var mutantIsBeforeEnd = mutantLocation.end.line < statementLocation.end.line ||","mutatedLines":"        var mutantIsBeforeEnd = mutantLocation.end.line <= statementLocation.end.line ||"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BinaryOperator","status":2,"replacement":"mutantLocation.end.line >= statementLocation.end.line","location":{"start":{"line":82,"column":32},"end":{"line":82,"column":84}},"range":[4215,4267],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)"],"originalLines":"        var mutantIsBeforeEnd = mutantLocation.end.line < statementLocation.end.line ||","mutatedLines":"        var mutantIsBeforeEnd = mutantLocation.end.line >= statementLocation.end.line ||"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"LogicalOperator","status":2,"replacement":"mutantLocation.end.line === statementLocation.end.line || mutantLocation.end.column <= statementLocation.end.column","location":{"start":{"line":83,"column":13},"end":{"line":83,"column":128}},"range":[4285,4400],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)"],"originalLines":"            (mutantLocation.end.line === statementLocation.end.line && mutantLocation.end.column <= statementLocation.end.column);","mutatedLines":"            (mutantLocation.end.line === statementLocation.end.line || mutantLocation.end.column <= statementLocation.end.column);"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BinaryOperator","status":1,"replacement":"mutantLocation.end.line !== statementLocation.end.line","location":{"start":{"line":83,"column":13},"end":{"line":83,"column":67}},"range":[4285,4339],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants"],"originalLines":"            (mutantLocation.end.line === statementLocation.end.line && mutantLocation.end.column <= statementLocation.end.column);","mutatedLines":"            (mutantLocation.end.line !== statementLocation.end.line && mutantLocation.end.column <= statementLocation.end.column);"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BinaryOperator","status":1,"replacement":"mutantLocation.end.column < statementLocation.end.column","location":{"start":{"line":83,"column":71},"end":{"line":83,"column":128}},"range":[4343,4400],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants"],"originalLines":"            (mutantLocation.end.line === statementLocation.end.line && mutantLocation.end.column <= statementLocation.end.column);","mutatedLines":"            (mutantLocation.end.line === statementLocation.end.line && mutantLocation.end.column < statementLocation.end.column);"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BinaryOperator","status":1,"replacement":"mutantLocation.end.column > statementLocation.end.column","location":{"start":{"line":83,"column":71},"end":{"line":83,"column":128}},"range":[4343,4400],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants"],"originalLines":"            (mutantLocation.end.line === statementLocation.end.line && mutantLocation.end.column <= statementLocation.end.column);","mutatedLines":"            (mutantLocation.end.line === statementLocation.end.line && mutantLocation.end.column > statementLocation.end.column);"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"LogicalOperator","status":1,"replacement":"mutantIsAfterStart || mutantIsBeforeEnd","location":{"start":{"line":84,"column":15},"end":{"line":84,"column":54}},"range":[4419,4458],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants"],"originalLines":"        return mutantIsAfterStart && mutantIsBeforeEnd;","mutatedLines":"        return mutantIsAfterStart || mutantIsBeforeEnd;"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":87,"column":12},"end":{"line":87,"column":42}},"range":[4566,4596],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants"],"originalLines":"        if (this.initialRunResult.coverage) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":87,"column":12},"end":{"line":87,"column":42}},"range":[4566,4596],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info \"before each\" hook for \"should add both tests to the mutants\""],"originalLines":"        if (this.initialRunResult.coverage) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":87,"column":44},"end":{"line":94,"column":9}},"range":[4598,4865],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants"],"originalLines":"        if (this.initialRunResult.coverage) {\r\n            if (this.isCoverageCollectionPerTest(this.initialRunResult.coverage)) {\r\n                return this.initialRunResult.coverage[testId];\r\n            }\r\n            else {\r\n                return this.initialRunResult.coverage;\r\n            }\r\n        }","mutatedLines":"        if (this.initialRunResult.coverage) {\n}"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":88,"column":16},"end":{"line":88,"column":80}},"range":[4617,4681],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants"],"originalLines":"            if (this.isCoverageCollectionPerTest(this.initialRunResult.coverage)) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":88,"column":16},"end":{"line":88,"column":80}},"range":[4617,4681],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)"],"originalLines":"            if (this.isCoverageCollectionPerTest(this.initialRunResult.coverage)) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":86,"column":82},"end":{"line":98,"column":5}},"range":[4551,4925],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants"],"originalLines":"    MutantTestMatcher.prototype.findCoverageCollectionForTest = function (testId) {\r\n        if (this.initialRunResult.coverage) {\r\n            if (this.isCoverageCollectionPerTest(this.initialRunResult.coverage)) {\r\n                return this.initialRunResult.coverage[testId];\r\n            }\r\n            else {\r\n                return this.initialRunResult.coverage;\r\n            }\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    };","mutatedLines":"    MutantTestMatcher.prototype.findCoverageCollectionForTest = function (testId) {\n};"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":91,"column":17},"end":{"line":93,"column":13}},"range":[4782,4854],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)"],"originalLines":"            else {\r\n                return this.initialRunResult.coverage;\r\n            }","mutatedLines":"            else {\n}"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":88,"column":82},"end":{"line":90,"column":13}},"range":[4683,4763],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants"],"originalLines":"            if (this.isCoverageCollectionPerTest(this.initialRunResult.coverage)) {\r\n                return this.initialRunResult.coverage[testId];\r\n            }","mutatedLines":"            if (this.isCoverageCollectionPerTest(this.initialRunResult.coverage)) {\n}"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":95,"column":13},"end":{"line":97,"column":9}},"range":[4880,4918],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)"],"originalLines":"        else {\r\n            return null;\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BinaryOperator","status":1,"replacement":"this.options.coverageAnalysis !== 'perTest'","location":{"start":{"line":100,"column":15},"end":{"line":100,"column":58}},"range":[5028,5071],"testsRan":["MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants"],"originalLines":"        return this.options.coverageAnalysis === 'perTest';","mutatedLines":"        return this.options.coverageAnalysis !== 'perTest';"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":28,"column":60},"end":{"line":28,"column":126}},"range":[1285,1351],"testsRan":["MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant"],"originalLines":"        mutatorFactory.knownNames().forEach(function (name) { return _this.mutators.push(mutatorFactory.create(name, null)); });","mutatedLines":"        mutatorFactory.knownNames().forEach(function (name) {\n});"},{"sourceFilePath":"/stryker/src/MutantTestMatcher.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":99,"column":82},"end":{"line":101,"column":5}},"range":[5010,5079],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants"],"originalLines":"    MutantTestMatcher.prototype.isCoverageCollectionPerTest = function (coverage) {\r\n        return this.options.coverageAnalysis === 'perTest';\r\n    };","mutatedLines":"    MutantTestMatcher.prototype.isCoverageCollectionPerTest = function (coverage) {\n};"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":22,"column":43},"end":{"line":29,"column":5}},"range":[1024,1360],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated"],"originalLines":"    function MutatorOrchestrator(reporter) {\r\n        var _this = this;\r\n        this.reporter = reporter;\r\n        this.mutators = [];\r\n        this.registerDefaultMutators();\r\n        var mutatorFactory = mutant_1.MutatorFactory.instance();\r\n        mutatorFactory.knownNames().forEach(function (name) { return _this.mutators.push(mutatorFactory.create(name, null)); });\r\n    }","mutatedLines":"    function MutatorOrchestrator(reporter) {\n}"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":18,"column":39},"end":{"line":125,"column":1}},"range":[891,6344],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator \"before each\" hook for \"should throw an error if no source files are provided\""],"originalLines":"var MutatorOrchestrator = (function () {\r\n    /**\r\n     * @param reporter - The reporter to report read input files to\r\n     */\r\n    function MutatorOrchestrator(reporter) {\r\n        var _this = this;\r\n        this.reporter = reporter;\r\n        this.mutators = [];\r\n        this.registerDefaultMutators();\r\n        var mutatorFactory = mutant_1.MutatorFactory.instance();\r\n        mutatorFactory.knownNames().forEach(function (name) { return _this.mutators.push(mutatorFactory.create(name, null)); });\r\n    }\r\n    /**\r\n     * Mutates source files. Mutated code is not writen to disk.\r\n     * @function\r\n     * @param sourceFiles - The list of files which should be mutated.\r\n     * @returns {Mutant[]} The generated Mutants.\r\n     */\r\n    MutatorOrchestrator.prototype.generateMutants = function (sourceFiles) {\r\n        var _this = this;\r\n        var mutants = [];\r\n        this.sourceFiles = [];\r\n        sourceFiles.forEach(function (sourceFile) {\r\n            try {\r\n                var fileContent = fileUtils.readFile(sourceFile);\r\n                _this.reportFileRead(sourceFile, fileContent);\r\n                var abstractSyntaxTree = parserUtils.parse(fileContent);\r\n                var nodes = parserUtils.collectFrozenNodes(abstractSyntaxTree);\r\n                var newMutants = _this.findMutants(sourceFile, fileContent, abstractSyntaxTree, nodes);\r\n                mutants = mutants.concat(newMutants);\r\n            }\r\n            catch (err) {\r\n                switch (err.code) {\r\n                    case 'ENOENT':\r\n                        log.info(\"Skipping file \" + err.path + \" because it does not exist\");\r\n                        break;\r\n                    default:\r\n                        console.log(err);\r\n                        throw err;\r\n                }\r\n            }\r\n        });\r\n        this.reportAllFilesRead();\r\n        return mutants;\r\n    };\r\n    ;\r\n    MutatorOrchestrator.prototype.reportFileRead = function (path, content) {\r\n        var fileToReport = { path: path, content: content };\r\n        objectUtils_1.freezeRecursively(fileToReport);\r\n        this.sourceFiles.push(fileToReport);\r\n        this.reporter.onSourceFileRead(fileToReport);\r\n    };\r\n    MutatorOrchestrator.prototype.reportAllFilesRead = function () {\r\n        objectUtils_1.freezeRecursively(this.sourceFiles);\r\n        this.reporter.onAllSourceFilesRead(this.sourceFiles);\r\n    };\r\n    MutatorOrchestrator.prototype.registerDefaultMutators = function () {\r\n        var mutatorFactory = mutant_1.MutatorFactory.instance();\r\n        mutatorFactory.register('BinaryOperator', BinaryOperatorMutator_1.default);\r\n        mutatorFactory.register('BlockStatement', BlockStatementMutator_1.default);\r\n        mutatorFactory.register('LogicalOperator', LogicalOperatorMutator_1.default);\r\n        mutatorFactory.register('RemoveConditionals', RemoveConditionalsMutator_1.default);\r\n        mutatorFactory.register('UnaryOperator', UnaryOperatorMutator_1.default);\r\n        mutatorFactory.register('UpdateOperator', UpdateOperatorMutator_1.default);\r\n    };\r\n    /**\r\n     * Finds all mutants for a given set of nodes.\r\n     * @function\r\n     * @param {String} sourceFile - The name source file.\r\n     * @param {String} originalCode - The original content of the file which has not been mutated.\r\n     * @param {Object} ast - The original abstract syntax tree which is used for reference when generating code.\r\n     * @param {AbstractSyntaxTreeNode[]} nodes - The nodes which could be used by mutations to generate mutants.\r\n     * @returns {Mutant[]} All possible Mutants for the given set of nodes.\r\n     */\r\n    MutatorOrchestrator.prototype.findMutants = function (sourceFile, originalCode, ast, nodes) {\r\n        var _this = this;\r\n        var mutants = [];\r\n        nodes.forEach(function (astnode) {\r\n            if (astnode.type) {\r\n                Object.freeze(astnode);\r\n                _this.mutators.forEach(function (mutator) {\r\n                    try {\r\n                        var mutatedNodes = mutator.applyMutations(astnode, objectUtils_1.copy);\r\n                        if (mutatedNodes) {\r\n                            if (!Array.isArray(mutatedNodes)) {\r\n                                mutatedNodes = [mutatedNodes];\r\n                            }\r\n                            if (mutatedNodes.length > 0) {\r\n                                log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);\r\n                            }\r\n                            mutatedNodes.forEach(function (mutatedNode) {\r\n                                var mutatedCode = parserUtils.generate(mutatedNode);\r\n                                var originalNode = nodes[mutatedNode.nodeID];\r\n                                mutants.push(new Mutant_1.default(mutator.name, sourceFile, originalCode, mutatedCode, originalNode.loc, originalNode.range));\r\n                            });\r\n                        }\r\n                    }\r\n                    catch (error) {\r\n                        throw new Error(\"The mutator named '\" + mutator.name + \"' caused an error: \" + error);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n        return mutants;\r\n    };\r\n    ;\r\n    return MutatorOrchestrator;\r\n}());","mutatedLines":"var MutatorOrchestrator = (function () {\n}());"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":40,"column":50},"end":{"line":59,"column":9}},"range":[1801,2663],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant"],"originalLines":"        sourceFiles.forEach(function (sourceFile) {\r\n            try {\r\n                var fileContent = fileUtils.readFile(sourceFile);\r\n                _this.reportFileRead(sourceFile, fileContent);\r\n                var abstractSyntaxTree = parserUtils.parse(fileContent);\r\n                var nodes = parserUtils.collectFrozenNodes(abstractSyntaxTree);\r\n                var newMutants = _this.findMutants(sourceFile, fileContent, abstractSyntaxTree, nodes);\r\n                mutants = mutants.concat(newMutants);\r\n            }\r\n            catch (err) {\r\n                switch (err.code) {\r\n                    case 'ENOENT':\r\n                        log.info(\"Skipping file \" + err.path + \" because it does not exist\");\r\n                        break;\r\n                    default:\r\n                        console.log(err);\r\n                        throw err;\r\n                }\r\n            }\r\n        });","mutatedLines":"        sourceFiles.forEach(function (sourceFile) {\n});"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":41,"column":16},"end":{"line":48,"column":13}},"range":[1820,2282],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant"],"originalLines":"            try {\r\n                var fileContent = fileUtils.readFile(sourceFile);\r\n                _this.reportFileRead(sourceFile, fileContent);\r\n                var abstractSyntaxTree = parserUtils.parse(fileContent);\r\n                var nodes = parserUtils.collectFrozenNodes(abstractSyntaxTree);\r\n                var newMutants = _this.findMutants(sourceFile, fileContent, abstractSyntaxTree, nodes);\r\n                mutants = mutants.concat(newMutants);\r\n            }","mutatedLines":"            try {\n}"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":36,"column":75},"end":{"line":62,"column":5}},"range":[1662,2733],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided"],"originalLines":"    MutatorOrchestrator.prototype.generateMutants = function (sourceFiles) {\r\n        var _this = this;\r\n        var mutants = [];\r\n        this.sourceFiles = [];\r\n        sourceFiles.forEach(function (sourceFile) {\r\n            try {\r\n                var fileContent = fileUtils.readFile(sourceFile);\r\n                _this.reportFileRead(sourceFile, fileContent);\r\n                var abstractSyntaxTree = parserUtils.parse(fileContent);\r\n                var nodes = parserUtils.collectFrozenNodes(abstractSyntaxTree);\r\n                var newMutants = _this.findMutants(sourceFile, fileContent, abstractSyntaxTree, nodes);\r\n                mutants = mutants.concat(newMutants);\r\n            }\r\n            catch (err) {\r\n                switch (err.code) {\r\n                    case 'ENOENT':\r\n                        log.info(\"Skipping file \" + err.path + \" because it does not exist\");\r\n                        break;\r\n                    default:\r\n                        console.log(err);\r\n                        throw err;\r\n                }\r\n            }\r\n        });\r\n        this.reportAllFilesRead();\r\n        return mutants;\r\n    };","mutatedLines":"    MutatorOrchestrator.prototype.generateMutants = function (sourceFiles) {\n};"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BinaryOperator","status":2,"replacement":"'Skipping file ' + err.path - ' because it does not exist'","location":{"start":{"line":52,"column":33},"end":{"line":52,"column":91}},"range":[2417,2475],"testsRan":["MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant"],"originalLines":"                        log.info(\"Skipping file \" + err.path + \" because it does not exist\");","mutatedLines":"                        log.info('Skipping file ' + err.path - ' because it does not exist');"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BinaryOperator","status":2,"replacement":"'Skipping file ' - err.path","location":{"start":{"line":52,"column":33},"end":{"line":52,"column":60}},"range":[2417,2444],"testsRan":["MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant"],"originalLines":"                        log.info(\"Skipping file \" + err.path + \" because it does not exist\");","mutatedLines":"                        log.info('Skipping file ' - err.path + \" because it does not exist\");"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":49,"column":24},"end":{"line":58,"column":13}},"range":[2308,2652],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID"],"originalLines":"            catch (err) {\r\n                switch (err.code) {\r\n                    case 'ENOENT':\r\n                        log.info(\"Skipping file \" + err.path + \" because it does not exist\");\r\n                        break;\r\n                    default:\r\n                        console.log(err);\r\n                        throw err;\r\n                }\r\n            }","mutatedLines":"            catch (err) {\n}"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":64,"column":76},"end":{"line":69,"column":5}},"range":[2819,3046],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead"],"originalLines":"    MutatorOrchestrator.prototype.reportFileRead = function (path, content) {\r\n        var fileToReport = { path: path, content: content };\r\n        objectUtils_1.freezeRecursively(fileToReport);\r\n        this.sourceFiles.push(fileToReport);\r\n        this.reporter.onSourceFileRead(fileToReport);\r\n    };","mutatedLines":"    MutatorOrchestrator.prototype.reportFileRead = function (path, content) {\n};"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":70,"column":67},"end":{"line":73,"column":5}},"range":[3116,3247],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead"],"originalLines":"    MutatorOrchestrator.prototype.reportAllFilesRead = function () {\r\n        objectUtils_1.freezeRecursively(this.sourceFiles);\r\n        this.reporter.onAllSourceFilesRead(this.sourceFiles);\r\n    };","mutatedLines":"    MutatorOrchestrator.prototype.reportAllFilesRead = function () {\n};"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":95,"column":41},"end":{"line":120,"column":9}},"range":[4663,6266],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code"],"originalLines":"        nodes.forEach(function (astnode) {\r\n            if (astnode.type) {\r\n                Object.freeze(astnode);\r\n                _this.mutators.forEach(function (mutator) {\r\n                    try {\r\n                        var mutatedNodes = mutator.applyMutations(astnode, objectUtils_1.copy);\r\n                        if (mutatedNodes) {\r\n                            if (!Array.isArray(mutatedNodes)) {\r\n                                mutatedNodes = [mutatedNodes];\r\n                            }\r\n                            if (mutatedNodes.length > 0) {\r\n                                log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);\r\n                            }\r\n                            mutatedNodes.forEach(function (mutatedNode) {\r\n                                var mutatedCode = parserUtils.generate(mutatedNode);\r\n                                var originalNode = nodes[mutatedNode.nodeID];\r\n                                mutants.push(new Mutant_1.default(mutator.name, sourceFile, originalCode, mutatedCode, originalNode.loc, originalNode.range));\r\n                            });\r\n                        }\r\n                    }\r\n                    catch (error) {\r\n                        throw new Error(\"The mutator named '\" + mutator.name + \"' caused an error: \" + error);\r\n                    }\r\n                });\r\n            }\r\n        });","mutatedLines":"        nodes.forEach(function (astnode) {\n});"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":96,"column":16},"end":{"line":96,"column":28}},"range":[4682,4694],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code"],"originalLines":"            if (astnode.type) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":92,"column":96},"end":{"line":122,"column":5}},"range":[4565,6300],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated"],"originalLines":"    MutatorOrchestrator.prototype.findMutants = function (sourceFile, originalCode, ast, nodes) {\r\n        var _this = this;\r\n        var mutants = [];\r\n        nodes.forEach(function (astnode) {\r\n            if (astnode.type) {\r\n                Object.freeze(astnode);\r\n                _this.mutators.forEach(function (mutator) {\r\n                    try {\r\n                        var mutatedNodes = mutator.applyMutations(astnode, objectUtils_1.copy);\r\n                        if (mutatedNodes) {\r\n                            if (!Array.isArray(mutatedNodes)) {\r\n                                mutatedNodes = [mutatedNodes];\r\n                            }\r\n                            if (mutatedNodes.length > 0) {\r\n                                log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);\r\n                            }\r\n                            mutatedNodes.forEach(function (mutatedNode) {\r\n                                var mutatedCode = parserUtils.generate(mutatedNode);\r\n                                var originalNode = nodes[mutatedNode.nodeID];\r\n                                mutants.push(new Mutant_1.default(mutator.name, sourceFile, originalCode, mutatedCode, originalNode.loc, originalNode.range));\r\n                            });\r\n                        }\r\n                    }\r\n                    catch (error) {\r\n                        throw new Error(\"The mutator named '\" + mutator.name + \"' caused an error: \" + error);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n        return mutants;\r\n    };","mutatedLines":"    MutatorOrchestrator.prototype.findMutants = function (sourceFile, originalCode, ast, nodes) {\n};"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":96,"column":16},"end":{"line":96,"column":28}},"range":[4682,4694],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID"],"originalLines":"            if (astnode.type) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":96,"column":30},"end":{"line":119,"column":13}},"range":[4696,6255],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code"],"originalLines":"            if (astnode.type) {\r\n                Object.freeze(astnode);\r\n                _this.mutators.forEach(function (mutator) {\r\n                    try {\r\n                        var mutatedNodes = mutator.applyMutations(astnode, objectUtils_1.copy);\r\n                        if (mutatedNodes) {\r\n                            if (!Array.isArray(mutatedNodes)) {\r\n                                mutatedNodes = [mutatedNodes];\r\n                            }\r\n                            if (mutatedNodes.length > 0) {\r\n                                log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);\r\n                            }\r\n                            mutatedNodes.forEach(function (mutatedNode) {\r\n                                var mutatedCode = parserUtils.generate(mutatedNode);\r\n                                var originalNode = nodes[mutatedNode.nodeID];\r\n                                mutants.push(new Mutant_1.default(mutator.name, sourceFile, originalCode, mutatedCode, originalNode.loc, originalNode.range));\r\n                            });\r\n                        }\r\n                    }\r\n                    catch (error) {\r\n                        throw new Error(\"The mutator named '\" + mutator.name + \"' caused an error: \" + error);\r\n                    }\r\n                });\r\n            }","mutatedLines":"            if (astnode.type) {\n}"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":98,"column":58},"end":{"line":118,"column":17}},"range":[4798,6238],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code"],"originalLines":"                _this.mutators.forEach(function (mutator) {\r\n                    try {\r\n                        var mutatedNodes = mutator.applyMutations(astnode, objectUtils_1.copy);\r\n                        if (mutatedNodes) {\r\n                            if (!Array.isArray(mutatedNodes)) {\r\n                                mutatedNodes = [mutatedNodes];\r\n                            }\r\n                            if (mutatedNodes.length > 0) {\r\n                                log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);\r\n                            }\r\n                            mutatedNodes.forEach(function (mutatedNode) {\r\n                                var mutatedCode = parserUtils.generate(mutatedNode);\r\n                                var originalNode = nodes[mutatedNode.nodeID];\r\n                                mutants.push(new Mutant_1.default(mutator.name, sourceFile, originalCode, mutatedCode, originalNode.loc, originalNode.range));\r\n                            });\r\n                        }\r\n                    }\r\n                    catch (error) {\r\n                        throw new Error(\"The mutator named '\" + mutator.name + \"' caused an error: \" + error);\r\n                    }\r\n                });","mutatedLines":"                _this.mutators.forEach(function (mutator) {\n});"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":99,"column":24},"end":{"line":114,"column":21}},"range":[4825,6047],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code"],"originalLines":"                    try {\r\n                        var mutatedNodes = mutator.applyMutations(astnode, objectUtils_1.copy);\r\n                        if (mutatedNodes) {\r\n                            if (!Array.isArray(mutatedNodes)) {\r\n                                mutatedNodes = [mutatedNodes];\r\n                            }\r\n                            if (mutatedNodes.length > 0) {\r\n                                log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);\r\n                            }\r\n                            mutatedNodes.forEach(function (mutatedNode) {\r\n                                var mutatedCode = parserUtils.generate(mutatedNode);\r\n                                var originalNode = nodes[mutatedNode.nodeID];\r\n                                mutants.push(new Mutant_1.default(mutator.name, sourceFile, originalCode, mutatedCode, originalNode.loc, originalNode.range));\r\n                            });\r\n                        }\r\n                    }","mutatedLines":"                    try {\n}"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":101,"column":28},"end":{"line":101,"column":40}},"range":[4953,4965],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code"],"originalLines":"                        if (mutatedNodes) {","mutatedLines":"                        if (false) {"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":101,"column":28},"end":{"line":101,"column":40}},"range":[4953,4965],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated"],"originalLines":"                        if (mutatedNodes) {","mutatedLines":"                        if (true) {"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":101,"column":42},"end":{"line":113,"column":25}},"range":[4967,6024],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code"],"originalLines":"                        if (mutatedNodes) {\r\n                            if (!Array.isArray(mutatedNodes)) {\r\n                                mutatedNodes = [mutatedNodes];\r\n                            }\r\n                            if (mutatedNodes.length > 0) {\r\n                                log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);\r\n                            }\r\n                            mutatedNodes.forEach(function (mutatedNode) {\r\n                                var mutatedCode = parserUtils.generate(mutatedNode);\r\n                                var originalNode = nodes[mutatedNode.nodeID];\r\n                                mutants.push(new Mutant_1.default(mutator.name, sourceFile, originalCode, mutatedCode, originalNode.loc, originalNode.range));\r\n                            });\r\n                        }","mutatedLines":"                        if (mutatedNodes) {\n}"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"RemoveConditionals","status":2,"replacement":"false","location":{"start":{"line":102,"column":32},"end":{"line":102,"column":60}},"range":[5002,5030],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID"],"originalLines":"                            if (!Array.isArray(mutatedNodes)) {","mutatedLines":"                            if (false) {"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":102,"column":32},"end":{"line":102,"column":60}},"range":[5002,5030],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated"],"originalLines":"                            if (!Array.isArray(mutatedNodes)) {","mutatedLines":"                            if (true) {"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":102,"column":62},"end":{"line":104,"column":29}},"range":[5032,5128],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID"],"originalLines":"                            if (!Array.isArray(mutatedNodes)) {\r\n                                mutatedNodes = [mutatedNodes];\r\n                            }","mutatedLines":"                            if (!Array.isArray(mutatedNodes)) {\n}"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"RemoveConditionals","status":2,"replacement":"false","location":{"start":{"line":105,"column":32},"end":{"line":105,"column":55}},"range":[5162,5185],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID"],"originalLines":"                            if (mutatedNodes.length > 0) {","mutatedLines":"                            if (false) {"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"LogicalOperator","status":3,"replacement":"startIndexLines > 0 || !this.isNewLine(startIndexLines - 1)","location":{"start":{"line":50,"column":15},"end":{"line":50,"column":74}},"range":[2060,2119],"testsRan":[],"originalLines":"        while (startIndexLines > 0 && !this.isNewLine(startIndexLines - 1)) {","mutatedLines":"        while (startIndexLines > 0 || !this.isNewLine(startIndexLines - 1)) {"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":105,"column":32},"end":{"line":105,"column":55}},"range":[5162,5185],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID"],"originalLines":"                            if (mutatedNodes.length > 0) {","mutatedLines":"                            if (true) {"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"LogicalOperator","status":3,"replacement":"endIndexLines < this.originalCode.length || !this.isNewLine(endIndexLines)","location":{"start":{"line":53,"column":15},"end":{"line":53,"column":89}},"range":[2182,2256],"testsRan":[],"originalLines":"        while (endIndexLines < this.originalCode.length && !this.isNewLine(endIndexLines)) {","mutatedLines":"        while (endIndexLines < this.originalCode.length || !this.isNewLine(endIndexLines)) {"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BlockStatement","status":3,"replacement":"{\n}","location":{"start":{"line":50,"column":76},"end":{"line":52,"column":9}},"range":[2121,2165],"testsRan":[],"originalLines":"        while (startIndexLines > 0 && !this.isNewLine(startIndexLines - 1)) {\r\n            startIndexLines--;\r\n        }","mutatedLines":"        while (startIndexLines > 0 && !this.isNewLine(startIndexLines - 1)) {\n}"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BinaryOperator","status":2,"replacement":"mutatedNodes.length >= 0","location":{"start":{"line":105,"column":32},"end":{"line":105,"column":55}},"range":[5162,5185],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID"],"originalLines":"                            if (mutatedNodes.length > 0) {","mutatedLines":"                            if (mutatedNodes.length >= 0) {"},{"sourceFilePath":"/stryker/src/Mutant.js","mutatorName":"BlockStatement","status":3,"replacement":"{\n}","location":{"start":{"line":53,"column":91},"end":{"line":55,"column":9}},"range":[2258,2300],"testsRan":[],"originalLines":"        while (endIndexLines < this.originalCode.length && !this.isNewLine(endIndexLines)) {\r\n            endIndexLines++;\r\n        }","mutatedLines":"        while (endIndexLines < this.originalCode.length && !this.isNewLine(endIndexLines)) {\n}"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BinaryOperator","status":2,"replacement":"'The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') + ' between (Ln ' + astnode.loc.start.line + ', Col ' + astnode.loc.start.column + ') and (Ln ' + astnode.loc.end.line - ', Col '","location":{"start":{"line":106,"column":42},"end":{"line":106,"column":288}},"range":[5232,5478],"testsRan":["MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID"],"originalLines":"                                log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);","mutatedLines":"                                log.debug('The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') + ' between (Ln ' + astnode.loc.start.line + ', Col ' + astnode.loc.start.column + ') and (Ln ' + astnode.loc.end.line - ', Col ' + astnode.loc.end.column + \") in file \" + sourceFile);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BinaryOperator","status":2,"replacement":"'The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') + ' between (Ln ' + astnode.loc.start.line + ', Col ' + astnode.loc.start.column + ') and (Ln ' + astnode.loc.end.line + ', Col ' + astnode.loc.end.column + ') in file ' - sourceFile","location":{"start":{"line":106,"column":42},"end":{"line":106,"column":341}},"range":[5232,5531],"testsRan":["MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID"],"originalLines":"                                log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);","mutatedLines":"                                log.debug('The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') + ' between (Ln ' + astnode.loc.start.line + ', Col ' + astnode.loc.start.column + ') and (Ln ' + astnode.loc.end.line + ', Col ' + astnode.loc.end.column + ') in file ' - sourceFile);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BinaryOperator","status":2,"replacement":"mutatedNodes.length <= 0","location":{"start":{"line":105,"column":32},"end":{"line":105,"column":55}},"range":[5162,5185],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID"],"originalLines":"                            if (mutatedNodes.length > 0) {","mutatedLines":"                            if (mutatedNodes.length <= 0) {"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BinaryOperator","status":2,"replacement":"'The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') + ' between (Ln ' + astnode.loc.start.line + ', Col ' + astnode.loc.start.column - ') and (Ln '","location":{"start":{"line":106,"column":42},"end":{"line":106,"column":254}},"range":[5232,5444],"testsRan":["MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID"],"originalLines":"                                log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);","mutatedLines":"                                log.debug('The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') + ' between (Ln ' + astnode.loc.start.line + ', Col ' + astnode.loc.start.column - ') and (Ln ' + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BinaryOperator","status":2,"replacement":"'The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') + ' between (Ln ' + astnode.loc.start.line + ', Col ' - astnode.loc.start.column","location":{"start":{"line":106,"column":42},"end":{"line":106,"column":239}},"range":[5232,5429],"testsRan":["MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID"],"originalLines":"                                log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);","mutatedLines":"                                log.debug('The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') + ' between (Ln ' + astnode.loc.start.line + ', Col ' - astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BinaryOperator","status":2,"replacement":"'The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') + ' between (Ln ' + astnode.loc.start.line - ', Col '","location":{"start":{"line":106,"column":42},"end":{"line":106,"column":212}},"range":[5232,5402],"testsRan":["MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID"],"originalLines":"                                log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);","mutatedLines":"                                log.debug('The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') + ' between (Ln ' + astnode.loc.start.line - ', Col ' + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BinaryOperator","status":2,"replacement":"'The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') - ' between (Ln '","location":{"start":{"line":106,"column":42},"end":{"line":106,"column":176}},"range":[5232,5366],"testsRan":["MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID"],"originalLines":"                                log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);","mutatedLines":"                                log.debug('The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') - ' between (Ln ' + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BinaryOperator","status":2,"replacement":"'The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') + ' between (Ln ' - astnode.loc.start.line","location":{"start":{"line":106,"column":42},"end":{"line":106,"column":201}},"range":[5232,5391],"testsRan":["MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID"],"originalLines":"                                log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);","mutatedLines":"                                log.debug('The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') + ' between (Ln ' - astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BinaryOperator","status":2,"replacement":"'The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' - (mutatedNodes.length > 1 ? 's' : '')","location":{"start":{"line":106,"column":42},"end":{"line":106,"column":158}},"range":[5232,5348],"testsRan":["MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID"],"originalLines":"                                log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);","mutatedLines":"                                log.debug('The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' - (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":74,"column":72},"end":{"line":82,"column":5}},"range":[3322,3914],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    MutatorOrchestrator.prototype.registerDefaultMutators = function () {\r\n        var mutatorFactory = mutant_1.MutatorFactory.instance();\r\n        mutatorFactory.register('BinaryOperator', BinaryOperatorMutator_1.default);\r\n        mutatorFactory.register('BlockStatement', BlockStatementMutator_1.default);\r\n        mutatorFactory.register('LogicalOperator', LogicalOperatorMutator_1.default);\r\n        mutatorFactory.register('RemoveConditionals', RemoveConditionalsMutator_1.default);\r\n        mutatorFactory.register('UnaryOperator', UnaryOperatorMutator_1.default);\r\n        mutatorFactory.register('UpdateOperator', UpdateOperatorMutator_1.default);\r\n    };","mutatedLines":"    MutatorOrchestrator.prototype.registerDefaultMutators = function () {\n};"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BinaryOperator","status":2,"replacement":"'The mutator \\'' + mutator.name + '\\' mutated ' - mutatedNodes.length","location":{"start":{"line":106,"column":42},"end":{"line":106,"column":109}},"range":[5232,5299],"testsRan":["MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID"],"originalLines":"                                log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);","mutatedLines":"                                log.debug('The mutator \\'' + mutator.name + '\\' mutated ' - mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BinaryOperator","status":2,"replacement":"'The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length - ' node'","location":{"start":{"line":106,"column":42},"end":{"line":106,"column":119}},"range":[5232,5309],"testsRan":["MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID"],"originalLines":"                                log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);","mutatedLines":"                                log.debug('The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length - ' node' + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BinaryOperator","status":2,"replacement":"'The mutator \\'' + mutator.name - '\\' mutated '","location":{"start":{"line":106,"column":42},"end":{"line":106,"column":87}},"range":[5232,5277],"testsRan":["MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID"],"originalLines":"                                log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);","mutatedLines":"                                log.debug('The mutator \\'' + mutator.name - '\\' mutated ' + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":106,"column":123},"end":{"line":106,"column":146}},"range":[5313,5336],"testsRan":["MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID"],"originalLines":"                                log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);","mutatedLines":"                                log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (true ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"RemoveConditionals","status":2,"replacement":"false","location":{"start":{"line":106,"column":123},"end":{"line":106,"column":146}},"range":[5313,5336],"testsRan":["MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID"],"originalLines":"                                log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);","mutatedLines":"                                log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (false ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BinaryOperator","status":2,"replacement":"'The mutator \\'' - mutator.name","location":{"start":{"line":106,"column":42},"end":{"line":106,"column":72}},"range":[5232,5262],"testsRan":["MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID"],"originalLines":"                                log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);","mutatedLines":"                                log.debug('The mutator \\'' - mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BinaryOperator","status":2,"replacement":"mutatedNodes.length >= 1","location":{"start":{"line":106,"column":123},"end":{"line":106,"column":146}},"range":[5313,5336],"testsRan":["MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID"],"originalLines":"                                log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);","mutatedLines":"                                log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length >= 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BinaryOperator","status":0,"replacement":"'The mutator named \\'' + mutator.name + '\\' caused an error: ' - error","location":{"start":{"line":116,"column":40},"end":{"line":116,"column":108}},"range":[6126,6194],"testsRan":[],"originalLines":"                        throw new Error(\"The mutator named '\" + mutator.name + \"' caused an error: \" + error);","mutatedLines":"                        throw new Error('The mutator named \\'' + mutator.name + '\\' caused an error: ' - error);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BinaryOperator","status":0,"replacement":"'The mutator named \\'' + mutator.name - '\\' caused an error: '","location":{"start":{"line":116,"column":40},"end":{"line":116,"column":100}},"range":[6126,6186],"testsRan":[],"originalLines":"                        throw new Error(\"The mutator named '\" + mutator.name + \"' caused an error: \" + error);","mutatedLines":"                        throw new Error('The mutator named \\'' + mutator.name - '\\' caused an error: ' + error);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BinaryOperator","status":0,"replacement":"'The mutator named \\'' - mutator.name","location":{"start":{"line":116,"column":40},"end":{"line":116,"column":76}},"range":[6126,6162],"testsRan":[],"originalLines":"                        throw new Error(\"The mutator named '\" + mutator.name + \"' caused an error: \" + error);","mutatedLines":"                        throw new Error('The mutator named \\'' - mutator.name + \"' caused an error: \" + error);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":108,"column":72},"end":{"line":112,"column":29}},"range":[5638,5995],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code"],"originalLines":"                            mutatedNodes.forEach(function (mutatedNode) {\r\n                                var mutatedCode = parserUtils.generate(mutatedNode);\r\n                                var originalNode = nodes[mutatedNode.nodeID];\r\n                                mutants.push(new Mutant_1.default(mutator.name, sourceFile, originalCode, mutatedCode, originalNode.loc, originalNode.range));\r\n                            });","mutatedLines":"                            mutatedNodes.forEach(function (mutatedNode) {\n});"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":115,"column":34},"end":{"line":117,"column":21}},"range":[6083,6219],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID"],"originalLines":"                    catch (error) {\r\n                        throw new Error(\"The mutator named '\" + mutator.name + \"' caused an error: \" + error);\r\n                    }","mutatedLines":"                    catch (error) {\n}"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BinaryOperator","status":2,"replacement":"mutatedNodes.length <= 1","location":{"start":{"line":106,"column":123},"end":{"line":106,"column":146}},"range":[5313,5336],"testsRan":["MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID"],"originalLines":"                                log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);","mutatedLines":"                                log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length <= 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);"},{"sourceFilePath":"/stryker/src/mutators/BinaryOperatorMutator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":24,"column":12},"end":{"line":24,"column":92}},"range":[681,761],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code"],"originalLines":"        if (node.type === esprima_1.Syntax.BinaryExpression && this.operators[node.operator]) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/mutators/BinaryOperatorMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":3,"column":41},"end":{"line":39,"column":1}},"range":[93,1301],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator \"before each\" hook for \"should throw an error if no source files are provided\""],"originalLines":"var BinaryOperatorMutator = (function () {\r\n    function BinaryOperatorMutator() {\r\n        this.name = 'BinaryOperator';\r\n        this.operators = {\r\n            '+': '-',\r\n            '-': '+',\r\n            '*': '/',\r\n            '/': '*',\r\n            '%': '*',\r\n            '<': ['<=', '>='],\r\n            '<=': ['<', '>'],\r\n            '>': ['>=', '<='],\r\n            '>=': ['>', '<'],\r\n            '==': '!=',\r\n            '!=': '==',\r\n            '===': '!==',\r\n            '!==': '==='\r\n        };\r\n    }\r\n    BinaryOperatorMutator.prototype.applyMutations = function (node, copy) {\r\n        var nodes = [];\r\n        if (node.type === esprima_1.Syntax.BinaryExpression && this.operators[node.operator]) {\r\n            var binaryNode_1 = node;\r\n            var mutatedOperators = this.operators[node.operator];\r\n            if (typeof mutatedOperators === 'string') {\r\n                mutatedOperators = [mutatedOperators];\r\n            }\r\n            mutatedOperators.forEach(function (operator) {\r\n                var mutatedNode = copy(binaryNode_1);\r\n                mutatedNode.operator = operator;\r\n                nodes.push(mutatedNode);\r\n            });\r\n        }\r\n        return nodes;\r\n    };\r\n    return BinaryOperatorMutator;\r\n}());","mutatedLines":"var BinaryOperatorMutator = (function () {\n}());"},{"sourceFilePath":"/stryker/src/mutators/BinaryOperatorMutator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":24,"column":12},"end":{"line":24,"column":92}},"range":[681,761],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated"],"originalLines":"        if (node.type === esprima_1.Syntax.BinaryExpression && this.operators[node.operator]) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/mutators/BinaryOperatorMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":4,"column":37},"end":{"line":21,"column":5}},"range":[133,564],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation \"before each\" hook for \"should return an array with a single mutant\""],"originalLines":"    function BinaryOperatorMutator() {\r\n        this.name = 'BinaryOperator';\r\n        this.operators = {\r\n            '+': '-',\r\n            '-': '+',\r\n            '*': '/',\r\n            '/': '*',\r\n            '%': '*',\r\n            '<': ['<=', '>='],\r\n            '<=': ['<', '>'],\r\n            '>': ['>=', '<='],\r\n            '>=': ['>', '<'],\r\n            '==': '!=',\r\n            '!=': '==',\r\n            '===': '!==',\r\n            '!==': '==='\r\n        };\r\n    }","mutatedLines":"    function BinaryOperatorMutator() {\n}"},{"sourceFilePath":"/stryker/src/mutators/BinaryOperatorMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":22,"column":75},"end":{"line":37,"column":5}},"range":[641,1262],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant"],"originalLines":"    BinaryOperatorMutator.prototype.applyMutations = function (node, copy) {\r\n        var nodes = [];\r\n        if (node.type === esprima_1.Syntax.BinaryExpression && this.operators[node.operator]) {\r\n            var binaryNode_1 = node;\r\n            var mutatedOperators = this.operators[node.operator];\r\n            if (typeof mutatedOperators === 'string') {\r\n                mutatedOperators = [mutatedOperators];\r\n            }\r\n            mutatedOperators.forEach(function (operator) {\r\n                var mutatedNode = copy(binaryNode_1);\r\n                mutatedNode.operator = operator;\r\n                nodes.push(mutatedNode);\r\n            });\r\n        }\r\n        return nodes;\r\n    };","mutatedLines":"    BinaryOperatorMutator.prototype.applyMutations = function (node, copy) {\n};"},{"sourceFilePath":"/stryker/src/mutators/BinaryOperatorMutator.js","mutatorName":"LogicalOperator","status":2,"replacement":"node.type === esprima_1.Syntax.BinaryExpression || this.operators[node.operator]","location":{"start":{"line":24,"column":12},"end":{"line":24,"column":92}},"range":[681,761],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node"],"originalLines":"        if (node.type === esprima_1.Syntax.BinaryExpression && this.operators[node.operator]) {","mutatedLines":"        if (node.type === esprima_1.Syntax.BinaryExpression || this.operators[node.operator]) {"},{"sourceFilePath":"/stryker/src/mutators/BinaryOperatorMutator.js","mutatorName":"BinaryOperator","status":1,"replacement":"node.type !== esprima_1.Syntax.BinaryExpression","location":{"start":{"line":24,"column":12},"end":{"line":24,"column":59}},"range":[681,728],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code"],"originalLines":"        if (node.type === esprima_1.Syntax.BinaryExpression && this.operators[node.operator]) {","mutatedLines":"        if (node.type !== esprima_1.Syntax.BinaryExpression && this.operators[node.operator]) {"},{"sourceFilePath":"/stryker/src/mutators/BinaryOperatorMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":24,"column":94},"end":{"line":35,"column":9}},"range":[763,1232],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code"],"originalLines":"        if (node.type === esprima_1.Syntax.BinaryExpression && this.operators[node.operator]) {\r\n            var binaryNode_1 = node;\r\n            var mutatedOperators = this.operators[node.operator];\r\n            if (typeof mutatedOperators === 'string') {\r\n                mutatedOperators = [mutatedOperators];\r\n            }\r\n            mutatedOperators.forEach(function (operator) {\r\n                var mutatedNode = copy(binaryNode_1);\r\n                mutatedNode.operator = operator;\r\n                nodes.push(mutatedNode);\r\n            });\r\n        }","mutatedLines":"        if (node.type === esprima_1.Syntax.BinaryExpression && this.operators[node.operator]) {\n}"},{"sourceFilePath":"/stryker/src/mutators/BinaryOperatorMutator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":27,"column":16},"end":{"line":27,"column":52}},"range":[887,923],"testsRan":["MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation \"before each\" hook for \"should be able to mutate code\""],"originalLines":"            if (typeof mutatedOperators === 'string') {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/mutators/BinaryOperatorMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":27,"column":54},"end":{"line":29,"column":13}},"range":[925,997],"testsRan":["MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation \"before each\" hook for \"should be able to mutate code\""],"originalLines":"            if (typeof mutatedOperators === 'string') {\r\n                mutatedOperators = [mutatedOperators];\r\n            }","mutatedLines":"            if (typeof mutatedOperators === 'string') {\n}"},{"sourceFilePath":"/stryker/src/mutators/BinaryOperatorMutator.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":27,"column":16},"end":{"line":27,"column":52}},"range":[887,923],"testsRan":["MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","BinaryOperatorMutator should mutate a valid Node"],"originalLines":"            if (typeof mutatedOperators === 'string') {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/mutators/BinaryOperatorMutator.js","mutatorName":"BinaryOperator","status":1,"replacement":"typeof mutatedOperators !== 'string'","location":{"start":{"line":27,"column":16},"end":{"line":27,"column":52}},"range":[887,923],"testsRan":["MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation \"before each\" hook for \"should be able to mutate code\""],"originalLines":"            if (typeof mutatedOperators === 'string') {","mutatedLines":"            if (typeof mutatedOperators !== 'string') {"},{"sourceFilePath":"/stryker/src/mutators/BinaryOperatorMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":30,"column":57},"end":{"line":34,"column":13}},"range":[1056,1219],"testsRan":["MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code"],"originalLines":"            mutatedOperators.forEach(function (operator) {\r\n                var mutatedNode = copy(binaryNode_1);\r\n                mutatedNode.operator = operator;\r\n                nodes.push(mutatedNode);\r\n            });","mutatedLines":"            mutatedOperators.forEach(function (operator) {\n});"},{"sourceFilePath":"/stryker/src/mutators/BlockStatementMutator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":12,"column":12},"end":{"line":12,"column":81}},"range":[411,480],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","BlockStatementMutator should mutate when supplied a block statement"],"originalLines":"        if (node.type === esprima_1.Syntax.BlockStatement && node.body.length > 0) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/mutators/BlockStatementMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":6,"column":41},"end":{"line":19,"column":1}},"range":[178,652],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator \"before each\" hook for \"should throw an error if no source files are provided\""],"originalLines":"var BlockStatementMutator = (function () {\r\n    function BlockStatementMutator() {\r\n        this.name = 'BlockStatement';\r\n        this.type = esprima_1.Syntax.BlockStatement;\r\n    }\r\n    BlockStatementMutator.prototype.applyMutations = function (node, copy) {\r\n        if (node.type === esprima_1.Syntax.BlockStatement && node.body.length > 0) {\r\n            var mutatedNode = copy(node);\r\n            mutatedNode.body = [];\r\n            return mutatedNode;\r\n        }\r\n    };\r\n    return BlockStatementMutator;\r\n}());","mutatedLines":"var BlockStatementMutator = (function () {\n}());"},{"sourceFilePath":"/stryker/src/mutators/BlockStatementMutator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":12,"column":12},"end":{"line":12,"column":81}},"range":[411,480],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated"],"originalLines":"        if (node.type === esprima_1.Syntax.BlockStatement && node.body.length > 0) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BinaryOperator","status":2,"replacement":"'The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') + ' between (Ln ' + astnode.loc.start.line + ', Col ' + astnode.loc.start.column + ') and (Ln ' + astnode.loc.end.line + ', Col ' + astnode.loc.end.column - ') in file '","location":{"start":{"line":106,"column":42},"end":{"line":106,"column":328}},"range":[5232,5518],"testsRan":["MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID"],"originalLines":"                                log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);","mutatedLines":"                                log.debug('The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') + ' between (Ln ' + astnode.loc.start.line + ', Col ' + astnode.loc.start.column + ') and (Ln ' + astnode.loc.end.line + ', Col ' + astnode.loc.end.column - ') in file ' + sourceFile);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":105,"column":57},"end":{"line":107,"column":29}},"range":[5187,5564],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID"],"originalLines":"                            if (mutatedNodes.length > 0) {\r\n                                log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);\r\n                            }","mutatedLines":"                            if (mutatedNodes.length > 0) {\n}"},{"sourceFilePath":"/stryker/src/mutators/BlockStatementMutator.js","mutatorName":"LogicalOperator","status":1,"replacement":"node.type === esprima_1.Syntax.BlockStatement || node.body.length > 0","location":{"start":{"line":12,"column":12},"end":{"line":12,"column":81}},"range":[411,480],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation \"before each\" hook for \"should be able to mutate code\""],"originalLines":"        if (node.type === esprima_1.Syntax.BlockStatement && node.body.length > 0) {","mutatedLines":"        if (node.type === esprima_1.Syntax.BlockStatement || node.body.length > 0) {"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BinaryOperator","status":2,"replacement":"'The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') + ' between (Ln ' + astnode.loc.start.line + ', Col ' + astnode.loc.start.column + ') and (Ln ' + astnode.loc.end.line + ', Col ' - astnode.loc.end.column","location":{"start":{"line":106,"column":42},"end":{"line":106,"column":313}},"range":[5232,5503],"testsRan":["MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID"],"originalLines":"                                log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);","mutatedLines":"                                log.debug('The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') + ' between (Ln ' + astnode.loc.start.line + ', Col ' + astnode.loc.start.column + ') and (Ln ' + astnode.loc.end.line + ', Col ' - astnode.loc.end.column + \") in file \" + sourceFile);"},{"sourceFilePath":"/stryker/src/MutatorOrchestrator.js","mutatorName":"BinaryOperator","status":2,"replacement":"'The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') + ' between (Ln ' + astnode.loc.start.line + ', Col ' + astnode.loc.start.column + ') and (Ln ' - astnode.loc.end.line","location":{"start":{"line":106,"column":42},"end":{"line":106,"column":277}},"range":[5232,5467],"testsRan":["MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID"],"originalLines":"                                log.debug(\"The mutator '\" + mutator.name + \"' mutated \" + mutatedNodes.length + \" node\" + (mutatedNodes.length > 1 ? 's' : '') + \" between (Ln \" + astnode.loc.start.line + \", Col \" + astnode.loc.start.column + \") and (Ln \" + astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);","mutatedLines":"                                log.debug('The mutator \\'' + mutator.name + '\\' mutated ' + mutatedNodes.length + ' node' + (mutatedNodes.length > 1 ? 's' : '') + ' between (Ln ' + astnode.loc.start.line + ', Col ' + astnode.loc.start.column + ') and (Ln ' - astnode.loc.end.line + \", Col \" + astnode.loc.end.column + \") in file \" + sourceFile);"},{"sourceFilePath":"/stryker/src/mutators/BlockStatementMutator.js","mutatorName":"BinaryOperator","status":1,"replacement":"node.type !== esprima_1.Syntax.BlockStatement","location":{"start":{"line":12,"column":12},"end":{"line":12,"column":57}},"range":[411,456],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation \"before each\" hook for \"should be able to mutate code\""],"originalLines":"        if (node.type === esprima_1.Syntax.BlockStatement && node.body.length > 0) {","mutatedLines":"        if (node.type !== esprima_1.Syntax.BlockStatement && node.body.length > 0) {"},{"sourceFilePath":"/stryker/src/mutators/BlockStatementMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":11,"column":75},"end":{"line":17,"column":5}},"range":[396,613],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement"],"originalLines":"    BlockStatementMutator.prototype.applyMutations = function (node, copy) {\r\n        if (node.type === esprima_1.Syntax.BlockStatement && node.body.length > 0) {\r\n            var mutatedNode = copy(node);\r\n            mutatedNode.body = [];\r\n            return mutatedNode;\r\n        }\r\n    };","mutatedLines":"    BlockStatementMutator.prototype.applyMutations = function (node, copy) {\n};"},{"sourceFilePath":"/stryker/src/mutators/BlockStatementMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":12,"column":83},"end":{"line":16,"column":9}},"range":[482,606],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","BlockStatementMutator should mutate when supplied a block statement"],"originalLines":"        if (node.type === esprima_1.Syntax.BlockStatement && node.body.length > 0) {\r\n            var mutatedNode = copy(node);\r\n            mutatedNode.body = [];\r\n            return mutatedNode;\r\n        }","mutatedLines":"        if (node.type === esprima_1.Syntax.BlockStatement && node.body.length > 0) {\n}"},{"sourceFilePath":"/stryker/src/mutators/BlockStatementMutator.js","mutatorName":"BinaryOperator","status":1,"replacement":"node.body.length <= 0","location":{"start":{"line":12,"column":61},"end":{"line":12,"column":81}},"range":[460,480],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","BlockStatementMutator should mutate when supplied a block statement"],"originalLines":"        if (node.type === esprima_1.Syntax.BlockStatement && node.body.length > 0) {","mutatedLines":"        if (node.type === esprima_1.Syntax.BlockStatement && node.body.length <= 0) {"},{"sourceFilePath":"/stryker/src/mutators/BlockStatementMutator.js","mutatorName":"BinaryOperator","status":1,"replacement":"node.body.length >= 0","location":{"start":{"line":12,"column":61},"end":{"line":12,"column":81}},"range":[460,480],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression"],"originalLines":"        if (node.type === esprima_1.Syntax.BlockStatement && node.body.length > 0) {","mutatedLines":"        if (node.type === esprima_1.Syntax.BlockStatement && node.body.length >= 0) {"},{"sourceFilePath":"/stryker/src/mutators/LogicalOperatorMutator.js","mutatorName":"RemoveConditionals","status":2,"replacement":"false","location":{"start":{"line":14,"column":12},"end":{"line":14,"column":93}},"range":[447,528],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead"],"originalLines":"        if (node.type === esprima_1.Syntax.LogicalExpression && this.operators[node.operator]) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/mutators/LogicalOperatorMutator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":14,"column":12},"end":{"line":14,"column":93}},"range":[447,528],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated"],"originalLines":"        if (node.type === esprima_1.Syntax.LogicalExpression && this.operators[node.operator]) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/mutators/LogicalOperatorMutator.js","mutatorName":"LogicalOperator","status":2,"replacement":"node.type === esprima_1.Syntax.LogicalExpression || this.operators[node.operator]","location":{"start":{"line":14,"column":12},"end":{"line":14,"column":93}},"range":[447,528],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead"],"originalLines":"        if (node.type === esprima_1.Syntax.LogicalExpression && this.operators[node.operator]) {","mutatedLines":"        if (node.type === esprima_1.Syntax.LogicalExpression || this.operators[node.operator]) {"},{"sourceFilePath":"/stryker/src/mutators/LogicalOperatorMutator.js","mutatorName":"BinaryOperator","status":2,"replacement":"node.type !== esprima_1.Syntax.LogicalExpression","location":{"start":{"line":14,"column":12},"end":{"line":14,"column":60}},"range":[447,495],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead"],"originalLines":"        if (node.type === esprima_1.Syntax.LogicalExpression && this.operators[node.operator]) {","mutatedLines":"        if (node.type !== esprima_1.Syntax.LogicalExpression && this.operators[node.operator]) {"},{"sourceFilePath":"/stryker/src/mutators/LogicalOperatorMutator.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":14,"column":95},"end":{"line":18,"column":9}},"range":[530,690],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead"],"originalLines":"        if (node.type === esprima_1.Syntax.LogicalExpression && this.operators[node.operator]) {\r\n            var mutatedNode = copy(node);\r\n            mutatedNode.operator = this.operators[node.operator];\r\n            nodes.push(mutatedNode);\r\n        }","mutatedLines":"        if (node.type === esprima_1.Syntax.LogicalExpression && this.operators[node.operator]) {\n}"},{"sourceFilePath":"/stryker/src/mutators/LogicalOperatorMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":3,"column":42},"end":{"line":22,"column":1}},"range":[94,760],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator \"before each\" hook for \"should throw an error if no source files are provided\""],"originalLines":"var LogicalOperatorMutator = (function () {\r\n    function LogicalOperatorMutator() {\r\n        this.name = 'LogicalOperator';\r\n        this.type = esprima_1.Syntax.LogicalExpression;\r\n        this.operators = {\r\n            '&&': '||',\r\n            '||': '&&'\r\n        };\r\n    }\r\n    LogicalOperatorMutator.prototype.applyMutations = function (node, copy) {\r\n        var nodes = [];\r\n        if (node.type === esprima_1.Syntax.LogicalExpression && this.operators[node.operator]) {\r\n            var mutatedNode = copy(node);\r\n            mutatedNode.operator = this.operators[node.operator];\r\n            nodes.push(mutatedNode);\r\n        }\r\n        return nodes;\r\n    };\r\n    return LogicalOperatorMutator;\r\n}());","mutatedLines":"var LogicalOperatorMutator = (function () {\n}());"},{"sourceFilePath":"/stryker/src/mutators/RemoveConditionalsMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":6,"column":45},"end":{"line":34,"column":1}},"range":[189,1401],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator \"before each\" hook for \"should throw an error if no source files are provided\""],"originalLines":"var RemoveConditionalsMutator = (function () {\r\n    function RemoveConditionalsMutator() {\r\n        this.name = 'RemoveConditionals';\r\n        this.types = [esprima_1.Syntax.DoWhileStatement, esprima_1.Syntax.IfStatement, esprima_1.Syntax.ForStatement, esprima_1.Syntax.WhileStatement, esprima_1.Syntax.ConditionalExpression];\r\n    }\r\n    RemoveConditionalsMutator.prototype.applyMutations = function (node, copy) {\r\n        if (this.canMutate(node)) {\r\n            var nodes = [];\r\n            nodes.push(this.booleanLiteralNode(node.test.nodeID, false));\r\n            if (node.type === esprima_1.Syntax.IfStatement || node.type === esprima_1.Syntax.ConditionalExpression) {\r\n                nodes.push(this.booleanLiteralNode(node.test.nodeID, true));\r\n            }\r\n            return nodes;\r\n        }\r\n    };\r\n    RemoveConditionalsMutator.prototype.booleanLiteralNode = function (nodeID, value) {\r\n        return {\r\n            nodeID: nodeID,\r\n            type: esprima_1.Syntax.Literal,\r\n            value: value,\r\n            raw: value.toString()\r\n        };\r\n    };\r\n    RemoveConditionalsMutator.prototype.canMutate = function (node) {\r\n        return this.types.indexOf(node.type) >= 0;\r\n    };\r\n    ;\r\n    return RemoveConditionalsMutator;\r\n}());","mutatedLines":"var RemoveConditionalsMutator = (function () {\n}());"},{"sourceFilePath":"/stryker/src/mutators/RemoveConditionalsMutator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":12,"column":12},"end":{"line":12,"column":32}},"range":[573,593],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated"],"originalLines":"        if (this.canMutate(node)) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/mutators/RemoveConditionalsMutator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":12,"column":12},"end":{"line":12,"column":32}},"range":[573,593],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop"],"originalLines":"        if (this.canMutate(node)) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/mutators/RemoveConditionalsMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":12,"column":34},"end":{"line":19,"column":9}},"range":[595,950],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop"],"originalLines":"        if (this.canMutate(node)) {\r\n            var nodes = [];\r\n            nodes.push(this.booleanLiteralNode(node.test.nodeID, false));\r\n            if (node.type === esprima_1.Syntax.IfStatement || node.type === esprima_1.Syntax.ConditionalExpression) {\r\n                nodes.push(this.booleanLiteralNode(node.test.nodeID, true));\r\n            }\r\n            return nodes;\r\n        }","mutatedLines":"        if (this.canMutate(node)) {\n}"},{"sourceFilePath":"/stryker/src/mutators/RemoveConditionalsMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":7,"column":41},"end":{"line":10,"column":5}},"range":[233,477],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated"],"originalLines":"    function RemoveConditionalsMutator() {\r\n        this.name = 'RemoveConditionals';\r\n        this.types = [esprima_1.Syntax.DoWhileStatement, esprima_1.Syntax.IfStatement, esprima_1.Syntax.ForStatement, esprima_1.Syntax.WhileStatement, esprima_1.Syntax.ConditionalExpression];\r\n    }","mutatedLines":"    function RemoveConditionalsMutator() {\n}"},{"sourceFilePath":"/stryker/src/mutators/RemoveConditionalsMutator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":15,"column":16},"end":{"line":15,"column":114}},"range":[718,816],"testsRan":["RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop"],"originalLines":"            if (node.type === esprima_1.Syntax.IfStatement || node.type === esprima_1.Syntax.ConditionalExpression) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/mutators/RemoveConditionalsMutator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":15,"column":16},"end":{"line":15,"column":114}},"range":[718,816],"testsRan":["RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement"],"originalLines":"            if (node.type === esprima_1.Syntax.IfStatement || node.type === esprima_1.Syntax.ConditionalExpression) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/mutators/RemoveConditionalsMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":11,"column":79},"end":{"line":20,"column":5}},"range":[558,957],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop"],"originalLines":"    RemoveConditionalsMutator.prototype.applyMutations = function (node, copy) {\r\n        if (this.canMutate(node)) {\r\n            var nodes = [];\r\n            nodes.push(this.booleanLiteralNode(node.test.nodeID, false));\r\n            if (node.type === esprima_1.Syntax.IfStatement || node.type === esprima_1.Syntax.ConditionalExpression) {\r\n                nodes.push(this.booleanLiteralNode(node.test.nodeID, true));\r\n            }\r\n            return nodes;\r\n        }\r\n    };","mutatedLines":"    RemoveConditionalsMutator.prototype.applyMutations = function (node, copy) {\n};"},{"sourceFilePath":"/stryker/src/mutators/RemoveConditionalsMutator.js","mutatorName":"LogicalOperator","status":1,"replacement":"node.type === esprima_1.Syntax.IfStatement && node.type === esprima_1.Syntax.ConditionalExpression","location":{"start":{"line":15,"column":16},"end":{"line":15,"column":114}},"range":[718,816],"testsRan":["RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement"],"originalLines":"            if (node.type === esprima_1.Syntax.IfStatement || node.type === esprima_1.Syntax.ConditionalExpression) {","mutatedLines":"            if (node.type === esprima_1.Syntax.IfStatement && node.type === esprima_1.Syntax.ConditionalExpression) {"},{"sourceFilePath":"/stryker/src/mutators/RemoveConditionalsMutator.js","mutatorName":"BinaryOperator","status":1,"replacement":"node.type !== esprima_1.Syntax.IfStatement","location":{"start":{"line":15,"column":16},"end":{"line":15,"column":58}},"range":[718,760],"testsRan":["RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop"],"originalLines":"            if (node.type === esprima_1.Syntax.IfStatement || node.type === esprima_1.Syntax.ConditionalExpression) {","mutatedLines":"            if (node.type !== esprima_1.Syntax.IfStatement || node.type === esprima_1.Syntax.ConditionalExpression) {"},{"sourceFilePath":"/stryker/src/mutators/RemoveConditionalsMutator.js","mutatorName":"BinaryOperator","status":1,"replacement":"node.type !== esprima_1.Syntax.ConditionalExpression","location":{"start":{"line":15,"column":62},"end":{"line":15,"column":114}},"range":[764,816],"testsRan":["RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop"],"originalLines":"            if (node.type === esprima_1.Syntax.IfStatement || node.type === esprima_1.Syntax.ConditionalExpression) {","mutatedLines":"            if (node.type === esprima_1.Syntax.IfStatement || node.type !== esprima_1.Syntax.ConditionalExpression) {"},{"sourceFilePath":"/stryker/src/mutators/RemoveConditionalsMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":15,"column":116},"end":{"line":17,"column":13}},"range":[818,912],"testsRan":["RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement"],"originalLines":"            if (node.type === esprima_1.Syntax.IfStatement || node.type === esprima_1.Syntax.ConditionalExpression) {\r\n                nodes.push(this.booleanLiteralNode(node.test.nodeID, true));\r\n            }","mutatedLines":"            if (node.type === esprima_1.Syntax.IfStatement || node.type === esprima_1.Syntax.ConditionalExpression) {\n}"},{"sourceFilePath":"/stryker/src/mutators/RemoveConditionalsMutator.js","mutatorName":"BinaryOperator","status":1,"replacement":"this.types.indexOf(node.type) < 0","location":{"start":{"line":30,"column":15},"end":{"line":30,"column":49}},"range":[1309,1343],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated"],"originalLines":"        return this.types.indexOf(node.type) >= 0;","mutatedLines":"        return this.types.indexOf(node.type) < 0;"},{"sourceFilePath":"/stryker/src/mutators/RemoveConditionalsMutator.js","mutatorName":"BinaryOperator","status":1,"replacement":"this.types.indexOf(node.type) > 0","location":{"start":{"line":30,"column":15},"end":{"line":30,"column":49}},"range":[1309,1343],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop"],"originalLines":"        return this.types.indexOf(node.type) >= 0;","mutatedLines":"        return this.types.indexOf(node.type) > 0;"},{"sourceFilePath":"/stryker/src/mutators/RemoveConditionalsMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":29,"column":68},"end":{"line":31,"column":5}},"range":[1291,1351],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop"],"originalLines":"    RemoveConditionalsMutator.prototype.canMutate = function (node) {\r\n        return this.types.indexOf(node.type) >= 0;\r\n    };","mutatedLines":"    RemoveConditionalsMutator.prototype.canMutate = function (node) {\n};"},{"sourceFilePath":"/stryker/src/mutators/RemoveConditionalsMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":21,"column":86},"end":{"line":28,"column":5}},"range":[1046,1220],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop"],"originalLines":"    RemoveConditionalsMutator.prototype.booleanLiteralNode = function (nodeID, value) {\r\n        return {\r\n            nodeID: nodeID,\r\n            type: esprima_1.Syntax.Literal,\r\n            value: value,\r\n            raw: value.toString()\r\n        };\r\n    };","mutatedLines":"    RemoveConditionalsMutator.prototype.booleanLiteralNode = function (nodeID, value) {\n};"},{"sourceFilePath":"/stryker/src/mutators/BlockStatementMutator.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":7,"column":37},"end":{"line":10,"column":5}},"range":[218,319],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    function BlockStatementMutator() {\r\n        this.name = 'BlockStatement';\r\n        this.type = esprima_1.Syntax.BlockStatement;\r\n    }","mutatedLines":"    function BlockStatementMutator() {\n}"},{"sourceFilePath":"/stryker/src/mutators/UnaryOperatorMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":3,"column":40},"end":{"line":22,"column":1}},"range":[92,742],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator \"before each\" hook for \"should throw an error if no source files are provided\""],"originalLines":"var UnaryOperatorMutator = (function () {\r\n    function UnaryOperatorMutator() {\r\n        this.name = 'UnaryOperator';\r\n        this.type = esprima_1.Syntax.UnaryExpression;\r\n        this.operators = {\r\n            '+': '-',\r\n            '-': '+'\r\n        };\r\n    }\r\n    UnaryOperatorMutator.prototype.applyMutations = function (node, copy) {\r\n        var nodes = [];\r\n        if (node.type === esprima_1.Syntax.UnaryExpression && this.operators[node.operator]) {\r\n            var mutatedNode = copy(node);\r\n            mutatedNode.operator = this.operators[node.operator];\r\n            nodes.push(mutatedNode);\r\n        }\r\n        return nodes;\r\n    };\r\n    return UnaryOperatorMutator;\r\n}());","mutatedLines":"var UnaryOperatorMutator = (function () {\n}());"},{"sourceFilePath":"/stryker/src/mutators/UnaryOperatorMutator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":14,"column":12},"end":{"line":14,"column":91}},"range":[433,512],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated"],"originalLines":"        if (node.type === esprima_1.Syntax.UnaryExpression && this.operators[node.operator]) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/mutators/UnaryOperatorMutator.js","mutatorName":"RemoveConditionals","status":2,"replacement":"false","location":{"start":{"line":14,"column":12},"end":{"line":14,"column":91}},"range":[433,512],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead"],"originalLines":"        if (node.type === esprima_1.Syntax.UnaryExpression && this.operators[node.operator]) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/mutators/UnaryOperatorMutator.js","mutatorName":"LogicalOperator","status":2,"replacement":"node.type === esprima_1.Syntax.UnaryExpression || this.operators[node.operator]","location":{"start":{"line":14,"column":12},"end":{"line":14,"column":91}},"range":[433,512],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead"],"originalLines":"        if (node.type === esprima_1.Syntax.UnaryExpression && this.operators[node.operator]) {","mutatedLines":"        if (node.type === esprima_1.Syntax.UnaryExpression || this.operators[node.operator]) {"},{"sourceFilePath":"/stryker/src/mutators/UnaryOperatorMutator.js","mutatorName":"BinaryOperator","status":2,"replacement":"node.type !== esprima_1.Syntax.UnaryExpression","location":{"start":{"line":14,"column":12},"end":{"line":14,"column":58}},"range":[433,479],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead"],"originalLines":"        if (node.type === esprima_1.Syntax.UnaryExpression && this.operators[node.operator]) {","mutatedLines":"        if (node.type !== esprima_1.Syntax.UnaryExpression && this.operators[node.operator]) {"},{"sourceFilePath":"/stryker/src/mutators/UnaryOperatorMutator.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":14,"column":93},"end":{"line":18,"column":9}},"range":[514,674],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead"],"originalLines":"        if (node.type === esprima_1.Syntax.UnaryExpression && this.operators[node.operator]) {\r\n            var mutatedNode = copy(node);\r\n            mutatedNode.operator = this.operators[node.operator];\r\n            nodes.push(mutatedNode);\r\n        }","mutatedLines":"        if (node.type === esprima_1.Syntax.UnaryExpression && this.operators[node.operator]) {\n}"},{"sourceFilePath":"/stryker/src/mutators/LogicalOperatorMutator.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":12,"column":76},"end":{"line":20,"column":5}},"range":[407,720],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    LogicalOperatorMutator.prototype.applyMutations = function (node, copy) {\r\n        var nodes = [];\r\n        if (node.type === esprima_1.Syntax.LogicalExpression && this.operators[node.operator]) {\r\n            var mutatedNode = copy(node);\r\n            mutatedNode.operator = this.operators[node.operator];\r\n            nodes.push(mutatedNode);\r\n        }\r\n        return nodes;\r\n    };","mutatedLines":"    LogicalOperatorMutator.prototype.applyMutations = function (node, copy) {\n};"},{"sourceFilePath":"/stryker/src/mutators/UpdateOperatorMutator.js","mutatorName":"RemoveConditionals","status":2,"replacement":"false","location":{"start":{"line":14,"column":12},"end":{"line":14,"column":92}},"range":[442,522],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead"],"originalLines":"        if (node.type === esprima_1.Syntax.UpdateExpression && this.operators[node.operator]) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/mutators/UpdateOperatorMutator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":3,"column":41},"end":{"line":22,"column":1}},"range":[93,753],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator \"before each\" hook for \"should throw an error if no source files are provided\""],"originalLines":"var UpdateOperatorMutator = (function () {\r\n    function UpdateOperatorMutator() {\r\n        this.name = 'UpdateOperator';\r\n        this.type = esprima_1.Syntax.UpdateExpression;\r\n        this.operators = {\r\n            '++': '--',\r\n            '--': '++'\r\n        };\r\n    }\r\n    UpdateOperatorMutator.prototype.applyMutations = function (node, copy) {\r\n        var nodes = [];\r\n        if (node.type === esprima_1.Syntax.UpdateExpression && this.operators[node.operator]) {\r\n            var mutatedNode = copy(node);\r\n            mutatedNode.operator = this.operators[node.operator];\r\n            nodes.push(mutatedNode);\r\n        }\r\n        return nodes;\r\n    };\r\n    return UpdateOperatorMutator;\r\n}());","mutatedLines":"var UpdateOperatorMutator = (function () {\n}());"},{"sourceFilePath":"/stryker/src/mutators/UpdateOperatorMutator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":14,"column":12},"end":{"line":14,"column":92}},"range":[442,522],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated"],"originalLines":"        if (node.type === esprima_1.Syntax.UpdateExpression && this.operators[node.operator]) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/mutators/UpdateOperatorMutator.js","mutatorName":"LogicalOperator","status":2,"replacement":"node.type === esprima_1.Syntax.UpdateExpression || this.operators[node.operator]","location":{"start":{"line":14,"column":12},"end":{"line":14,"column":92}},"range":[442,522],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead"],"originalLines":"        if (node.type === esprima_1.Syntax.UpdateExpression && this.operators[node.operator]) {","mutatedLines":"        if (node.type === esprima_1.Syntax.UpdateExpression || this.operators[node.operator]) {"},{"sourceFilePath":"/stryker/src/mutators/UpdateOperatorMutator.js","mutatorName":"BinaryOperator","status":2,"replacement":"node.type !== esprima_1.Syntax.UpdateExpression","location":{"start":{"line":14,"column":12},"end":{"line":14,"column":59}},"range":[442,489],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead"],"originalLines":"        if (node.type === esprima_1.Syntax.UpdateExpression && this.operators[node.operator]) {","mutatedLines":"        if (node.type !== esprima_1.Syntax.UpdateExpression && this.operators[node.operator]) {"},{"sourceFilePath":"/stryker/src/mutators/LogicalOperatorMutator.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":4,"column":38},"end":{"line":11,"column":5}},"range":[135,329],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    function LogicalOperatorMutator() {\r\n        this.name = 'LogicalOperator';\r\n        this.type = esprima_1.Syntax.LogicalExpression;\r\n        this.operators = {\r\n            '&&': '||',\r\n            '||': '&&'\r\n        };\r\n    }","mutatedLines":"    function LogicalOperatorMutator() {\n}"},{"sourceFilePath":"/stryker/src/mutators/UpdateOperatorMutator.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":14,"column":94},"end":{"line":18,"column":9}},"range":[524,684],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead"],"originalLines":"        if (node.type === esprima_1.Syntax.UpdateExpression && this.operators[node.operator]) {\r\n            var mutatedNode = copy(node);\r\n            mutatedNode.operator = this.operators[node.operator];\r\n            nodes.push(mutatedNode);\r\n        }","mutatedLines":"        if (node.type === esprima_1.Syntax.UpdateExpression && this.operators[node.operator]) {\n}"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":10,"column":35},"end":{"line":12,"column":5}},"range":[350,391],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors \"before each\" hook for \"should have imported the given modules\""],"originalLines":"    function PluginLoader(plugins) {\r\n        this.plugins = plugins;\r\n    }","mutatedLines":"    function PluginLoader(plugins) {\n}"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":9,"column":32},"end":{"line":66,"column":1}},"range":[312,3083],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards \"before each\" hook for \"should have imported the given modules\""],"originalLines":"var PluginLoader = (function () {\r\n    function PluginLoader(plugins) {\r\n        this.plugins = plugins;\r\n    }\r\n    PluginLoader.prototype.load = function () {\r\n        this.getModules().forEach(this.requirePlugin);\r\n    };\r\n    PluginLoader.prototype.getModules = function () {\r\n        var modules = [];\r\n        this.plugins.forEach(function (pluginExpression) {\r\n            if (_.isString(pluginExpression)) {\r\n                if (pluginExpression.indexOf('*') !== -1) {\r\n                    // Plugin directory is the node_modules folder of the module that installed stryker\r\n                    // So if current __dirname is './stryker/src' than the plugin directory should be 2 directories above\r\n                    var pluginDirectory_1 = path.normalize(__dirname + '/../..');\r\n                    var regexp_1 = new RegExp('^' + pluginExpression.replace('*', '.*'));\r\n                    log.debug('Loading %s from %s', pluginExpression, pluginDirectory_1);\r\n                    var plugins = fs.readdirSync(pluginDirectory_1)\r\n                        .filter(function (pluginName) { return IGNORED_PACKAGES.indexOf(pluginName) === -1 && regexp_1.test(pluginName); })\r\n                        .map(function (pluginName) { return pluginDirectory_1 + '/' + pluginName; });\r\n                    if (plugins.length === 0) {\r\n                        log.debug('Expression %s not resulted in plugins to load', pluginExpression);\r\n                    }\r\n                    plugins\r\n                        .map(function (plugin) { return path.basename(plugin); })\r\n                        .map(function (plugin) {\r\n                        log.debug('Loading plugins %s (matched with expression %s)', plugin, pluginExpression);\r\n                        return plugin;\r\n                    })\r\n                        .forEach(function (p) { return modules.push(p); });\r\n                }\r\n                else {\r\n                    modules.push(pluginExpression);\r\n                }\r\n            }\r\n            else {\r\n                log.warn('Ignoring plugin %s, as its not a string type', pluginExpression);\r\n            }\r\n        });\r\n        return modules;\r\n    };\r\n    PluginLoader.prototype.requirePlugin = function (name) {\r\n        log.debug(\"Loading plugins \" + name);\r\n        try {\r\n            fileUtils_1.importModule(name);\r\n        }\r\n        catch (e) {\r\n            if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(name) !== -1) {\r\n                log.warn('Cannot find plugin \"%s\".\\n  Did you forget to install it ?\\n' +\r\n                    '  npm install %s --save-dev', name, name);\r\n            }\r\n            else {\r\n                log.warn('Error during loading \"%s\" plugin:\\n  %s', name, e.message);\r\n            }\r\n        }\r\n    };\r\n    return PluginLoader;\r\n}());","mutatedLines":"var PluginLoader = (function () {\n}());"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":16,"column":52},"end":{"line":49,"column":5}},"range":[558,2456],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors \"before each\" hook for \"should have imported the given modules\""],"originalLines":"    PluginLoader.prototype.getModules = function () {\r\n        var modules = [];\r\n        this.plugins.forEach(function (pluginExpression) {\r\n            if (_.isString(pluginExpression)) {\r\n                if (pluginExpression.indexOf('*') !== -1) {\r\n                    // Plugin directory is the node_modules folder of the module that installed stryker\r\n                    // So if current __dirname is './stryker/src' than the plugin directory should be 2 directories above\r\n                    var pluginDirectory_1 = path.normalize(__dirname + '/../..');\r\n                    var regexp_1 = new RegExp('^' + pluginExpression.replace('*', '.*'));\r\n                    log.debug('Loading %s from %s', pluginExpression, pluginDirectory_1);\r\n                    var plugins = fs.readdirSync(pluginDirectory_1)\r\n                        .filter(function (pluginName) { return IGNORED_PACKAGES.indexOf(pluginName) === -1 && regexp_1.test(pluginName); })\r\n                        .map(function (pluginName) { return pluginDirectory_1 + '/' + pluginName; });\r\n                    if (plugins.length === 0) {\r\n                        log.debug('Expression %s not resulted in plugins to load', pluginExpression);\r\n                    }\r\n                    plugins\r\n                        .map(function (plugin) { return path.basename(plugin); })\r\n                        .map(function (plugin) {\r\n                        log.debug('Loading plugins %s (matched with expression %s)', plugin, pluginExpression);\r\n                        return plugin;\r\n                    })\r\n                        .forEach(function (p) { return modules.push(p); });\r\n                }\r\n                else {\r\n                    modules.push(pluginExpression);\r\n                }\r\n            }\r\n            else {\r\n                log.warn('Ignoring plugin %s, as its not a string type', pluginExpression);\r\n            }\r\n        });\r\n        return modules;\r\n    };","mutatedLines":"    PluginLoader.prototype.getModules = function () {\n};"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":13,"column":46},"end":{"line":15,"column":5}},"range":[439,503],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules"],"originalLines":"    PluginLoader.prototype.load = function () {\r\n        this.getModules().forEach(this.requirePlugin);\r\n    };","mutatedLines":"    PluginLoader.prototype.load = function () {\n};"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":18,"column":57},"end":{"line":47,"column":9}},"range":[645,2422],"testsRan":["PluginLoader without wildcards load() without errors should have imported the given modules"],"originalLines":"        this.plugins.forEach(function (pluginExpression) {\r\n            if (_.isString(pluginExpression)) {\r\n                if (pluginExpression.indexOf('*') !== -1) {\r\n                    // Plugin directory is the node_modules folder of the module that installed stryker\r\n                    // So if current __dirname is './stryker/src' than the plugin directory should be 2 directories above\r\n                    var pluginDirectory_1 = path.normalize(__dirname + '/../..');\r\n                    var regexp_1 = new RegExp('^' + pluginExpression.replace('*', '.*'));\r\n                    log.debug('Loading %s from %s', pluginExpression, pluginDirectory_1);\r\n                    var plugins = fs.readdirSync(pluginDirectory_1)\r\n                        .filter(function (pluginName) { return IGNORED_PACKAGES.indexOf(pluginName) === -1 && regexp_1.test(pluginName); })\r\n                        .map(function (pluginName) { return pluginDirectory_1 + '/' + pluginName; });\r\n                    if (plugins.length === 0) {\r\n                        log.debug('Expression %s not resulted in plugins to load', pluginExpression);\r\n                    }\r\n                    plugins\r\n                        .map(function (plugin) { return path.basename(plugin); })\r\n                        .map(function (plugin) {\r\n                        log.debug('Loading plugins %s (matched with expression %s)', plugin, pluginExpression);\r\n                        return plugin;\r\n                    })\r\n                        .forEach(function (p) { return modules.push(p); });\r\n                }\r\n                else {\r\n                    modules.push(pluginExpression);\r\n                }\r\n            }\r\n            else {\r\n                log.warn('Ignoring plugin %s, as its not a string type', pluginExpression);\r\n            }\r\n        });","mutatedLines":"        this.plugins.forEach(function (pluginExpression) {\n});"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":19,"column":16},"end":{"line":19,"column":44}},"range":[664,692],"testsRan":["PluginLoader without wildcards load() without errors should have imported the given modules"],"originalLines":"            if (_.isString(pluginExpression)) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":19,"column":46},"end":{"line":43,"column":13}},"range":[694,2283],"testsRan":["PluginLoader without wildcards load() without errors should have imported the given modules"],"originalLines":"            if (_.isString(pluginExpression)) {\r\n                if (pluginExpression.indexOf('*') !== -1) {\r\n                    // Plugin directory is the node_modules folder of the module that installed stryker\r\n                    // So if current __dirname is './stryker/src' than the plugin directory should be 2 directories above\r\n                    var pluginDirectory_1 = path.normalize(__dirname + '/../..');\r\n                    var regexp_1 = new RegExp('^' + pluginExpression.replace('*', '.*'));\r\n                    log.debug('Loading %s from %s', pluginExpression, pluginDirectory_1);\r\n                    var plugins = fs.readdirSync(pluginDirectory_1)\r\n                        .filter(function (pluginName) { return IGNORED_PACKAGES.indexOf(pluginName) === -1 && regexp_1.test(pluginName); })\r\n                        .map(function (pluginName) { return pluginDirectory_1 + '/' + pluginName; });\r\n                    if (plugins.length === 0) {\r\n                        log.debug('Expression %s not resulted in plugins to load', pluginExpression);\r\n                    }\r\n                    plugins\r\n                        .map(function (plugin) { return path.basename(plugin); })\r\n                        .map(function (plugin) {\r\n                        log.debug('Loading plugins %s (matched with expression %s)', plugin, pluginExpression);\r\n                        return plugin;\r\n                    })\r\n                        .forEach(function (p) { return modules.push(p); });\r\n                }\r\n                else {\r\n                    modules.push(pluginExpression);\r\n                }\r\n            }","mutatedLines":"            if (_.isString(pluginExpression)) {\n}"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":20,"column":20},"end":{"line":20,"column":56}},"range":[717,753],"testsRan":["PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder"],"originalLines":"                if (pluginExpression.indexOf('*') !== -1) {","mutatedLines":"                if (false) {"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":19,"column":16},"end":{"line":19,"column":44}},"range":[664,692],"testsRan":["PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\""],"originalLines":"            if (_.isString(pluginExpression)) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":20,"column":20},"end":{"line":20,"column":56}},"range":[717,753],"testsRan":["PluginLoader without wildcards load() without errors \"before each\" hook for \"should have imported the given modules\""],"originalLines":"                if (pluginExpression.indexOf('*') !== -1) {","mutatedLines":"                if (true) {"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BinaryOperator","status":1,"replacement":"pluginExpression.indexOf('*') === -1","location":{"start":{"line":20,"column":20},"end":{"line":20,"column":56}},"range":[717,753],"testsRan":["PluginLoader without wildcards load() without errors \"before each\" hook for \"should have imported the given modules\""],"originalLines":"                if (pluginExpression.indexOf('*') !== -1) {","mutatedLines":"                if (pluginExpression.indexOf('*') === -1) {"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"UnaryOperator","status":1,"replacement":"+1","location":{"start":{"line":20,"column":54},"end":{"line":20,"column":56}},"range":[751,753],"testsRan":["PluginLoader without wildcards load() without errors \"before each\" hook for \"should have imported the given modules\""],"originalLines":"                if (pluginExpression.indexOf('*') !== -1) {","mutatedLines":"                if (pluginExpression.indexOf('*') !== +1) {"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":20,"column":58},"end":{"line":39,"column":17}},"range":[755,2172],"testsRan":["PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder"],"originalLines":"                if (pluginExpression.indexOf('*') !== -1) {\r\n                    // Plugin directory is the node_modules folder of the module that installed stryker\r\n                    // So if current __dirname is './stryker/src' than the plugin directory should be 2 directories above\r\n                    var pluginDirectory_1 = path.normalize(__dirname + '/../..');\r\n                    var regexp_1 = new RegExp('^' + pluginExpression.replace('*', '.*'));\r\n                    log.debug('Loading %s from %s', pluginExpression, pluginDirectory_1);\r\n                    var plugins = fs.readdirSync(pluginDirectory_1)\r\n                        .filter(function (pluginName) { return IGNORED_PACKAGES.indexOf(pluginName) === -1 && regexp_1.test(pluginName); })\r\n                        .map(function (pluginName) { return pluginDirectory_1 + '/' + pluginName; });\r\n                    if (plugins.length === 0) {\r\n                        log.debug('Expression %s not resulted in plugins to load', pluginExpression);\r\n                    }\r\n                    plugins\r\n                        .map(function (plugin) { return path.basename(plugin); })\r\n                        .map(function (plugin) {\r\n                        log.debug('Loading plugins %s (matched with expression %s)', plugin, pluginExpression);\r\n                        return plugin;\r\n                    })\r\n                        .forEach(function (p) { return modules.push(p); });\r\n                }","mutatedLines":"                if (pluginExpression.indexOf('*') !== -1) {\n}"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BinaryOperator","status":1,"replacement":"__dirname - '/../..'","location":{"start":{"line":23,"column":59},"end":{"line":23,"column":79}},"range":[1045,1065],"testsRan":["PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() \"before each\" hook for \"should read from a `node_modules` folder\""],"originalLines":"                    var pluginDirectory_1 = path.normalize(__dirname + '/../..');","mutatedLines":"                    var pluginDirectory_1 = path.normalize(__dirname - '/../..');"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":27,"column":54},"end":{"line":27,"column":138}},"range":[1374,1458],"testsRan":["PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\""],"originalLines":"                        .filter(function (pluginName) { return IGNORED_PACKAGES.indexOf(pluginName) === -1 && regexp_1.test(pluginName); })","mutatedLines":"                        .filter(function (pluginName) {\n})"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BinaryOperator","status":1,"replacement":"'^' - pluginExpression.replace('*', '.*')","location":{"start":{"line":24,"column":46},"end":{"line":24,"column":87}},"range":[1115,1156],"testsRan":["PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\""],"originalLines":"                    var regexp_1 = new RegExp('^' + pluginExpression.replace('*', '.*'));","mutatedLines":"                    var regexp_1 = new RegExp('^' - pluginExpression.replace('*', '.*'));"},{"sourceFilePath":"/stryker/src/mutators/UnaryOperatorMutator.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":4,"column":36},"end":{"line":11,"column":5}},"range":[131,317],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    function UnaryOperatorMutator() {\r\n        this.name = 'UnaryOperator';\r\n        this.type = esprima_1.Syntax.UnaryExpression;\r\n        this.operators = {\r\n            '+': '-',\r\n            '-': '+'\r\n        };\r\n    }","mutatedLines":"    function UnaryOperatorMutator() {\n}"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"LogicalOperator","status":1,"replacement":"IGNORED_PACKAGES.indexOf(pluginName) === -1 || regexp_1.test(pluginName)","location":{"start":{"line":27,"column":63},"end":{"line":27,"column":135}},"range":[1383,1455],"testsRan":["PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\""],"originalLines":"                        .filter(function (pluginName) { return IGNORED_PACKAGES.indexOf(pluginName) === -1 && regexp_1.test(pluginName); })","mutatedLines":"                        .filter(function (pluginName) { return IGNORED_PACKAGES.indexOf(pluginName) === -1 || regexp_1.test(pluginName); })"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BinaryOperator","status":1,"replacement":"IGNORED_PACKAGES.indexOf(pluginName) !== -1","location":{"start":{"line":27,"column":63},"end":{"line":27,"column":106}},"range":[1383,1426],"testsRan":["PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\""],"originalLines":"                        .filter(function (pluginName) { return IGNORED_PACKAGES.indexOf(pluginName) === -1 && regexp_1.test(pluginName); })","mutatedLines":"                        .filter(function (pluginName) { return IGNORED_PACKAGES.indexOf(pluginName) !== -1 && regexp_1.test(pluginName); })"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"UnaryOperator","status":1,"replacement":"+1","location":{"start":{"line":27,"column":104},"end":{"line":27,"column":106}},"range":[1424,1426],"testsRan":["PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\""],"originalLines":"                        .filter(function (pluginName) { return IGNORED_PACKAGES.indexOf(pluginName) === -1 && regexp_1.test(pluginName); })","mutatedLines":"                        .filter(function (pluginName) { return IGNORED_PACKAGES.indexOf(pluginName) === +1 && regexp_1.test(pluginName); })"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":28,"column":51},"end":{"line":28,"column":99}},"range":[1512,1560],"testsRan":["PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() \"before each\" hook for \"should read from a `node_modules` folder\""],"originalLines":"                        .map(function (pluginName) { return pluginDirectory_1 + '/' + pluginName; });","mutatedLines":"                        .map(function (pluginName) {\n});"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BinaryOperator","status":1,"replacement":"pluginDirectory_1 + '/' - pluginName","location":{"start":{"line":28,"column":60},"end":{"line":28,"column":96}},"range":[1521,1557],"testsRan":["PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() \"before each\" hook for \"should read from a `node_modules` folder\""],"originalLines":"                        .map(function (pluginName) { return pluginDirectory_1 + '/' + pluginName; });","mutatedLines":"                        .map(function (pluginName) { return pluginDirectory_1 + '/' - pluginName; });"},{"sourceFilePath":"/stryker/src/mutators/UnaryOperatorMutator.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":12,"column":74},"end":{"line":20,"column":5}},"range":[393,704],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    UnaryOperatorMutator.prototype.applyMutations = function (node, copy) {\r\n        var nodes = [];\r\n        if (node.type === esprima_1.Syntax.UnaryExpression && this.operators[node.operator]) {\r\n            var mutatedNode = copy(node);\r\n            mutatedNode.operator = this.operators[node.operator];\r\n            nodes.push(mutatedNode);\r\n        }\r\n        return nodes;\r\n    };","mutatedLines":"    UnaryOperatorMutator.prototype.applyMutations = function (node, copy) {\n};"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"RemoveConditionals","status":2,"replacement":"false","location":{"start":{"line":29,"column":24},"end":{"line":29,"column":44}},"range":[1588,1608],"testsRan":["PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\""],"originalLines":"                    if (plugins.length === 0) {","mutatedLines":"                    if (false) {"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BinaryOperator","status":2,"replacement":"pluginDirectory_1 - '/'","location":{"start":{"line":28,"column":60},"end":{"line":28,"column":83}},"range":[1521,1544],"testsRan":["PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\""],"originalLines":"                        .map(function (pluginName) { return pluginDirectory_1 + '/' + pluginName; });","mutatedLines":"                        .map(function (pluginName) { return pluginDirectory_1 - '/' + pluginName; });"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":29,"column":24},"end":{"line":29,"column":44}},"range":[1588,1608],"testsRan":["PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\""],"originalLines":"                    if (plugins.length === 0) {","mutatedLines":"                    if (true) {"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BinaryOperator","status":2,"replacement":"plugins.length !== 0","location":{"start":{"line":29,"column":24},"end":{"line":29,"column":44}},"range":[1588,1608],"testsRan":["PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\""],"originalLines":"                    if (plugins.length === 0) {","mutatedLines":"                    if (plugins.length !== 0) {"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":29,"column":46},"end":{"line":31,"column":21}},"range":[1610,1737],"testsRan":["PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\""],"originalLines":"                    if (plugins.length === 0) {\r\n                        log.debug('Expression %s not resulted in plugins to load', pluginExpression);\r\n                    }","mutatedLines":"                    if (plugins.length === 0) {\n}"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":33,"column":47},"end":{"line":33,"column":80}},"range":[1815,1848],"testsRan":["PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\""],"originalLines":"                        .map(function (plugin) { return path.basename(plugin); })","mutatedLines":"                        .map(function (plugin) {\n})"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":34,"column":47},"end":{"line":37,"column":21}},"range":[1898,2075],"testsRan":["PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\""],"originalLines":"                        .map(function (plugin) {\r\n                        log.debug('Loading plugins %s (matched with expression %s)', plugin, pluginExpression);\r\n                        return plugin;\r\n                    })","mutatedLines":"                        .map(function (plugin) {\n})"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":38,"column":46},"end":{"line":38,"column":73}},"range":[2124,2151],"testsRan":["PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\""],"originalLines":"                        .forEach(function (p) { return modules.push(p); });","mutatedLines":"                        .forEach(function (p) {\n});"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":40,"column":21},"end":{"line":42,"column":17}},"range":[2195,2268],"testsRan":["PluginLoader without wildcards load() without errors should have imported the given modules"],"originalLines":"                else {\r\n                    modules.push(pluginExpression);\r\n                }","mutatedLines":"                else {\n}"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":44,"column":17},"end":{"line":46,"column":13}},"range":[2302,2411],"testsRan":["PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\""],"originalLines":"            else {\r\n                log.warn('Ignoring plugin %s, as its not a string type', pluginExpression);\r\n            }","mutatedLines":"            else {\n}"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BinaryOperator","status":2,"replacement":"'Loading plugins ' - name","location":{"start":{"line":51,"column":18},"end":{"line":51,"column":43}},"range":[2539,2564],"testsRan":["PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\""],"originalLines":"        log.debug(\"Loading plugins \" + name);","mutatedLines":"        log.debug('Loading plugins ' - name);"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":52,"column":12},"end":{"line":54,"column":9}},"range":[2580,2637],"testsRan":["PluginLoader without wildcards load() without errors should have imported the given modules"],"originalLines":"        try {\r\n            fileUtils_1.importModule(name);\r\n        }","mutatedLines":"        try {\n}"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":56,"column":16},"end":{"line":56,"column":79}},"range":[2676,2739],"testsRan":["PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings"],"originalLines":"            if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(name) !== -1) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":55,"column":18},"end":{"line":63,"column":9}},"range":[2657,3046],"testsRan":["PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings"],"originalLines":"        catch (e) {\r\n            if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(name) !== -1) {\r\n                log.warn('Cannot find plugin \"%s\".\\n  Did you forget to install it ?\\n' +\r\n                    '  npm install %s --save-dev', name, name);\r\n            }\r\n            else {\r\n                log.warn('Error during loading \"%s\" plugin:\\n  %s', name, e.message);\r\n            }\r\n        }","mutatedLines":"        catch (e) {\n}"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":56,"column":16},"end":{"line":56,"column":79}},"range":[2676,2739],"testsRan":["PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings"],"originalLines":"            if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(name) !== -1) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/mutators/UpdateOperatorMutator.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":12,"column":75},"end":{"line":20,"column":5}},"range":[402,714],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    UpdateOperatorMutator.prototype.applyMutations = function (node, copy) {\r\n        var nodes = [];\r\n        if (node.type === esprima_1.Syntax.UpdateExpression && this.operators[node.operator]) {\r\n            var mutatedNode = copy(node);\r\n            mutatedNode.operator = this.operators[node.operator];\r\n            nodes.push(mutatedNode);\r\n        }\r\n        return nodes;\r\n    };","mutatedLines":"    UpdateOperatorMutator.prototype.applyMutations = function (node, copy) {\n};"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"LogicalOperator","status":1,"replacement":"e.code === 'MODULE_NOT_FOUND' || e.message.indexOf(name) !== -1","location":{"start":{"line":56,"column":16},"end":{"line":56,"column":79}},"range":[2676,2739],"testsRan":["PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings"],"originalLines":"            if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(name) !== -1) {","mutatedLines":"            if (e.code === 'MODULE_NOT_FOUND' || e.message.indexOf(name) !== -1) {"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BinaryOperator","status":1,"replacement":"e.code !== 'MODULE_NOT_FOUND'","location":{"start":{"line":56,"column":16},"end":{"line":56,"column":45}},"range":[2676,2705],"testsRan":["PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings"],"originalLines":"            if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(name) !== -1) {","mutatedLines":"            if (e.code !== 'MODULE_NOT_FOUND' && e.message.indexOf(name) !== -1) {"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BinaryOperator","status":2,"replacement":"e.message.indexOf(name) === -1","location":{"start":{"line":56,"column":49},"end":{"line":56,"column":79}},"range":[2709,2739],"testsRan":["PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings"],"originalLines":"            if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(name) !== -1) {","mutatedLines":"            if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(name) === -1) {"},{"sourceFilePath":"/stryker/src/mutators/UpdateOperatorMutator.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":4,"column":37},"end":{"line":11,"column":5}},"range":[133,325],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    function UpdateOperatorMutator() {\r\n        this.name = 'UpdateOperator';\r\n        this.type = esprima_1.Syntax.UpdateExpression;\r\n        this.operators = {\r\n            '++': '--',\r\n            '--': '++'\r\n        };\r\n    }","mutatedLines":"    function UpdateOperatorMutator() {\n}"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":50,"column":59},"end":{"line":64,"column":5}},"range":[2518,3053],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules"],"originalLines":"    PluginLoader.prototype.requirePlugin = function (name) {\r\n        log.debug(\"Loading plugins \" + name);\r\n        try {\r\n            fileUtils_1.importModule(name);\r\n        }\r\n        catch (e) {\r\n            if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(name) !== -1) {\r\n                log.warn('Cannot find plugin \"%s\".\\n  Did you forget to install it ?\\n' +\r\n                    '  npm install %s --save-dev', name, name);\r\n            }\r\n            else {\r\n                log.warn('Error during loading \"%s\" plugin:\\n  %s', name, e.message);\r\n            }\r\n        }\r\n    };","mutatedLines":"    PluginLoader.prototype.requirePlugin = function (name) {\n};"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"RemoveConditionals","status":0,"replacement":"false","location":{"start":{"line":18,"column":12},"end":{"line":18,"column":26}},"range":[798,812],"testsRan":[],"originalLines":"        if (reporterOption) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"RemoveConditionals","status":0,"replacement":"true","location":{"start":{"line":18,"column":12},"end":{"line":18,"column":26}},"range":[798,812],"testsRan":[],"originalLines":"        if (reporterOption) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":18,"column":28},"end":{"line":25,"column":9}},"range":[814,1269],"testsRan":[],"originalLines":"        if (reporterOption) {\r\n            if (Array.isArray(reporterOption)) {\r\n                reporterOption.forEach(function (reporterName) { return reporters.push({ name: reporterName, reporter: report_1.ReporterFactory.instance().create(reporterName, _this.options) }); });\r\n            }\r\n            else {\r\n                reporters.push({ name: reporterOption, reporter: report_1.ReporterFactory.instance().create(reporterOption, this.options) });\r\n            }\r\n        }","mutatedLines":"        if (reporterOption) {\n}"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"RemoveConditionals","status":0,"replacement":"false","location":{"start":{"line":19,"column":16},"end":{"line":19,"column":45}},"range":[833,862],"testsRan":[],"originalLines":"            if (Array.isArray(reporterOption)) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"RemoveConditionals","status":0,"replacement":"true","location":{"start":{"line":19,"column":16},"end":{"line":19,"column":45}},"range":[833,862],"testsRan":[],"originalLines":"            if (Array.isArray(reporterOption)) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":19,"column":47},"end":{"line":21,"column":13}},"range":[864,1080],"testsRan":[],"originalLines":"            if (Array.isArray(reporterOption)) {\r\n                reporterOption.forEach(function (reporterName) { return reporters.push({ name: reporterName, reporter: report_1.ReporterFactory.instance().create(reporterName, _this.options) }); });\r\n            }","mutatedLines":"            if (Array.isArray(reporterOption)) {\n}"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":20,"column":63},"end":{"line":20,"column":196}},"range":[930,1063],"testsRan":[],"originalLines":"                reporterOption.forEach(function (reporterName) { return reporters.push({ name: reporterName, reporter: report_1.ReporterFactory.instance().create(reporterName, _this.options) }); });","mutatedLines":"                reporterOption.forEach(function (reporterName) {\n});"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":22,"column":17},"end":{"line":24,"column":13}},"range":[1099,1258],"testsRan":[],"originalLines":"            else {\r\n                reporters.push({ name: reporterOption, reporter: report_1.ReporterFactory.instance().create(reporterOption, this.options) });\r\n            }","mutatedLines":"            else {\n}"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":26,"column":13},"end":{"line":29,"column":9}},"range":[1284,1470],"testsRan":[],"originalLines":"        else {\r\n            log.warn(\"No reporter configured. Please configure one or more reporters in the (for example: reporter: 'progress')\");\r\n            this.logPossibleReporters();\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"UnaryOperator","status":1,"replacement":"+1","location":{"start":{"line":56,"column":77},"end":{"line":56,"column":79}},"range":[2737,2739],"testsRan":["PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings"],"originalLines":"            if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(name) !== -1) {","mutatedLines":"            if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(name) !== +1) {"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":34,"column":81},"end":{"line":39,"column":9}},"range":[1734,1899],"testsRan":[],"originalLines":"        report_1.ReporterFactory.instance().knownNames().forEach(function (name) {\r\n            if (possibleReportersCsv.length) {\r\n                possibleReportersCsv += ', ';\r\n            }\r\n            possibleReportersCsv += name;\r\n        });","mutatedLines":"        report_1.ReporterFactory.instance().knownNames().forEach(function (name) {\n});"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"RemoveConditionals","status":0,"replacement":"false","location":{"start":{"line":35,"column":16},"end":{"line":35,"column":43}},"range":[1753,1780],"testsRan":[],"originalLines":"            if (possibleReportersCsv.length) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"RemoveConditionals","status":0,"replacement":"true","location":{"start":{"line":35,"column":16},"end":{"line":35,"column":43}},"range":[1753,1780],"testsRan":[],"originalLines":"            if (possibleReportersCsv.length) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":35,"column":45},"end":{"line":37,"column":13}},"range":[1782,1845],"testsRan":[],"originalLines":"            if (possibleReportersCsv.length) {\r\n                possibleReportersCsv += ', ';\r\n            }","mutatedLines":"            if (possibleReportersCsv.length) {\n}"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"BinaryOperator","status":0,"replacement":"'Possible reporters: ' - possibleReportersCsv","location":{"start":{"line":40,"column":17},"end":{"line":40,"column":62}},"range":[1920,1965],"testsRan":[],"originalLines":"        log.warn(\"Possible reporters: \" + possibleReportersCsv);","mutatedLines":"        log.warn('Possible reporters: ' - possibleReportersCsv);"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":56,"column":81},"end":{"line":59,"column":13}},"range":[2741,2913],"testsRan":["PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings"],"originalLines":"            if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(name) !== -1) {\r\n                log.warn('Cannot find plugin \"%s\".\\n  Did you forget to install it ?\\n' +\r\n                    '  npm install %s --save-dev', name, name);\r\n            }","mutatedLines":"            if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(name) !== -1) {\n}"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BinaryOperator","status":1,"replacement":"'Cannot find plugin \"%s\".\\n  Did you forget to install it ?\\n' - '  npm install %s --save-dev'","location":{"start":{"line":57,"column":25},"end":{"line":58,"column":49}},"range":[2769,2884],"testsRan":["PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings"],"originalLines":"                log.warn('Cannot find plugin \"%s\".\\n  Did you forget to install it ?\\n' +\r\n                    '  npm install %s --save-dev', name, name);","mutatedLines":"                log.warn('Cannot find plugin \"%s\".\\n  Did you forget to install it ?\\n' - '  npm install %s --save-dev', name, name);"},{"sourceFilePath":"/stryker/src/PluginLoader.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":60,"column":17},"end":{"line":62,"column":13}},"range":[2932,3035],"testsRan":["PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings"],"originalLines":"            else {\r\n                log.warn('Error during loading \"%s\" plugin:\\n  %s', name, e.message);\r\n            }","mutatedLines":"            else {\n}"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":10,"column":82},"end":{"line":14,"column":9}},"range":[519,647],"testsRan":["BroadcastReporter should forward all events"],"originalLines":"        exports.ALL_EVENT_METHOD_NAMES.concat('wrapUp').forEach(function (method) {\r\n            _this[method] = function (arg) {\r\n                return _this.broadcast(method, arg);\r\n            };\r\n        });","mutatedLines":"        exports.ALL_EVENT_METHOD_NAMES.concat('wrapUp').forEach(function (method) {\n});"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":11,"column":43},"end":{"line":13,"column":13}},"range":[565,635],"testsRan":["BroadcastReporter should forward all events"],"originalLines":"            _this[method] = function (arg) {\r\n                return _this.broadcast(method, arg);\r\n            };","mutatedLines":"            _this[method] = function (arg) {\n};"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":6,"column":37},"end":{"line":43,"column":1}},"range":[325,1910],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter \"before each\" hook for \"should forward all events\""],"originalLines":"var BroadcastReporter = (function () {\r\n    function BroadcastReporter(reporters) {\r\n        var _this = this;\r\n        this.reporters = reporters;\r\n        exports.ALL_EVENT_METHOD_NAMES.concat('wrapUp').forEach(function (method) {\r\n            _this[method] = function (arg) {\r\n                return _this.broadcast(method, arg);\r\n            };\r\n        });\r\n    }\r\n    BroadcastReporter.prototype.broadcast = function (methodName, eventArgs) {\r\n        var _this = this;\r\n        var allPromises = [];\r\n        this.reporters.forEach(function (namedReporter) {\r\n            var reporter = namedReporter.reporter;\r\n            if (reporter[methodName] && typeof reporter[methodName] === 'function') {\r\n                try {\r\n                    var maybePromise = reporter[methodName](eventArgs);\r\n                    if (objectUtils_1.isPromise(maybePromise)) {\r\n                        allPromises.push(maybePromise.catch(function (error) {\r\n                            _this.handleError(error, methodName, namedReporter.name);\r\n                        }));\r\n                    }\r\n                }\r\n                catch (error) {\r\n                    _this.handleError(error, methodName, namedReporter.name);\r\n                }\r\n            }\r\n        });\r\n        if (allPromises.length) {\r\n            return Promise.all(allPromises);\r\n        }\r\n    };\r\n    BroadcastReporter.prototype.handleError = function (error, methodName, reporterName) {\r\n        log.error(\"An error occurred during '\" + methodName + \"' on reporter '\" + reporterName + \"'. Error is: \" + error);\r\n    };\r\n    return BroadcastReporter;\r\n}());","mutatedLines":"var BroadcastReporter = (function () {\n}());"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":7,"column":42},"end":{"line":15,"column":5}},"range":[370,656],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events"],"originalLines":"    function BroadcastReporter(reporters) {\r\n        var _this = this;\r\n        this.reporters = reporters;\r\n        exports.ALL_EVENT_METHOD_NAMES.concat('wrapUp').forEach(function (method) {\r\n            _this[method] = function (arg) {\r\n                return _this.broadcast(method, arg);\r\n            };\r\n        });\r\n    }","mutatedLines":"    function BroadcastReporter(reporters) {\n}"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":19,"column":56},"end":{"line":34,"column":9}},"range":[852,1550],"testsRan":["BroadcastReporter should forward all events"],"originalLines":"        this.reporters.forEach(function (namedReporter) {\r\n            var reporter = namedReporter.reporter;\r\n            if (reporter[methodName] && typeof reporter[methodName] === 'function') {\r\n                try {\r\n                    var maybePromise = reporter[methodName](eventArgs);\r\n                    if (objectUtils_1.isPromise(maybePromise)) {\r\n                        allPromises.push(maybePromise.catch(function (error) {\r\n                            _this.handleError(error, methodName, namedReporter.name);\r\n                        }));\r\n                    }\r\n                }\r\n                catch (error) {\r\n                    _this.handleError(error, methodName, namedReporter.name);\r\n                }\r\n            }\r\n        });","mutatedLines":"        this.reporters.forEach(function (namedReporter) {\n});"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":21,"column":16},"end":{"line":21,"column":82}},"range":[923,989],"testsRan":["BroadcastReporter should forward all events"],"originalLines":"            if (reporter[methodName] && typeof reporter[methodName] === 'function') {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":21,"column":16},"end":{"line":21,"column":82}},"range":[923,989],"testsRan":["BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error"],"originalLines":"            if (reporter[methodName] && typeof reporter[methodName] === 'function') {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"LogicalOperator","status":2,"replacement":"reporter[methodName] || typeof reporter[methodName] === 'function'","location":{"start":{"line":21,"column":16},"end":{"line":21,"column":82}},"range":[923,989],"testsRan":["BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error"],"originalLines":"            if (reporter[methodName] && typeof reporter[methodName] === 'function') {","mutatedLines":"            if (reporter[methodName] || typeof reporter[methodName] === 'function') {"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":16,"column":77},"end":{"line":38,"column":5}},"range":[735,1651],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events"],"originalLines":"    BroadcastReporter.prototype.broadcast = function (methodName, eventArgs) {\r\n        var _this = this;\r\n        var allPromises = [];\r\n        this.reporters.forEach(function (namedReporter) {\r\n            var reporter = namedReporter.reporter;\r\n            if (reporter[methodName] && typeof reporter[methodName] === 'function') {\r\n                try {\r\n                    var maybePromise = reporter[methodName](eventArgs);\r\n                    if (objectUtils_1.isPromise(maybePromise)) {\r\n                        allPromises.push(maybePromise.catch(function (error) {\r\n                            _this.handleError(error, methodName, namedReporter.name);\r\n                        }));\r\n                    }\r\n                }\r\n                catch (error) {\r\n                    _this.handleError(error, methodName, namedReporter.name);\r\n                }\r\n            }\r\n        });\r\n        if (allPromises.length) {\r\n            return Promise.all(allPromises);\r\n        }\r\n    };","mutatedLines":"    BroadcastReporter.prototype.broadcast = function (methodName, eventArgs) {\n};"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"typeof reporter[methodName] !== 'function'","location":{"start":{"line":21,"column":40},"end":{"line":21,"column":82}},"range":[947,989],"testsRan":["BroadcastReporter should forward all events"],"originalLines":"            if (reporter[methodName] && typeof reporter[methodName] === 'function') {","mutatedLines":"            if (reporter[methodName] && typeof reporter[methodName] !== 'function') {"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":21,"column":84},"end":{"line":33,"column":13}},"range":[991,1539],"testsRan":["BroadcastReporter should forward all events"],"originalLines":"            if (reporter[methodName] && typeof reporter[methodName] === 'function') {\r\n                try {\r\n                    var maybePromise = reporter[methodName](eventArgs);\r\n                    if (objectUtils_1.isPromise(maybePromise)) {\r\n                        allPromises.push(maybePromise.catch(function (error) {\r\n                            _this.handleError(error, methodName, namedReporter.name);\r\n                        }));\r\n                    }\r\n                }\r\n                catch (error) {\r\n                    _this.handleError(error, methodName, namedReporter.name);\r\n                }\r\n            }","mutatedLines":"            if (reporter[methodName] && typeof reporter[methodName] === 'function') {\n}"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":22,"column":20},"end":{"line":29,"column":17}},"range":[1014,1393],"testsRan":["BroadcastReporter should forward all events"],"originalLines":"                try {\r\n                    var maybePromise = reporter[methodName](eventArgs);\r\n                    if (objectUtils_1.isPromise(maybePromise)) {\r\n                        allPromises.push(maybePromise.catch(function (error) {\r\n                            _this.handleError(error, methodName, namedReporter.name);\r\n                        }));\r\n                    }\r\n                }","mutatedLines":"                try {\n}"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":24,"column":24},"end":{"line":24,"column":61}},"range":[1114,1151],"testsRan":["BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises \"before each\" hook for \"should forward a combined promise\""],"originalLines":"                    if (objectUtils_1.isPromise(maybePromise)) {","mutatedLines":"                    if (false) {"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":9,"column":40},"end":{"line":48,"column":1}},"range":[470,2396],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker \"before each\" hook for \"should exit the process\""],"originalLines":"var ReporterOrchestrator = (function () {\r\n    function ReporterOrchestrator(options) {\r\n        this.options = options;\r\n        this.registerDefaultReporters();\r\n    }\r\n    ReporterOrchestrator.prototype.createBroadcastReporter = function () {\r\n        var _this = this;\r\n        var reporters = [];\r\n        var reporterOption = this.options.reporter;\r\n        if (reporterOption) {\r\n            if (Array.isArray(reporterOption)) {\r\n                reporterOption.forEach(function (reporterName) { return reporters.push({ name: reporterName, reporter: report_1.ReporterFactory.instance().create(reporterName, _this.options) }); });\r\n            }\r\n            else {\r\n                reporters.push({ name: reporterOption, reporter: report_1.ReporterFactory.instance().create(reporterOption, this.options) });\r\n            }\r\n        }\r\n        else {\r\n            log.warn(\"No reporter configured. Please configure one or more reporters in the (for example: reporter: 'progress')\");\r\n            this.logPossibleReporters();\r\n        }\r\n        return new BroadcastReporter_1.default(reporters);\r\n    };\r\n    ReporterOrchestrator.prototype.logPossibleReporters = function () {\r\n        var possibleReportersCsv = '';\r\n        report_1.ReporterFactory.instance().knownNames().forEach(function (name) {\r\n            if (possibleReportersCsv.length) {\r\n                possibleReportersCsv += ', ';\r\n            }\r\n            possibleReportersCsv += name;\r\n        });\r\n        log.warn(\"Possible reporters: \" + possibleReportersCsv);\r\n    };\r\n    ReporterOrchestrator.prototype.registerDefaultReporters = function () {\r\n        report_1.ReporterFactory.instance().register('progress', ProgressReporter_1.default);\r\n        report_1.ReporterFactory.instance().register('clear-text', ClearTextReporter_1.default);\r\n        report_1.ReporterFactory.instance().register('event-recorder', EventRecorderReporter_1.default);\r\n    };\r\n    return ReporterOrchestrator;\r\n}());","mutatedLines":"var ReporterOrchestrator = (function () {\n}());"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":24,"column":63},"end":{"line":28,"column":21}},"range":[1153,1374],"testsRan":["BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises \"before each\" hook for \"should forward a combined promise\""],"originalLines":"                    if (objectUtils_1.isPromise(maybePromise)) {\r\n                        allPromises.push(maybePromise.catch(function (error) {\r\n                            _this.handleError(error, methodName, namedReporter.name);\r\n                        }));\r\n                    }","mutatedLines":"                    if (objectUtils_1.isPromise(maybePromise)) {\n}"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":24,"column":24},"end":{"line":24,"column":61}},"range":[1114,1151],"testsRan":["BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error"],"originalLines":"                    if (objectUtils_1.isPromise(maybePromise)) {","mutatedLines":"                    if (true) {"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":25,"column":77},"end":{"line":27,"column":25}},"range":[1233,1348],"testsRan":["BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error"],"originalLines":"                        allPromises.push(maybePromise.catch(function (error) {\r\n                            _this.handleError(error, methodName, namedReporter.name);\r\n                        }));","mutatedLines":"                        allPromises.push(maybePromise.catch(function (error) {\n}));"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":30,"column":30},"end":{"line":32,"column":17}},"range":[1425,1524],"testsRan":["BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error"],"originalLines":"                catch (error) {\r\n                    _this.handleError(error, methodName, namedReporter.name);\r\n                }","mutatedLines":"                catch (error) {\n}"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":35,"column":32},"end":{"line":37,"column":9}},"range":[1586,1644],"testsRan":["BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises \"before each\" hook for \"should forward a combined promise\""],"originalLines":"        if (allPromises.length) {\r\n            return Promise.all(allPromises);\r\n        }","mutatedLines":"        if (allPromises.length) {\n}"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":35,"column":12},"end":{"line":35,"column":30}},"range":[1566,1584],"testsRan":["BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises \"before each\" hook for \"should forward a combined promise\""],"originalLines":"        if (allPromises.length) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":35,"column":12},"end":{"line":35,"column":30}},"range":[1566,1584],"testsRan":["BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error"],"originalLines":"        if (allPromises.length) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"'An error occurred during \\'' + methodName + '\\' on reporter \\'' + reporterName + '\\'. Error is: ' - error","location":{"start":{"line":40,"column":18},"end":{"line":40,"column":120}},"range":[1764,1866],"testsRan":["BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error"],"originalLines":"        log.error(\"An error occurred during '\" + methodName + \"' on reporter '\" + reporterName + \"'. Error is: \" + error);","mutatedLines":"        log.error('An error occurred during \\'' + methodName + '\\' on reporter \\'' + reporterName + '\\'. Error is: ' - error);"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"'An error occurred during \\'' + methodName + '\\' on reporter \\'' + reporterName - '\\'. Error is: '","location":{"start":{"line":40,"column":18},"end":{"line":40,"column":112}},"range":[1764,1858],"testsRan":["BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error"],"originalLines":"        log.error(\"An error occurred during '\" + methodName + \"' on reporter '\" + reporterName + \"'. Error is: \" + error);","mutatedLines":"        log.error('An error occurred during \\'' + methodName + '\\' on reporter \\'' + reporterName - '\\'. Error is: ' + error);"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"'An error occurred during \\'' + methodName + '\\' on reporter \\'' - reporterName","location":{"start":{"line":40,"column":18},"end":{"line":40,"column":94}},"range":[1764,1840],"testsRan":["BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error"],"originalLines":"        log.error(\"An error occurred during '\" + methodName + \"' on reporter '\" + reporterName + \"'. Error is: \" + error);","mutatedLines":"        log.error('An error occurred during \\'' + methodName + '\\' on reporter \\'' - reporterName + \"'. Error is: \" + error);"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"'An error occurred during \\'' + methodName - '\\' on reporter \\''","location":{"start":{"line":40,"column":18},"end":{"line":40,"column":79}},"range":[1764,1825],"testsRan":["BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error"],"originalLines":"        log.error(\"An error occurred during '\" + methodName + \"' on reporter '\" + reporterName + \"'. Error is: \" + error);","mutatedLines":"        log.error('An error occurred during \\'' + methodName - '\\' on reporter \\'' + reporterName + \"'. Error is: \" + error);"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"'An error occurred during \\'' - methodName","location":{"start":{"line":40,"column":18},"end":{"line":40,"column":59}},"range":[1764,1805],"testsRan":["BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error"],"originalLines":"        log.error(\"An error occurred during '\" + methodName + \"' on reporter '\" + reporterName + \"'. Error is: \" + error);","mutatedLines":"        log.error('An error occurred during \\'' - methodName + \"' on reporter '\" + reporterName + \"'. Error is: \" + error);"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":10,"column":43},"end":{"line":13,"column":5}},"range":[516,599],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    function ReporterOrchestrator(options) {\r\n        this.options = options;\r\n        this.registerDefaultReporters();\r\n    }","mutatedLines":"    function ReporterOrchestrator(options) {\n}"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":32,"column":70},"end":{"line":41,"column":5}},"range":[1610,1974],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    ReporterOrchestrator.prototype.logPossibleReporters = function () {\r\n        var possibleReportersCsv = '';\r\n        report_1.ReporterFactory.instance().knownNames().forEach(function (name) {\r\n            if (possibleReportersCsv.length) {\r\n                possibleReportersCsv += ', ';\r\n            }\r\n            possibleReportersCsv += name;\r\n        });\r\n        log.warn(\"Possible reporters: \" + possibleReportersCsv);\r\n    };","mutatedLines":"    ReporterOrchestrator.prototype.logPossibleReporters = function () {\n};"},{"sourceFilePath":"/stryker/src/reporters/BroadcastReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":39,"column":89},"end":{"line":41,"column":5}},"range":[1743,1875],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error"],"originalLines":"    BroadcastReporter.prototype.handleError = function (error, methodName, reporterName) {\r\n        log.error(\"An error occurred during '\" + methodName + \"' on reporter '\" + reporterName + \"'. Error is: \" + error);\r\n    };","mutatedLines":"    BroadcastReporter.prototype.handleError = function (error, methodName, reporterName) {\n};"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":14,"column":73},"end":{"line":31,"column":5}},"range":[674,1537],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    ReporterOrchestrator.prototype.createBroadcastReporter = function () {\r\n        var _this = this;\r\n        var reporters = [];\r\n        var reporterOption = this.options.reporter;\r\n        if (reporterOption) {\r\n            if (Array.isArray(reporterOption)) {\r\n                reporterOption.forEach(function (reporterName) { return reporters.push({ name: reporterName, reporter: report_1.ReporterFactory.instance().create(reporterName, _this.options) }); });\r\n            }\r\n            else {\r\n                reporters.push({ name: reporterOption, reporter: report_1.ReporterFactory.instance().create(reporterOption, this.options) });\r\n            }\r\n        }\r\n        else {\r\n            log.warn(\"No reporter configured. Please configure one or more reporters in the (for example: reporter: 'progress')\");\r\n            this.logPossibleReporters();\r\n        }\r\n        return new BroadcastReporter_1.default(reporters);\r\n    };","mutatedLines":"    ReporterOrchestrator.prototype.createBroadcastReporter = function () {\n};"},{"sourceFilePath":"/stryker/src/ReporterOrchestrator.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":42,"column":74},"end":{"line":46,"column":5}},"range":[2051,2358],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    ReporterOrchestrator.prototype.registerDefaultReporters = function () {\r\n        report_1.ReporterFactory.instance().register('progress', ProgressReporter_1.default);\r\n        report_1.ReporterFactory.instance().register('clear-text', ClearTextReporter_1.default);\r\n        report_1.ReporterFactory.instance().register('event-recorder', EventRecorderReporter_1.default);\r\n    };","mutatedLines":"    ReporterOrchestrator.prototype.registerDefaultReporters = function () {\n};"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"LogicalOperator","status":1,"replacement":"output && ''","location":{"start":{"line":12,"column":24},"end":{"line":12,"column":36}},"range":[424,436],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant"],"originalLines":"        this.out.write((output || '') + \"\\n\");","mutatedLines":"        this.out.write((output && '') + \"\\n\");"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"(output || '') - '\\n'","location":{"start":{"line":12,"column":23},"end":{"line":12,"column":44}},"range":[423,444],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant"],"originalLines":"        this.out.write((output || '') + \"\\n\");","mutatedLines":"        this.out.write((output || '') - '\\n');"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":24,"column":43},"end":{"line":24,"column":77}},"range":[939,973],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant"],"originalLines":"        var writeLineFn = function (input) { return _this.writeLine(input); };","mutatedLines":"        var writeLineFn = function (input) {\n};"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":25,"column":48},"end":{"line":51,"column":9}},"range":[1024,2245],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant"],"originalLines":"        mutantResults.forEach(function (result) {\r\n            if (result.testsRan) {\r\n                totalTests += result.testsRan.length;\r\n            }\r\n            switch (result.status) {\r\n                case report_1.MutantStatus.Killed:\r\n                    mutantsKilled++;\r\n                    log.debug(chalk.bold.green('Mutant killed!'));\r\n                    _this.logMutantResult(result, logDebugFn);\r\n                    break;\r\n                case report_1.MutantStatus.TimedOut:\r\n                    mutantsTimedOut++;\r\n                    log.debug(chalk.bold.yellow('Mutant timed out!'));\r\n                    _this.logMutantResult(result, logDebugFn);\r\n                    break;\r\n                case report_1.MutantStatus.Survived:\r\n                    mutantsSurvived++;\r\n                    _this.writeLine(chalk.bold.red('Mutant survived!'));\r\n                    _this.logMutantResult(result, writeLineFn);\r\n                    break;\r\n                case report_1.MutantStatus.NoCoverage:\r\n                    mutantsNoCoverage++;\r\n                    _this.writeLine(chalk.bold.yellow('Mutant survived! (not covered'));\r\n                    _this.logMutantResult(result, writeLineFn);\r\n                    break;\r\n            }\r\n        });","mutatedLines":"        mutantResults.forEach(function (result) {\n});"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":6,"column":37},"end":{"line":113,"column":1}},"range":[213,5334],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" \"before each\" hook for \"should report on the survived mutant\""],"originalLines":"var ClearTextReporter = (function () {\r\n    function ClearTextReporter(options) {\r\n        this.options = options;\r\n        this.out = process.stdout;\r\n    }\r\n    ClearTextReporter.prototype.writeLine = function (output) {\r\n        this.out.write((output || '') + \"\\n\");\r\n    };\r\n    ClearTextReporter.prototype.onAllMutantsTested = function (mutantResults) {\r\n        var _this = this;\r\n        this.writeLine();\r\n        var totalTests = 0;\r\n        var mutantsKilled = 0;\r\n        var mutantsTimedOut = 0;\r\n        var mutantsNoCoverage = 0;\r\n        var mutantsSurvived = 0;\r\n        // use these fn's in order to preserve the 'this` pointer\r\n        var logDebugFn = function (input) { return log.debug(input); };\r\n        var writeLineFn = function (input) { return _this.writeLine(input); };\r\n        mutantResults.forEach(function (result) {\r\n            if (result.testsRan) {\r\n                totalTests += result.testsRan.length;\r\n            }\r\n            switch (result.status) {\r\n                case report_1.MutantStatus.Killed:\r\n                    mutantsKilled++;\r\n                    log.debug(chalk.bold.green('Mutant killed!'));\r\n                    _this.logMutantResult(result, logDebugFn);\r\n                    break;\r\n                case report_1.MutantStatus.TimedOut:\r\n                    mutantsTimedOut++;\r\n                    log.debug(chalk.bold.yellow('Mutant timed out!'));\r\n                    _this.logMutantResult(result, logDebugFn);\r\n                    break;\r\n                case report_1.MutantStatus.Survived:\r\n                    mutantsSurvived++;\r\n                    _this.writeLine(chalk.bold.red('Mutant survived!'));\r\n                    _this.logMutantResult(result, writeLineFn);\r\n                    break;\r\n                case report_1.MutantStatus.NoCoverage:\r\n                    mutantsNoCoverage++;\r\n                    _this.writeLine(chalk.bold.yellow('Mutant survived! (not covered'));\r\n                    _this.logMutantResult(result, writeLineFn);\r\n                    break;\r\n            }\r\n        });\r\n        var mutationScoreCodebase = (((mutantsKilled + mutantsTimedOut) / mutantResults.length) * 100).toFixed(2);\r\n        var mutationScoreCodeCoverage = (((mutantsKilled + mutantsTimedOut) / ((mutantResults.length - mutantsNoCoverage) || 1)) * 100).toFixed(2);\r\n        var codebaseColor = this.getColorForMutationScore(+mutationScoreCodebase);\r\n        var codecoverageColor = this.getColorForMutationScore(+mutationScoreCodeCoverage);\r\n        this.writeLine(mutantResults.length + \" total mutants.\");\r\n        this.writeLine((mutantsSurvived + mutantsNoCoverage) + ' mutants survived.');\r\n        if (mutantsNoCoverage > 0) {\r\n            this.writeLine(\"  of which \" + mutantsNoCoverage + \" were not covered by the tests.\");\r\n        }\r\n        this.writeLine(mutantsTimedOut + ' mutants timed out.');\r\n        this.writeLine(mutantsKilled + ' mutants killed.');\r\n        this.writeLine(\"Ran \" + (totalTests / mutantResults.length).toFixed(2) + \" tests per mutant on average.\");\r\n        if (this.options.coverageAnalysis === 'off') {\r\n            this.writeLine(\"Mutation score based on covered code: n/a\");\r\n        }\r\n        else {\r\n            this.writeLine(\"Mutation score based on covered code: \" + codecoverageColor(mutationScoreCodeCoverage + '%'));\r\n        }\r\n        this.writeLine(\"Mutation score based on all code: \" + codebaseColor(mutationScoreCodebase + '%'));\r\n    };\r\n    ClearTextReporter.prototype.logMutantResult = function (result, logImplementation) {\r\n        logImplementation(result.sourceFilePath + ': line ' + result.location.start.line + ':' + result.location.start.column);\r\n        logImplementation('Mutator: ' + result.mutatorName);\r\n        result.originalLines.split('\\n').forEach(function (line) {\r\n            logImplementation(chalk.red('-   ' + line));\r\n        });\r\n        result.mutatedLines.split('\\n').forEach(function (line) {\r\n            logImplementation(chalk.green('+   ' + line));\r\n        });\r\n        logImplementation('');\r\n        if (this.options.coverageAnalysis === 'perTest') {\r\n            if (result.testsRan && result.testsRan.length > 0) {\r\n                logImplementation('Tests ran: ');\r\n                result.testsRan.forEach(function (spec) { return logImplementation('    ' + spec); });\r\n                logImplementation('');\r\n            }\r\n        }\r\n        else if (result.testsRan && result.testsRan.length > 0) {\r\n            logImplementation('Ran all tests for this mutant.');\r\n        }\r\n    };\r\n    /**\r\n     * Gets the color associated with a mutation score.\r\n     * @function\r\n     * @param score - The mutation score.\r\n     * @returns {Function} The function which can give the mutation score the right color.\r\n     */\r\n    ClearTextReporter.prototype.getColorForMutationScore = function (score) {\r\n        var color;\r\n        if (score > 80) {\r\n            color = chalk.green;\r\n        }\r\n        else if (score > 50) {\r\n            color = chalk.yellow;\r\n        }\r\n        else {\r\n            color = chalk.red;\r\n        }\r\n        return color;\r\n    };\r\n    return ClearTextReporter;\r\n}());","mutatedLines":"var ClearTextReporter = (function () {\n}());"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":23,"column":42},"end":{"line":23,"column":70}},"range":[865,893],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran"],"originalLines":"        var logDebugFn = function (input) { return log.debug(input); };","mutatedLines":"        var logDebugFn = function (input) {\n};"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":7,"column":40},"end":{"line":10,"column":5}},"range":[256,333],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() \"before each\" hook for \"should report on the survived mutant\""],"originalLines":"    function ClearTextReporter(options) {\r\n        this.options = options;\r\n        this.out = process.stdout;\r\n    }","mutatedLines":"    function ClearTextReporter(options) {\n}"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":11,"column":62},"end":{"line":13,"column":5}},"range":[397,453],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant"],"originalLines":"    ClearTextReporter.prototype.writeLine = function (output) {\r\n        this.out.write((output || '') + \"\\n\");\r\n    };","mutatedLines":"    ClearTextReporter.prototype.writeLine = function (output) {\n};"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":26,"column":16},"end":{"line":26,"column":31}},"range":[1043,1058],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran"],"originalLines":"            if (result.testsRan) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"UpdateOperator","status":1,"replacement":"mutantsTimedOut--","location":{"start":{"line":36,"column":20},"end":{"line":36,"column":37}},"range":[1495,1512],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation"],"originalLines":"                    mutantsTimedOut++;","mutatedLines":"                    mutantsTimedOut--;"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":14,"column":78},"end":{"line":71,"column":5}},"range":[534,3641],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant"],"originalLines":"    ClearTextReporter.prototype.onAllMutantsTested = function (mutantResults) {\r\n        var _this = this;\r\n        this.writeLine();\r\n        var totalTests = 0;\r\n        var mutantsKilled = 0;\r\n        var mutantsTimedOut = 0;\r\n        var mutantsNoCoverage = 0;\r\n        var mutantsSurvived = 0;\r\n        // use these fn's in order to preserve the 'this` pointer\r\n        var logDebugFn = function (input) { return log.debug(input); };\r\n        var writeLineFn = function (input) { return _this.writeLine(input); };\r\n        mutantResults.forEach(function (result) {\r\n            if (result.testsRan) {\r\n                totalTests += result.testsRan.length;\r\n            }\r\n            switch (result.status) {\r\n                case report_1.MutantStatus.Killed:\r\n                    mutantsKilled++;\r\n                    log.debug(chalk.bold.green('Mutant killed!'));\r\n                    _this.logMutantResult(result, logDebugFn);\r\n                    break;\r\n                case report_1.MutantStatus.TimedOut:\r\n                    mutantsTimedOut++;\r\n                    log.debug(chalk.bold.yellow('Mutant timed out!'));\r\n                    _this.logMutantResult(result, logDebugFn);\r\n                    break;\r\n                case report_1.MutantStatus.Survived:\r\n                    mutantsSurvived++;\r\n                    _this.writeLine(chalk.bold.red('Mutant survived!'));\r\n                    _this.logMutantResult(result, writeLineFn);\r\n                    break;\r\n                case report_1.MutantStatus.NoCoverage:\r\n                    mutantsNoCoverage++;\r\n                    _this.writeLine(chalk.bold.yellow('Mutant survived! (not covered'));\r\n                    _this.logMutantResult(result, writeLineFn);\r\n                    break;\r\n            }\r\n        });\r\n        var mutationScoreCodebase = (((mutantsKilled + mutantsTimedOut) / mutantResults.length) * 100).toFixed(2);\r\n        var mutationScoreCodeCoverage = (((mutantsKilled + mutantsTimedOut) / ((mutantResults.length - mutantsNoCoverage) || 1)) * 100).toFixed(2);\r\n        var codebaseColor = this.getColorForMutationScore(+mutationScoreCodebase);\r\n        var codecoverageColor = this.getColorForMutationScore(+mutationScoreCodeCoverage);\r\n        this.writeLine(mutantResults.length + \" total mutants.\");\r\n        this.writeLine((mutantsSurvived + mutantsNoCoverage) + ' mutants survived.');\r\n        if (mutantsNoCoverage > 0) {\r\n            this.writeLine(\"  of which \" + mutantsNoCoverage + \" were not covered by the tests.\");\r\n        }\r\n        this.writeLine(mutantsTimedOut + ' mutants timed out.');\r\n        this.writeLine(mutantsKilled + ' mutants killed.');\r\n        this.writeLine(\"Ran \" + (totalTests / mutantResults.length).toFixed(2) + \" tests per mutant on average.\");\r\n        if (this.options.coverageAnalysis === 'off') {\r\n            this.writeLine(\"Mutation score based on covered code: n/a\");\r\n        }\r\n        else {\r\n            this.writeLine(\"Mutation score based on covered code: \" + codecoverageColor(mutationScoreCodeCoverage + '%'));\r\n        }\r\n        this.writeLine(\"Mutation score based on all code: \" + codebaseColor(mutationScoreCodebase + '%'));\r\n    };","mutatedLines":"    ClearTextReporter.prototype.onAllMutantsTested = function (mutantResults) {\n};"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"UpdateOperator","status":1,"replacement":"mutantsKilled--","location":{"start":{"line":31,"column":20},"end":{"line":31,"column":35}},"range":[1243,1258],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation"],"originalLines":"                    mutantsKilled++;","mutatedLines":"                    mutantsKilled--;"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":26,"column":16},"end":{"line":26,"column":31}},"range":[1043,1058],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran"],"originalLines":"            if (result.testsRan) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":26,"column":33},"end":{"line":28,"column":13}},"range":[1060,1131],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran"],"originalLines":"            if (result.testsRan) {\r\n                totalTests += result.testsRan.length;\r\n            }","mutatedLines":"            if (result.testsRan) {\n}"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"UpdateOperator","status":1,"replacement":"mutantsNoCoverage--","location":{"start":{"line":46,"column":20},"end":{"line":46,"column":39}},"range":[2016,2035],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation"],"originalLines":"                    mutantsNoCoverage++;","mutatedLines":"                    mutantsNoCoverage--;"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"UpdateOperator","status":1,"replacement":"mutantsSurvived--","location":{"start":{"line":41,"column":20},"end":{"line":41,"column":37}},"range":[1753,1770],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation"],"originalLines":"                    mutantsSurvived++;","mutatedLines":"                    mutantsSurvived--;"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"(mutantsKilled + mutantsTimedOut) / mutantResults.length / 100","location":{"start":{"line":52,"column":37},"end":{"line":52,"column":101}},"range":[2286,2350],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation"],"originalLines":"        var mutationScoreCodebase = (((mutantsKilled + mutantsTimedOut) / mutantResults.length) * 100).toFixed(2);","mutatedLines":"        var mutationScoreCodebase = ((mutantsKilled + mutantsTimedOut) / mutantResults.length / 100).toFixed(2);"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"(mutantsKilled + mutantsTimedOut) * mutantResults.length","location":{"start":{"line":52,"column":38},"end":{"line":52,"column":94}},"range":[2287,2343],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation"],"originalLines":"        var mutationScoreCodebase = (((mutantsKilled + mutantsTimedOut) / mutantResults.length) * 100).toFixed(2);","mutatedLines":"        var mutationScoreCodebase = (((mutantsKilled + mutantsTimedOut) * mutantResults.length) * 100).toFixed(2);"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"(mutantsKilled + mutantsTimedOut) * (mutantResults.length - mutantsNoCoverage || 1)","location":{"start":{"line":53,"column":42},"end":{"line":53,"column":127}},"range":[2407,2492],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation"],"originalLines":"        var mutationScoreCodeCoverage = (((mutantsKilled + mutantsTimedOut) / ((mutantResults.length - mutantsNoCoverage) || 1)) * 100).toFixed(2);","mutatedLines":"        var mutationScoreCodeCoverage = (((mutantsKilled + mutantsTimedOut) * (mutantResults.length - mutantsNoCoverage || 1)) * 100).toFixed(2);"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"(mutantsKilled + mutantsTimedOut) / (mutantResults.length - mutantsNoCoverage || 1) / 100","location":{"start":{"line":53,"column":41},"end":{"line":53,"column":134}},"range":[2406,2499],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation"],"originalLines":"        var mutationScoreCodeCoverage = (((mutantsKilled + mutantsTimedOut) / ((mutantResults.length - mutantsNoCoverage) || 1)) * 100).toFixed(2);","mutatedLines":"        var mutationScoreCodeCoverage = ((mutantsKilled + mutantsTimedOut) / (mutantResults.length - mutantsNoCoverage || 1) / 100).toFixed(2);"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"mutantsKilled - mutantsTimedOut","location":{"start":{"line":52,"column":39},"end":{"line":52,"column":70}},"range":[2288,2319],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation"],"originalLines":"        var mutationScoreCodebase = (((mutantsKilled + mutantsTimedOut) / mutantResults.length) * 100).toFixed(2);","mutatedLines":"        var mutationScoreCodebase = (((mutantsKilled - mutantsTimedOut) / mutantResults.length) * 100).toFixed(2);"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"mutantsKilled - mutantsTimedOut","location":{"start":{"line":53,"column":43},"end":{"line":53,"column":74}},"range":[2408,2439],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation"],"originalLines":"        var mutationScoreCodeCoverage = (((mutantsKilled + mutantsTimedOut) / ((mutantResults.length - mutantsNoCoverage) || 1)) * 100).toFixed(2);","mutatedLines":"        var mutationScoreCodeCoverage = (((mutantsKilled - mutantsTimedOut) / ((mutantResults.length - mutantsNoCoverage) || 1)) * 100).toFixed(2);"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"LogicalOperator","status":1,"replacement":"mutantResults.length - mutantsNoCoverage && 1","location":{"start":{"line":53,"column":79},"end":{"line":53,"column":126}},"range":[2444,2491],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation"],"originalLines":"        var mutationScoreCodeCoverage = (((mutantsKilled + mutantsTimedOut) / ((mutantResults.length - mutantsNoCoverage) || 1)) * 100).toFixed(2);","mutatedLines":"        var mutationScoreCodeCoverage = (((mutantsKilled + mutantsTimedOut) / (mutantResults.length - mutantsNoCoverage && 1)) * 100).toFixed(2);"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"mutantResults.length + mutantsNoCoverage","location":{"start":{"line":53,"column":80},"end":{"line":53,"column":120}},"range":[2445,2485],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation"],"originalLines":"        var mutationScoreCodeCoverage = (((mutantsKilled + mutantsTimedOut) / ((mutantResults.length - mutantsNoCoverage) || 1)) * 100).toFixed(2);","mutatedLines":"        var mutationScoreCodeCoverage = (((mutantsKilled + mutantsTimedOut) / ((mutantResults.length + mutantsNoCoverage) || 1)) * 100).toFixed(2);"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"mutantResults.length - ' total mutants.'","location":{"start":{"line":56,"column":23},"end":{"line":56,"column":63}},"range":[2713,2753],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation"],"originalLines":"        this.writeLine(mutantResults.length + \" total mutants.\");","mutatedLines":"        this.writeLine(mutantResults.length - ' total mutants.');"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"mutantsSurvived + mutantsNoCoverage - ' mutants survived.'","location":{"start":{"line":57,"column":23},"end":{"line":57,"column":83}},"range":[2780,2840],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation"],"originalLines":"        this.writeLine((mutantsSurvived + mutantsNoCoverage) + ' mutants survived.');","mutatedLines":"        this.writeLine(mutantsSurvived + mutantsNoCoverage - ' mutants survived.');"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"mutantsSurvived - mutantsNoCoverage","location":{"start":{"line":57,"column":24},"end":{"line":57,"column":59}},"range":[2781,2816],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation"],"originalLines":"        this.writeLine((mutantsSurvived + mutantsNoCoverage) + ' mutants survived.');","mutatedLines":"        this.writeLine((mutantsSurvived - mutantsNoCoverage) + ' mutants survived.');"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"UnaryOperator","status":2,"replacement":"-mutationScoreCodeCoverage","location":{"start":{"line":55,"column":62},"end":{"line":55,"column":88}},"range":[2660,2686],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran"],"originalLines":"        var codecoverageColor = this.getColorForMutationScore(+mutationScoreCodeCoverage);","mutatedLines":"        var codecoverageColor = this.getColorForMutationScore(-mutationScoreCodeCoverage);"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"UnaryOperator","status":2,"replacement":"-mutationScoreCodebase","location":{"start":{"line":54,"column":58},"end":{"line":54,"column":80}},"range":[2572,2594],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran"],"originalLines":"        var codebaseColor = this.getColorForMutationScore(+mutationScoreCodebase);","mutatedLines":"        var codebaseColor = this.getColorForMutationScore(-mutationScoreCodebase);"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"RemoveConditionals","status":2,"replacement":"false","location":{"start":{"line":58,"column":12},"end":{"line":58,"column":33}},"range":[2856,2877],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran"],"originalLines":"        if (mutantsNoCoverage > 0) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":58,"column":12},"end":{"line":58,"column":33}},"range":[2856,2877],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran"],"originalLines":"        if (mutantsNoCoverage > 0) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":2,"replacement":"mutantsNoCoverage >= 0","location":{"start":{"line":58,"column":12},"end":{"line":58,"column":33}},"range":[2856,2877],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran"],"originalLines":"        if (mutantsNoCoverage > 0) {","mutatedLines":"        if (mutantsNoCoverage >= 0) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":2,"replacement":"mutantsNoCoverage <= 0","location":{"start":{"line":58,"column":12},"end":{"line":58,"column":33}},"range":[2856,2877],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran"],"originalLines":"        if (mutantsNoCoverage > 0) {","mutatedLines":"        if (mutantsNoCoverage <= 0) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":58,"column":35},"end":{"line":60,"column":9}},"range":[2879,2991],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran"],"originalLines":"        if (mutantsNoCoverage > 0) {\r\n            this.writeLine(\"  of which \" + mutantsNoCoverage + \" were not covered by the tests.\");\r\n        }","mutatedLines":"        if (mutantsNoCoverage > 0) {\n}"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":2,"replacement":"'  of which ' + mutantsNoCoverage - ' were not covered by the tests.'","location":{"start":{"line":59,"column":27},"end":{"line":59,"column":96}},"range":[2909,2978],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran"],"originalLines":"            this.writeLine(\"  of which \" + mutantsNoCoverage + \" were not covered by the tests.\");","mutatedLines":"            this.writeLine('  of which ' + mutantsNoCoverage - ' were not covered by the tests.');"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":2,"replacement":"'  of which ' - mutantsNoCoverage","location":{"start":{"line":59,"column":27},"end":{"line":59,"column":60}},"range":[2909,2942],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran"],"originalLines":"            this.writeLine(\"  of which \" + mutantsNoCoverage + \" were not covered by the tests.\");","mutatedLines":"            this.writeLine('  of which ' - mutantsNoCoverage + \" were not covered by the tests.\");"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":2,"replacement":"mutantsTimedOut - ' mutants timed out.'","location":{"start":{"line":61,"column":23},"end":{"line":61,"column":62}},"range":[3016,3055],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran"],"originalLines":"        this.writeLine(mutantsTimedOut + ' mutants timed out.');","mutatedLines":"        this.writeLine(mutantsTimedOut - ' mutants timed out.');"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":2,"replacement":"mutantsKilled - ' mutants killed.'","location":{"start":{"line":62,"column":23},"end":{"line":62,"column":57}},"range":[3082,3116],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran"],"originalLines":"        this.writeLine(mutantsKilled + ' mutants killed.');","mutatedLines":"        this.writeLine(mutantsKilled - ' mutants killed.');"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":64,"column":12},"end":{"line":64,"column":51}},"range":[3248,3287],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation"],"originalLines":"        if (this.options.coverageAnalysis === 'off') {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"this.options.coverageAnalysis !== 'off'","location":{"start":{"line":64,"column":12},"end":{"line":64,"column":51}},"range":[3248,3287],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation"],"originalLines":"        if (this.options.coverageAnalysis === 'off') {","mutatedLines":"        if (this.options.coverageAnalysis !== 'off') {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"totalTests * mutantResults.length","location":{"start":{"line":63,"column":33},"end":{"line":63,"column":66}},"range":[3153,3186],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran"],"originalLines":"        this.writeLine(\"Ran \" + (totalTests / mutantResults.length).toFixed(2) + \" tests per mutant on average.\");","mutatedLines":"        this.writeLine(\"Ran \" + (totalTests * mutantResults.length).toFixed(2) + \" tests per mutant on average.\");"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"'Ran ' + (totalTests / mutantResults.length).toFixed(2) - ' tests per mutant on average.'","location":{"start":{"line":63,"column":23},"end":{"line":63,"column":112}},"range":[3143,3232],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran"],"originalLines":"        this.writeLine(\"Ran \" + (totalTests / mutantResults.length).toFixed(2) + \" tests per mutant on average.\");","mutatedLines":"        this.writeLine('Ran ' + (totalTests / mutantResults.length).toFixed(2) - ' tests per mutant on average.');"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"'Ran ' - (totalTests / mutantResults.length).toFixed(2)","location":{"start":{"line":63,"column":23},"end":{"line":63,"column":78}},"range":[3143,3198],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran"],"originalLines":"        this.writeLine(\"Ran \" + (totalTests / mutantResults.length).toFixed(2) + \" tests per mutant on average.\");","mutatedLines":"        this.writeLine('Ran ' - (totalTests / mutantResults.length).toFixed(2) + \" tests per mutant on average.\");"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":64,"column":12},"end":{"line":64,"column":51}},"range":[3248,3287],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available"],"originalLines":"        if (this.options.coverageAnalysis === 'off') {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":67,"column":13},"end":{"line":69,"column":9}},"range":[3390,3526],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation"],"originalLines":"        else {\r\n            this.writeLine(\"Mutation score based on covered code: \" + codecoverageColor(mutationScoreCodeCoverage + '%'));\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":64,"column":53},"end":{"line":66,"column":9}},"range":[3289,3375],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available"],"originalLines":"        if (this.options.coverageAnalysis === 'off') {\r\n            this.writeLine(\"Mutation score based on covered code: n/a\");\r\n        }","mutatedLines":"        if (this.options.coverageAnalysis === 'off') {\n}"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"mutationScoreCodeCoverage - '%'","location":{"start":{"line":68,"column":88},"end":{"line":68,"column":119}},"range":[3481,3512],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation"],"originalLines":"            this.writeLine(\"Mutation score based on covered code: \" + codecoverageColor(mutationScoreCodeCoverage + '%'));","mutatedLines":"            this.writeLine(\"Mutation score based on covered code: \" + codecoverageColor(mutationScoreCodeCoverage - '%'));"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"'Mutation score based on covered code: ' - codecoverageColor(mutationScoreCodeCoverage + '%')","location":{"start":{"line":68,"column":27},"end":{"line":68,"column":120}},"range":[3420,3513],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation"],"originalLines":"            this.writeLine(\"Mutation score based on covered code: \" + codecoverageColor(mutationScoreCodeCoverage + '%'));","mutatedLines":"            this.writeLine('Mutation score based on covered code: ' - codecoverageColor(mutationScoreCodeCoverage + '%'));"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"'Mutation score based on all code: ' - codebaseColor(mutationScoreCodebase + '%')","location":{"start":{"line":70,"column":23},"end":{"line":70,"column":104}},"range":[3551,3632],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation"],"originalLines":"        this.writeLine(\"Mutation score based on all code: \" + codebaseColor(mutationScoreCodebase + '%'));","mutatedLines":"        this.writeLine('Mutation score based on all code: ' - codebaseColor(mutationScoreCodebase + '%'));"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"mutationScoreCodebase - '%'","location":{"start":{"line":70,"column":76},"end":{"line":70,"column":103}},"range":[3604,3631],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation"],"originalLines":"        this.writeLine(\"Mutation score based on all code: \" + codebaseColor(mutationScoreCodebase + '%'));","mutatedLines":"        this.writeLine(\"Mutation score based on all code: \" + codebaseColor(mutationScoreCodebase - '%'));"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":75,"column":65},"end":{"line":77,"column":9}},"range":[3990,4060],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant"],"originalLines":"        result.originalLines.split('\\n').forEach(function (line) {\r\n            logImplementation(chalk.red('-   ' + line));\r\n        });","mutatedLines":"        result.originalLines.split('\\n').forEach(function (line) {\n});"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":2,"replacement":"result.sourceFilePath + ': line ' + result.location.start.line + ':' - result.location.start.column","location":{"start":{"line":73,"column":26},"end":{"line":73,"column":125}},"range":[3760,3859],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran"],"originalLines":"        logImplementation(result.sourceFilePath + ': line ' + result.location.start.line + ':' + result.location.start.column);","mutatedLines":"        logImplementation(result.sourceFilePath + ': line ' + result.location.start.line + ':' - result.location.start.column);"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"'Mutator: ' - result.mutatorName","location":{"start":{"line":74,"column":26},"end":{"line":74,"column":58}},"range":[3889,3921],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant"],"originalLines":"        logImplementation('Mutator: ' + result.mutatorName);","mutatedLines":"        logImplementation('Mutator: ' - result.mutatorName);"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"'-   ' - line","location":{"start":{"line":76,"column":40},"end":{"line":76,"column":53}},"range":[4033,4046],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant"],"originalLines":"            logImplementation(chalk.red('-   ' + line));","mutatedLines":"            logImplementation(chalk.red('-   ' - line));"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":72,"column":87},"end":{"line":92,"column":5}},"range":[3731,4732],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant"],"originalLines":"    ClearTextReporter.prototype.logMutantResult = function (result, logImplementation) {\r\n        logImplementation(result.sourceFilePath + ': line ' + result.location.start.line + ':' + result.location.start.column);\r\n        logImplementation('Mutator: ' + result.mutatorName);\r\n        result.originalLines.split('\\n').forEach(function (line) {\r\n            logImplementation(chalk.red('-   ' + line));\r\n        });\r\n        result.mutatedLines.split('\\n').forEach(function (line) {\r\n            logImplementation(chalk.green('+   ' + line));\r\n        });\r\n        logImplementation('');\r\n        if (this.options.coverageAnalysis === 'perTest') {\r\n            if (result.testsRan && result.testsRan.length > 0) {\r\n                logImplementation('Tests ran: ');\r\n                result.testsRan.forEach(function (spec) { return logImplementation('    ' + spec); });\r\n                logImplementation('');\r\n            }\r\n        }\r\n        else if (result.testsRan && result.testsRan.length > 0) {\r\n            logImplementation('Ran all tests for this mutant.');\r\n        }\r\n    };","mutatedLines":"    ClearTextReporter.prototype.logMutantResult = function (result, logImplementation) {\n};"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":2,"replacement":"result.sourceFilePath + ': line ' - result.location.start.line","location":{"start":{"line":73,"column":26},"end":{"line":73,"column":88}},"range":[3760,3822],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran"],"originalLines":"        logImplementation(result.sourceFilePath + ': line ' + result.location.start.line + ':' + result.location.start.column);","mutatedLines":"        logImplementation(result.sourceFilePath + ': line ' - result.location.start.line + ':' + result.location.start.column);"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"'+   ' - line","location":{"start":{"line":79,"column":42},"end":{"line":79,"column":55}},"range":[4173,4186],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant"],"originalLines":"            logImplementation(chalk.green('+   ' + line));","mutatedLines":"            logImplementation(chalk.green('+   ' - line));"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":78,"column":64},"end":{"line":80,"column":9}},"range":[4128,4200],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant"],"originalLines":"        result.mutatedLines.split('\\n').forEach(function (line) {\r\n            logImplementation(chalk.green('+   ' + line));\r\n        });","mutatedLines":"        result.mutatedLines.split('\\n').forEach(function (line) {\n});"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":2,"replacement":"result.sourceFilePath + ': line ' + result.location.start.line - ':'","location":{"start":{"line":73,"column":26},"end":{"line":73,"column":94}},"range":[3760,3828],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran"],"originalLines":"        logImplementation(result.sourceFilePath + ': line ' + result.location.start.line + ':' + result.location.start.column);","mutatedLines":"        logImplementation(result.sourceFilePath + ': line ' + result.location.start.line - ':' + result.location.start.column);"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":2,"replacement":"result.sourceFilePath - ': line '","location":{"start":{"line":73,"column":26},"end":{"line":73,"column":59}},"range":[3760,3793],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran"],"originalLines":"        logImplementation(result.sourceFilePath + ': line ' + result.location.start.line + ':' + result.location.start.column);","mutatedLines":"        logImplementation(result.sourceFilePath - ': line ' + result.location.start.line + ':' + result.location.start.column);"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":82,"column":12},"end":{"line":82,"column":55}},"range":[4248,4291],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests"],"originalLines":"        if (this.options.coverageAnalysis === 'perTest') {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":82,"column":12},"end":{"line":82,"column":55}},"range":[4248,4291],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests"],"originalLines":"        if (this.options.coverageAnalysis === 'perTest') {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":83,"column":16},"end":{"line":83,"column":61}},"range":[4312,4357],"testsRan":["ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests"],"originalLines":"            if (result.testsRan && result.testsRan.length > 0) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"this.options.coverageAnalysis !== 'perTest'","location":{"start":{"line":82,"column":12},"end":{"line":82,"column":55}},"range":[4248,4291],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests"],"originalLines":"        if (this.options.coverageAnalysis === 'perTest') {","mutatedLines":"        if (this.options.coverageAnalysis !== 'perTest') {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":83,"column":16},"end":{"line":83,"column":61}},"range":[4312,4357],"testsRan":["ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests"],"originalLines":"            if (result.testsRan && result.testsRan.length > 0) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":2,"replacement":"result.testsRan.length >= 0","location":{"start":{"line":83,"column":35},"end":{"line":83,"column":61}},"range":[4331,4357],"testsRan":["ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests"],"originalLines":"            if (result.testsRan && result.testsRan.length > 0) {","mutatedLines":"            if (result.testsRan && result.testsRan.length >= 0) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"LogicalOperator","status":2,"replacement":"result.testsRan || result.testsRan.length > 0","location":{"start":{"line":83,"column":16},"end":{"line":83,"column":61}},"range":[4312,4357],"testsRan":["ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests"],"originalLines":"            if (result.testsRan && result.testsRan.length > 0) {","mutatedLines":"            if (result.testsRan || result.testsRan.length > 0) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"result.testsRan.length <= 0","location":{"start":{"line":83,"column":35},"end":{"line":83,"column":61}},"range":[4331,4357],"testsRan":["ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests"],"originalLines":"            if (result.testsRan && result.testsRan.length > 0) {","mutatedLines":"            if (result.testsRan && result.testsRan.length <= 0) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":83,"column":63},"end":{"line":87,"column":13}},"range":[4359,4570],"testsRan":["ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests"],"originalLines":"            if (result.testsRan && result.testsRan.length > 0) {\r\n                logImplementation('Tests ran: ');\r\n                result.testsRan.forEach(function (spec) { return logImplementation('    ' + spec); });\r\n                logImplementation('');\r\n            }","mutatedLines":"            if (result.testsRan && result.testsRan.length > 0) {\n}"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":82,"column":57},"end":{"line":88,"column":9}},"range":[4293,4581],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests"],"originalLines":"        if (this.options.coverageAnalysis === 'perTest') {\r\n            if (result.testsRan && result.testsRan.length > 0) {\r\n                logImplementation('Tests ran: ');\r\n                result.testsRan.forEach(function (spec) { return logImplementation('    ' + spec); });\r\n                logImplementation('');\r\n            }\r\n        }","mutatedLines":"        if (this.options.coverageAnalysis === 'perTest') {\n}"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":85,"column":56},"end":{"line":85,"column":100}},"range":[4469,4513],"testsRan":["ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests"],"originalLines":"                result.testsRan.forEach(function (spec) { return logImplementation('    ' + spec); });","mutatedLines":"                result.testsRan.forEach(function (spec) {\n});"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":89,"column":17},"end":{"line":89,"column":62}},"range":[4600,4645],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests"],"originalLines":"        else if (result.testsRan && result.testsRan.length > 0) {","mutatedLines":"        else if (false) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"'    ' - spec","location":{"start":{"line":85,"column":83},"end":{"line":85,"column":96}},"range":[4496,4509],"testsRan":["ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests"],"originalLines":"                result.testsRan.forEach(function (spec) { return logImplementation('    ' + spec); });","mutatedLines":"                result.testsRan.forEach(function (spec) { return logImplementation('    ' - spec); });"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":89,"column":64},"end":{"line":91,"column":9}},"range":[4647,4725],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests"],"originalLines":"        else if (result.testsRan && result.testsRan.length > 0) {\r\n            logImplementation('Ran all tests for this mutant.');\r\n        }","mutatedLines":"        else if (result.testsRan && result.testsRan.length > 0) {\n}"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"result.testsRan.length <= 0","location":{"start":{"line":89,"column":36},"end":{"line":89,"column":62}},"range":[4619,4645],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests"],"originalLines":"        else if (result.testsRan && result.testsRan.length > 0) {","mutatedLines":"        else if (result.testsRan && result.testsRan.length <= 0) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":89,"column":17},"end":{"line":89,"column":62}},"range":[4600,4645],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran"],"originalLines":"        else if (result.testsRan && result.testsRan.length > 0) {","mutatedLines":"        else if (true) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":2,"replacement":"result.testsRan.length >= 0","location":{"start":{"line":89,"column":36},"end":{"line":89,"column":62}},"range":[4619,4645],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran"],"originalLines":"        else if (result.testsRan && result.testsRan.length > 0) {","mutatedLines":"        else if (result.testsRan && result.testsRan.length >= 0) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"LogicalOperator","status":2,"replacement":"result.testsRan || result.testsRan.length > 0","location":{"start":{"line":89,"column":17},"end":{"line":89,"column":62}},"range":[4600,4645],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran"],"originalLines":"        else if (result.testsRan && result.testsRan.length > 0) {","mutatedLines":"        else if (result.testsRan || result.testsRan.length > 0) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"RemoveConditionals","status":2,"replacement":"false","location":{"start":{"line":101,"column":12},"end":{"line":101,"column":22}},"range":[5074,5084],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran"],"originalLines":"        if (score > 80) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":101,"column":12},"end":{"line":101,"column":22}},"range":[5074,5084],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran"],"originalLines":"        if (score > 80) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":2,"replacement":"score >= 80","location":{"start":{"line":101,"column":12},"end":{"line":101,"column":22}},"range":[5074,5084],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran"],"originalLines":"        if (score > 80) {","mutatedLines":"        if (score >= 80) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":2,"replacement":"score <= 80","location":{"start":{"line":101,"column":12},"end":{"line":101,"column":22}},"range":[5074,5084],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran"],"originalLines":"        if (score > 80) {","mutatedLines":"        if (score <= 80) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":99,"column":76},"end":{"line":111,"column":5}},"range":[5039,5299],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() \"before each\" hook for \"should report on the survived mutant\""],"originalLines":"    ClearTextReporter.prototype.getColorForMutationScore = function (score) {\r\n        var color;\r\n        if (score > 80) {\r\n            color = chalk.green;\r\n        }\r\n        else if (score > 50) {\r\n            color = chalk.yellow;\r\n        }\r\n        else {\r\n            color = chalk.red;\r\n        }\r\n        return color;\r\n    };","mutatedLines":"    ClearTextReporter.prototype.getColorForMutationScore = function (score) {\n};"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":101,"column":24},"end":{"line":103,"column":9}},"range":[5086,5132],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran"],"originalLines":"        if (score > 80) {\r\n            color = chalk.green;\r\n        }","mutatedLines":"        if (score > 80) {\n}"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"RemoveConditionals","status":2,"replacement":"false","location":{"start":{"line":104,"column":17},"end":{"line":104,"column":27}},"range":[5151,5161],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran"],"originalLines":"        else if (score > 50) {","mutatedLines":"        else if (false) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":104,"column":17},"end":{"line":104,"column":27}},"range":[5151,5161],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran"],"originalLines":"        else if (score > 50) {","mutatedLines":"        else if (true) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":104,"column":29},"end":{"line":106,"column":9}},"range":[5163,5210],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() \"before each\" hook for \"should report on the survived mutant\""],"originalLines":"        else if (score > 50) {\r\n            color = chalk.yellow;\r\n        }","mutatedLines":"        else if (score > 50) {\n}"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":107,"column":13},"end":{"line":109,"column":9}},"range":[5225,5269],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() \"before each\" hook for \"should report on the survived mutant\""],"originalLines":"        else {\r\n            color = chalk.red;\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":2,"replacement":"score >= 50","location":{"start":{"line":104,"column":17},"end":{"line":104,"column":27}},"range":[5151,5161],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran"],"originalLines":"        else if (score > 50) {","mutatedLines":"        else if (score >= 50) {"},{"sourceFilePath":"/stryker/src/reporters/ClearTextReporter.js","mutatorName":"BinaryOperator","status":2,"replacement":"score <= 50","location":{"start":{"line":104,"column":17},"end":{"line":104,"column":27}},"range":[5151,5161],"testsRan":["ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran"],"originalLines":"        else if (score > 50) {","mutatedLines":"        else if (score <= 50) {"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":15,"column":77},"end":{"line":19,"column":9}},"range":[649,860],"testsRan":["EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection \"before each\" hook for \"should reject `wrapUp`\""],"originalLines":"        BroadcastReporter_1.ALL_EVENT_METHOD_NAMES.forEach(function (method) {\r\n            _this[method] = function (data) {\r\n                _this.allWork.push(_this.createBaseFolderTask.then(function () { return _this.writeToFile(index++, method, data); }));\r\n            };\r\n        });","mutatedLines":"        BroadcastReporter_1.ALL_EVENT_METHOD_NAMES.forEach(function (method) {\n});"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":16,"column":44},"end":{"line":18,"column":13}},"range":[696,848],"testsRan":["EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`"],"originalLines":"            _this[method] = function (data) {\r\n                _this.allWork.push(_this.createBaseFolderTask.then(function () { return _this.writeToFile(index++, method, data); }));\r\n            };","mutatedLines":"            _this[method] = function (data) {\n};"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":17,"column":79},"end":{"line":17,"column":131}},"range":[778,830],"testsRan":["EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`"],"originalLines":"                _this.allWork.push(_this.createBaseFolderTask.then(function () { return _this.writeToFile(index++, method, data); }));","mutatedLines":"                _this.allWork.push(_this.createBaseFolderTask.then(function () {\n}));"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"UpdateOperator","status":2,"replacement":"index--","location":{"start":{"line":17,"column":106},"end":{"line":17,"column":113}},"range":[805,812],"testsRan":["EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile"],"originalLines":"                _this.allWork.push(_this.createBaseFolderTask.then(function () { return _this.writeToFile(index++, method, data); }));","mutatedLines":"                _this.allWork.push(_this.createBaseFolderTask.then(function () { return _this.writeToFile(index--, method, data); }));"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":23,"column":16},"end":{"line":23,"column":33}},"range":[991,1008],"testsRan":["EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder"],"originalLines":"            if (!this._baseFolder) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":23,"column":35},"end":{"line":32,"column":13}},"range":[1010,1590],"testsRan":["EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder"],"originalLines":"            if (!this._baseFolder) {\r\n                if (this.options['eventReporter'] && this.options['eventReporter']['baseDir']) {\r\n                    this._baseFolder = this.options['eventReporter']['baseDir'];\r\n                    log.debug(\"Using configured output folder \" + this._baseFolder);\r\n                }\r\n                else {\r\n                    log.debug(\"No base folder configuration found (using configuration: eventReporter: { baseDir: 'output/folder' }), using default \" + DEFAULT_BASE_FOLDER);\r\n                    this._baseFolder = DEFAULT_BASE_FOLDER;\r\n                }\r\n            }","mutatedLines":"            if (!this._baseFolder) {\n}"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":23,"column":16},"end":{"line":23,"column":33}},"range":[991,1008],"testsRan":["EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject"],"originalLines":"            if (!this._baseFolder) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BinaryOperator","status":0,"replacement":"'Using configured output folder ' - this._baseFolder","location":{"start":{"line":26,"column":30},"end":{"line":26,"column":82}},"range":[1223,1275],"testsRan":[],"originalLines":"                    log.debug(\"Using configured output folder \" + this._baseFolder);","mutatedLines":"                    log.debug('Using configured output folder ' - this._baseFolder);"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"RemoveConditionals","status":2,"replacement":"false","location":{"start":{"line":24,"column":20},"end":{"line":24,"column":93}},"range":[1033,1106],"testsRan":["EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject"],"originalLines":"                if (this.options['eventReporter'] && this.options['eventReporter']['baseDir']) {","mutatedLines":"                if (false) {"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":24,"column":20},"end":{"line":24,"column":93}},"range":[1033,1106],"testsRan":["EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly \"before each\" hook for \"should log about the default baseFolder\""],"originalLines":"                if (this.options['eventReporter'] && this.options['eventReporter']['baseDir']) {","mutatedLines":"                if (true) {"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"LogicalOperator","status":1,"replacement":"this.options['eventReporter'] || this.options['eventReporter']['baseDir']","location":{"start":{"line":24,"column":20},"end":{"line":24,"column":93}},"range":[1033,1106],"testsRan":["EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly \"before each\" hook for \"should log about the default baseFolder\""],"originalLines":"                if (this.options['eventReporter'] && this.options['eventReporter']['baseDir']) {","mutatedLines":"                if (this.options['eventReporter'] || this.options['eventReporter']['baseDir']) {"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":8,"column":41},"end":{"line":57,"column":1}},"range":[333,2550],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly \"before each\" hook for \"should log about the default baseFolder\""],"originalLines":"var EventRecorderReporter = (function () {\r\n    function EventRecorderReporter(options) {\r\n        var _this = this;\r\n        this.options = options;\r\n        this.allWork = [];\r\n        var index = 0;\r\n        this.createBaseFolderTask = fileUtils.cleanFolder(this.baseFolder);\r\n        BroadcastReporter_1.ALL_EVENT_METHOD_NAMES.forEach(function (method) {\r\n            _this[method] = function (data) {\r\n                _this.allWork.push(_this.createBaseFolderTask.then(function () { return _this.writeToFile(index++, method, data); }));\r\n            };\r\n        });\r\n    }\r\n    Object.defineProperty(EventRecorderReporter.prototype, \"baseFolder\", {\r\n        get: function () {\r\n            if (!this._baseFolder) {\r\n                if (this.options['eventReporter'] && this.options['eventReporter']['baseDir']) {\r\n                    this._baseFolder = this.options['eventReporter']['baseDir'];\r\n                    log.debug(\"Using configured output folder \" + this._baseFolder);\r\n                }\r\n                else {\r\n                    log.debug(\"No base folder configuration found (using configuration: eventReporter: { baseDir: 'output/folder' }), using default \" + DEFAULT_BASE_FOLDER);\r\n                    this._baseFolder = DEFAULT_BASE_FOLDER;\r\n                }\r\n            }\r\n            return this._baseFolder;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    EventRecorderReporter.prototype.writeToFile = function (index, methodName, data) {\r\n        var filename = path.join(this.baseFolder, this.format(index) + \"-\" + methodName + \".json\");\r\n        log.debug(\"Writing event \" + methodName + \" to file \" + filename);\r\n        return fileUtils.writeFile(filename, JSON.stringify(data));\r\n    };\r\n    EventRecorderReporter.prototype.format = function (input) {\r\n        var str = input.toString();\r\n        for (var i = 10000; i > 1; i = i / 10) {\r\n            if (i > input) {\r\n                str = '0' + str;\r\n            }\r\n        }\r\n        return str;\r\n    };\r\n    EventRecorderReporter.prototype.wrapUp = function () {\r\n        var _this = this;\r\n        return this.createBaseFolderTask.then(function () { return Promise.all(_this.allWork); });\r\n    };\r\n    return EventRecorderReporter;\r\n}());","mutatedLines":"var EventRecorderReporter = (function () {\n}());"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":9,"column":44},"end":{"line":20,"column":5}},"range":[380,869],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder"],"originalLines":"    function EventRecorderReporter(options) {\r\n        var _this = this;\r\n        this.options = options;\r\n        this.allWork = [];\r\n        var index = 0;\r\n        this.createBaseFolderTask = fileUtils.cleanFolder(this.baseFolder);\r\n        BroadcastReporter_1.ALL_EVENT_METHOD_NAMES.forEach(function (method) {\r\n            _this[method] = function (data) {\r\n                _this.allWork.push(_this.createBaseFolderTask.then(function () { return _this.writeToFile(index++, method, data); }));\r\n            };\r\n        });\r\n    }","mutatedLines":"    function EventRecorderReporter(options) {\n}"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":24,"column":95},"end":{"line":27,"column":17}},"range":[1108,1296],"testsRan":["EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject"],"originalLines":"                if (this.options['eventReporter'] && this.options['eventReporter']['baseDir']) {\r\n                    this._baseFolder = this.options['eventReporter']['baseDir'];\r\n                    log.debug(\"Using configured output folder \" + this._baseFolder);\r\n                }","mutatedLines":"                if (this.options['eventReporter'] && this.options['eventReporter']['baseDir']) {\n}"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":28,"column":21},"end":{"line":31,"column":17}},"range":[1319,1575],"testsRan":["EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder"],"originalLines":"                else {\r\n                    log.debug(\"No base folder configuration found (using configuration: eventReporter: { baseDir: 'output/folder' }), using default \" + DEFAULT_BASE_FOLDER);\r\n                    this._baseFolder = DEFAULT_BASE_FOLDER;\r\n                }","mutatedLines":"                else {\n}"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"'No base folder configuration found (using configuration: eventReporter: { baseDir: \\'output/folder\\' }), using default ' - DEFAULT_BASE_FOLDER","location":{"start":{"line":29,"column":30},"end":{"line":29,"column":171}},"range":[1352,1493],"testsRan":["EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder"],"originalLines":"                    log.debug(\"No base folder configuration found (using configuration: eventReporter: { baseDir: 'output/folder' }), using default \" + DEFAULT_BASE_FOLDER);","mutatedLines":"                    log.debug('No base folder configuration found (using configuration: eventReporter: { baseDir: \\'output/folder\\' }), using default ' - DEFAULT_BASE_FOLDER);"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"this.format(index) + '-' + methodName - '.json'","location":{"start":{"line":39,"column":50},"end":{"line":39,"column":97}},"range":[1844,1891],"testsRan":["EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`"],"originalLines":"        var filename = path.join(this.baseFolder, this.format(index) + \"-\" + methodName + \".json\");","mutatedLines":"        var filename = path.join(this.baseFolder, this.format(index) + '-' + methodName - '.json');"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":22,"column":25},"end":{"line":34,"column":9}},"range":[972,1639],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder"],"originalLines":"        get: function () {\r\n            if (!this._baseFolder) {\r\n                if (this.options['eventReporter'] && this.options['eventReporter']['baseDir']) {\r\n                    this._baseFolder = this.options['eventReporter']['baseDir'];\r\n                    log.debug(\"Using configured output folder \" + this._baseFolder);\r\n                }\r\n                else {\r\n                    log.debug(\"No base folder configuration found (using configuration: eventReporter: { baseDir: 'output/folder' }), using default \" + DEFAULT_BASE_FOLDER);\r\n                    this._baseFolder = DEFAULT_BASE_FOLDER;\r\n                }\r\n            }\r\n            return this._baseFolder;\r\n        },","mutatedLines":"        get: function () {\n},"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"this.format(index) + '-' - methodName","location":{"start":{"line":39,"column":50},"end":{"line":39,"column":87}},"range":[1844,1881],"testsRan":["EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile"],"originalLines":"        var filename = path.join(this.baseFolder, this.format(index) + \"-\" + methodName + \".json\");","mutatedLines":"        var filename = path.join(this.baseFolder, this.format(index) + '-' - methodName + \".json\");"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"this.format(index) - '-'","location":{"start":{"line":39,"column":50},"end":{"line":39,"column":74}},"range":[1844,1868],"testsRan":["EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile"],"originalLines":"        var filename = path.join(this.baseFolder, this.format(index) + \"-\" + methodName + \".json\");","mutatedLines":"        var filename = path.join(this.baseFolder, this.format(index) - '-' + methodName + \".json\");"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BinaryOperator","status":2,"replacement":"'Writing event ' + methodName - ' to file '","location":{"start":{"line":40,"column":18},"end":{"line":40,"column":61}},"range":[1913,1956],"testsRan":["EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile"],"originalLines":"        log.debug(\"Writing event \" + methodName + \" to file \" + filename);","mutatedLines":"        log.debug('Writing event ' + methodName - ' to file ' + filename);"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BinaryOperator","status":2,"replacement":"'Writing event ' + methodName + ' to file ' - filename","location":{"start":{"line":40,"column":18},"end":{"line":40,"column":72}},"range":[1913,1967],"testsRan":["EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile"],"originalLines":"        log.debug(\"Writing event \" + methodName + \" to file \" + filename);","mutatedLines":"        log.debug('Writing event ' + methodName + ' to file ' - filename);"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BinaryOperator","status":2,"replacement":"'Writing event ' - methodName","location":{"start":{"line":40,"column":18},"end":{"line":40,"column":47}},"range":[1913,1942],"testsRan":["EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile"],"originalLines":"        log.debug(\"Writing event \" + methodName + \" to file \" + filename);","mutatedLines":"        log.debug('Writing event ' - methodName + \" to file \" + filename);"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":45,"column":28},"end":{"line":45,"column":33}},"range":[2178,2183],"testsRan":["EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile"],"originalLines":"        for (var i = 10000; i > 1; i = i / 10) {","mutatedLines":"        for (var i = 10000; false; i = i / 10) {"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BinaryOperator","status":2,"replacement":"i >= 1","location":{"start":{"line":45,"column":28},"end":{"line":45,"column":33}},"range":[2178,2183],"testsRan":["EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile"],"originalLines":"        for (var i = 10000; i > 1; i = i / 10) {","mutatedLines":"        for (var i = 10000; i >= 1; i = i / 10) {"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"i <= 1","location":{"start":{"line":45,"column":28},"end":{"line":45,"column":33}},"range":[2178,2183],"testsRan":["EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile"],"originalLines":"        for (var i = 10000; i > 1; i = i / 10) {","mutatedLines":"        for (var i = 10000; i <= 1; i = i / 10) {"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":45,"column":47},"end":{"line":49,"column":9}},"range":[2197,2288],"testsRan":["EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile"],"originalLines":"        for (var i = 10000; i > 1; i = i / 10) {\r\n            if (i > input) {\r\n                str = '0' + str;\r\n            }\r\n        }","mutatedLines":"        for (var i = 10000; i > 1; i = i / 10) {\n}"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":38,"column":85},"end":{"line":42,"column":5}},"range":[1791,2045],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`"],"originalLines":"    EventRecorderReporter.prototype.writeToFile = function (index, methodName, data) {\r\n        var filename = path.join(this.baseFolder, this.format(index) + \"-\" + methodName + \".json\");\r\n        log.debug(\"Writing event \" + methodName + \" to file \" + filename);\r\n        return fileUtils.writeFile(filename, JSON.stringify(data));\r\n    };","mutatedLines":"    EventRecorderReporter.prototype.writeToFile = function (index, methodName, data) {\n};"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":46,"column":16},"end":{"line":46,"column":25}},"range":[2216,2225],"testsRan":["EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile"],"originalLines":"            if (i > input) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":46,"column":16},"end":{"line":46,"column":25}},"range":[2216,2225],"testsRan":["EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile"],"originalLines":"            if (i > input) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"i <= input","location":{"start":{"line":46,"column":16},"end":{"line":46,"column":25}},"range":[2216,2225],"testsRan":["EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile"],"originalLines":"            if (i > input) {","mutatedLines":"            if (i <= input) {"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BinaryOperator","status":2,"replacement":"i >= input","location":{"start":{"line":46,"column":16},"end":{"line":46,"column":25}},"range":[2216,2225],"testsRan":["EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile"],"originalLines":"            if (i > input) {","mutatedLines":"            if (i >= input) {"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":46,"column":27},"end":{"line":48,"column":13}},"range":[2227,2277],"testsRan":["EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile"],"originalLines":"            if (i > input) {\r\n                str = '0' + str;\r\n            }","mutatedLines":"            if (i > input) {\n}"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BinaryOperator","status":1,"replacement":"'0' - str","location":{"start":{"line":47,"column":22},"end":{"line":47,"column":31}},"range":[2252,2261],"testsRan":["EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile"],"originalLines":"                str = '0' + str;","mutatedLines":"                str = '0' - str;"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":43,"column":62},"end":{"line":51,"column":5}},"range":[2110,2316],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile"],"originalLines":"    EventRecorderReporter.prototype.format = function (input) {\r\n        var str = input.toString();\r\n        for (var i = 10000; i > 1; i = i / 10) {\r\n            if (i > input) {\r\n                str = '0' + str;\r\n            }\r\n        }\r\n        return str;\r\n    };","mutatedLines":"    EventRecorderReporter.prototype.format = function (input) {\n};"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":54,"column":58},"end":{"line":54,"column":96}},"range":[2464,2502],"testsRan":["EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`"],"originalLines":"        return this.createBaseFolderTask.then(function () { return Promise.all(_this.allWork); });","mutatedLines":"        return this.createBaseFolderTask.then(function () {\n});"},{"sourceFilePath":"/stryker/src/Sandbox.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":23,"column":30},"end":{"line":23,"column":70}},"range":[1083,1123],"testsRan":["Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook"],"originalLines":"            .then(function () { return _this.initializeTestRunner(); });","mutatedLines":"            .then(function () {\n});"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":52,"column":57},"end":{"line":55,"column":5}},"range":[2376,2511],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection \"before each\" hook for \"should reject `wrapUp`\""],"originalLines":"    EventRecorderReporter.prototype.wrapUp = function () {\r\n        var _this = this;\r\n        return this.createBaseFolderTask.then(function () { return Promise.all(_this.allWork); });\r\n    };","mutatedLines":"    EventRecorderReporter.prototype.wrapUp = function () {\n};"},{"sourceFilePath":"/stryker/src/reporters/ProgressReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":4,"column":36},"end":{"line":26,"column":1}},"range":[129,800],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter \"before each\" hook for \"should log \".\"\""],"originalLines":"var ProgressReporter = (function () {\r\n    function ProgressReporter() {\r\n    }\r\n    ProgressReporter.prototype.onMutantTested = function (result) {\r\n        var toLog;\r\n        switch (result.status) {\r\n            case report_1.MutantStatus.Killed:\r\n                toLog = '.';\r\n                break;\r\n            case report_1.MutantStatus.TimedOut:\r\n                toLog = chalk.yellow('T');\r\n                break;\r\n            case report_1.MutantStatus.Survived:\r\n                toLog = chalk.bold.red('S');\r\n                break;\r\n            default:\r\n                toLog = '';\r\n                break;\r\n        }\r\n        process.stdout.write(toLog);\r\n    };\r\n    return ProgressReporter;\r\n}());","mutatedLines":"var ProgressReporter = (function () {\n}());"},{"sourceFilePath":"/stryker/src/reporters/ProgressReporter.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":7,"column":66},"end":{"line":24,"column":5}},"range":[240,766],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\""],"originalLines":"    ProgressReporter.prototype.onMutantTested = function (result) {\r\n        var toLog;\r\n        switch (result.status) {\r\n            case report_1.MutantStatus.Killed:\r\n                toLog = '.';\r\n                break;\r\n            case report_1.MutantStatus.TimedOut:\r\n                toLog = chalk.yellow('T');\r\n                break;\r\n            case report_1.MutantStatus.Survived:\r\n                toLog = chalk.bold.red('S');\r\n                break;\r\n            default:\r\n                toLog = '';\r\n                break;\r\n        }\r\n        process.stdout.write(toLog);\r\n    };","mutatedLines":"    ProgressReporter.prototype.onMutantTested = function (result) {\n};"},{"sourceFilePath":"/stryker/src/Sandbox.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":9,"column":27},"end":{"line":88,"column":1}},"range":[395,4360],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator \"before each\" hook for \"should create a sandbox with correct arguments\""],"originalLines":"var Sandbox = (function () {\r\n    function Sandbox(options, index, files, testFramework, coverageInstrumenter) {\r\n        this.options = options;\r\n        this.index = index;\r\n        this.files = files;\r\n        this.testFramework = testFramework;\r\n        this.coverageInstrumenter = coverageInstrumenter;\r\n        this.workingFolder = StrykerTempFolder_1.default.createRandomFolder('sandbox');\r\n        log.debug('Creating a sandbox for files in %s', this.workingFolder);\r\n        this.testHooksFile = path.join(this.workingFolder, '___testHooksForStryker.js');\r\n    }\r\n    Sandbox.prototype.initialize = function () {\r\n        var _this = this;\r\n        return this.fillSandbox()\r\n            .then(function () { return _this.initializeTestRunner(); });\r\n    };\r\n    Sandbox.prototype.run = function (timeout) {\r\n        return this.testRunner.run({ timeout: timeout });\r\n    };\r\n    Sandbox.prototype.dispose = function () {\r\n        return this.testRunner.dispose();\r\n    };\r\n    Sandbox.prototype.runMutant = function (mutant) {\r\n        var _this = this;\r\n        var targetedFile = this.fileMap[mutant.filename];\r\n        return Promise.all([mutant.save(targetedFile), this.filterTests(mutant)])\r\n            .then(function () { return _this.run(_this.calculateTimeout(mutant)); })\r\n            .then(function (runResult) { return mutant.reset(targetedFile).then(function () { return runResult; }); });\r\n    };\r\n    Sandbox.prototype.fillSandbox = function () {\r\n        var _this = this;\r\n        this.fileMap = Object.create(null);\r\n        var copyPromises = this.files\r\n            .map(function (file) { return _this.copyFile(file); });\r\n        if (this.coverageInstrumenter) {\r\n            copyPromises.push(StrykerTempFolder_1.default.writeFile(this.testHooksFile, this.coverageInstrumenter.hooksForTestRun()));\r\n        }\r\n        else {\r\n            copyPromises.push(StrykerTempFolder_1.default.writeFile(this.testHooksFile, ''));\r\n        }\r\n        return Promise.all(copyPromises);\r\n    };\r\n    Sandbox.prototype.copyFile = function (file) {\r\n        var cwd = process.cwd();\r\n        var relativePath = file.path.substr(cwd.length);\r\n        var folderName = StrykerTempFolder_1.default.ensureFolderExists(this.workingFolder + path.dirname(relativePath));\r\n        var targetFile = path.join(folderName, path.basename(relativePath));\r\n        this.fileMap[file.path] = targetFile;\r\n        var instrumentingStream = this.coverageInstrumenter ?\r\n            this.coverageInstrumenter.instrumenterStreamForFile(file) : null;\r\n        return StrykerTempFolder_1.default.copyFile(file.path, targetFile, instrumentingStream);\r\n    };\r\n    Sandbox.prototype.initializeTestRunner = function () {\r\n        var _this = this;\r\n        var files = this.files.map(function (originalFile) { return _.assign(_.cloneDeep(originalFile), { path: _this.fileMap[originalFile.path] }); });\r\n        files.unshift({ path: this.testHooksFile, mutated: false, included: true });\r\n        var settings = {\r\n            files: files,\r\n            strykerOptions: this.options,\r\n            port: this.options.port + this.index\r\n        };\r\n        log.debug(\"Creating test runner %s using settings {port: %s}\", this.index, settings.port);\r\n        this.testRunner = IsolatedTestRunnerAdapterFactory_1.default.create(settings);\r\n        return this.testRunner.init();\r\n    };\r\n    Sandbox.prototype.calculateTimeout = function (mutant) {\r\n        var baseTimeout = mutant.timeSpentScopedTests;\r\n        return (this.options.timeoutFactor * baseTimeout) + this.options.timeoutMs;\r\n    };\r\n    Sandbox.prototype.filterTests = function (mutant) {\r\n        if (this.testFramework) {\r\n            var fileContent = objectUtils_1.wrapInClosure(this.testFramework.filter(mutant.scopedTestIds));\r\n            return StrykerTempFolder_1.default.writeFile(this.testHooksFile, fileContent);\r\n        }\r\n        else {\r\n            return Promise.resolve(void 0);\r\n        }\r\n    };\r\n    return Sandbox;\r\n}());","mutatedLines":"var Sandbox = (function () {\n}());"},{"sourceFilePath":"/stryker/src/Sandbox.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":35,"column":30},"end":{"line":35,"column":83}},"range":[1604,1657],"testsRan":["Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout"],"originalLines":"            .then(function () { return _this.run(_this.calculateTimeout(mutant)); })","mutatedLines":"            .then(function () {\n})"},{"sourceFilePath":"/stryker/src/Sandbox.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":10,"column":81},"end":{"line":19,"column":5}},"range":[479,939],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() \"before each\" hook for \"should have instrumented the input files\""],"originalLines":"    function Sandbox(options, index, files, testFramework, coverageInstrumenter) {\r\n        this.options = options;\r\n        this.index = index;\r\n        this.files = files;\r\n        this.testFramework = testFramework;\r\n        this.coverageInstrumenter = coverageInstrumenter;\r\n        this.workingFolder = StrykerTempFolder_1.default.createRandomFolder('sandbox');\r\n        log.debug('Creating a sandbox for files in %s', this.workingFolder);\r\n        this.testHooksFile = path.join(this.workingFolder, '___testHooksForStryker.js');\r\n    }","mutatedLines":"    function Sandbox(options, index, files, testFramework, coverageInstrumenter) {\n}"},{"sourceFilePath":"/stryker/src/Sandbox.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":36,"column":39},"end":{"line":36,"column":117}},"range":[1699,1777],"testsRan":["Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file"],"originalLines":"            .then(function (runResult) { return mutant.reset(targetedFile).then(function () { return runResult; }); });","mutatedLines":"            .then(function (runResult) {\n});"},{"sourceFilePath":"/stryker/src/Sandbox.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":20,"column":47},"end":{"line":24,"column":5}},"range":[988,1132],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files"],"originalLines":"    Sandbox.prototype.initialize = function () {\r\n        var _this = this;\r\n        return this.fillSandbox()\r\n            .then(function () { return _this.initializeTestRunner(); });\r\n    };","mutatedLines":"    Sandbox.prototype.initialize = function () {\n};"},{"sourceFilePath":"/stryker/src/Sandbox.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":36,"column":92},"end":{"line":36,"column":113}},"range":[1752,1773],"testsRan":["Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests"],"originalLines":"            .then(function (runResult) { return mutant.reset(targetedFile).then(function () { return runResult; }); });","mutatedLines":"            .then(function (runResult) { return mutant.reset(targetedFile).then(function () {\n}); });"},{"sourceFilePath":"/stryker/src/Sandbox.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":42,"column":33},"end":{"line":42,"column":65}},"range":[1984,2016],"testsRan":["Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files"],"originalLines":"            .map(function (file) { return _this.copyFile(file); });","mutatedLines":"            .map(function (file) {\n});"},{"sourceFilePath":"/stryker/src/Sandbox.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":25,"column":47},"end":{"line":27,"column":5}},"range":[1182,1249],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner"],"originalLines":"    Sandbox.prototype.run = function (timeout) {\r\n        return this.testRunner.run({ timeout: timeout });\r\n    };","mutatedLines":"    Sandbox.prototype.run = function (timeout) {\n};"},{"sourceFilePath":"/stryker/src/Sandbox.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":43,"column":12},"end":{"line":43,"column":37}},"range":[2032,2057],"testsRan":["Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() \"before each\" hook for \"should have copied the input files\""],"originalLines":"        if (this.coverageInstrumenter) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/Sandbox.js","mutatorName":"RemoveConditionals","status":2,"replacement":"false","location":{"start":{"line":43,"column":12},"end":{"line":43,"column":37}},"range":[2032,2057],"testsRan":["Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests"],"originalLines":"        if (this.coverageInstrumenter) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/Sandbox.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":43,"column":39},"end":{"line":45,"column":9}},"range":[2059,2207],"testsRan":["Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests"],"originalLines":"        if (this.coverageInstrumenter) {\r\n            copyPromises.push(StrykerTempFolder_1.default.writeFile(this.testHooksFile, this.coverageInstrumenter.hooksForTestRun()));\r\n        }","mutatedLines":"        if (this.coverageInstrumenter) {\n}"},{"sourceFilePath":"/stryker/src/Sandbox.js","mutatorName":"BinaryOperator","status":1,"replacement":"this.workingFolder - path.dirname(relativePath)","location":{"start":{"line":54,"column":72},"end":{"line":54,"column":119}},"range":[2598,2645],"testsRan":["Sandbox when constructed with a CoverageInstrumenter when initialize() \"before each\" hook for \"should have instrumented the input files\""],"originalLines":"        var folderName = StrykerTempFolder_1.default.ensureFolderExists(this.workingFolder + path.dirname(relativePath));","mutatedLines":"        var folderName = StrykerTempFolder_1.default.ensureFolderExists(this.workingFolder - path.dirname(relativePath));"},{"sourceFilePath":"/stryker/src/Sandbox.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":46,"column":13},"end":{"line":48,"column":9}},"range":[2222,2329],"testsRan":["Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests"],"originalLines":"        else {\r\n            copyPromises.push(StrykerTempFolder_1.default.writeFile(this.testHooksFile, ''));\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/Sandbox.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":57,"column":34},"end":{"line":57,"column":59}},"range":[2808,2833],"testsRan":["Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files"],"originalLines":"        var instrumentingStream = this.coverageInstrumenter ?","mutatedLines":"        var instrumentingStream = false ?"},{"sourceFilePath":"/stryker/src/Sandbox.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":57,"column":34},"end":{"line":57,"column":59}},"range":[2808,2833],"testsRan":["Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() \"before each\" hook for \"should have copied the input files\""],"originalLines":"        var instrumentingStream = this.coverageInstrumenter ?","mutatedLines":"        var instrumentingStream = true ?"},{"sourceFilePath":"/stryker/src/Sandbox.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":31,"column":52},"end":{"line":37,"column":5}},"range":[1402,1786],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds \"before each\" hook for \"should save the mutant to disk\""],"originalLines":"    Sandbox.prototype.runMutant = function (mutant) {\r\n        var _this = this;\r\n        var targetedFile = this.fileMap[mutant.filename];\r\n        return Promise.all([mutant.save(targetedFile), this.filterTests(mutant)])\r\n            .then(function () { return _this.run(_this.calculateTimeout(mutant)); })\r\n            .then(function (runResult) { return mutant.reset(targetedFile).then(function () { return runResult; }); });\r\n    };","mutatedLines":"    Sandbox.prototype.runMutant = function (mutant) {\n};"},{"sourceFilePath":"/stryker/src/Sandbox.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":63,"column":59},"end":{"line":63,"column":150}},"range":[3168,3259],"testsRan":["Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook"],"originalLines":"        var files = this.files.map(function (originalFile) { return _.assign(_.cloneDeep(originalFile), { path: _this.fileMap[originalFile.path] }); });","mutatedLines":"        var files = this.files.map(function (originalFile) {\n});"},{"sourceFilePath":"/stryker/src/Sandbox.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":38,"column":48},"end":{"line":50,"column":5}},"range":[1837,2379],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() \"before each\" hook for \"should have instrumented the input files\""],"originalLines":"    Sandbox.prototype.fillSandbox = function () {\r\n        var _this = this;\r\n        this.fileMap = Object.create(null);\r\n        var copyPromises = this.files\r\n            .map(function (file) { return _this.copyFile(file); });\r\n        if (this.coverageInstrumenter) {\r\n            copyPromises.push(StrykerTempFolder_1.default.writeFile(this.testHooksFile, this.coverageInstrumenter.hooksForTestRun()));\r\n        }\r\n        else {\r\n            copyPromises.push(StrykerTempFolder_1.default.writeFile(this.testHooksFile, ''));\r\n        }\r\n        return Promise.all(copyPromises);\r\n    };","mutatedLines":"    Sandbox.prototype.fillSandbox = function () {\n};"},{"sourceFilePath":"/stryker/src/Sandbox.js","mutatorName":"BinaryOperator","status":1,"replacement":"this.options.port - this.index","location":{"start":{"line":68,"column":18},"end":{"line":68,"column":48}},"range":[3463,3493],"testsRan":["Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook"],"originalLines":"            port: this.options.port + this.index","mutatedLines":"            port: this.options.port - this.index"},{"sourceFilePath":"/stryker/src/Sandbox.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":28,"column":44},"end":{"line":30,"column":5}},"range":[1296,1347],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    Sandbox.prototype.dispose = function () {\r\n        return this.testRunner.dispose();\r\n    };","mutatedLines":"    Sandbox.prototype.dispose = function () {\n};"},{"sourceFilePath":"/stryker/src/Sandbox.js","mutatorName":"BinaryOperator","status":1,"replacement":"this.options.timeoutFactor * baseTimeout - this.options.timeoutMs","location":{"start":{"line":76,"column":15},"end":{"line":76,"column":82}},"range":[3876,3943],"testsRan":["Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout"],"originalLines":"        return (this.options.timeoutFactor * baseTimeout) + this.options.timeoutMs;","mutatedLines":"        return this.options.timeoutFactor * baseTimeout - this.options.timeoutMs;"},{"sourceFilePath":"/stryker/src/Sandbox.js","mutatorName":"BinaryOperator","status":1,"replacement":"this.options.timeoutFactor / baseTimeout","location":{"start":{"line":76,"column":16},"end":{"line":76,"column":56}},"range":[3877,3917],"testsRan":["Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout"],"originalLines":"        return (this.options.timeoutFactor * baseTimeout) + this.options.timeoutMs;","mutatedLines":"        return (this.options.timeoutFactor / baseTimeout) + this.options.timeoutMs;"},{"sourceFilePath":"/stryker/src/Sandbox.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":79,"column":12},"end":{"line":79,"column":30}},"range":[4023,4041],"testsRan":["Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests"],"originalLines":"        if (this.testFramework) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/Sandbox.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":79,"column":12},"end":{"line":79,"column":30}},"range":[4023,4041],"testsRan":["Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() \"before each\" hook for \"should not filter any tests\""],"originalLines":"        if (this.testFramework) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/Sandbox.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":79,"column":32},"end":{"line":82,"column":9}},"range":[4043,4256],"testsRan":["Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests"],"originalLines":"        if (this.testFramework) {\r\n            var fileContent = objectUtils_1.wrapInClosure(this.testFramework.filter(mutant.scopedTestIds));\r\n            return StrykerTempFolder_1.default.writeFile(this.testHooksFile, fileContent);\r\n        }","mutatedLines":"        if (this.testFramework) {\n}"},{"sourceFilePath":"/stryker/src/Sandbox.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":51,"column":49},"end":{"line":60,"column":5}},"range":[2431,3019],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files"],"originalLines":"    Sandbox.prototype.copyFile = function (file) {\r\n        var cwd = process.cwd();\r\n        var relativePath = file.path.substr(cwd.length);\r\n        var folderName = StrykerTempFolder_1.default.ensureFolderExists(this.workingFolder + path.dirname(relativePath));\r\n        var targetFile = path.join(folderName, path.basename(relativePath));\r\n        this.fileMap[file.path] = targetFile;\r\n        var instrumentingStream = this.coverageInstrumenter ?\r\n            this.coverageInstrumenter.instrumenterStreamForFile(file) : null;\r\n        return StrykerTempFolder_1.default.copyFile(file.path, targetFile, instrumentingStream);\r\n    };","mutatedLines":"    Sandbox.prototype.copyFile = function (file) {\n};"},{"sourceFilePath":"/stryker/src/Sandbox.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":83,"column":13},"end":{"line":85,"column":9}},"range":[4271,4328],"testsRan":["Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests"],"originalLines":"        else {\r\n            return Promise.resolve(void 0);\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/Sandbox.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":61,"column":57},"end":{"line":73,"column":5}},"range":[3079,3740],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook"],"originalLines":"    Sandbox.prototype.initializeTestRunner = function () {\r\n        var _this = this;\r\n        var files = this.files.map(function (originalFile) { return _.assign(_.cloneDeep(originalFile), { path: _this.fileMap[originalFile.path] }); });\r\n        files.unshift({ path: this.testHooksFile, mutated: false, included: true });\r\n        var settings = {\r\n            files: files,\r\n            strykerOptions: this.options,\r\n            port: this.options.port + this.index\r\n        };\r\n        log.debug(\"Creating test runner %s using settings {port: %s}\", this.index, settings.port);\r\n        this.testRunner = IsolatedTestRunnerAdapterFactory_1.default.create(settings);\r\n        return this.testRunner.init();\r\n    };","mutatedLines":"    Sandbox.prototype.initializeTestRunner = function () {\n};"},{"sourceFilePath":"/stryker/src/Sandbox.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":74,"column":59},"end":{"line":77,"column":5}},"range":[3802,3951],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout"],"originalLines":"    Sandbox.prototype.calculateTimeout = function (mutant) {\r\n        var baseTimeout = mutant.timeSpentScopedTests;\r\n        return (this.options.timeoutFactor * baseTimeout) + this.options.timeoutMs;\r\n    };","mutatedLines":"    Sandbox.prototype.calculateTimeout = function (mutant) {\n};"},{"sourceFilePath":"/stryker/src/Sandbox.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":78,"column":54},"end":{"line":86,"column":5}},"range":[4008,4335],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests"],"originalLines":"    Sandbox.prototype.filterTests = function (mutant) {\r\n        if (this.testFramework) {\r\n            var fileContent = objectUtils_1.wrapInClosure(this.testFramework.filter(mutant.scopedTestIds));\r\n            return StrykerTempFolder_1.default.writeFile(this.testHooksFile, fileContent);\r\n        }\r\n        else {\r\n            return Promise.resolve(void 0);\r\n        }\r\n    };","mutatedLines":"    Sandbox.prototype.filterTests = function (mutant) {\n};"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":27,"column":30},"end":{"line":27,"column":74}},"range":[1195,1239],"testsRan":["SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout"],"originalLines":"            .then(function () { return sandbox.run(INITIAL_RUN_TIMEOUT); })","mutatedLines":"            .then(function () {\n})"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BinaryOperator","status":1,"replacement":"60 * 1000 / 5","location":{"start":{"line":14,"column":26},"end":{"line":14,"column":39}},"range":[562,575],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout"],"originalLines":"var INITIAL_RUN_TIMEOUT = 60 * 1000 * 5;","mutatedLines":"var INITIAL_RUN_TIMEOUT = 60 * 1000 / 5;"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BinaryOperator","status":1,"replacement":"60 / 1000","location":{"start":{"line":14,"column":26},"end":{"line":14,"column":35}},"range":[562,571],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout"],"originalLines":"var INITIAL_RUN_TIMEOUT = 60 * 1000 * 5;","mutatedLines":"var INITIAL_RUN_TIMEOUT = 60 / 1000 * 5;"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":28,"column":39},"end":{"line":28,"column":108}},"range":[1281,1350],"testsRan":["SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox"],"originalLines":"            .then(function (runResult) { return sandbox.dispose().then(function () { return runResult; }); });","mutatedLines":"            .then(function (runResult) {\n});"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":28,"column":83},"end":{"line":28,"column":104}},"range":[1325,1346],"testsRan":["SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result"],"originalLines":"            .then(function (runResult) { return sandbox.dispose().then(function () { return runResult; }); });","mutatedLines":"            .then(function (runResult) { return sandbox.dispose().then(function () {\n}); });"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":16,"column":73},"end":{"line":21,"column":5}},"range":[692,842],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments"],"originalLines":"    function SandboxCoordinator(options, files, testFramework, reporter) {\r\n        this.options = options;\r\n        this.files = files;\r\n        this.testFramework = testFramework;\r\n        this.reporter = reporter;\r\n    }","mutatedLines":"    function SandboxCoordinator(options, files, testFramework, reporter) {\n}"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":22,"column":78},"end":{"line":29,"column":5}},"range":[922,1359],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun \"before each\" hook for \"should create a sandbox with correct arguments\""],"originalLines":"    SandboxCoordinator.prototype.initialRun = function (coverageInstrumenter) {\r\n        log.info(\"Starting initial test run. This may take a while.\");\r\n        var sandbox = new Sandbox_1.default(this.options, 0, this.files, this.testFramework, coverageInstrumenter);\r\n        return sandbox\r\n            .initialize()\r\n            .then(function () { return sandbox.run(INITIAL_RUN_TIMEOUT); })\r\n            .then(function (runResult) { return sandbox.dispose().then(function () { return runResult; }); });\r\n    };","mutatedLines":"    SandboxCoordinator.prototype.initialRun = function (coverageInstrumenter) {\n};"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":15,"column":38},"end":{"line":123,"column":1}},"range":[616,5773],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator \"before each\" hook for \"should create a sandbox with correct arguments\""],"originalLines":"var SandboxCoordinator = (function () {\r\n    function SandboxCoordinator(options, files, testFramework, reporter) {\r\n        this.options = options;\r\n        this.files = files;\r\n        this.testFramework = testFramework;\r\n        this.reporter = reporter;\r\n    }\r\n    SandboxCoordinator.prototype.initialRun = function (coverageInstrumenter) {\r\n        log.info(\"Starting initial test run. This may take a while.\");\r\n        var sandbox = new Sandbox_1.default(this.options, 0, this.files, this.testFramework, coverageInstrumenter);\r\n        return sandbox\r\n            .initialize()\r\n            .then(function () { return sandbox.run(INITIAL_RUN_TIMEOUT); })\r\n            .then(function (runResult) { return sandbox.dispose().then(function () { return runResult; }); });\r\n    };\r\n    SandboxCoordinator.prototype.runMutants = function (mutants) {\r\n        var _this = this;\r\n        mutants = _.clone(mutants); // work with a copy because we're changing state (pop'ing values)\r\n        var results = [];\r\n        return this.createSandboxes().then(function (sandboxes) {\r\n            var promiseProducer = function () {\r\n                if (mutants.length === 0) {\r\n                    return null; // we're done\r\n                }\r\n                else {\r\n                    var mutant_1 = mutants.shift();\r\n                    if (mutant_1.scopedTestIds.length > 0) {\r\n                        var sandbox_1 = sandboxes.shift();\r\n                        return sandbox_1.runMutant(mutant_1)\r\n                            .then(function (runResult) { return _this.reportMutantTested(mutant_1, runResult, results); })\r\n                            .then(function () { return sandboxes.push(sandbox_1); }); // mark the sandbox as available again\r\n                    }\r\n                    else {\r\n                        _this.reportMutantTested(mutant_1, null, results);\r\n                        return Promise.resolve();\r\n                    }\r\n                }\r\n            };\r\n            return new PromisePool(promiseProducer, sandboxes.length)\r\n                .start()\r\n                .then(function () { return _this.reportAllMutantsTested(results); })\r\n                .then(function () { return Promise.all(sandboxes.map(function (sandbox) { return sandbox.dispose(); })); })\r\n                .then(function () { return results; });\r\n        });\r\n    };\r\n    SandboxCoordinator.prototype.createSandboxes = function () {\r\n        var cpuCount = os.cpus().length;\r\n        var sandboxes = [];\r\n        for (var i = 0; i < cpuCount; i++) {\r\n            sandboxes.push(new Sandbox_1.default(this.options, i, this.files, this.testFramework, null));\r\n        }\r\n        log.info(\"Creating \" + cpuCount + \" test runners (based on cpu count)\");\r\n        return Promise.all(sandboxes.map(function (s) { return s.initialize(); }))\r\n            .then(function () { return sandboxes; });\r\n    };\r\n    SandboxCoordinator.prototype.reportMutantTested = function (mutant, runResult, results) {\r\n        var result = this.collectFrozenMutantResult(mutant, runResult);\r\n        results.push(result);\r\n        this.reporter.onMutantTested(result);\r\n    };\r\n    SandboxCoordinator.prototype.collectFrozenMutantResult = function (mutant, runResult) {\r\n        var status;\r\n        var testNames;\r\n        if (runResult) {\r\n            switch (runResult.status) {\r\n                case test_runner_1.RunStatus.Timeout:\r\n                    status = report_1.MutantStatus.TimedOut;\r\n                    break;\r\n                case test_runner_1.RunStatus.Error:\r\n                    log.debug('Converting a test result `error` to mutant status `killed`.');\r\n                    status = report_1.MutantStatus.Killed;\r\n                    break;\r\n                case test_runner_1.RunStatus.Complete:\r\n                    if (runResult.tests.some(function (t) { return t.status === test_runner_1.TestStatus.Failed; })) {\r\n                        status = report_1.MutantStatus.Killed;\r\n                    }\r\n                    else {\r\n                        status = report_1.MutantStatus.Survived;\r\n                    }\r\n                    break;\r\n            }\r\n            testNames = runResult.tests\r\n                .filter(function (t) { return t.status !== test_runner_1.TestStatus.Skipped; })\r\n                .map(function (t) { return t.name; });\r\n        }\r\n        else {\r\n            testNames = [];\r\n            status = report_1.MutantStatus.NoCoverage;\r\n        }\r\n        var result = {\r\n            sourceFilePath: mutant.filename,\r\n            mutatorName: mutant.mutatorName,\r\n            status: status,\r\n            replacement: mutant.replacement,\r\n            location: mutant.location,\r\n            range: mutant.range,\r\n            testsRan: testNames,\r\n            originalLines: mutant.originalLines,\r\n            mutatedLines: mutant.mutatedLines,\r\n        };\r\n        objectUtils_1.freezeRecursively(result);\r\n        return result;\r\n    };\r\n    SandboxCoordinator.prototype.reportAllMutantsTested = function (results) {\r\n        objectUtils_1.freezeRecursively(results);\r\n        this.reporter.onAllMutantsTested(results);\r\n    };\r\n    return SandboxCoordinator;\r\n}());","mutatedLines":"var SandboxCoordinator = (function () {\n}());"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":34,"column":64},"end":{"line":58,"column":9}},"range":[1651,2936],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox"],"originalLines":"        return this.createSandboxes().then(function (sandboxes) {\r\n            var promiseProducer = function () {\r\n                if (mutants.length === 0) {\r\n                    return null; // we're done\r\n                }\r\n                else {\r\n                    var mutant_1 = mutants.shift();\r\n                    if (mutant_1.scopedTestIds.length > 0) {\r\n                        var sandbox_1 = sandboxes.shift();\r\n                        return sandbox_1.runMutant(mutant_1)\r\n                            .then(function (runResult) { return _this.reportMutantTested(mutant_1, runResult, results); })\r\n                            .then(function () { return sandboxes.push(sandbox_1); }); // mark the sandbox as available again\r\n                    }\r\n                    else {\r\n                        _this.reportMutantTested(mutant_1, null, results);\r\n                        return Promise.resolve();\r\n                    }\r\n                }\r\n            };\r\n            return new PromisePool(promiseProducer, sandboxes.length)\r\n                .start()\r\n                .then(function () { return _this.reportAllMutantsTested(results); })\r\n                .then(function () { return Promise.all(sandboxes.map(function (sandbox) { return sandbox.dispose(); })); })\r\n                .then(function () { return results; });\r\n        });","mutatedLines":"        return this.createSandboxes().then(function (sandboxes) {\n});"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":35,"column":46},"end":{"line":52,"column":13}},"range":[1700,2559],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox"],"originalLines":"            var promiseProducer = function () {\r\n                if (mutants.length === 0) {\r\n                    return null; // we're done\r\n                }\r\n                else {\r\n                    var mutant_1 = mutants.shift();\r\n                    if (mutant_1.scopedTestIds.length > 0) {\r\n                        var sandbox_1 = sandboxes.shift();\r\n                        return sandbox_1.runMutant(mutant_1)\r\n                            .then(function (runResult) { return _this.reportMutantTested(mutant_1, runResult, results); })\r\n                            .then(function () { return sandboxes.push(sandbox_1); }); // mark the sandbox as available again\r\n                    }\r\n                    else {\r\n                        _this.reportMutantTested(mutant_1, null, results);\r\n                        return Promise.resolve();\r\n                    }\r\n                }\r\n            };","mutatedLines":"            var promiseProducer = function () {\n};"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":36,"column":20},"end":{"line":36,"column":40}},"range":[1723,1743],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox"],"originalLines":"                if (mutants.length === 0) {","mutatedLines":"                if (true) {"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":36,"column":20},"end":{"line":36,"column":40}},"range":[1723,1743],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants \"before each\" hook for \"should have created 2 sandboxes\""],"originalLines":"                if (mutants.length === 0) {","mutatedLines":"                if (false) {"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BinaryOperator","status":1,"replacement":"mutants.length !== 0","location":{"start":{"line":36,"column":20},"end":{"line":36,"column":40}},"range":[1723,1743],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox"],"originalLines":"                if (mutants.length === 0) {","mutatedLines":"                if (mutants.length !== 0) {"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":41,"column":24},"end":{"line":41,"column":57}},"range":[1916,1949],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants \"before each\" hook for \"should have created 2 sandboxes\""],"originalLines":"                    if (mutant_1.scopedTestIds.length > 0) {","mutatedLines":"                    if (true) {"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":39,"column":21},"end":{"line":51,"column":17}},"range":[1836,2544],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox"],"originalLines":"                else {\r\n                    var mutant_1 = mutants.shift();\r\n                    if (mutant_1.scopedTestIds.length > 0) {\r\n                        var sandbox_1 = sandboxes.shift();\r\n                        return sandbox_1.runMutant(mutant_1)\r\n                            .then(function (runResult) { return _this.reportMutantTested(mutant_1, runResult, results); })\r\n                            .then(function () { return sandboxes.push(sandbox_1); }); // mark the sandbox as available again\r\n                    }\r\n                    else {\r\n                        _this.reportMutantTested(mutant_1, null, results);\r\n                        return Promise.resolve();\r\n                    }\r\n                }","mutatedLines":"                else {\n}"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":41,"column":24},"end":{"line":41,"column":57}},"range":[1916,1949],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox"],"originalLines":"                    if (mutant_1.scopedTestIds.length > 0) {","mutatedLines":"                    if (false) {"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BinaryOperator","status":1,"replacement":"mutant_1.scopedTestIds.length >= 0","location":{"start":{"line":41,"column":24},"end":{"line":41,"column":57}},"range":[1916,1949],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants \"before each\" hook for \"should have created 2 sandboxes\""],"originalLines":"                    if (mutant_1.scopedTestIds.length > 0) {","mutatedLines":"                    if (mutant_1.scopedTestIds.length >= 0) {"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BinaryOperator","status":1,"replacement":"mutant_1.scopedTestIds.length <= 0","location":{"start":{"line":41,"column":24},"end":{"line":41,"column":57}},"range":[1916,1949],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants \"before each\" hook for \"should have created 2 sandboxes\""],"originalLines":"                    if (mutant_1.scopedTestIds.length > 0) {","mutatedLines":"                    if (mutant_1.scopedTestIds.length <= 0) {"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":36,"column":42},"end":{"line":38,"column":17}},"range":[1745,1813],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes"],"originalLines":"                if (mutants.length === 0) {\r\n                    return null; // we're done\r\n                }","mutatedLines":"                if (mutants.length === 0) {\n}"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":41,"column":59},"end":{"line":46,"column":21}},"range":[1951,2347],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox"],"originalLines":"                    if (mutant_1.scopedTestIds.length > 0) {\r\n                        var sandbox_1 = sandboxes.shift();\r\n                        return sandbox_1.runMutant(mutant_1)\r\n                            .then(function (runResult) { return _this.reportMutantTested(mutant_1, runResult, results); })\r\n                            .then(function () { return sandboxes.push(sandbox_1); }); // mark the sandbox as available again\r\n                    }","mutatedLines":"                    if (mutant_1.scopedTestIds.length > 0) {\n}"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":45,"column":46},"end":{"line":45,"column":83}},"range":[2246,2283],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants \"before each\" hook for \"should have created 2 sandboxes\""],"originalLines":"                            .then(function () { return sandboxes.push(sandbox_1); }); // mark the sandbox as available again","mutatedLines":"                            .then(function () {\n}); // mark the sandbox as available again"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":47,"column":25},"end":{"line":50,"column":21}},"range":[2374,2525],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox"],"originalLines":"                    else {\r\n                        _this.reportMutantTested(mutant_1, null, results);\r\n                        return Promise.resolve();\r\n                    }","mutatedLines":"                    else {\n}"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":44,"column":55},"end":{"line":44,"column":121}},"range":[2131,2197],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants"],"originalLines":"                            .then(function (runResult) { return _this.reportMutantTested(mutant_1, runResult, results); })","mutatedLines":"                            .then(function (runResult) {\n})"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":55,"column":34},"end":{"line":55,"column":83}},"range":[2693,2742],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested"],"originalLines":"                .then(function () { return _this.reportAllMutantsTested(results); })","mutatedLines":"                .then(function () {\n})"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":30,"column":65},"end":{"line":59,"column":5}},"range":[1427,2945],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants \"before each\" hook for \"should have created 2 sandboxes\""],"originalLines":"    SandboxCoordinator.prototype.runMutants = function (mutants) {\r\n        var _this = this;\r\n        mutants = _.clone(mutants); // work with a copy because we're changing state (pop'ing values)\r\n        var results = [];\r\n        return this.createSandboxes().then(function (sandboxes) {\r\n            var promiseProducer = function () {\r\n                if (mutants.length === 0) {\r\n                    return null; // we're done\r\n                }\r\n                else {\r\n                    var mutant_1 = mutants.shift();\r\n                    if (mutant_1.scopedTestIds.length > 0) {\r\n                        var sandbox_1 = sandboxes.shift();\r\n                        return sandbox_1.runMutant(mutant_1)\r\n                            .then(function (runResult) { return _this.reportMutantTested(mutant_1, runResult, results); })\r\n                            .then(function () { return sandboxes.push(sandbox_1); }); // mark the sandbox as available again\r\n                    }\r\n                    else {\r\n                        _this.reportMutantTested(mutant_1, null, results);\r\n                        return Promise.resolve();\r\n                    }\r\n                }\r\n            };\r\n            return new PromisePool(promiseProducer, sandboxes.length)\r\n                .start()\r\n                .then(function () { return _this.reportAllMutantsTested(results); })\r\n                .then(function () { return Promise.all(sandboxes.map(function (sandbox) { return sandbox.dispose(); })); })\r\n                .then(function () { return results; });\r\n        });\r\n    };","mutatedLines":"    SandboxCoordinator.prototype.runMutants = function (mutants) {\n};"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":56,"column":88},"end":{"line":56,"column":117}},"range":[2833,2862],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes"],"originalLines":"                .then(function () { return Promise.all(sandboxes.map(function (sandbox) { return sandbox.dispose(); })); })","mutatedLines":"                .then(function () { return Promise.all(sandboxes.map(function (sandbox) {\n})); })"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":63,"column":24},"end":{"line":63,"column":36}},"range":[3109,3121],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants \"before each\" hook for \"should have created 2 sandboxes\""],"originalLines":"        for (var i = 0; i < cpuCount; i++) {","mutatedLines":"        for (var i = 0; false; i++) {"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":56,"column":34},"end":{"line":56,"column":122}},"range":[2779,2867],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes"],"originalLines":"                .then(function () { return Promise.all(sandboxes.map(function (sandbox) { return sandbox.dispose(); })); })","mutatedLines":"                .then(function () {\n})"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BinaryOperator","status":1,"replacement":"i <= cpuCount","location":{"start":{"line":63,"column":24},"end":{"line":63,"column":36}},"range":[3109,3121],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants \"before each\" hook for \"should have created 2 sandboxes\""],"originalLines":"        for (var i = 0; i < cpuCount; i++) {","mutatedLines":"        for (var i = 0; i <= cpuCount; i++) {"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":57,"column":34},"end":{"line":57,"column":53}},"range":[2904,2923],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants"],"originalLines":"                .then(function () { return results; });","mutatedLines":"                .then(function () {\n});"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BinaryOperator","status":1,"replacement":"i >= cpuCount","location":{"start":{"line":63,"column":24},"end":{"line":63,"column":36}},"range":[3109,3121],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants \"before each\" hook for \"should have created 2 sandboxes\""],"originalLines":"        for (var i = 0; i < cpuCount; i++) {","mutatedLines":"        for (var i = 0; i >= cpuCount; i++) {"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":63,"column":43},"end":{"line":65,"column":9}},"range":[3128,3247],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants \"before each\" hook for \"should have created 2 sandboxes\""],"originalLines":"        for (var i = 0; i < cpuCount; i++) {\r\n            sandboxes.push(new Sandbox_1.default(this.options, i, this.files, this.testFramework, null));\r\n        }","mutatedLines":"        for (var i = 0; i < cpuCount; i++) {\n}"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":68,"column":30},"end":{"line":68,"column":51}},"range":[3445,3466],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants \"before each\" hook for \"should have created 2 sandboxes\""],"originalLines":"            .then(function () { return sandboxes; });","mutatedLines":"            .then(function () {\n});"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BinaryOperator","status":2,"replacement":"'Creating ' - cpuCount","location":{"start":{"line":66,"column":17},"end":{"line":66,"column":39}},"range":[3266,3288],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes"],"originalLines":"        log.info(\"Creating \" + cpuCount + \" test runners (based on cpu count)\");","mutatedLines":"        log.info('Creating ' - cpuCount + \" test runners (based on cpu count)\");"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BinaryOperator","status":2,"replacement":"'Creating ' + cpuCount - ' test runners (based on cpu count)'","location":{"start":{"line":66,"column":17},"end":{"line":66,"column":78}},"range":[3266,3327],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes"],"originalLines":"        log.info(\"Creating \" + cpuCount + \" test runners (based on cpu count)\");","mutatedLines":"        log.info('Creating ' + cpuCount - ' test runners (based on cpu count)');"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":67,"column":54},"end":{"line":67,"column":80}},"range":[3385,3411],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes"],"originalLines":"        return Promise.all(sandboxes.map(function (s) { return s.initialize(); }))","mutatedLines":"        return Promise.all(sandboxes.map(function (s) {\n}))"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":78,"column":12},"end":{"line":78,"column":21}},"range":[3882,3891],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants \"before each\" hook for \"should have created 2 sandboxes\""],"originalLines":"        if (runResult) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":78,"column":12},"end":{"line":78,"column":21}},"range":[3882,3891],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results"],"originalLines":"        if (runResult) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":78,"column":23},"end":{"line":99,"column":9}},"range":[3893,4944],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results"],"originalLines":"        if (runResult) {\r\n            switch (runResult.status) {\r\n                case test_runner_1.RunStatus.Timeout:\r\n                    status = report_1.MutantStatus.TimedOut;\r\n                    break;\r\n                case test_runner_1.RunStatus.Error:\r\n                    log.debug('Converting a test result `error` to mutant status `killed`.');\r\n                    status = report_1.MutantStatus.Killed;\r\n                    break;\r\n                case test_runner_1.RunStatus.Complete:\r\n                    if (runResult.tests.some(function (t) { return t.status === test_runner_1.TestStatus.Failed; })) {\r\n                        status = report_1.MutantStatus.Killed;\r\n                    }\r\n                    else {\r\n                        status = report_1.MutantStatus.Survived;\r\n                    }\r\n                    break;\r\n            }\r\n            testNames = runResult.tests\r\n                .filter(function (t) { return t.status !== test_runner_1.TestStatus.Skipped; })\r\n                .map(function (t) { return t.name; });\r\n        }","mutatedLines":"        if (runResult) {\n}"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":88,"column":24},"end":{"line":88,"column":115}},"range":[4398,4489],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results"],"originalLines":"                    if (runResult.tests.some(function (t) { return t.status === test_runner_1.TestStatus.Failed; })) {","mutatedLines":"                    if (false) {"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":60,"column":63},"end":{"line":69,"column":5}},"range":[3011,3475],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants \"before each\" hook for \"should have created 2 sandboxes\""],"originalLines":"    SandboxCoordinator.prototype.createSandboxes = function () {\r\n        var cpuCount = os.cpus().length;\r\n        var sandboxes = [];\r\n        for (var i = 0; i < cpuCount; i++) {\r\n            sandboxes.push(new Sandbox_1.default(this.options, i, this.files, this.testFramework, null));\r\n        }\r\n        log.info(\"Creating \" + cpuCount + \" test runners (based on cpu count)\");\r\n        return Promise.all(sandboxes.map(function (s) { return s.initialize(); }))\r\n            .then(function () { return sandboxes; });\r\n    };","mutatedLines":"    SandboxCoordinator.prototype.createSandboxes = function () {\n};"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":88,"column":24},"end":{"line":88,"column":115}},"range":[4398,4489],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results"],"originalLines":"                    if (runResult.tests.some(function (t) { return t.status === test_runner_1.TestStatus.Failed; })) {","mutatedLines":"                    if (true) {"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BinaryOperator","status":1,"replacement":"t.status !== test_runner_1.TestStatus.Failed","location":{"start":{"line":88,"column":67},"end":{"line":88,"column":111}},"range":[4441,4485],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results"],"originalLines":"                    if (runResult.tests.some(function (t) { return t.status === test_runner_1.TestStatus.Failed; })) {","mutatedLines":"                    if (runResult.tests.some(function (t) { return t.status !== test_runner_1.TestStatus.Failed; })) {"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":88,"column":58},"end":{"line":88,"column":114}},"range":[4432,4488],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results"],"originalLines":"                    if (runResult.tests.some(function (t) { return t.status === test_runner_1.TestStatus.Failed; })) {","mutatedLines":"                    if (runResult.tests.some(function (t) {\n})) {"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":88,"column":117},"end":{"line":90,"column":21}},"range":[4491,4579],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results"],"originalLines":"                    if (runResult.tests.some(function (t) { return t.status === test_runner_1.TestStatus.Failed; })) {\r\n                        status = report_1.MutantStatus.Killed;\r\n                    }","mutatedLines":"                    if (runResult.tests.some(function (t) { return t.status === test_runner_1.TestStatus.Failed; })) {\n}"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":75,"column":90},"end":{"line":117,"column":5}},"range":[3822,5546],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results"],"originalLines":"    SandboxCoordinator.prototype.collectFrozenMutantResult = function (mutant, runResult) {\r\n        var status;\r\n        var testNames;\r\n        if (runResult) {\r\n            switch (runResult.status) {\r\n                case test_runner_1.RunStatus.Timeout:\r\n                    status = report_1.MutantStatus.TimedOut;\r\n                    break;\r\n                case test_runner_1.RunStatus.Error:\r\n                    log.debug('Converting a test result `error` to mutant status `killed`.');\r\n                    status = report_1.MutantStatus.Killed;\r\n                    break;\r\n                case test_runner_1.RunStatus.Complete:\r\n                    if (runResult.tests.some(function (t) { return t.status === test_runner_1.TestStatus.Failed; })) {\r\n                        status = report_1.MutantStatus.Killed;\r\n                    }\r\n                    else {\r\n                        status = report_1.MutantStatus.Survived;\r\n                    }\r\n                    break;\r\n            }\r\n            testNames = runResult.tests\r\n                .filter(function (t) { return t.status !== test_runner_1.TestStatus.Skipped; })\r\n                .map(function (t) { return t.name; });\r\n        }\r\n        else {\r\n            testNames = [];\r\n            status = report_1.MutantStatus.NoCoverage;\r\n        }\r\n        var result = {\r\n            sourceFilePath: mutant.filename,\r\n            mutatorName: mutant.mutatorName,\r\n            status: status,\r\n            replacement: mutant.replacement,\r\n            location: mutant.location,\r\n            range: mutant.range,\r\n            testsRan: testNames,\r\n            originalLines: mutant.originalLines,\r\n            mutatedLines: mutant.mutatedLines,\r\n        };\r\n        objectUtils_1.freezeRecursively(result);\r\n        return result;\r\n    };","mutatedLines":"    SandboxCoordinator.prototype.collectFrozenMutantResult = function (mutant, runResult) {\n};"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":91,"column":25},"end":{"line":93,"column":21}},"range":[4606,4696],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results"],"originalLines":"                    else {\r\n                        status = report_1.MutantStatus.Survived;\r\n                    }","mutatedLines":"                    else {\n}"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":97,"column":37},"end":{"line":97,"column":94}},"range":[4819,4876],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes"],"originalLines":"                .filter(function (t) { return t.status !== test_runner_1.TestStatus.Skipped; })","mutatedLines":"                .filter(function (t) {\n})"},{"sourceFilePath":"/stryker/src/stryker-cli.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":7,"column":19},"end":{"line":9,"column":1}},"range":[236,268],"testsRan":[],"originalLines":"function list(val) {\r\n    return val.split(',');\r\n}","mutatedLines":"function list(val) {\n}"},{"sourceFilePath":"/stryker/src/stryker-cli.js","mutatorName":"BinaryOperator","status":0,"replacement":"'A location to a config file. That file should export a function which accepts a \"config\" object\\n' - ConfigReader_1.CONFIG_SYNTAX_HELP","location":{"start":{"line":23,"column":53},"end":{"line":24,"column":37}},"range":[2899,3039],"testsRan":[],"originalLines":"    .option('-c, --configFile <configFileLocation>', 'A location to a config file. That file should export a function which accepts a \"config\" object\\n' +\r\n    ConfigReader_1.CONFIG_SYNTAX_HELP)","mutatedLines":"    .option('-c, --configFile <configFileLocation>', 'A location to a config file. That file should export a function which accepts a \"config\" object\\n' - ConfigReader_1.CONFIG_SYNTAX_HELP)"},{"sourceFilePath":"/stryker/src/stryker-cli.js","mutatorName":"LogicalOperator","status":0,"replacement":"program['logLevel'] && 'info'","location":{"start":{"line":27,"column":25},"end":{"line":27,"column":54}},"range":[3245,3274],"testsRan":[],"originalLines":"log4js.setGlobalLogLevel(program['logLevel'] || 'info');","mutatedLines":"log4js.setGlobalLogLevel(program['logLevel'] && 'info');"},{"sourceFilePath":"/stryker/src/stryker-cli.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":33,"column":23},"end":{"line":37,"column":1}},"range":[3427,3498],"testsRan":[],"originalLines":"for (var i in program) {\r\n    if (i.charAt(0) === '_') {\r\n        delete program[i];\r\n    }\r\n}","mutatedLines":"for (var i in program) {\n}"},{"sourceFilePath":"/stryker/src/stryker-cli.js","mutatorName":"RemoveConditionals","status":0,"replacement":"false","location":{"start":{"line":34,"column":8},"end":{"line":34,"column":27}},"range":[3438,3457],"testsRan":[],"originalLines":"    if (i.charAt(0) === '_') {","mutatedLines":"    if (false) {"},{"sourceFilePath":"/stryker/src/stryker-cli.js","mutatorName":"RemoveConditionals","status":0,"replacement":"true","location":{"start":{"line":34,"column":8},"end":{"line":34,"column":27}},"range":[3438,3457],"testsRan":[],"originalLines":"    if (i.charAt(0) === '_') {","mutatedLines":"    if (true) {"},{"sourceFilePath":"/stryker/src/stryker-cli.js","mutatorName":"BinaryOperator","status":0,"replacement":"i.charAt(0) !== '_'","location":{"start":{"line":34,"column":8},"end":{"line":34,"column":27}},"range":[3438,3457],"testsRan":[],"originalLines":"    if (i.charAt(0) === '_') {","mutatedLines":"    if (i.charAt(0) !== '_') {"},{"sourceFilePath":"/stryker/src/stryker-cli.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":34,"column":29},"end":{"line":36,"column":5}},"range":[3459,3495],"testsRan":[],"originalLines":"    if (i.charAt(0) === '_') {\r\n        delete program[i];\r\n    }","mutatedLines":"    if (i.charAt(0) === '_') {\n}"},{"sourceFilePath":"/stryker/src/stryker-cli.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":39,"column":26},"end":{"line":39,"column":73}},"range":[3576,3623],"testsRan":[],"originalLines":"    .catch(function (err) { return log.error(\"an error occurred\", err); });","mutatedLines":"    .catch(function (err) {\n});"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BinaryOperator","status":2,"replacement":"t.status === test_runner_1.TestStatus.Skipped","location":{"start":{"line":97,"column":46},"end":{"line":97,"column":91}},"range":[4828,4873],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes"],"originalLines":"                .filter(function (t) { return t.status !== test_runner_1.TestStatus.Skipped; })","mutatedLines":"                .filter(function (t) { return t.status === test_runner_1.TestStatus.Skipped; })"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":70,"column":92},"end":{"line":74,"column":5}},"range":[3570,3729],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants"],"originalLines":"    SandboxCoordinator.prototype.reportMutantTested = function (mutant, runResult, results) {\r\n        var result = this.collectFrozenMutantResult(mutant, runResult);\r\n        results.push(result);\r\n        this.reporter.onMutantTested(result);\r\n    };","mutatedLines":"    SandboxCoordinator.prototype.reportMutantTested = function (mutant, runResult, results) {\n};"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":98,"column":34},"end":{"line":98,"column":52}},"range":[4913,4931],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes"],"originalLines":"                .map(function (t) { return t.name; });","mutatedLines":"                .map(function (t) {\n});"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":100,"column":13},"end":{"line":103,"column":9}},"range":[4959,5056],"testsRan":["SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results"],"originalLines":"        else {\r\n            testNames = [];\r\n            status = report_1.MutantStatus.NoCoverage;\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":58,"column":40},"end":{"line":58,"column":84}},"range":[2923,2967],"testsRan":["Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator"],"originalLines":"            .then(function (inputFiles) { return _this.initialTestRun(inputFiles); })","mutatedLines":"            .then(function (inputFiles) {\n})"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":59,"column":32},"end":{"line":62,"column":9}},"range":[3002,3223],"testsRan":["Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection"],"originalLines":"            .then(function (_a) {\r\n            var runResult = _a.runResult, inputFiles = _a.inputFiles, sandboxCoordinator = _a.sandboxCoordinator;\r\n            return _this.generateAndRunMutations(inputFiles, runResult, sandboxCoordinator);\r\n        })","mutatedLines":"            .then(function (_a) {\n})"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":118,"column":77},"end":{"line":121,"column":5}},"range":[5626,5737],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested"],"originalLines":"    SandboxCoordinator.prototype.reportAllMutantsTested = function (results) {\r\n        objectUtils_1.freezeRecursively(results);\r\n        this.reporter.onAllMutantsTested(results);\r\n    };","mutatedLines":"    SandboxCoordinator.prototype.reportAllMutantsTested = function (results) {\n};"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":63,"column":43},"end":{"line":66,"column":59}},"range":[3269,3475],"testsRan":["Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder"],"originalLines":"            .then(function (mutantResults) { return _this.wrapUpReporter()\r\n            .then(StrykerTempFolder_1.default.clean)\r\n            .then(function () { return _this.logDone(); })\r\n            .then(function () { return mutantResults; }); });","mutatedLines":"            .then(function (mutantResults) {\n});"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":36,"column":30},"end":{"line":49,"column":5}},"range":[1836,2583],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process"],"originalLines":"    function Stryker(options) {\r\n        this.timer = new Timer_1.default();\r\n        var configReader = new ConfigReader_1.default(options);\r\n        this.config = configReader.readConfig();\r\n        this.setGlobalLogLevel(); // loglevel could be changed\r\n        this.loadPlugins();\r\n        this.applyConfigWriters();\r\n        this.setGlobalLogLevel(); // loglevel could be changed\r\n        this.freezeConfig();\r\n        this.reporter = new ReporterOrchestrator_1.default(this.config).createBroadcastReporter();\r\n        this.testFramework = new TestFrameworkOrchestrator_1.default(this.config).determineTestFramework();\r\n        this.coverageInstrumenter = new CoverageInstrumenter_1.default(this.config.coverageAnalysis, this.testFramework);\r\n        this.verify();\r\n    }","mutatedLines":"    function Stryker(options) {\n}"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":28,"column":27},"end":{"line":180,"column":1}},"range":[1257,9094],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework \"before each\" hook for \"should exit the process\""],"originalLines":"var Stryker = (function () {\r\n    /**\r\n     * The Stryker mutation tester.\r\n     * @constructor\r\n     * @param {String[]} mutateFilePatterns - A comma seperated list of globbing expression used for selecting the files that should be mutated\r\n     * @param {String[]} allFilePatterns - A comma seperated list of globbing expression used for selecting all files needed to run the tests. These include library files, test files and files to mutate, but should NOT include test framework files (for example jasmine)\r\n     * @param {Object} [options] - Optional options.\r\n     */\r\n    function Stryker(options) {\r\n        this.timer = new Timer_1.default();\r\n        var configReader = new ConfigReader_1.default(options);\r\n        this.config = configReader.readConfig();\r\n        this.setGlobalLogLevel(); // loglevel could be changed\r\n        this.loadPlugins();\r\n        this.applyConfigWriters();\r\n        this.setGlobalLogLevel(); // loglevel could be changed\r\n        this.freezeConfig();\r\n        this.reporter = new ReporterOrchestrator_1.default(this.config).createBroadcastReporter();\r\n        this.testFramework = new TestFrameworkOrchestrator_1.default(this.config).determineTestFramework();\r\n        this.coverageInstrumenter = new CoverageInstrumenter_1.default(this.config.coverageAnalysis, this.testFramework);\r\n        this.verify();\r\n    }\r\n    /**\r\n     * Runs mutation testing. This may take a while.\r\n     * @function\r\n     */\r\n    Stryker.prototype.runMutationTest = function () {\r\n        var _this = this;\r\n        this.timer.reset();\r\n        return new InputFileResolver_1.default(this.config.mutate, this.config.files).resolve()\r\n            .then(function (inputFiles) { return _this.initialTestRun(inputFiles); })\r\n            .then(function (_a) {\r\n            var runResult = _a.runResult, inputFiles = _a.inputFiles, sandboxCoordinator = _a.sandboxCoordinator;\r\n            return _this.generateAndRunMutations(inputFiles, runResult, sandboxCoordinator);\r\n        })\r\n            .then(function (mutantResults) { return _this.wrapUpReporter()\r\n            .then(StrykerTempFolder_1.default.clean)\r\n            .then(function () { return _this.logDone(); })\r\n            .then(function () { return mutantResults; }); });\r\n    };\r\n    Stryker.prototype.filterOutFailedTests = function (runResult) {\r\n        return runResult.tests.filter(function (testResult) { return testResult.status === test_runner_1.TestStatus.Failed; });\r\n    };\r\n    Stryker.prototype.loadPlugins = function () {\r\n        if (this.config.plugins) {\r\n            new PluginLoader_1.default(this.config.plugins).load();\r\n        }\r\n    };\r\n    Stryker.prototype.verify = function () {\r\n        if (this.config.coverageAnalysis === 'perTest' && !this.testFramework) {\r\n            log.fatal('Configured coverage analysis \"perTest\" requires there to be a testFramework configured. Either configure a testFramework or set coverageAnalysis to \"all\" or \"off\".');\r\n            process.exit(1);\r\n        }\r\n    };\r\n    Stryker.prototype.initialTestRun = function (inputFiles) {\r\n        var _this = this;\r\n        var sandboxCoordinator = new SandboxCoordinator_1.default(this.config, inputFiles, this.testFramework, this.reporter);\r\n        return sandboxCoordinator.initialRun(this.coverageInstrumenter)\r\n            .then(function (runResult) {\r\n            switch (runResult.status) {\r\n                case test_runner_1.RunStatus.Complete:\r\n                    var failedTests = _this.filterOutFailedTests(runResult);\r\n                    if (failedTests.length) {\r\n                        _this.logFailedTestsInInitialRun(failedTests);\r\n                        throw new Error('There were failed tests in the initial test run:');\r\n                    }\r\n                    else {\r\n                        _this.logInitialTestRunSucceeded(runResult.tests);\r\n                        return { runResult: runResult, inputFiles: inputFiles, sandboxCoordinator: sandboxCoordinator };\r\n                    }\r\n                case test_runner_1.RunStatus.Error:\r\n                    _this.logErrorredInitialRun(runResult);\r\n                    break;\r\n                case test_runner_1.RunStatus.Timeout:\r\n                    _this.logTimeoutInitialRun(runResult);\r\n                    break;\r\n            }\r\n        });\r\n    };\r\n    Stryker.prototype.generateAndRunMutations = function (inputFiles, initialRunResult, sandboxCoordinator) {\r\n        var mutants = this.generateMutants(inputFiles, initialRunResult);\r\n        if (mutants.length) {\r\n            return sandboxCoordinator.runMutants(mutants);\r\n        }\r\n        else {\r\n            log.info('It\\'s a mutant-free world, nothing to test.');\r\n            return Promise.resolve([]);\r\n        }\r\n    };\r\n    Stryker.prototype.generateMutants = function (inputFiles, runResult) {\r\n        var mutatorOrchestrator = new MutatorOrchestrator_1.default(this.reporter);\r\n        var mutants = mutatorOrchestrator.generateMutants(inputFiles\r\n            .filter(function (inputFile) { return inputFile.mutated; })\r\n            .map(function (file) { return file.path; }));\r\n        log.info(mutants.length + \" Mutant(s) generated\");\r\n        var mutantRunResultMatcher = new MutantTestMatcher_1.default(mutants, runResult, this.coverageInstrumenter.retrieveStatementMapsPerFile(), this.config);\r\n        mutantRunResultMatcher.matchWithMutants();\r\n        return mutants;\r\n    };\r\n    Stryker.prototype.wrapUpReporter = function () {\r\n        var maybePromise = this.reporter.wrapUp();\r\n        if (objectUtils_1.isPromise(maybePromise)) {\r\n            return maybePromise;\r\n        }\r\n        else {\r\n            return Promise.resolve();\r\n        }\r\n    };\r\n    Stryker.prototype.applyConfigWriters = function () {\r\n        var _this = this;\r\n        config_1.ConfigWriterFactory.instance().knownNames().forEach(function (configWriterName) {\r\n            config_1.ConfigWriterFactory.instance().create(configWriterName, undefined).write(_this.config);\r\n        });\r\n    };\r\n    Stryker.prototype.freezeConfig = function () {\r\n        objectUtils_1.freezeRecursively(this.config);\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(\"Using config: \" + JSON.stringify(this.config));\r\n        }\r\n    };\r\n    Stryker.prototype.logInitialTestRunSucceeded = function (tests) {\r\n        log.info('Initial test run succeeded. Ran %s tests in %s.', tests.length, this.timer.humanReadableElapsed());\r\n    };\r\n    Stryker.prototype.logDone = function () {\r\n        log.info('Done in %s.', this.timer.humanReadableElapsed());\r\n    };\r\n    Stryker.prototype.setGlobalLogLevel = function () {\r\n        log4js.setGlobalLogLevel(this.config.logLevel);\r\n    };\r\n    Stryker.prototype.logFailedTestsInInitialRun = function (failedTests) {\r\n        var message = 'One or more tests failed in the initial test run:';\r\n        failedTests.forEach(function (test) {\r\n            message += \"\\n\\t\" + test.name;\r\n            if (test.failureMessages && test.failureMessages.length) {\r\n                message += \"\\n\\t\" + test.failureMessages.join('\\n\\t');\r\n            }\r\n        });\r\n        log.error(message);\r\n    };\r\n    Stryker.prototype.logErrorredInitialRun = function (runResult) {\r\n        var message = 'One or more tests errored in the initial test run:';\r\n        if (runResult.errorMessages && runResult.errorMessages.length) {\r\n            runResult.errorMessages.forEach(function (error) { return message += \"\\n\\t\" + error; });\r\n        }\r\n        log.error(message);\r\n    };\r\n    Stryker.prototype.logTimeoutInitialRun = function (runResult) {\r\n        var message = 'Initial run timed out! Ran following tests before timeout:';\r\n        runResult.tests.forEach(function (test) { return (\"\\n\\t\" + test.name + \" \" + humanReadableTestState(test.status)); });\r\n        log.error(message);\r\n    };\r\n    return Stryker;\r\n}());","mutatedLines":"var Stryker = (function () {\n}());"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":65,"column":30},"end":{"line":65,"column":57}},"range":[3386,3413],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder"],"originalLines":"            .then(function () { return _this.logDone(); })","mutatedLines":"            .then(function () {\n})"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":54,"column":52},"end":{"line":67,"column":5}},"range":[2727,3484],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection"],"originalLines":"    Stryker.prototype.runMutationTest = function () {\r\n        var _this = this;\r\n        this.timer.reset();\r\n        return new InputFileResolver_1.default(this.config.mutate, this.config.files).resolve()\r\n            .then(function (inputFiles) { return _this.initialTestRun(inputFiles); })\r\n            .then(function (_a) {\r\n            var runResult = _a.runResult, inputFiles = _a.inputFiles, sandboxCoordinator = _a.sandboxCoordinator;\r\n            return _this.generateAndRunMutations(inputFiles, runResult, sandboxCoordinator);\r\n        })\r\n            .then(function (mutantResults) { return _this.wrapUpReporter()\r\n            .then(StrykerTempFolder_1.default.clean)\r\n            .then(function () { return _this.logDone(); })\r\n            .then(function () { return mutantResults; }); });\r\n    };","mutatedLines":"    Stryker.prototype.runMutationTest = function () {\n};"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BinaryOperator","status":1,"replacement":"testResult.status !== test_runner_1.TestStatus.Failed","location":{"start":{"line":69,"column":69},"end":{"line":69,"column":122}},"range":[3625,3678],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants \"before each\" hook for \"should log to have quite early\""],"originalLines":"        return runResult.tests.filter(function (testResult) { return testResult.status === test_runner_1.TestStatus.Failed; });","mutatedLines":"        return runResult.tests.filter(function (testResult) { return testResult.status !== test_runner_1.TestStatus.Failed; });"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":66,"column":30},"end":{"line":66,"column":55}},"range":[3446,3471],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder"],"originalLines":"            .then(function () { return mutantResults; }); });","mutatedLines":"            .then(function () {\n}); });"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":72,"column":12},"end":{"line":72,"column":31}},"range":[3756,3775],"testsRan":["Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins"],"originalLines":"        if (this.config.plugins) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":69,"column":60},"end":{"line":69,"column":125}},"range":[3616,3681],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder"],"originalLines":"        return runResult.tests.filter(function (testResult) { return testResult.status === test_runner_1.TestStatus.Failed; });","mutatedLines":"        return runResult.tests.filter(function (testResult) {\n});"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":18,"column":50},"end":{"line":27,"column":1}},"range":[955,1227],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"var humanReadableTestState = function (testState) {\r\n    switch (testState) {\r\n        case test_runner_1.TestStatus.Success:\r\n            return 'SUCCESS';\r\n        case test_runner_1.TestStatus.Failed:\r\n            return 'FAILED';\r\n        case test_runner_1.TestStatus.Skipped:\r\n            return 'SKIPPED';\r\n    }\r\n};","mutatedLines":"var humanReadableTestState = function (testState) {\n};"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":72,"column":33},"end":{"line":74,"column":9}},"range":[3777,3858],"testsRan":["Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins"],"originalLines":"        if (this.config.plugins) {\r\n            new PluginLoader_1.default(this.config.plugins).load();\r\n        }","mutatedLines":"        if (this.config.plugins) {\n}"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":77,"column":12},"end":{"line":77,"column":77}},"range":[3926,3991],"testsRan":["Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process"],"originalLines":"        if (this.config.coverageAnalysis === 'perTest' && !this.testFramework) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":72,"column":12},"end":{"line":72,"column":31}},"range":[3756,3775],"testsRan":["Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder"],"originalLines":"        if (this.config.plugins) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":77,"column":12},"end":{"line":77,"column":77}},"range":[3926,3991],"testsRan":["Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder"],"originalLines":"        if (this.config.coverageAnalysis === 'perTest' && !this.testFramework) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BinaryOperator","status":1,"replacement":"this.config.coverageAnalysis !== 'perTest'","location":{"start":{"line":77,"column":12},"end":{"line":77,"column":54}},"range":[3926,3968],"testsRan":["Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process"],"originalLines":"        if (this.config.coverageAnalysis === 'perTest' && !this.testFramework) {","mutatedLines":"        if (this.config.coverageAnalysis !== 'perTest' && !this.testFramework) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"LogicalOperator","status":2,"replacement":"this.config.coverageAnalysis === 'perTest' || !this.testFramework","location":{"start":{"line":77,"column":12},"end":{"line":77,"column":77}},"range":[3926,3991],"testsRan":["Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder"],"originalLines":"        if (this.config.coverageAnalysis === 'perTest' && !this.testFramework) {","mutatedLines":"        if (this.config.coverageAnalysis === 'perTest' || !this.testFramework) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":71,"column":48},"end":{"line":75,"column":5}},"range":[3741,3865],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins"],"originalLines":"    Stryker.prototype.loadPlugins = function () {\r\n        if (this.config.plugins) {\r\n            new PluginLoader_1.default(this.config.plugins).load();\r\n        }\r\n    };","mutatedLines":"    Stryker.prototype.loadPlugins = function () {\n};"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":77,"column":79},"end":{"line":80,"column":9}},"range":[3993,4226],"testsRan":["Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process"],"originalLines":"        if (this.config.coverageAnalysis === 'perTest' && !this.testFramework) {\r\n            log.fatal('Configured coverage analysis \"perTest\" requires there to be a testFramework configured. Either configure a testFramework or set coverageAnalysis to \"all\" or \"off\".');\r\n            process.exit(1);\r\n        }","mutatedLines":"        if (this.config.coverageAnalysis === 'perTest' && !this.testFramework) {\n}"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":68,"column":66},"end":{"line":70,"column":5}},"range":[3553,3690],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants \"before each\" hook for \"should log to have quite early\""],"originalLines":"    Stryker.prototype.filterOutFailedTests = function (runResult) {\r\n        return runResult.tests.filter(function (testResult) { return testResult.status === test_runner_1.TestStatus.Failed; });\r\n    };","mutatedLines":"    Stryker.prototype.filterOutFailedTests = function (runResult) {\n};"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":86,"column":39},"end":{"line":105,"column":9}},"range":[4567,5539],"testsRan":["Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors"],"originalLines":"            .then(function (runResult) {\r\n            switch (runResult.status) {\r\n                case test_runner_1.RunStatus.Complete:\r\n                    var failedTests = _this.filterOutFailedTests(runResult);\r\n                    if (failedTests.length) {\r\n                        _this.logFailedTestsInInitialRun(failedTests);\r\n                        throw new Error('There were failed tests in the initial test run:');\r\n                    }\r\n                    else {\r\n                        _this.logInitialTestRunSucceeded(runResult.tests);\r\n                        return { runResult: runResult, inputFiles: inputFiles, sandboxCoordinator: sandboxCoordinator };\r\n                    }\r\n                case test_runner_1.RunStatus.Error:\r\n                    _this.logErrorredInitialRun(runResult);\r\n                    break;\r\n                case test_runner_1.RunStatus.Timeout:\r\n                    _this.logTimeoutInitialRun(runResult);\r\n                    break;\r\n            }\r\n        });","mutatedLines":"            .then(function (runResult) {\n});"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":90,"column":24},"end":{"line":90,"column":42}},"range":[4769,4787],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants \"before each\" hook for \"should log to have quite early\""],"originalLines":"                    if (failedTests.length) {","mutatedLines":"                    if (true) {"},{"sourceFilePath":"/stryker/src/reporters/EventRecorderReporter.js","mutatorName":"BinaryOperator","status":3,"replacement":"i * 10","location":{"start":{"line":45,"column":39},"end":{"line":45,"column":45}},"range":[2189,2195],"testsRan":[],"originalLines":"        for (var i = 10000; i > 1; i = i / 10) {","mutatedLines":"        for (var i = 10000; i > 1; i = i * 10) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":94,"column":25},"end":{"line":97,"column":21}},"range":[5006,5228],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants \"before each\" hook for \"should log to have quite early\""],"originalLines":"                    else {\r\n                        _this.logInitialTestRunSucceeded(runResult.tests);\r\n                        return { runResult: runResult, inputFiles: inputFiles, sandboxCoordinator: sandboxCoordinator };\r\n                    }","mutatedLines":"                    else {\n}"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":76,"column":43},"end":{"line":81,"column":5}},"range":[3911,4233],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process"],"originalLines":"    Stryker.prototype.verify = function () {\r\n        if (this.config.coverageAnalysis === 'perTest' && !this.testFramework) {\r\n            log.fatal('Configured coverage analysis \"perTest\" requires there to be a testFramework configured. Either configure a testFramework or set coverageAnalysis to \"all\" or \"off\".');\r\n            process.exit(1);\r\n        }\r\n    };","mutatedLines":"    Stryker.prototype.verify = function () {\n};"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"RemoveConditionals","status":2,"replacement":"false","location":{"start":{"line":90,"column":24},"end":{"line":90,"column":42}},"range":[4769,4787],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder"],"originalLines":"                    if (failedTests.length) {","mutatedLines":"                    if (false) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":90,"column":44},"end":{"line":93,"column":21}},"range":[4789,4979],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder"],"originalLines":"                    if (failedTests.length) {\r\n                        _this.logFailedTestsInInitialRun(failedTests);\r\n                        throw new Error('There were failed tests in the initial test run:');\r\n                    }","mutatedLines":"                    if (failedTests.length) {\n}"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":112,"column":13},"end":{"line":115,"column":9}},"range":[5852,5975],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early"],"originalLines":"        else {\r\n            log.info('It\\'s a mutant-free world, nothing to test.');\r\n            return Promise.resolve([]);\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":109,"column":28},"end":{"line":111,"column":9}},"range":[5765,5837],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise"],"originalLines":"        if (mutants.length) {\r\n            return sandboxCoordinator.runMutants(mutants);\r\n        }","mutatedLines":"        if (mutants.length) {\n}"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":120,"column":41},"end":{"line":120,"column":70}},"range":[6257,6286],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder"],"originalLines":"            .filter(function (inputFile) { return inputFile.mutated; })","mutatedLines":"            .filter(function (inputFile) {\n})"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":121,"column":33},"end":{"line":121,"column":54}},"range":[6322,6343],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder"],"originalLines":"            .map(function (file) { return file.path; }));","mutatedLines":"            .map(function (file) {\n}));"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":82,"column":61},"end":{"line":106,"column":5}},"range":[4297,5548],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator"],"originalLines":"    Stryker.prototype.initialTestRun = function (inputFiles) {\r\n        var _this = this;\r\n        var sandboxCoordinator = new SandboxCoordinator_1.default(this.config, inputFiles, this.testFramework, this.reporter);\r\n        return sandboxCoordinator.initialRun(this.coverageInstrumenter)\r\n            .then(function (runResult) {\r\n            switch (runResult.status) {\r\n                case test_runner_1.RunStatus.Complete:\r\n                    var failedTests = _this.filterOutFailedTests(runResult);\r\n                    if (failedTests.length) {\r\n                        _this.logFailedTestsInInitialRun(failedTests);\r\n                        throw new Error('There were failed tests in the initial test run:');\r\n                    }\r\n                    else {\r\n                        _this.logInitialTestRunSucceeded(runResult.tests);\r\n                        return { runResult: runResult, inputFiles: inputFiles, sandboxCoordinator: sandboxCoordinator };\r\n                    }\r\n                case test_runner_1.RunStatus.Error:\r\n                    _this.logErrorredInitialRun(runResult);\r\n                    break;\r\n                case test_runner_1.RunStatus.Timeout:\r\n                    _this.logTimeoutInitialRun(runResult);\r\n                    break;\r\n            }\r\n        });\r\n    };","mutatedLines":"    Stryker.prototype.initialTestRun = function (inputFiles) {\n};"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":107,"column":108},"end":{"line":116,"column":5}},"range":[5659,5982],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early"],"originalLines":"    Stryker.prototype.generateAndRunMutations = function (inputFiles, initialRunResult, sandboxCoordinator) {\r\n        var mutants = this.generateMutants(inputFiles, initialRunResult);\r\n        if (mutants.length) {\r\n            return sandboxCoordinator.runMutants(mutants);\r\n        }\r\n        else {\r\n            log.info('It\\'s a mutant-free world, nothing to test.');\r\n            return Promise.resolve([]);\r\n        }\r\n    };","mutatedLines":"    Stryker.prototype.generateAndRunMutations = function (inputFiles, initialRunResult, sandboxCoordinator) {\n};"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":129,"column":12},"end":{"line":129,"column":49}},"range":[6773,6810],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise"],"originalLines":"        if (objectUtils_1.isPromise(maybePromise)) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BinaryOperator","status":2,"replacement":"mutants.length - ' Mutant(s) generated'","location":{"start":{"line":122,"column":17},"end":{"line":122,"column":56}},"range":[6365,6404],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder"],"originalLines":"        log.info(mutants.length + \" Mutant(s) generated\");","mutatedLines":"        log.info(mutants.length - ' Mutant(s) generated');"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":129,"column":12},"end":{"line":129,"column":49}},"range":[6773,6810],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants \"before each\" hook for \"should log to have quite early\""],"originalLines":"        if (objectUtils_1.isPromise(maybePromise)) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":132,"column":13},"end":{"line":134,"column":9}},"range":[6873,6924],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants \"before each\" hook for \"should log to have quite early\""],"originalLines":"        else {\r\n            return Promise.resolve();\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":117,"column":73},"end":{"line":126,"column":5}},"range":[6058,6652],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants \"before each\" hook for \"should log to have quite early\""],"originalLines":"    Stryker.prototype.generateMutants = function (inputFiles, runResult) {\r\n        var mutatorOrchestrator = new MutatorOrchestrator_1.default(this.reporter);\r\n        var mutants = mutatorOrchestrator.generateMutants(inputFiles\r\n            .filter(function (inputFile) { return inputFile.mutated; })\r\n            .map(function (file) { return file.path; }));\r\n        log.info(mutants.length + \" Mutant(s) generated\");\r\n        var mutantRunResultMatcher = new MutantTestMatcher_1.default(mutants, runResult, this.coverageInstrumenter.retrieveStatementMapsPerFile(), this.config);\r\n        mutantRunResultMatcher.matchWithMutants();\r\n        return mutants;\r\n    };","mutatedLines":"    Stryker.prototype.generateMutants = function (inputFiles, runResult) {\n};"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":129,"column":51},"end":{"line":131,"column":9}},"range":[6812,6858],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up \"before each\" hook for \"should resolve the stryker promise\""],"originalLines":"        if (objectUtils_1.isPromise(maybePromise)) {\r\n            return maybePromise;\r\n        }","mutatedLines":"        if (objectUtils_1.isPromise(maybePromise)) {\n}"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":138,"column":97},"end":{"line":140,"column":9}},"range":[7116,7238],"testsRan":["Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config"],"originalLines":"        config_1.ConfigWriterFactory.instance().knownNames().forEach(function (configWriterName) {\r\n            config_1.ConfigWriterFactory.instance().create(configWriterName, undefined).write(_this.config);\r\n        });","mutatedLines":"        config_1.ConfigWriterFactory.instance().knownNames().forEach(function (configWriterName) {\n});"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":109,"column":12},"end":{"line":109,"column":26}},"range":[5749,5763],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise"],"originalLines":"        if (mutants.length) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":127,"column":51},"end":{"line":135,"column":5}},"range":[6706,6931],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants \"before each\" hook for \"should log to have quite early\""],"originalLines":"    Stryker.prototype.wrapUpReporter = function () {\r\n        var maybePromise = this.reporter.wrapUp();\r\n        if (objectUtils_1.isPromise(maybePromise)) {\r\n            return maybePromise;\r\n        }\r\n        else {\r\n            return Promise.resolve();\r\n        }\r\n    };","mutatedLines":"    Stryker.prototype.wrapUpReporter = function () {\n};"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BinaryOperator","status":0,"replacement":"'Using config: ' - JSON.stringify(this.config)","location":{"start":{"line":145,"column":22},"end":{"line":145,"column":68}},"range":[7416,7462],"testsRan":[],"originalLines":"            log.debug(\"Using config: \" + JSON.stringify(this.config));","mutatedLines":"            log.debug('Using config: ' - JSON.stringify(this.config));"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"RemoveConditionals","status":2,"replacement":"false","location":{"start":{"line":144,"column":12},"end":{"line":144,"column":32}},"range":[7369,7389],"testsRan":["Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder"],"originalLines":"        if (log.isDebugEnabled()) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":144,"column":12},"end":{"line":144,"column":32}},"range":[7369,7389],"testsRan":["Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder"],"originalLines":"        if (log.isDebugEnabled()) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":136,"column":55},"end":{"line":141,"column":5}},"range":[6989,7247],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config"],"originalLines":"    Stryker.prototype.applyConfigWriters = function () {\r\n        var _this = this;\r\n        config_1.ConfigWriterFactory.instance().knownNames().forEach(function (configWriterName) {\r\n            config_1.ConfigWriterFactory.instance().create(configWriterName, undefined).write(_this.config);\r\n        });\r\n    };","mutatedLines":"    Stryker.prototype.applyConfigWriters = function () {\n};"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":142,"column":49},"end":{"line":147,"column":5}},"range":[7299,7482],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config"],"originalLines":"    Stryker.prototype.freezeConfig = function () {\r\n        objectUtils_1.freezeRecursively(this.config);\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(\"Using config: \" + JSON.stringify(this.config));\r\n        }\r\n    };","mutatedLines":"    Stryker.prototype.freezeConfig = function () {\n};"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":159,"column":44},"end":{"line":164,"column":9}},"range":[8126,8341],"testsRan":[],"originalLines":"        failedTests.forEach(function (test) {\r\n            message += \"\\n\\t\" + test.name;\r\n            if (test.failureMessages && test.failureMessages.length) {\r\n                message += \"\\n\\t\" + test.failureMessages.join('\\n\\t');\r\n            }\r\n        });","mutatedLines":"        failedTests.forEach(function (test) {\n});"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BinaryOperator","status":0,"replacement":"'\\n\\t' - test.name","location":{"start":{"line":160,"column":23},"end":{"line":160,"column":41}},"range":[8152,8170],"testsRan":[],"originalLines":"            message += \"\\n\\t\" + test.name;","mutatedLines":"            message += '\\n\\t' - test.name;"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"RemoveConditionals","status":0,"replacement":"false","location":{"start":{"line":161,"column":16},"end":{"line":161,"column":67}},"range":[8189,8240],"testsRan":[],"originalLines":"            if (test.failureMessages && test.failureMessages.length) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"RemoveConditionals","status":0,"replacement":"true","location":{"start":{"line":161,"column":16},"end":{"line":161,"column":67}},"range":[8189,8240],"testsRan":[],"originalLines":"            if (test.failureMessages && test.failureMessages.length) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"LogicalOperator","status":0,"replacement":"test.failureMessages || test.failureMessages.length","location":{"start":{"line":161,"column":16},"end":{"line":161,"column":67}},"range":[8189,8240],"testsRan":[],"originalLines":"            if (test.failureMessages && test.failureMessages.length) {","mutatedLines":"            if (test.failureMessages || test.failureMessages.length) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":161,"column":69},"end":{"line":163,"column":13}},"range":[8242,8330],"testsRan":[],"originalLines":"            if (test.failureMessages && test.failureMessages.length) {\r\n                message += \"\\n\\t\" + test.failureMessages.join('\\n\\t');\r\n            }","mutatedLines":"            if (test.failureMessages && test.failureMessages.length) {\n}"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BinaryOperator","status":0,"replacement":"'\\n\\t' - test.failureMessages.join('\\n\\t')","location":{"start":{"line":162,"column":27},"end":{"line":162,"column":69}},"range":[8272,8314],"testsRan":[],"originalLines":"                message += \"\\n\\t\" + test.failureMessages.join('\\n\\t');","mutatedLines":"                message += '\\n\\t' - test.failureMessages.join('\\n\\t');"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":144,"column":34},"end":{"line":146,"column":9}},"range":[7391,7475],"testsRan":["Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder"],"originalLines":"        if (log.isDebugEnabled()) {\r\n            log.debug(\"Using config: \" + JSON.stringify(this.config));\r\n        }","mutatedLines":"        if (log.isDebugEnabled()) {\n}"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":169,"column":12},"end":{"line":169,"column":69}},"range":[8541,8598],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors"],"originalLines":"        if (runResult.errorMessages && runResult.errorMessages.length) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":169,"column":12},"end":{"line":169,"column":69}},"range":[8541,8598],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection"],"originalLines":"        if (runResult.errorMessages && runResult.errorMessages.length) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":109,"column":12},"end":{"line":109,"column":26}},"range":[5749,5763],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants \"before each\" hook for \"should log to have quite early\""],"originalLines":"        if (mutants.length) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"LogicalOperator","status":2,"replacement":"runResult.errorMessages || runResult.errorMessages.length","location":{"start":{"line":169,"column":12},"end":{"line":169,"column":69}},"range":[8541,8598],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection"],"originalLines":"        if (runResult.errorMessages && runResult.errorMessages.length) {","mutatedLines":"        if (runResult.errorMessages || runResult.errorMessages.length) {"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":169,"column":71},"end":{"line":171,"column":9}},"range":[8600,8714],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors"],"originalLines":"        if (runResult.errorMessages && runResult.errorMessages.length) {\r\n            runResult.errorMessages.forEach(function (error) { return message += \"\\n\\t\" + error; });\r\n        }","mutatedLines":"        if (runResult.errorMessages && runResult.errorMessages.length) {\n}"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BinaryOperator","status":1,"replacement":"'\\n\\t' - error","location":{"start":{"line":170,"column":81},"end":{"line":170,"column":95}},"range":[8684,8698],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors"],"originalLines":"            runResult.errorMessages.forEach(function (error) { return message += \"\\n\\t\" + error; });","mutatedLines":"            runResult.errorMessages.forEach(function (error) { return message += '\\n\\t' - error; });"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":170,"column":61},"end":{"line":170,"column":98}},"range":[8664,8701],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors"],"originalLines":"            runResult.errorMessages.forEach(function (error) { return message += \"\\n\\t\" + error; });","mutatedLines":"            runResult.errorMessages.forEach(function (error) {\n});"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":176,"column":48},"end":{"line":176,"column":124}},"range":[8955,9031],"testsRan":[],"originalLines":"        runResult.tests.forEach(function (test) { return (\"\\n\\t\" + test.name + \" \" + humanReadableTestState(test.status)); });","mutatedLines":"        runResult.tests.forEach(function (test) {\n});"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BinaryOperator","status":0,"replacement":"'\\n\\t' + test.name + ' ' - humanReadableTestState(test.status)","location":{"start":{"line":176,"column":58},"end":{"line":176,"column":120}},"range":[8965,9027],"testsRan":[],"originalLines":"        runResult.tests.forEach(function (test) { return (\"\\n\\t\" + test.name + \" \" + humanReadableTestState(test.status)); });","mutatedLines":"        runResult.tests.forEach(function (test) { return ('\\n\\t' + test.name + ' ' - humanReadableTestState(test.status)); });"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BinaryOperator","status":0,"replacement":"'\\n\\t' + test.name - ' '","location":{"start":{"line":176,"column":58},"end":{"line":176,"column":82}},"range":[8965,8989],"testsRan":[],"originalLines":"        runResult.tests.forEach(function (test) { return (\"\\n\\t\" + test.name + \" \" + humanReadableTestState(test.status)); });","mutatedLines":"        runResult.tests.forEach(function (test) { return ('\\n\\t' + test.name - ' ' + humanReadableTestState(test.status)); });"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BinaryOperator","status":0,"replacement":"'\\n\\t' - test.name","location":{"start":{"line":176,"column":58},"end":{"line":176,"column":76}},"range":[8965,8983],"testsRan":[],"originalLines":"        runResult.tests.forEach(function (test) { return (\"\\n\\t\" + test.name + \" \" + humanReadableTestState(test.status)); });","mutatedLines":"        runResult.tests.forEach(function (test) { return ('\\n\\t' - test.name + \" \" + humanReadableTestState(test.status)); });"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":148,"column":68},"end":{"line":150,"column":5}},"range":[7553,7680],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran"],"originalLines":"    Stryker.prototype.logInitialTestRunSucceeded = function (tests) {\r\n        log.info('Initial test run succeeded. Ran %s tests in %s.', tests.length, this.timer.humanReadableElapsed());\r\n    };","mutatedLines":"    Stryker.prototype.logInitialTestRunSucceeded = function (tests) {\n};"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":151,"column":44},"end":{"line":153,"column":5}},"range":[7727,7804],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    Stryker.prototype.logDone = function () {\r\n        log.info('Done in %s.', this.timer.humanReadableElapsed());\r\n    };","mutatedLines":"    Stryker.prototype.logDone = function () {\n};"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":154,"column":54},"end":{"line":156,"column":5}},"range":[7861,7926],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    Stryker.prototype.setGlobalLogLevel = function () {\r\n        log4js.setGlobalLogLevel(this.config.logLevel);\r\n    };","mutatedLines":"    Stryker.prototype.setGlobalLogLevel = function () {\n};"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":167,"column":67},"end":{"line":173,"column":5}},"range":[8449,8750],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors"],"originalLines":"    Stryker.prototype.logErrorredInitialRun = function (runResult) {\r\n        var message = 'One or more tests errored in the initial test run:';\r\n        if (runResult.errorMessages && runResult.errorMessages.length) {\r\n            runResult.errorMessages.forEach(function (error) { return message += \"\\n\\t\" + error; });\r\n        }\r\n        log.error(message);\r\n    };","mutatedLines":"    Stryker.prototype.logErrorredInitialRun = function (runResult) {\n};"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":157,"column":74},"end":{"line":166,"column":5}},"range":[8003,8379],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    Stryker.prototype.logFailedTestsInInitialRun = function (failedTests) {\r\n        var message = 'One or more tests failed in the initial test run:';\r\n        failedTests.forEach(function (test) {\r\n            message += \"\\n\\t\" + test.name;\r\n            if (test.failureMessages && test.failureMessages.length) {\r\n                message += \"\\n\\t\" + test.failureMessages.join('\\n\\t');\r\n            }\r\n        });\r\n        log.error(message);\r\n    };","mutatedLines":"    Stryker.prototype.logFailedTestsInInitialRun = function (failedTests) {\n};"},{"sourceFilePath":"/stryker/src/TestFrameworkOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":10,"column":12},"end":{"line":10,"column":55}},"range":[400,443],"testsRan":["TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework"],"originalLines":"        if (this.options.coverageAnalysis !== 'perTest') {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/TestFrameworkOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":10,"column":12},"end":{"line":10,"column":55}},"range":[400,443],"testsRan":["TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting"],"originalLines":"        if (this.options.coverageAnalysis !== 'perTest') {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/TestFrameworkOrchestrator.js","mutatorName":"BinaryOperator","status":1,"replacement":"this.options.coverageAnalysis === 'perTest'","location":{"start":{"line":10,"column":12},"end":{"line":10,"column":55}},"range":[400,443],"testsRan":["TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework"],"originalLines":"        if (this.options.coverageAnalysis !== 'perTest') {","mutatedLines":"        if (this.options.coverageAnalysis === 'perTest') {"},{"sourceFilePath":"/stryker/src/TestFrameworkOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":10,"column":57},"end":{"line":13,"column":9}},"range":[445,650],"testsRan":["TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework"],"originalLines":"        if (this.options.coverageAnalysis !== 'perTest') {\r\n            log.debug('The `coverageAnalysis` setting is \"%s\", not hooking into the test framework to achieve performance benefits.', this.options.coverageAnalysis);\r\n            return null;\r\n        }","mutatedLines":"        if (this.options.coverageAnalysis !== 'perTest') {\n}"},{"sourceFilePath":"/stryker/src/TestFrameworkOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":14,"column":13},"end":{"line":16,"column":9}},"range":[665,744],"testsRan":["TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting"],"originalLines":"        else {\r\n            return this.determineFrameworkWithCoverageAnalysis();\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/TestFrameworkOrchestrator.js","mutatorName":"RemoveConditionals","status":2,"replacement":"false","location":{"start":{"line":20,"column":12},"end":{"line":20,"column":38}},"range":[897,923],"testsRan":["TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework"],"originalLines":"        if (this.options.testFramework) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/TestFrameworkOrchestrator.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":20,"column":40},"end":{"line":28,"column":9}},"range":[925,1405],"testsRan":["TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework"],"originalLines":"        if (this.options.testFramework) {\r\n            if (this.testFrameworkExists(this.options.testFramework)) {\r\n                log.debug(\"Using testFramework \" + this.options.testFramework + \" based on `testFramework` setting\");\r\n                testFramework = this.createTestFramework(this.options.testFramework);\r\n            }\r\n            else {\r\n                log.warn(\"Could not find test framework `\" + this.options.testFramework + \"`. \" + this.informAboutKnownTestFrameworks());\r\n            }\r\n        }","mutatedLines":"        if (this.options.testFramework) {\n}"},{"sourceFilePath":"/stryker/src/TestFrameworkOrchestrator.js","mutatorName":"RemoveConditionals","status":0,"replacement":"false","location":{"start":{"line":21,"column":16},"end":{"line":21,"column":68}},"range":[944,996],"testsRan":[],"originalLines":"            if (this.testFrameworkExists(this.options.testFramework)) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/TestFrameworkOrchestrator.js","mutatorName":"RemoveConditionals","status":0,"replacement":"true","location":{"start":{"line":21,"column":16},"end":{"line":21,"column":68}},"range":[944,996],"testsRan":[],"originalLines":"            if (this.testFrameworkExists(this.options.testFramework)) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/TestFrameworkOrchestrator.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":21,"column":70},"end":{"line":24,"column":13}},"range":[998,1220],"testsRan":[],"originalLines":"            if (this.testFrameworkExists(this.options.testFramework)) {\r\n                log.debug(\"Using testFramework \" + this.options.testFramework + \" based on `testFramework` setting\");\r\n                testFramework = this.createTestFramework(this.options.testFramework);\r\n            }","mutatedLines":"            if (this.testFrameworkExists(this.options.testFramework)) {\n}"},{"sourceFilePath":"/stryker/src/TestFrameworkOrchestrator.js","mutatorName":"BinaryOperator","status":0,"replacement":"'Using testFramework ' + this.options.testFramework - ' based on `testFramework` setting'","location":{"start":{"line":22,"column":26},"end":{"line":22,"column":115}},"range":[1027,1116],"testsRan":[],"originalLines":"                log.debug(\"Using testFramework \" + this.options.testFramework + \" based on `testFramework` setting\");","mutatedLines":"                log.debug('Using testFramework ' + this.options.testFramework - ' based on `testFramework` setting');"},{"sourceFilePath":"/stryker/src/TestFrameworkOrchestrator.js","mutatorName":"BinaryOperator","status":0,"replacement":"'Using testFramework ' - this.options.testFramework","location":{"start":{"line":22,"column":26},"end":{"line":22,"column":77}},"range":[1027,1078],"testsRan":[],"originalLines":"                log.debug(\"Using testFramework \" + this.options.testFramework + \" based on `testFramework` setting\");","mutatedLines":"                log.debug('Using testFramework ' - this.options.testFramework + \" based on `testFramework` setting\");"},{"sourceFilePath":"/stryker/src/TestFrameworkOrchestrator.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":25,"column":17},"end":{"line":27,"column":13}},"range":[1239,1394],"testsRan":[],"originalLines":"            else {\r\n                log.warn(\"Could not find test framework `\" + this.options.testFramework + \"`. \" + this.informAboutKnownTestFrameworks());\r\n            }","mutatedLines":"            else {\n}"},{"sourceFilePath":"/stryker/src/TestFrameworkOrchestrator.js","mutatorName":"BinaryOperator","status":0,"replacement":"'Could not find test framework `' + this.options.testFramework + '`. ' - this.informAboutKnownTestFrameworks()","location":{"start":{"line":26,"column":25},"end":{"line":26,"column":135}},"range":[1267,1377],"testsRan":[],"originalLines":"                log.warn(\"Could not find test framework `\" + this.options.testFramework + \"`. \" + this.informAboutKnownTestFrameworks());","mutatedLines":"                log.warn('Could not find test framework `' + this.options.testFramework + '`. ' - this.informAboutKnownTestFrameworks());"},{"sourceFilePath":"/stryker/src/TestFrameworkOrchestrator.js","mutatorName":"BinaryOperator","status":0,"replacement":"'Could not find test framework `' + this.options.testFramework - '`. '","location":{"start":{"line":26,"column":25},"end":{"line":26,"column":95}},"range":[1267,1337],"testsRan":[],"originalLines":"                log.warn(\"Could not find test framework `\" + this.options.testFramework + \"`. \" + this.informAboutKnownTestFrameworks());","mutatedLines":"                log.warn('Could not find test framework `' + this.options.testFramework - '`. ' + this.informAboutKnownTestFrameworks());"},{"sourceFilePath":"/stryker/src/TestFrameworkOrchestrator.js","mutatorName":"BinaryOperator","status":0,"replacement":"'Could not find test framework `' - this.options.testFramework","location":{"start":{"line":26,"column":25},"end":{"line":26,"column":87}},"range":[1267,1329],"testsRan":[],"originalLines":"                log.warn(\"Could not find test framework `\" + this.options.testFramework + \"`. \" + this.informAboutKnownTestFrameworks());","mutatedLines":"                log.warn('Could not find test framework `' - this.options.testFramework + \"`. \" + this.informAboutKnownTestFrameworks());"},{"sourceFilePath":"/stryker/src/TestFrameworkOrchestrator.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":20,"column":12},"end":{"line":20,"column":38}},"range":[897,923],"testsRan":["TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting"],"originalLines":"        if (this.options.testFramework) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/TestFrameworkOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":29,"column":13},"end":{"line":31,"column":9}},"range":[1420,1573],"testsRan":["TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting"],"originalLines":"        else {\r\n            log.warn('Missing config settings `testFramework`. Set `coverageAnalysis` option explicitly to \"off\" to ignore this warning.');\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/TestFrameworkOrchestrator.js","mutatorName":"BinaryOperator","status":0,"replacement":"'Did you forget to load a plugin? Known test frameworks: ' + JSON.stringify(test_framework_1.TestFrameworkFactory.instance().knownNames()) - '.'","location":{"start":{"line":35,"column":15},"end":{"line":35,"column":159}},"range":[1717,1861],"testsRan":[],"originalLines":"        return \"Did you forget to load a plugin? Known test frameworks: \" + JSON.stringify(test_framework_1.TestFrameworkFactory.instance().knownNames()) + \".\";","mutatedLines":"        return 'Did you forget to load a plugin? Known test frameworks: ' + JSON.stringify(test_framework_1.TestFrameworkFactory.instance().knownNames()) - '.';"},{"sourceFilePath":"/stryker/src/TestFrameworkOrchestrator.js","mutatorName":"BinaryOperator","status":0,"replacement":"'Did you forget to load a plugin? Known test frameworks: ' - JSON.stringify(test_framework_1.TestFrameworkFactory.instance().knownNames())","location":{"start":{"line":35,"column":15},"end":{"line":35,"column":153}},"range":[1717,1855],"testsRan":[],"originalLines":"        return \"Did you forget to load a plugin? Known test frameworks: \" + JSON.stringify(test_framework_1.TestFrameworkFactory.instance().knownNames()) + \".\";","mutatedLines":"        return 'Did you forget to load a plugin? Known test frameworks: ' - JSON.stringify(test_framework_1.TestFrameworkFactory.instance().knownNames()) + \".\";"},{"sourceFilePath":"/stryker/src/TestFrameworkOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":5,"column":45},"end":{"line":44,"column":1}},"range":[214,2314],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker \"before each\" hook for \"should exit the process\""],"originalLines":"var TestFrameworkOrchestrator = (function () {\r\n    function TestFrameworkOrchestrator(options) {\r\n        this.options = options;\r\n    }\r\n    TestFrameworkOrchestrator.prototype.determineTestFramework = function () {\r\n        if (this.options.coverageAnalysis !== 'perTest') {\r\n            log.debug('The `coverageAnalysis` setting is \"%s\", not hooking into the test framework to achieve performance benefits.', this.options.coverageAnalysis);\r\n            return null;\r\n        }\r\n        else {\r\n            return this.determineFrameworkWithCoverageAnalysis();\r\n        }\r\n    };\r\n    TestFrameworkOrchestrator.prototype.determineFrameworkWithCoverageAnalysis = function () {\r\n        var testFramework = null;\r\n        if (this.options.testFramework) {\r\n            if (this.testFrameworkExists(this.options.testFramework)) {\r\n                log.debug(\"Using testFramework \" + this.options.testFramework + \" based on `testFramework` setting\");\r\n                testFramework = this.createTestFramework(this.options.testFramework);\r\n            }\r\n            else {\r\n                log.warn(\"Could not find test framework `\" + this.options.testFramework + \"`. \" + this.informAboutKnownTestFrameworks());\r\n            }\r\n        }\r\n        else {\r\n            log.warn('Missing config settings `testFramework`. Set `coverageAnalysis` option explicitly to \"off\" to ignore this warning.');\r\n        }\r\n        return testFramework;\r\n    };\r\n    TestFrameworkOrchestrator.prototype.informAboutKnownTestFrameworks = function () {\r\n        return \"Did you forget to load a plugin? Known test frameworks: \" + JSON.stringify(test_framework_1.TestFrameworkFactory.instance().knownNames()) + \".\";\r\n    };\r\n    TestFrameworkOrchestrator.prototype.createTestFramework = function (name) {\r\n        return test_framework_1.TestFrameworkFactory.instance().create(name, { options: this.options });\r\n    };\r\n    TestFrameworkOrchestrator.prototype.testFrameworkExists = function (maybeFramework) {\r\n        return test_framework_1.TestFrameworkFactory.instance().knownNames().indexOf(maybeFramework) > -1;\r\n    };\r\n    return TestFrameworkOrchestrator;\r\n}());","mutatedLines":"var TestFrameworkOrchestrator = (function () {\n}());"},{"sourceFilePath":"/stryker/src/Stryker.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":174,"column":66},"end":{"line":178,"column":5}},"range":[8819,9069],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    Stryker.prototype.logTimeoutInitialRun = function (runResult) {\r\n        var message = 'Initial run timed out! Ran following tests before timeout:';\r\n        runResult.tests.forEach(function (test) { return (\"\\n\\t\" + test.name + \" \" + humanReadableTestState(test.status)); });\r\n        log.error(message);\r\n    };","mutatedLines":"    Stryker.prototype.logTimeoutInitialRun = function (runResult) {\n};"},{"sourceFilePath":"/stryker/src/TestFrameworkOrchestrator.js","mutatorName":"BinaryOperator","status":0,"replacement":"test_framework_1.TestFrameworkFactory.instance().knownNames().indexOf(maybeFramework) >= -1","location":{"start":{"line":41,"column":15},"end":{"line":41,"column":105}},"range":[2173,2263],"testsRan":[],"originalLines":"        return test_framework_1.TestFrameworkFactory.instance().knownNames().indexOf(maybeFramework) > -1;","mutatedLines":"        return test_framework_1.TestFrameworkFactory.instance().knownNames().indexOf(maybeFramework) >= -1;"},{"sourceFilePath":"/stryker/src/TestFrameworkOrchestrator.js","mutatorName":"BinaryOperator","status":0,"replacement":"test_framework_1.TestFrameworkFactory.instance().knownNames().indexOf(maybeFramework) <= -1","location":{"start":{"line":41,"column":15},"end":{"line":41,"column":105}},"range":[2173,2263],"testsRan":[],"originalLines":"        return test_framework_1.TestFrameworkFactory.instance().knownNames().indexOf(maybeFramework) > -1;","mutatedLines":"        return test_framework_1.TestFrameworkFactory.instance().knownNames().indexOf(maybeFramework) <= -1;"},{"sourceFilePath":"/stryker/src/TestFrameworkOrchestrator.js","mutatorName":"UnaryOperator","status":0,"replacement":"+1","location":{"start":{"line":41,"column":103},"end":{"line":41,"column":105}},"range":[2261,2263],"testsRan":[],"originalLines":"        return test_framework_1.TestFrameworkFactory.instance().knownNames().indexOf(maybeFramework) > -1;","mutatedLines":"        return test_framework_1.TestFrameworkFactory.instance().knownNames().indexOf(maybeFramework) > +1;"},{"sourceFilePath":"/stryker/src/TestFrameworkOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":9,"column":77},"end":{"line":17,"column":5}},"range":[385,751],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework"],"originalLines":"    TestFrameworkOrchestrator.prototype.determineTestFramework = function () {\r\n        if (this.options.coverageAnalysis !== 'perTest') {\r\n            log.debug('The `coverageAnalysis` setting is \"%s\", not hooking into the test framework to achieve performance benefits.', this.options.coverageAnalysis);\r\n            return null;\r\n        }\r\n        else {\r\n            return this.determineFrameworkWithCoverageAnalysis();\r\n        }\r\n    };","mutatedLines":"    TestFrameworkOrchestrator.prototype.determineTestFramework = function () {\n};"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":14,"column":8},"end":{"line":17,"column":5}},"range":[363,422],"testsRan":[],"originalLines":"    try {\r\n        fs.lstatSync(path);\r\n        return true;\r\n    }","mutatedLines":"    try {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":18,"column":18},"end":{"line":20,"column":5}},"range":[442,473],"testsRan":[],"originalLines":"    catch (error) {\r\n        return false;\r\n    }","mutatedLines":"    catch (error) {\n}"},{"sourceFilePath":"/stryker/src/TestFrameworkOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":6,"column":48},"end":{"line":8,"column":5}},"range":[265,306],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" \"before each\" hook for \"should not retrieve a testFramework\""],"originalLines":"    function TestFrameworkOrchestrator(options) {\r\n        this.options = options;\r\n    }","mutatedLines":"    function TestFrameworkOrchestrator(options) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":25,"column":42},"end":{"line":29,"column":5}},"range":[618,719],"testsRan":[],"originalLines":"    return new Promise(function (resolve) {\r\n        fs.lstat(path, function (error, stats) {\r\n            resolve(!error);\r\n        });\r\n    });","mutatedLines":"    return new Promise(function (resolve) {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":26,"column":47},"end":{"line":28,"column":9}},"range":[668,710],"testsRan":[],"originalLines":"        fs.lstat(path, function (error, stats) {\r\n            resolve(!error);\r\n        });","mutatedLines":"        fs.lstat(path, function (error, stats) {\n});"},{"sourceFilePath":"/stryker/src/TestFrameworkOrchestrator.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":18,"column":93},"end":{"line":33,"column":5}},"range":[847,1611],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting"],"originalLines":"    TestFrameworkOrchestrator.prototype.determineFrameworkWithCoverageAnalysis = function () {\r\n        var testFramework = null;\r\n        if (this.options.testFramework) {\r\n            if (this.testFrameworkExists(this.options.testFramework)) {\r\n                log.debug(\"Using testFramework \" + this.options.testFramework + \" based on `testFramework` setting\");\r\n                testFramework = this.createTestFramework(this.options.testFramework);\r\n            }\r\n            else {\r\n                log.warn(\"Could not find test framework `\" + this.options.testFramework + \"`. \" + this.informAboutKnownTestFrameworks());\r\n            }\r\n        }\r\n        else {\r\n            log.warn('Missing config settings `testFramework`. Set `coverageAnalysis` option explicitly to \"off\" to ignore this warning.');\r\n        }\r\n        return testFramework;\r\n    };","mutatedLines":"    TestFrameworkOrchestrator.prototype.determineFrameworkWithCoverageAnalysis = function () {\n};"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":47,"column":26},"end":{"line":51,"column":1}},"range":[1175,1291],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files"],"originalLines":"function normalize(files) {\r\n    _.forEach(files, function (file, key) {\r\n        files[key] = path.resolve(path.normalize(file));\r\n    });\r\n}","mutatedLines":"function normalize(files) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":38,"column":28},"end":{"line":40,"column":1}},"range":[928,979],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist"],"originalLines":"function readFile(filename) {\r\n    return fs.readFileSync(filename, 'utf8');\r\n}","mutatedLines":"function readFile(filename) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":48,"column":42},"end":{"line":50,"column":5}},"range":[1220,1286],"testsRan":["InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files"],"originalLines":"    _.forEach(files, function (file, key) {\r\n        files[key] = path.resolve(path.normalize(file));\r\n    });","mutatedLines":"    _.forEach(files, function (file, key) {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":55,"column":50},"end":{"line":64,"column":5}},"range":[1407,1629],"testsRan":[],"originalLines":"    return new Promise(function (resolve, reject) {\r\n        nodeGlob(expression, function (error, matches) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve(matches);\r\n            }\r\n        });\r\n    });","mutatedLines":"    return new Promise(function (resolve, reject) {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":56,"column":55},"end":{"line":63,"column":9}},"range":[1465,1620],"testsRan":[],"originalLines":"        nodeGlob(expression, function (error, matches) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve(matches);\r\n            }\r\n        });","mutatedLines":"        nodeGlob(expression, function (error, matches) {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":0,"replacement":"false","location":{"start":{"line":57,"column":16},"end":{"line":57,"column":21}},"range":[1484,1489],"testsRan":[],"originalLines":"            if (error) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":0,"replacement":"true","location":{"start":{"line":57,"column":16},"end":{"line":57,"column":21}},"range":[1484,1489],"testsRan":[],"originalLines":"            if (error) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":57,"column":23},"end":{"line":59,"column":13}},"range":[1491,1539],"testsRan":[],"originalLines":"            if (error) {\r\n                reject(error);\r\n            }","mutatedLines":"            if (error) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":60,"column":17},"end":{"line":62,"column":13}},"range":[1558,1609],"testsRan":[],"originalLines":"            else {\r\n                resolve(matches);\r\n            }","mutatedLines":"            else {\n}"},{"sourceFilePath":"/stryker/src/TestFrameworkOrchestrator.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":34,"column":85},"end":{"line":36,"column":5}},"range":[1699,1869],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    TestFrameworkOrchestrator.prototype.informAboutKnownTestFrameworks = function () {\r\n        return \"Did you forget to load a plugin? Known test frameworks: \" + JSON.stringify(test_framework_1.TestFrameworkFactory.instance().knownNames()) + \".\";\r\n    };","mutatedLines":"    TestFrameworkOrchestrator.prototype.informAboutKnownTestFrameworks = function () {\n};"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":68,"column":50},"end":{"line":77,"column":5}},"range":[1734,1948],"testsRan":[],"originalLines":"    return new Promise(function (resolve, reject) {\r\n        fs.readdir(path, function (error, files) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve(files);\r\n            }\r\n        });\r\n    });","mutatedLines":"    return new Promise(function (resolve, reject) {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":69,"column":49},"end":{"line":76,"column":9}},"range":[1786,1939],"testsRan":[],"originalLines":"        fs.readdir(path, function (error, files) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve(files);\r\n            }\r\n        });","mutatedLines":"        fs.readdir(path, function (error, files) {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":0,"replacement":"false","location":{"start":{"line":70,"column":16},"end":{"line":70,"column":21}},"range":[1805,1810],"testsRan":[],"originalLines":"            if (error) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":0,"replacement":"true","location":{"start":{"line":70,"column":16},"end":{"line":70,"column":21}},"range":[1805,1810],"testsRan":[],"originalLines":"            if (error) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":70,"column":23},"end":{"line":72,"column":13}},"range":[1812,1860],"testsRan":[],"originalLines":"            if (error) {\r\n                reject(error);\r\n            }","mutatedLines":"            if (error) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":73,"column":17},"end":{"line":75,"column":13}},"range":[1879,1928],"testsRan":[],"originalLines":"            else {\r\n                resolve(files);\r\n            }","mutatedLines":"            else {\n}"},{"sourceFilePath":"/stryker/src/TestFrameworkOrchestrator.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":37,"column":78},"end":{"line":39,"column":5}},"range":[1950,2064],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    TestFrameworkOrchestrator.prototype.createTestFramework = function (name) {\r\n        return test_framework_1.TestFrameworkFactory.instance().create(name, { options: this.options });\r\n    };","mutatedLines":"    TestFrameworkOrchestrator.prototype.createTestFramework = function (name) {\n};"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":81,"column":50},"end":{"line":90,"column":5}},"range":[2057,2268],"testsRan":[],"originalLines":"    return new Promise(function (resolve, reject) {\r\n        fs.stat(path, function (error, stats) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve(stats);\r\n            }\r\n        });\r\n    });","mutatedLines":"    return new Promise(function (resolve, reject) {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":82,"column":46},"end":{"line":89,"column":9}},"range":[2106,2259],"testsRan":[],"originalLines":"        fs.stat(path, function (error, stats) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve(stats);\r\n            }\r\n        });","mutatedLines":"        fs.stat(path, function (error, stats) {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":0,"replacement":"false","location":{"start":{"line":83,"column":16},"end":{"line":83,"column":21}},"range":[2125,2130],"testsRan":[],"originalLines":"            if (error) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":0,"replacement":"true","location":{"start":{"line":83,"column":16},"end":{"line":83,"column":21}},"range":[2125,2130],"testsRan":[],"originalLines":"            if (error) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":83,"column":23},"end":{"line":85,"column":13}},"range":[2132,2180],"testsRan":[],"originalLines":"            if (error) {\r\n                reject(error);\r\n            }","mutatedLines":"            if (error) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":86,"column":17},"end":{"line":88,"column":13}},"range":[2199,2248],"testsRan":[],"originalLines":"            else {\r\n                resolve(stats);\r\n            }","mutatedLines":"            else {\n}"},{"sourceFilePath":"/stryker/src/SandboxCoordinator.js","mutatorName":"UpdateOperator","status":3,"replacement":"i--","location":{"start":{"line":63,"column":38},"end":{"line":63,"column":41}},"range":[3123,3126],"testsRan":[],"originalLines":"        for (var i = 0; i < cpuCount; i++) {","mutatedLines":"        for (var i = 0; i < cpuCount; i--) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":93,"column":58},"end":{"line":102,"column":5}},"range":[2358,2567],"testsRan":[],"originalLines":"    return new Promise(function (fileResolve, fileReject) {\r\n        fs.unlink(path, function (error) {\r\n            if (error) {\r\n                fileReject(error);\r\n            }\r\n            else {\r\n                fileResolve();\r\n            }\r\n        });\r\n    });","mutatedLines":"    return new Promise(function (fileResolve, fileReject) {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":94,"column":41},"end":{"line":101,"column":9}},"range":[2402,2558],"testsRan":[],"originalLines":"        fs.unlink(path, function (error) {\r\n            if (error) {\r\n                fileReject(error);\r\n            }\r\n            else {\r\n                fileResolve();\r\n            }\r\n        });","mutatedLines":"        fs.unlink(path, function (error) {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":0,"replacement":"false","location":{"start":{"line":95,"column":16},"end":{"line":95,"column":21}},"range":[2421,2426],"testsRan":[],"originalLines":"            if (error) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":0,"replacement":"true","location":{"start":{"line":95,"column":16},"end":{"line":95,"column":21}},"range":[2421,2426],"testsRan":[],"originalLines":"            if (error) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":95,"column":23},"end":{"line":97,"column":13}},"range":[2428,2480],"testsRan":[],"originalLines":"            if (error) {\r\n                fileReject(error);\r\n            }","mutatedLines":"            if (error) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":98,"column":17},"end":{"line":100,"column":13}},"range":[2499,2547],"testsRan":[],"originalLines":"            else {\r\n                fileResolve();\r\n            }","mutatedLines":"            else {\n}"},{"sourceFilePath":"/stryker/src/TestFrameworkOrchestrator.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":40,"column":88},"end":{"line":42,"column":5}},"range":[2155,2271],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    TestFrameworkOrchestrator.prototype.testFrameworkExists = function (maybeFramework) {\r\n        return test_framework_1.TestFrameworkFactory.instance().knownNames().indexOf(maybeFramework) > -1;\r\n    };","mutatedLines":"    TestFrameworkOrchestrator.prototype.testFrameworkExists = function (maybeFramework) {\n};"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":105,"column":50},"end":{"line":114,"column":5}},"range":[2655,2862],"testsRan":[],"originalLines":"    return new Promise(function (resolve, reject) {\r\n        fs.rmdir(dirToDelete, function (error) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve();\r\n            }\r\n        });\r\n    });","mutatedLines":"    return new Promise(function (resolve, reject) {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":106,"column":47},"end":{"line":113,"column":9}},"range":[2705,2853],"testsRan":[],"originalLines":"        fs.rmdir(dirToDelete, function (error) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve();\r\n            }\r\n        });","mutatedLines":"        fs.rmdir(dirToDelete, function (error) {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":0,"replacement":"false","location":{"start":{"line":107,"column":16},"end":{"line":107,"column":21}},"range":[2724,2729],"testsRan":[],"originalLines":"            if (error) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":0,"replacement":"true","location":{"start":{"line":107,"column":16},"end":{"line":107,"column":21}},"range":[2724,2729],"testsRan":[],"originalLines":"            if (error) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":107,"column":23},"end":{"line":109,"column":13}},"range":[2731,2779],"testsRan":[],"originalLines":"            if (error) {\r\n                reject(error);\r\n            }","mutatedLines":"            if (error) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":110,"column":17},"end":{"line":112,"column":13}},"range":[2798,2842],"testsRan":[],"originalLines":"            else {\r\n                resolve();\r\n            }","mutatedLines":"            else {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":13,"column":38},"end":{"line":21,"column":1}},"range":[352,476],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"function fileOrFolderExistsSync(path) {\r\n    try {\r\n        fs.lstatSync(path);\r\n        return true;\r\n    }\r\n    catch (error) {\r\n        return false;\r\n    }\r\n}","mutatedLines":"function fileOrFolderExistsSync(path) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":120,"column":66},"end":{"line":140,"column":5}},"range":[3016,3856],"testsRan":[],"originalLines":"    return fileOrFolderExists(dirToDelete).then(function (exists) {\r\n        if (exists) {\r\n            return readdir(dirToDelete).then(function (files) {\r\n                var promisses = files.map(function (file) {\r\n                    var currentPath = path.join(dirToDelete, file);\r\n                    return stats(currentPath).then(function (stats) {\r\n                        if (stats.isDirectory()) {\r\n                            // recursive\r\n                            return deleteDir(currentPath);\r\n                        }\r\n                        else {\r\n                            // delete file\r\n                            return rmFile(currentPath);\r\n                        }\r\n                    });\r\n                });\r\n                // delete dir\r\n                return Promise.all(promisses).then(function () { return rmdir(dirToDelete); });\r\n            });\r\n        }\r\n    });","mutatedLines":"    return fileOrFolderExists(dirToDelete).then(function (exists) {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":0,"replacement":"false","location":{"start":{"line":121,"column":12},"end":{"line":121,"column":18}},"range":[3031,3037],"testsRan":[],"originalLines":"        if (exists) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":0,"replacement":"true","location":{"start":{"line":121,"column":12},"end":{"line":121,"column":18}},"range":[3031,3037],"testsRan":[],"originalLines":"        if (exists) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":121,"column":20},"end":{"line":139,"column":9}},"range":[3039,3849],"testsRan":[],"originalLines":"        if (exists) {\r\n            return readdir(dirToDelete).then(function (files) {\r\n                var promisses = files.map(function (file) {\r\n                    var currentPath = path.join(dirToDelete, file);\r\n                    return stats(currentPath).then(function (stats) {\r\n                        if (stats.isDirectory()) {\r\n                            // recursive\r\n                            return deleteDir(currentPath);\r\n                        }\r\n                        else {\r\n                            // delete file\r\n                            return rmFile(currentPath);\r\n                        }\r\n                    });\r\n                });\r\n                // delete dir\r\n                return Promise.all(promisses).then(function () { return rmdir(dirToDelete); });\r\n            });\r\n        }","mutatedLines":"        if (exists) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":122,"column":62},"end":{"line":138,"column":13}},"range":[3104,3836],"testsRan":[],"originalLines":"            return readdir(dirToDelete).then(function (files) {\r\n                var promisses = files.map(function (file) {\r\n                    var currentPath = path.join(dirToDelete, file);\r\n                    return stats(currentPath).then(function (stats) {\r\n                        if (stats.isDirectory()) {\r\n                            // recursive\r\n                            return deleteDir(currentPath);\r\n                        }\r\n                        else {\r\n                            // delete file\r\n                            return rmFile(currentPath);\r\n                        }\r\n                    });\r\n                });\r\n                // delete dir\r\n                return Promise.all(promisses).then(function () { return rmdir(dirToDelete); });\r\n            });","mutatedLines":"            return readdir(dirToDelete).then(function (files) {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":123,"column":58},"end":{"line":135,"column":17}},"range":[3165,3691],"testsRan":[],"originalLines":"                var promisses = files.map(function (file) {\r\n                    var currentPath = path.join(dirToDelete, file);\r\n                    return stats(currentPath).then(function (stats) {\r\n                        if (stats.isDirectory()) {\r\n                            // recursive\r\n                            return deleteDir(currentPath);\r\n                        }\r\n                        else {\r\n                            // delete file\r\n                            return rmFile(currentPath);\r\n                        }\r\n                    });\r\n                });","mutatedLines":"                var promisses = files.map(function (file) {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":125,"column":68},"end":{"line":134,"column":21}},"range":[3305,3670],"testsRan":[],"originalLines":"                    return stats(currentPath).then(function (stats) {\r\n                        if (stats.isDirectory()) {\r\n                            // recursive\r\n                            return deleteDir(currentPath);\r\n                        }\r\n                        else {\r\n                            // delete file\r\n                            return rmFile(currentPath);\r\n                        }\r\n                    });","mutatedLines":"                    return stats(currentPath).then(function (stats) {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":0,"replacement":"false","location":{"start":{"line":126,"column":28},"end":{"line":126,"column":47}},"range":[3336,3355],"testsRan":[],"originalLines":"                        if (stats.isDirectory()) {","mutatedLines":"                        if (false) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":0,"replacement":"true","location":{"start":{"line":126,"column":28},"end":{"line":126,"column":47}},"range":[3336,3355],"testsRan":[],"originalLines":"                        if (stats.isDirectory()) {","mutatedLines":"                        if (true) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":126,"column":49},"end":{"line":129,"column":25}},"range":[3357,3487],"testsRan":[],"originalLines":"                        if (stats.isDirectory()) {\r\n                            // recursive\r\n                            return deleteDir(currentPath);\r\n                        }","mutatedLines":"                        if (stats.isDirectory()) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":130,"column":29},"end":{"line":133,"column":25}},"range":[3518,3647],"testsRan":[],"originalLines":"                        else {\r\n                            // delete file\r\n                            return rmFile(currentPath);\r\n                        }","mutatedLines":"                        else {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":137,"column":63},"end":{"line":137,"column":93}},"range":[3789,3819],"testsRan":[],"originalLines":"                return Promise.all(promisses).then(function () { return rmdir(dirToDelete); });","mutatedLines":"                return Promise.all(promisses).then(function () {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":24,"column":34},"end":{"line":30,"column":1}},"range":[573,724],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"function fileOrFolderExists(path) {\r\n    return new Promise(function (resolve) {\r\n        fs.lstat(path, function (error, stats) {\r\n            resolve(!error);\r\n        });\r\n    });\r\n}","mutatedLines":"function fileOrFolderExists(path) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":145,"column":32},"end":{"line":153,"column":5}},"range":[4006,4241],"testsRan":[],"originalLines":"        .then(function (exists) {\r\n        if (exists) {\r\n            return deleteDir(folderName)\r\n                .then(function () { return mkdirRecursive(folderName); });\r\n        }\r\n        else {\r\n            return mkdirRecursive(folderName);\r\n        }\r\n    });","mutatedLines":"        .then(function (exists) {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":0,"replacement":"false","location":{"start":{"line":146,"column":12},"end":{"line":146,"column":18}},"range":[4021,4027],"testsRan":[],"originalLines":"        if (exists) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":0,"replacement":"true","location":{"start":{"line":146,"column":12},"end":{"line":146,"column":18}},"range":[4021,4027],"testsRan":[],"originalLines":"        if (exists) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":146,"column":20},"end":{"line":149,"column":9}},"range":[4029,4159],"testsRan":[],"originalLines":"        if (exists) {\r\n            return deleteDir(folderName)\r\n                .then(function () { return mkdirRecursive(folderName); });\r\n        }","mutatedLines":"        if (exists) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":148,"column":34},"end":{"line":148,"column":72}},"range":[4108,4146],"testsRan":[],"originalLines":"                .then(function () { return mkdirRecursive(folderName); });","mutatedLines":"                .then(function () {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":150,"column":13},"end":{"line":152,"column":9}},"range":[4174,4234],"testsRan":[],"originalLines":"        else {\r\n            return mkdirRecursive(folderName);\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":54,"column":26},"end":{"line":65,"column":1}},"range":[1354,1634],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"function glob(expression) {\r\n    return new Promise(function (resolve, reject) {\r\n        nodeGlob(expression, function (error, matches) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve(matches);\r\n            }\r\n        });\r\n    });\r\n}","mutatedLines":"function glob(expression) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":157,"column":50},"end":{"line":166,"column":5}},"range":[4375,4586],"testsRan":[],"originalLines":"    return new Promise(function (resolve, reject) {\r\n        fs.writeFile(fileName, content, function (err) {\r\n            if (err) {\r\n                reject(err);\r\n            }\r\n            else {\r\n                resolve();\r\n            }\r\n        });\r\n    });","mutatedLines":"    return new Promise(function (resolve, reject) {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":158,"column":55},"end":{"line":165,"column":9}},"range":[4433,4577],"testsRan":[],"originalLines":"        fs.writeFile(fileName, content, function (err) {\r\n            if (err) {\r\n                reject(err);\r\n            }\r\n            else {\r\n                resolve();\r\n            }\r\n        });","mutatedLines":"        fs.writeFile(fileName, content, function (err) {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":0,"replacement":"false","location":{"start":{"line":159,"column":16},"end":{"line":159,"column":19}},"range":[4452,4455],"testsRan":[],"originalLines":"            if (err) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":0,"replacement":"true","location":{"start":{"line":159,"column":16},"end":{"line":159,"column":19}},"range":[4452,4455],"testsRan":[],"originalLines":"            if (err) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":159,"column":21},"end":{"line":161,"column":13}},"range":[4457,4503],"testsRan":[],"originalLines":"            if (err) {\r\n                reject(err);\r\n            }","mutatedLines":"            if (err) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":162,"column":17},"end":{"line":164,"column":13}},"range":[4522,4566],"testsRan":[],"originalLines":"            else {\r\n                resolve();\r\n            }","mutatedLines":"            else {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":80,"column":21},"end":{"line":91,"column":1}},"range":[2004,2273],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"function stats(path) {\r\n    return new Promise(function (resolve, reject) {\r\n        fs.stat(path, function (error, stats) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve(stats);\r\n            }\r\n        });\r\n    });\r\n}","mutatedLines":"function stats(path) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":0,"replacement":"false","location":{"start":{"line":170,"column":8},"end":{"line":170,"column":43}},"range":[4672,4707],"testsRan":[],"originalLines":"    if (!fileOrFolderExistsSync(folderName)) {","mutatedLines":"    if (false) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"RemoveConditionals","status":0,"replacement":"true","location":{"start":{"line":170,"column":8},"end":{"line":170,"column":43}},"range":[4672,4707],"testsRan":[],"originalLines":"    if (!fileOrFolderExistsSync(folderName)) {","mutatedLines":"    if (true) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":170,"column":45},"end":{"line":172,"column":5}},"range":[4709,4751],"testsRan":[],"originalLines":"    if (!fileOrFolderExistsSync(folderName)) {\r\n        mkdirp.sync(folderName);\r\n    }","mutatedLines":"    if (!fileOrFolderExistsSync(folderName)) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":67,"column":23},"end":{"line":78,"column":1}},"range":[1681,1953],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"function readdir(path) {\r\n    return new Promise(function (resolve, reject) {\r\n        fs.readdir(path, function (error, files) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve(files);\r\n            }\r\n        });\r\n    });\r\n}","mutatedLines":"function readdir(path) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":92,"column":22},"end":{"line":103,"column":1}},"range":[2297,2572],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"function rmFile(path) {\r\n    return new Promise(function (fileResolve, fileReject) {\r\n        fs.unlink(path, function (error) {\r\n            if (error) {\r\n                fileReject(error);\r\n            }\r\n            else {\r\n                fileResolve();\r\n            }\r\n        });\r\n    });\r\n}","mutatedLines":"function rmFile(path) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":119,"column":32},"end":{"line":141,"column":1}},"range":[2947,3861],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"function deleteDir(dirToDelete) {\r\n    return fileOrFolderExists(dirToDelete).then(function (exists) {\r\n        if (exists) {\r\n            return readdir(dirToDelete).then(function (files) {\r\n                var promisses = files.map(function (file) {\r\n                    var currentPath = path.join(dirToDelete, file);\r\n                    return stats(currentPath).then(function (stats) {\r\n                        if (stats.isDirectory()) {\r\n                            // recursive\r\n                            return deleteDir(currentPath);\r\n                        }\r\n                        else {\r\n                            // delete file\r\n                            return rmFile(currentPath);\r\n                        }\r\n                    });\r\n                });\r\n                // delete dir\r\n                return Promise.all(promisses).then(function () { return rmdir(dirToDelete); });\r\n            });\r\n        }\r\n    });\r\n}","mutatedLines":"function deleteDir(dirToDelete) {\n}"},{"sourceFilePath":"/stryker/src/utils/objectUtils.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":7,"column":47},"end":{"line":11,"column":5}},"range":[287,391],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder"],"originalLines":"    Object.keys(target).forEach(function (key) {\r\n        if (_.isObject(target[key])) {\r\n            freezeRecursively(target[key]);\r\n        }\r\n    });","mutatedLines":"    Object.keys(target).forEach(function (key) {\n});"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":156,"column":38},"end":{"line":167,"column":1}},"range":[4322,4591],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"function writeFile(fileName, content) {\r\n    return new Promise(function (resolve, reject) {\r\n        fs.writeFile(fileName, content, function (err) {\r\n            if (err) {\r\n                reject(err);\r\n            }\r\n            else {\r\n                resolve();\r\n            }\r\n        });\r\n    });\r\n}","mutatedLines":"function writeFile(fileName, content) {\n}"},{"sourceFilePath":"/stryker/src/utils/objectUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":8,"column":12},"end":{"line":8,"column":35}},"range":[302,325],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated"],"originalLines":"        if (_.isObject(target[key])) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":143,"column":33},"end":{"line":154,"column":1}},"range":[3928,4246],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"function cleanFolder(folderName) {\r\n    return fileOrFolderExists(folderName)\r\n        .then(function (exists) {\r\n        if (exists) {\r\n            return deleteDir(folderName)\r\n                .then(function () { return mkdirRecursive(folderName); });\r\n        }\r\n        else {\r\n            return mkdirRecursive(folderName);\r\n        }\r\n    });\r\n}","mutatedLines":"function cleanFolder(folderName) {\n}"},{"sourceFilePath":"/stryker/src/utils/objectUtils.js","mutatorName":"RemoveConditionals","status":2,"replacement":"false","location":{"start":{"line":8,"column":12},"end":{"line":8,"column":35}},"range":[302,325],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder"],"originalLines":"        if (_.isObject(target[key])) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/utils/objectUtils.js","mutatorName":"BinaryOperator","status":1,"replacement":"typeof input['then'] !== 'function'","location":{"start":{"line":15,"column":20},"end":{"line":15,"column":55}},"range":[495,530],"testsRan":["BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises \"before each\" hook for \"should forward a combined promise\""],"originalLines":"    return input && typeof input['then'] === 'function';","mutatedLines":"    return input && typeof input['then'] !== 'function';"},{"sourceFilePath":"/stryker/src/utils/objectUtils.js","mutatorName":"LogicalOperator","status":1,"replacement":"input || typeof input['then'] === 'function'","location":{"start":{"line":15,"column":11},"end":{"line":15,"column":55}},"range":[486,530],"testsRan":["BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants \"before each\" hook for \"should log to have quite early\""],"originalLines":"    return input && typeof input['then'] === 'function';","mutatedLines":"    return input || typeof input['then'] === 'function';"},{"sourceFilePath":"/stryker/src/utils/objectUtils.js","mutatorName":"BinaryOperator","status":0,"replacement":"'(' + serializedJavascript - ')'","location":{"start":{"line":21,"column":16},"end":{"line":21,"column":48}},"range":[734,766],"testsRan":[],"originalLines":"    return eval(\"(\" + serializedJavascript + \")\");","mutatedLines":"    return eval('(' + serializedJavascript - ')');"},{"sourceFilePath":"/stryker/src/utils/objectUtils.js","mutatorName":"BinaryOperator","status":0,"replacement":"'(' - serializedJavascript","location":{"start":{"line":21,"column":16},"end":{"line":21,"column":42}},"range":[734,760],"testsRan":[],"originalLines":"    return eval(\"(\" + serializedJavascript + \")\");","mutatedLines":"    return eval('(' - serializedJavascript + \")\");"},{"sourceFilePath":"/stryker/src/utils/objectUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":5,"column":35},"end":{"line":12,"column":1}},"range":[209,396],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config"],"originalLines":"function freezeRecursively(target) {\r\n    Object.freeze(target);\r\n    Object.keys(target).forEach(function (key) {\r\n        if (_.isObject(target[key])) {\r\n            freezeRecursively(target[key]);\r\n        }\r\n    });\r\n}","mutatedLines":"function freezeRecursively(target) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":169,"column":36},"end":{"line":173,"column":1}},"range":[4661,4754],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"function mkdirRecursive(folderName) {\r\n    if (!fileOrFolderExistsSync(folderName)) {\r\n        mkdirp.sync(folderName);\r\n    }\r\n}","mutatedLines":"function mkdirRecursive(folderName) {\n}"},{"sourceFilePath":"/stryker/src/utils/objectUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":14,"column":26},"end":{"line":16,"column":1}},"range":[472,534],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises \"before each\" hook for \"should forward a combined promise\""],"originalLines":"function isPromise(input) {\r\n    return input && typeof input['then'] === 'function';\r\n}","mutatedLines":"function isPromise(input) {\n}"},{"sourceFilePath":"/stryker/src/utils/objectUtils.js","mutatorName":"RemoveConditionals","status":2,"replacement":"false","location":{"start":{"line":26,"column":8},"end":{"line":26,"column":12}},"range":[867,871],"testsRan":["MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","BlockStatementMutator should mutate when supplied a block statement"],"originalLines":"    if (deep) {","mutatedLines":"    if (false) {"},{"sourceFilePath":"/stryker/src/utils/objectUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":29,"column":9},"end":{"line":31,"column":5}},"range":[926,964],"testsRan":["MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation \"before each\" hook for \"should be able to mutate code\""],"originalLines":"    else {\r\n        return _.clone(obj);\r\n    }","mutatedLines":"    else {\n}"},{"sourceFilePath":"/stryker/src/utils/objectUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":25,"column":25},"end":{"line":32,"column":1}},"range":[856,967],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation \"before each\" hook for \"should return an array with a single mutant\""],"originalLines":"function copy(obj, deep) {\r\n    if (deep) {\r\n        return _.cloneDeep(obj);\r\n    }\r\n    else {\r\n        return _.clone(obj);\r\n    }\r\n}","mutatedLines":"function copy(obj, deep) {\n}"},{"sourceFilePath":"/stryker/src/utils/objectUtils.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":26,"column":14},"end":{"line":28,"column":5}},"range":[873,915],"testsRan":["MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","BlockStatementMutator should mutate when supplied a block statement"],"originalLines":"    if (deep) {\r\n        return _.cloneDeep(obj);\r\n    }","mutatedLines":"    if (deep) {\n}"},{"sourceFilePath":"/stryker/src/utils/objectUtils.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":26,"column":8},"end":{"line":26,"column":12}},"range":[867,871],"testsRan":["MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","BlockStatementMutator should mutate when supplied a block statement"],"originalLines":"    if (deep) {","mutatedLines":"    if (true) {"},{"sourceFilePath":"/stryker/src/utils/objectUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":34,"column":37},"end":{"line":36,"column":1}},"range":[1028,1140],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks"],"originalLines":"function wrapInClosure(codeFragment) {\r\n    return \"\\n    (function (window) {\\n      \" + codeFragment + \"\\n    })((Function('return this'))());\";\r\n}","mutatedLines":"function wrapInClosure(codeFragment) {\n}"},{"sourceFilePath":"/stryker/src/utils/objectUtils.js","mutatorName":"BinaryOperator","status":1,"replacement":"'\\n    (function (window) {\\n      ' - codeFragment","location":{"start":{"line":35,"column":11},"end":{"line":35,"column":62}},"range":[1042,1093],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks"],"originalLines":"    return \"\\n    (function (window) {\\n      \" + codeFragment + \"\\n    })((Function('return this'))());\";","mutatedLines":"    return '\\n    (function (window) {\\n      ' - codeFragment + \"\\n    })((Function('return this'))());\";"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":178,"column":34},"end":{"line":180,"column":1}},"range":[4902,4932],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"function importModule(moduleName) {\r\n    require(moduleName);\r\n}","mutatedLines":"function importModule(moduleName) {\n}"},{"sourceFilePath":"/stryker/src/utils/objectUtils.js","mutatorName":"BinaryOperator","status":1,"replacement":"'\\n    (function (window) {\\n      ' + codeFragment - '\\n    })((Function(\\'return this\\'))());'","location":{"start":{"line":35,"column":11},"end":{"line":35,"column":105}},"range":[1042,1136],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks"],"originalLines":"    return \"\\n    (function (window) {\\n      \" + codeFragment + \"\\n    })((Function('return this'))());\";","mutatedLines":"    return '\\n    (function (window) {\\n      ' + codeFragment - '\\n    })((Function(\\'return this\\'))());';"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"BinaryOperator","status":1,"replacement":"code !== undefined","location":{"start":{"line":22,"column":8},"end":{"line":22,"column":26}},"range":[514,532],"testsRan":["Mutant \"before each\" hook for \"the filename\""],"originalLines":"    if (code === undefined) {","mutatedLines":"    if (code !== undefined) {"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":22,"column":8},"end":{"line":22,"column":26}},"range":[514,532],"testsRan":["Mutant \"before each\" hook for \"the filename\""],"originalLines":"    if (code === undefined) {","mutatedLines":"    if (true) {"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"LogicalOperator","status":1,"replacement":"nodes && []","location":{"start":{"line":37,"column":12},"end":{"line":37,"column":23}},"range":[1040,1051],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated"],"originalLines":"    nodes = nodes || [];","mutatedLines":"    nodes = nodes && [];"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":22,"column":8},"end":{"line":22,"column":26}},"range":[514,532],"testsRan":["Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"    if (code === undefined) {","mutatedLines":"    if (false) {"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":22,"column":28},"end":{"line":24,"column":5}},"range":[534,606],"testsRan":["Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"    if (code === undefined) {\r\n        throw new Error('Code parameter cannot be undefined');\r\n    }","mutatedLines":"    if (code === undefined) {\n}"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":21,"column":21},"end":{"line":27,"column":1}},"range":[503,708],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant \"before each\" hook for \"the filename\""],"originalLines":"function parse(code) {\r\n    if (code === undefined) {\r\n        throw new Error('Code parameter cannot be undefined');\r\n    }\r\n    var abstractSyntaxTree = esprima.parse(code, esprimaOptions);\r\n    return abstractSyntaxTree;\r\n}","mutatedLines":"function parse(code) {\n}"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":38,"column":8},"end":{"line":38,"column":143}},"range":[1062,1197],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code"],"originalLines":"    if (!_.isArray(abstractSyntaxTree) && _.isObject(abstractSyntaxTree) && abstractSyntaxTree.type && _.isUndefined(abstractSyntaxTree.nodeID)) {","mutatedLines":"    if (false) {"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":38,"column":8},"end":{"line":38,"column":143}},"range":[1062,1197],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","parserUtils collectFrozenNodes when provided a try catch block"],"originalLines":"    if (!_.isArray(abstractSyntaxTree) && _.isObject(abstractSyntaxTree) && abstractSyntaxTree.type && _.isUndefined(abstractSyntaxTree.nodeID)) {","mutatedLines":"    if (true) {"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":36,"column":55},"end":{"line":56,"column":1}},"range":[1025,1869],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated"],"originalLines":"function collectFrozenNodes(abstractSyntaxTree, nodes) {\r\n    nodes = nodes || [];\r\n    if (!_.isArray(abstractSyntaxTree) && _.isObject(abstractSyntaxTree) && abstractSyntaxTree.type && _.isUndefined(abstractSyntaxTree.nodeID)) {\r\n        abstractSyntaxTree.nodeID = nodes.length;\r\n        nodes.push(abstractSyntaxTree);\r\n    }\r\n    Object.freeze(abstractSyntaxTree);\r\n    _.forOwn(abstractSyntaxTree, function (childNode, i) {\r\n        if (childNode instanceof Object && !(childNode instanceof Array)) {\r\n            collectFrozenNodes(childNode, nodes);\r\n        }\r\n        else if (childNode instanceof Array) {\r\n            _.forEach(childNode, function (arrayChild) {\r\n                if (arrayChild instanceof Object && !(arrayChild instanceof Array)) {\r\n                    collectFrozenNodes(arrayChild, nodes);\r\n                }\r\n            });\r\n        }\r\n    });\r\n    return nodes;\r\n}","mutatedLines":"function collectFrozenNodes(abstractSyntaxTree, nodes) {\n}"},{"sourceFilePath":"/stryker/src/utils/objectUtils.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":8,"column":37},"end":{"line":10,"column":9}},"range":[327,384],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder"],"originalLines":"        if (_.isObject(target[key])) {\r\n            freezeRecursively(target[key]);\r\n        }","mutatedLines":"        if (_.isObject(target[key])) {\n}"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"LogicalOperator","status":1,"replacement":"!_.isArray(abstractSyntaxTree) && _.isObject(abstractSyntaxTree) && abstractSyntaxTree.type || _.isUndefined(abstractSyntaxTree.nodeID)","location":{"start":{"line":38,"column":8},"end":{"line":38,"column":143}},"range":[1062,1197],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","parserUtils collectFrozenNodes when provided a try catch block"],"originalLines":"    if (!_.isArray(abstractSyntaxTree) && _.isObject(abstractSyntaxTree) && abstractSyntaxTree.type && _.isUndefined(abstractSyntaxTree.nodeID)) {","mutatedLines":"    if (!_.isArray(abstractSyntaxTree) && _.isObject(abstractSyntaxTree) && abstractSyntaxTree.type || _.isUndefined(abstractSyntaxTree.nodeID)) {"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":38,"column":145},"end":{"line":41,"column":5}},"range":[1199,1299],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code"],"originalLines":"    if (!_.isArray(abstractSyntaxTree) && _.isObject(abstractSyntaxTree) && abstractSyntaxTree.type && _.isUndefined(abstractSyntaxTree.nodeID)) {\r\n        abstractSyntaxTree.nodeID = nodes.length;\r\n        nodes.push(abstractSyntaxTree);\r\n    }","mutatedLines":"    if (!_.isArray(abstractSyntaxTree) && _.isObject(abstractSyntaxTree) && abstractSyntaxTree.type && _.isUndefined(abstractSyntaxTree.nodeID)) {\n}"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"LogicalOperator","status":1,"replacement":"!_.isArray(abstractSyntaxTree) && _.isObject(abstractSyntaxTree) || abstractSyntaxTree.type","location":{"start":{"line":38,"column":8},"end":{"line":38,"column":99}},"range":[1062,1153],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","parserUtils collectFrozenNodes when provided a try catch block"],"originalLines":"    if (!_.isArray(abstractSyntaxTree) && _.isObject(abstractSyntaxTree) && abstractSyntaxTree.type && _.isUndefined(abstractSyntaxTree.nodeID)) {","mutatedLines":"    if (!_.isArray(abstractSyntaxTree) && _.isObject(abstractSyntaxTree) || abstractSyntaxTree.type && _.isUndefined(abstractSyntaxTree.nodeID)) {"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":43,"column":57},"end":{"line":54,"column":5}},"range":[1398,1845],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code"],"originalLines":"    _.forOwn(abstractSyntaxTree, function (childNode, i) {\r\n        if (childNode instanceof Object && !(childNode instanceof Array)) {\r\n            collectFrozenNodes(childNode, nodes);\r\n        }\r\n        else if (childNode instanceof Array) {\r\n            _.forEach(childNode, function (arrayChild) {\r\n                if (arrayChild instanceof Object && !(arrayChild instanceof Array)) {\r\n                    collectFrozenNodes(arrayChild, nodes);\r\n                }\r\n            });\r\n        }\r\n    });","mutatedLines":"    _.forOwn(abstractSyntaxTree, function (childNode, i) {\n});"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"LogicalOperator","status":1,"replacement":"!_.isArray(abstractSyntaxTree) || _.isObject(abstractSyntaxTree)","location":{"start":{"line":38,"column":8},"end":{"line":38,"column":72}},"range":[1062,1126],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","parserUtils collectFrozenNodes when provided a try catch block"],"originalLines":"    if (!_.isArray(abstractSyntaxTree) && _.isObject(abstractSyntaxTree) && abstractSyntaxTree.type && _.isUndefined(abstractSyntaxTree.nodeID)) {","mutatedLines":"    if (!_.isArray(abstractSyntaxTree) || _.isObject(abstractSyntaxTree) && abstractSyntaxTree.type && _.isUndefined(abstractSyntaxTree.nodeID)) {"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":44,"column":12},"end":{"line":44,"column":72}},"range":[1413,1473],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code"],"originalLines":"        if (childNode instanceof Object && !(childNode instanceof Array)) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":44,"column":74},"end":{"line":46,"column":9}},"range":[1475,1538],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code"],"originalLines":"        if (childNode instanceof Object && !(childNode instanceof Array)) {\r\n            collectFrozenNodes(childNode, nodes);\r\n        }","mutatedLines":"        if (childNode instanceof Object && !(childNode instanceof Array)) {\n}"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":44,"column":12},"end":{"line":44,"column":72}},"range":[1413,1473],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated"],"originalLines":"        if (childNode instanceof Object && !(childNode instanceof Array)) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"LogicalOperator","status":1,"replacement":"childNode instanceof Object || !(childNode instanceof Array)","location":{"start":{"line":44,"column":12},"end":{"line":44,"column":72}},"range":[1413,1473],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated"],"originalLines":"        if (childNode instanceof Object && !(childNode instanceof Array)) {","mutatedLines":"        if (childNode instanceof Object || !(childNode instanceof Array)) {"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":47,"column":17},"end":{"line":47,"column":43}},"range":[1557,1583],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code"],"originalLines":"        else if (childNode instanceof Array) {","mutatedLines":"        else if (false) {"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":47,"column":45},"end":{"line":53,"column":9}},"range":[1585,1838],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code"],"originalLines":"        else if (childNode instanceof Array) {\r\n            _.forEach(childNode, function (arrayChild) {\r\n                if (arrayChild instanceof Object && !(arrayChild instanceof Array)) {\r\n                    collectFrozenNodes(arrayChild, nodes);\r\n                }\r\n            });\r\n        }","mutatedLines":"        else if (childNode instanceof Array) {\n}"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":48,"column":55},"end":{"line":52,"column":13}},"range":[1643,1825],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code"],"originalLines":"            _.forEach(childNode, function (arrayChild) {\r\n                if (arrayChild instanceof Object && !(arrayChild instanceof Array)) {\r\n                    collectFrozenNodes(arrayChild, nodes);\r\n                }\r\n            });","mutatedLines":"            _.forEach(childNode, function (arrayChild) {\n});"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":49,"column":20},"end":{"line":49,"column":82}},"range":[1666,1728],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code"],"originalLines":"                if (arrayChild instanceof Object && !(arrayChild instanceof Array)) {","mutatedLines":"                if (false) {"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":49,"column":20},"end":{"line":49,"column":82}},"range":[1666,1728],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","parserUtils collectFrozenNodes when provided a try catch block"],"originalLines":"                if (arrayChild instanceof Object && !(arrayChild instanceof Array)) {","mutatedLines":"                if (true) {"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BinaryOperator","status":0,"replacement":"tempFolder + path.sep + prefix - random()","location":{"start":{"line":18,"column":30},"end":{"line":18,"column":71}},"range":[623,664],"testsRan":[],"originalLines":"    return ensureFolderExists(tempFolder + path.sep + prefix + random());","mutatedLines":"    return ensureFolderExists(tempFolder + path.sep + prefix - random());"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BinaryOperator","status":0,"replacement":"tempFolder + path.sep - prefix","location":{"start":{"line":18,"column":30},"end":{"line":18,"column":60}},"range":[623,653],"testsRan":[],"originalLines":"    return ensureFolderExists(tempFolder + path.sep + prefix + random());","mutatedLines":"    return ensureFolderExists(tempFolder + path.sep - prefix + random());"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BinaryOperator","status":0,"replacement":"tempFolder - path.sep","location":{"start":{"line":18,"column":30},"end":{"line":18,"column":51}},"range":[623,644],"testsRan":[],"originalLines":"    return ensureFolderExists(tempFolder + path.sep + prefix + random());","mutatedLines":"    return ensureFolderExists(tempFolder - path.sep + prefix + random());"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":49,"column":84},"end":{"line":51,"column":17}},"range":[1730,1810],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code"],"originalLines":"                if (arrayChild instanceof Object && !(arrayChild instanceof Array)) {\r\n                    collectFrozenNodes(arrayChild, nodes);\r\n                }","mutatedLines":"                if (arrayChild instanceof Object && !(arrayChild instanceof Array)) {\n}"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"LogicalOperator","status":2,"replacement":"arrayChild instanceof Object || !(arrayChild instanceof Array)","location":{"start":{"line":49,"column":20},"end":{"line":49,"column":82}},"range":[1666,1728],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","parserUtils collectFrozenNodes when provided a try catch block"],"originalLines":"                if (arrayChild instanceof Object && !(arrayChild instanceof Array)) {","mutatedLines":"                if (arrayChild instanceof Object || !(arrayChild instanceof Array)) {"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":24,"column":18},"end":{"line":26,"column":1}},"range":[767,820],"testsRan":[],"originalLines":"function random() {\r\n    return Math.ceil(Math.random() * 10000000);\r\n}","mutatedLines":"function random() {\n}"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":47,"column":17},"end":{"line":47,"column":43}},"range":[1557,1583],"testsRan":["MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","parserUtils collectFrozenNodes when provided a try catch block"],"originalLines":"        else if (childNode instanceof Array) {","mutatedLines":"        else if (true) {"},{"sourceFilePath":"/stryker/src/utils/parserUtils.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":64,"column":24},"end":{"line":66,"column":1}},"range":[2094,2136],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code"],"originalLines":"function generate(node) {\r\n    return escodegen.generate(node);\r\n}","mutatedLines":"function generate(node) {\n}"},{"sourceFilePath":"/stryker/src/utils/fileUtils.js","mutatorName":"BlockStatement","status":3,"replacement":"{\n}","location":{"start":{"line":104,"column":28},"end":{"line":115,"column":1}},"range":[2602,2867],"testsRan":[],"originalLines":"function rmdir(dirToDelete) {\r\n    return new Promise(function (resolve, reject) {\r\n        fs.rmdir(dirToDelete, function (error) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve();\r\n            }\r\n        });\r\n    });\r\n}","mutatedLines":"function rmdir(dirToDelete) {\n}"},{"sourceFilePath":"/stryker/src/utils/objectUtils.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":18,"column":43},"end":{"line":23,"column":1}},"range":[611,793],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"function deserialize(serializedJavascript) {\r\n    // Don't use JSON.parse, as it does not allow for regexes or functions, etc\r\n    // tslint:disable\r\n    return eval(\"(\" + serializedJavascript + \")\");\r\n    // tslint:enable\r\n}","mutatedLines":"function deserialize(serializedJavascript) {\n}"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"RemoveConditionals","status":2,"replacement":"true","location":{"start":{"line":33,"column":8},"end":{"line":33,"column":33}},"range":[1021,1046],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    if (!fileOrFolderExists(path)) {","mutatedLines":"    if (true) {"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":17,"column":36},"end":{"line":19,"column":1}},"range":[590,669],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"function createRandomFolder(prefix) {\r\n    return ensureFolderExists(tempFolder + path.sep + prefix + random());\r\n}","mutatedLines":"function createRandomFolder(prefix) {\n}"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"RemoveConditionals","status":2,"replacement":"false","location":{"start":{"line":33,"column":8},"end":{"line":33,"column":33}},"range":[1021,1046],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    if (!fileOrFolderExists(path)) {","mutatedLines":"    if (false) {"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":59,"column":50},"end":{"line":68,"column":5}},"range":[1672,1908],"testsRan":[],"originalLines":"    return new Promise(function (resolve, reject) {\r\n        fs.writeFile(filename, data, { encoding: 'utf8' }, function (error) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve();\r\n            }\r\n        });\r\n    });","mutatedLines":"    return new Promise(function (resolve, reject) {\n});"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":60,"column":76},"end":{"line":67,"column":9}},"range":[1751,1899],"testsRan":[],"originalLines":"        fs.writeFile(filename, data, { encoding: 'utf8' }, function (error) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve();\r\n            }\r\n        });","mutatedLines":"        fs.writeFile(filename, data, { encoding: 'utf8' }, function (error) {\n});"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"RemoveConditionals","status":0,"replacement":"false","location":{"start":{"line":61,"column":16},"end":{"line":61,"column":21}},"range":[1770,1775],"testsRan":[],"originalLines":"            if (error) {","mutatedLines":"            if (false) {"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"RemoveConditionals","status":0,"replacement":"true","location":{"start":{"line":61,"column":16},"end":{"line":61,"column":21}},"range":[1770,1775],"testsRan":[],"originalLines":"            if (error) {","mutatedLines":"            if (true) {"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":61,"column":23},"end":{"line":63,"column":13}},"range":[1777,1825],"testsRan":[],"originalLines":"            if (error) {\r\n                reject(error);\r\n            }","mutatedLines":"            if (error) {\n}"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":64,"column":17},"end":{"line":66,"column":13}},"range":[1844,1888],"testsRan":[],"originalLines":"            else {\r\n                resolve();\r\n            }","mutatedLines":"            else {\n}"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":33,"column":35},"end":{"line":35,"column":5}},"range":[1048,1084],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    if (!fileOrFolderExists(path)) {\r\n        mkdirp.sync(path);\r\n    }","mutatedLines":"    if (!fileOrFolderExists(path)) {\n}"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":78,"column":50},"end":{"line":88,"column":5}},"range":[2300,2759],"testsRan":[],"originalLines":"    return new Promise(function (resolve, reject) {\r\n        var readStream = fs.createReadStream(fromFilename, { encoding: 'utf8' });\r\n        var writeStream = fs.createWriteStream(toFilename, { encoding: 'utf8' });\r\n        readStream.on('error', reject);\r\n        writeStream.on('error', reject);\r\n        if (instrumenter) {\r\n            readStream = readStream.pipe(instrumenter);\r\n        }\r\n        readStream.pipe(writeStream);\r\n        readStream.on('end', function () { return resolve(); });\r\n    });","mutatedLines":"    return new Promise(function (resolve, reject) {\n});"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"RemoveConditionals","status":0,"replacement":"false","location":{"start":{"line":83,"column":12},"end":{"line":83,"column":24}},"range":[2564,2576],"testsRan":[],"originalLines":"        if (instrumenter) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"RemoveConditionals","status":0,"replacement":"true","location":{"start":{"line":83,"column":12},"end":{"line":83,"column":24}},"range":[2564,2576],"testsRan":[],"originalLines":"        if (instrumenter) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":83,"column":26},"end":{"line":85,"column":9}},"range":[2578,2647],"testsRan":[],"originalLines":"        if (instrumenter) {\r\n            readStream = readStream.pipe(instrumenter);\r\n        }","mutatedLines":"        if (instrumenter) {\n}"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BlockStatement","status":0,"replacement":"{\n}","location":{"start":{"line":87,"column":41},"end":{"line":87,"column":62}},"range":[2729,2750],"testsRan":[],"originalLines":"        readStream.on('end', function () { return resolve(); });","mutatedLines":"        readStream.on('end', function () {\n});"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BinaryOperator","status":2,"replacement":"Math.random() / 10000000","location":{"start":{"line":25,"column":21},"end":{"line":25,"column":45}},"range":[791,815],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    return Math.ceil(Math.random() * 10000000);","mutatedLines":"    return Math.ceil(Math.random() / 10000000);"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BinaryOperator","status":0,"replacement":"'Cleaning stryker temp folder ' - baseTempFolder","location":{"start":{"line":94,"column":14},"end":{"line":94,"column":62}},"range":[2846,2894],"testsRan":[],"originalLines":"    log.debug(\"Cleaning stryker temp folder \" + baseTempFolder);","mutatedLines":"    log.debug('Cleaning stryker temp folder ' - baseTempFolder);"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":32,"column":34},"end":{"line":37,"column":1}},"range":[1010,1105],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"function ensureFolderExists(path) {\r\n    if (!fileOrFolderExists(path)) {\r\n        mkdirp.sync(path);\r\n    }\r\n    return path;\r\n}","mutatedLines":"function ensureFolderExists(path) {\n}"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":44,"column":8},"end":{"line":47,"column":5}},"range":[1287,1346],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    try {\r\n        fs.lstatSync(path);\r\n        return true;\r\n    }","mutatedLines":"    try {\n}"},{"sourceFilePath":"/stryker/src/utils/Timer.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":2,"column":25},"end":{"line":36,"column":1}},"range":[40,1192],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework \"before each\" hook for \"should exit the process\""],"originalLines":"var Timer = (function () {\r\n    function Timer() {\r\n        this.reset();\r\n    }\r\n    Timer.prototype.reset = function () {\r\n        this.start = new Date();\r\n    };\r\n    Timer.prototype.humanReadableElapsed = function () {\r\n        var elapsedMs = new Date().getTime() - this.start.getTime();\r\n        var elapsedSeconds = Math.floor(elapsedMs / 1000);\r\n        return Timer.humanReadableElapsedMinutes(elapsedSeconds) + Timer.humanReadableElapsedSeconds(elapsedSeconds);\r\n    };\r\n    Timer.humanReadableElapsedSeconds = function (elapsedSeconds) {\r\n        var restSeconds = elapsedSeconds % 60;\r\n        if (restSeconds === 1) {\r\n            return restSeconds + \" second\";\r\n        }\r\n        else {\r\n            return restSeconds + \" seconds\";\r\n        }\r\n    };\r\n    Timer.humanReadableElapsedMinutes = function (elapsedSeconds) {\r\n        var elapsedMinutes = Math.floor(elapsedSeconds / 60);\r\n        if (elapsedMinutes > 1) {\r\n            return elapsedMinutes + \" minutes \";\r\n        }\r\n        else if (elapsedMinutes > 0) {\r\n            return elapsedMinutes + \" minute \";\r\n        }\r\n        else {\r\n            return '';\r\n        }\r\n    };\r\n    return Timer;\r\n}());","mutatedLines":"var Timer = (function () {\n}());"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":58,"column":35},"end":{"line":69,"column":1}},"range":[1619,1913],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"function writeFile(filename, data) {\r\n    return new Promise(function (resolve, reject) {\r\n        fs.writeFile(filename, data, { encoding: 'utf8' }, function (error) {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve();\r\n            }\r\n        });\r\n    });\r\n}","mutatedLines":"function writeFile(filename, data) {\n}"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":48,"column":18},"end":{"line":50,"column":5}},"range":[1366,1397],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"    catch (error) {\r\n        return false;\r\n    }","mutatedLines":"    catch (error) {\n}"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":77,"column":58},"end":{"line":89,"column":1}},"range":[2247,2764],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"function copyFile(fromFilename, toFilename, instrumenter) {\r\n    return new Promise(function (resolve, reject) {\r\n        var readStream = fs.createReadStream(fromFilename, { encoding: 'utf8' });\r\n        var writeStream = fs.createWriteStream(toFilename, { encoding: 'utf8' });\r\n        readStream.on('error', reject);\r\n        writeStream.on('error', reject);\r\n        if (instrumenter) {\r\n            readStream = readStream.pipe(instrumenter);\r\n        }\r\n        readStream.pipe(writeStream);\r\n        readStream.on('end', function () { return resolve(); });\r\n    });\r\n}","mutatedLines":"function copyFile(fromFilename, toFilename, instrumenter) {\n}"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":93,"column":17},"end":{"line":96,"column":1}},"range":[2829,2948],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"function clean() {\r\n    log.debug(\"Cleaning stryker temp folder \" + baseTempFolder);\r\n    return fileUtils.deleteDir(baseTempFolder);\r\n}","mutatedLines":"function clean() {\n}"},{"sourceFilePath":"/stryker/src/utils/Timer.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":3,"column":21},"end":{"line":5,"column":5}},"range":[64,95],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()"],"originalLines":"    function Timer() {\r\n        this.reset();\r\n    }","mutatedLines":"    function Timer() {\n}"},{"sourceFilePath":"/stryker/src/utils/Timer.js","mutatorName":"BinaryOperator","status":1,"replacement":"elapsedMs * 1000","location":{"start":{"line":11,"column":40},"end":{"line":11,"column":56}},"range":[350,366],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()"],"originalLines":"        var elapsedSeconds = Math.floor(elapsedMs / 1000);","mutatedLines":"        var elapsedSeconds = Math.floor(elapsedMs * 1000);"},{"sourceFilePath":"/stryker/src/utils/Timer.js","mutatorName":"BinaryOperator","status":2,"replacement":"new Date().getTime() + this.start.getTime()","location":{"start":{"line":10,"column":24},"end":{"line":10,"column":67}},"range":[264,307],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"        var elapsedMs = new Date().getTime() - this.start.getTime();","mutatedLines":"        var elapsedMs = new Date().getTime() + this.start.getTime();"},{"sourceFilePath":"/stryker/src/utils/Timer.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":6,"column":40},"end":{"line":8,"column":5}},"range":[137,179],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants \"before each\" hook for \"should log to have quite early\""],"originalLines":"    Timer.prototype.reset = function () {\r\n        this.start = new Date();\r\n    };","mutatedLines":"    Timer.prototype.reset = function () {\n};"},{"sourceFilePath":"/stryker/src/utils/Timer.js","mutatorName":"BinaryOperator","status":1,"replacement":"Timer.humanReadableElapsedMinutes(elapsedSeconds) - Timer.humanReadableElapsedSeconds(elapsedSeconds)","location":{"start":{"line":12,"column":15},"end":{"line":12,"column":116}},"range":[385,486],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()"],"originalLines":"        return Timer.humanReadableElapsedMinutes(elapsedSeconds) + Timer.humanReadableElapsedSeconds(elapsedSeconds);","mutatedLines":"        return Timer.humanReadableElapsedMinutes(elapsedSeconds) - Timer.humanReadableElapsedSeconds(elapsedSeconds);"},{"sourceFilePath":"/stryker/src/utils/Timer.js","mutatorName":"BinaryOperator","status":1,"replacement":"elapsedSeconds * 60","location":{"start":{"line":15,"column":26},"end":{"line":15,"column":45}},"range":[592,611],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()"],"originalLines":"        var restSeconds = elapsedSeconds % 60;","mutatedLines":"        var restSeconds = elapsedSeconds * 60;"},{"sourceFilePath":"/stryker/src/utils/Timer.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":16,"column":12},"end":{"line":16,"column":29}},"range":[626,643],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()"],"originalLines":"        if (restSeconds === 1) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/utils/Timer.js","mutatorName":"BinaryOperator","status":1,"replacement":"restSeconds - ' second'","location":{"start":{"line":17,"column":19},"end":{"line":17,"column":42}},"range":[667,690],"testsRan":["Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()"],"originalLines":"            return restSeconds + \" second\";","mutatedLines":"            return restSeconds - ' second';"},{"sourceFilePath":"/stryker/src/utils/Timer.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":16,"column":12},"end":{"line":16,"column":29}},"range":[626,643],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()"],"originalLines":"        if (restSeconds === 1) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/utils/Timer.js","mutatorName":"BinaryOperator","status":1,"replacement":"restSeconds !== 1","location":{"start":{"line":16,"column":12},"end":{"line":16,"column":29}},"range":[626,643],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()"],"originalLines":"        if (restSeconds === 1) {","mutatedLines":"        if (restSeconds !== 1) {"},{"sourceFilePath":"/stryker/src/utils/Timer.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":16,"column":31},"end":{"line":18,"column":9}},"range":[645,702],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()"],"originalLines":"        if (restSeconds === 1) {\r\n            return restSeconds + \" second\";\r\n        }","mutatedLines":"        if (restSeconds === 1) {\n}"},{"sourceFilePath":"/stryker/src/utils/StrykerTempFolder.js","mutatorName":"BlockStatement","status":2,"replacement":"{\n}","location":{"start":{"line":43,"column":34},"end":{"line":51,"column":1}},"range":[1276,1400],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()","Timer after 2 minutes 1 second should show \"2 minutes 1 second\" when humanReadableElapsed()","Timer after 1 minute 1 second should show \"1 minute 1 second\" when humanReadableElapsed()"],"originalLines":"function fileOrFolderExists(path) {\r\n    try {\r\n        fs.lstatSync(path);\r\n        return true;\r\n    }\r\n    catch (error) {\r\n        return false;\r\n    }\r\n}","mutatedLines":"function fileOrFolderExists(path) {\n}"},{"sourceFilePath":"/stryker/src/utils/Timer.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":19,"column":13},"end":{"line":21,"column":9}},"range":[717,775],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()"],"originalLines":"        else {\r\n            return restSeconds + \" seconds\";\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/utils/Timer.js","mutatorName":"BinaryOperator","status":1,"replacement":"restSeconds - ' seconds'","location":{"start":{"line":20,"column":19},"end":{"line":20,"column":43}},"range":[739,763],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()"],"originalLines":"            return restSeconds + \" seconds\";","mutatedLines":"            return restSeconds - ' seconds';"},{"sourceFilePath":"/stryker/src/utils/Timer.js","mutatorName":"BinaryOperator","status":1,"replacement":"elapsedSeconds * 60","location":{"start":{"line":24,"column":40},"end":{"line":24,"column":59}},"range":[894,913],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()"],"originalLines":"        var elapsedMinutes = Math.floor(elapsedSeconds / 60);","mutatedLines":"        var elapsedMinutes = Math.floor(elapsedSeconds * 60);"},{"sourceFilePath":"/stryker/src/utils/Timer.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":25,"column":12},"end":{"line":25,"column":30}},"range":[929,947],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()"],"originalLines":"        if (elapsedMinutes > 1) {","mutatedLines":"        if (false) {"},{"sourceFilePath":"/stryker/src/utils/Timer.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":9,"column":55},"end":{"line":13,"column":5}},"range":[237,494],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()"],"originalLines":"    Timer.prototype.humanReadableElapsed = function () {\r\n        var elapsedMs = new Date().getTime() - this.start.getTime();\r\n        var elapsedSeconds = Math.floor(elapsedMs / 1000);\r\n        return Timer.humanReadableElapsedMinutes(elapsedSeconds) + Timer.humanReadableElapsedSeconds(elapsedSeconds);\r\n    };","mutatedLines":"    Timer.prototype.humanReadableElapsed = function () {\n};"},{"sourceFilePath":"/stryker/src/utils/Timer.js","mutatorName":"BinaryOperator","status":1,"replacement":"elapsedMinutes - ' minutes '","location":{"start":{"line":26,"column":19},"end":{"line":26,"column":47}},"range":[971,999],"testsRan":["Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()"],"originalLines":"            return elapsedMinutes + \" minutes \";","mutatedLines":"            return elapsedMinutes - ' minutes ';"},{"sourceFilePath":"/stryker/src/utils/Timer.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":25,"column":12},"end":{"line":25,"column":30}},"range":[929,947],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()"],"originalLines":"        if (elapsedMinutes > 1) {","mutatedLines":"        if (true) {"},{"sourceFilePath":"/stryker/src/utils/Timer.js","mutatorName":"BinaryOperator","status":1,"replacement":"elapsedMinutes >= 1","location":{"start":{"line":25,"column":12},"end":{"line":25,"column":30}},"range":[929,947],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()"],"originalLines":"        if (elapsedMinutes > 1) {","mutatedLines":"        if (elapsedMinutes >= 1) {"},{"sourceFilePath":"/stryker/src/utils/Timer.js","mutatorName":"BinaryOperator","status":1,"replacement":"elapsedMinutes <= 1","location":{"start":{"line":25,"column":12},"end":{"line":25,"column":30}},"range":[929,947],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()"],"originalLines":"        if (elapsedMinutes > 1) {","mutatedLines":"        if (elapsedMinutes <= 1) {"},{"sourceFilePath":"/stryker/src/utils/Timer.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":25,"column":32},"end":{"line":27,"column":9}},"range":[949,1011],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()","Timer after 2 minutes 0 seconds should show \"2 minutes 0 seconds\" when humanReadableElapsed()"],"originalLines":"        if (elapsedMinutes > 1) {\r\n            return elapsedMinutes + \" minutes \";\r\n        }","mutatedLines":"        if (elapsedMinutes > 1) {\n}"},{"sourceFilePath":"/stryker/src/utils/Timer.js","mutatorName":"BinaryOperator","status":1,"replacement":"elapsedMinutes - ' minute '","location":{"start":{"line":29,"column":19},"end":{"line":29,"column":46}},"range":[1072,1099],"testsRan":["Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()"],"originalLines":"            return elapsedMinutes + \" minute \";","mutatedLines":"            return elapsedMinutes - ' minute ';"},{"sourceFilePath":"/stryker/src/utils/Timer.js","mutatorName":"RemoveConditionals","status":1,"replacement":"false","location":{"start":{"line":28,"column":17},"end":{"line":28,"column":35}},"range":[1030,1048],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()"],"originalLines":"        else if (elapsedMinutes > 0) {","mutatedLines":"        else if (false) {"},{"sourceFilePath":"/stryker/src/utils/Timer.js","mutatorName":"RemoveConditionals","status":1,"replacement":"true","location":{"start":{"line":28,"column":17},"end":{"line":28,"column":35}},"range":[1030,1048],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()"],"originalLines":"        else if (elapsedMinutes > 0) {","mutatedLines":"        else if (true) {"},{"sourceFilePath":"/stryker/src/utils/Timer.js","mutatorName":"BinaryOperator","status":1,"replacement":"elapsedMinutes >= 0","location":{"start":{"line":28,"column":17},"end":{"line":28,"column":35}},"range":[1030,1048],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()"],"originalLines":"        else if (elapsedMinutes > 0) {","mutatedLines":"        else if (elapsedMinutes >= 0) {"},{"sourceFilePath":"/stryker/src/utils/Timer.js","mutatorName":"BinaryOperator","status":1,"replacement":"elapsedMinutes <= 0","location":{"start":{"line":28,"column":17},"end":{"line":28,"column":35}},"range":[1030,1048],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()"],"originalLines":"        else if (elapsedMinutes > 0) {","mutatedLines":"        else if (elapsedMinutes <= 0) {"},{"sourceFilePath":"/stryker/src/utils/Timer.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":28,"column":37},"end":{"line":30,"column":9}},"range":[1050,1111],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()","Timer after 1 minute 59 seconds should show \"1 minute 59 seconds\" when humanReadableElapsed()"],"originalLines":"        else if (elapsedMinutes > 0) {\r\n            return elapsedMinutes + \" minute \";\r\n        }","mutatedLines":"        else if (elapsedMinutes > 0) {\n}"},{"sourceFilePath":"/stryker/src/utils/Timer.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":31,"column":13},"end":{"line":33,"column":9}},"range":[1126,1162],"testsRan":["Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()"],"originalLines":"        else {\r\n            return '';\r\n        }","mutatedLines":"        else {\n}"},{"sourceFilePath":"/stryker/src/utils/Timer.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":14,"column":66},"end":{"line":22,"column":5}},"range":[563,782],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()"],"originalLines":"    Timer.humanReadableElapsedSeconds = function (elapsedSeconds) {\r\n        var restSeconds = elapsedSeconds % 60;\r\n        if (restSeconds === 1) {\r\n            return restSeconds + \" second\";\r\n        }\r\n        else {\r\n            return restSeconds + \" seconds\";\r\n        }\r\n    };","mutatedLines":"    Timer.humanReadableElapsedSeconds = function (elapsedSeconds) {\n};"},{"sourceFilePath":"/stryker/src/utils/Timer.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":23,"column":66},"end":{"line":34,"column":5}},"range":[851,1169],"testsRan":["CoverageInstrumenter with coverageAnalysis \"perTest\" when hooksForTestRun() should return the perTest hooks","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve an intrumenter stream for mutated files","CoverageInstrumenter with coverageAnalysis \"perTest\" when instrumenterStreamForFile() should retrieve a PassThrough stream for non-mutated files","CoverageInstrumenter with coverageAnalysis \"off\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"off\" when instrumenterStreamForFile() should retrieve a PassThrough stream for mutated files","CoverageInstrumenter with coverageAnalysis \"off\" retrieveStatementMapsPerFile() with 2 streams should retrieve 0 statement maps","CoverageInstrumenter with coverageAnalysis \"all\" when hooksForTestRun() should return the empty string","CoverageInstrumenter with coverageAnalysis \"all\" when instrumenterStreamForFile() should retrieve a CoverageInstrumenterStream stream for mutated files","CoverageInstrumenter with coverageAnalysis \"all\" retrieveStatementMapsPerFile() with 2 streams should retrieve 2 statement maps","CoverageInstrumenterStream should extend Duplex","CoverageInstrumenterStream when piped when input is a valid javascript file should instrument the input","CoverageInstrumenterStream when piped when input is a valid javascript file should contain the statement map","CoverageInstrumenterStream when piped when input is invalid javascript should just pass through the input","CoverageInstrumenterStream when piped when input is invalid javascript should log the error","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver when supplying an InputFileDescriptor without `pattern` property should result in an error","InputFileResolver without mutate property, but with mutated: true in files should result in the expected input files","InputFileResolver without mutate property, but with mutated: true in files should log that one file is about to be mutated","InputFileResolver without mutate property and without mutated: true in files should warn about dry-run","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should send `dispose` to worker process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process responses to dispose and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred and child process is unresponsive and to init should result in a `timeout` after the restart","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without code coverage info should add both tests to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults without the tests having covered the mutants should not have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() with 2 mutants and 2 testResults with tests having covered the mutants should have added the run results to the mutants","MutantTestMatcher with coverageAnalysis: \"perTest\" matchWithMutants() should not result in regression should match up mutant for issue #151 (https://github.com/stryker-mutator/stryker/issues/151)","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","BinaryOperatorMutator should mutate a valid Node","BinaryOperatorMutator should not mutate an invalid Node","BlockStatementMutator should mutate when supplied a block statement","BlockStatementMutator should not mutate an empty expression","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","RemoveConditionalsMutator should generate multiple mutants when given a ternary-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should report on the survived mutant","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis is \"all\" onAllMutantsTested() should make a correct calculation","ClearTextReporter when coverageAnalysis: \"perTest\" onAllMutantsTested() should log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should not log individual ran tests","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should indicate that mutation score based on covered code is not available","ClearTextReporter when coverageAnalysis: \"off\" onAllMutantsTested() should report the average amount of tests ran","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should log about the default baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly should clean the baseFolder","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onSourceFileRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllSourceFilesRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onMutantTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onAllMutantsTested event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile results in a rejection should reject `wrapUp`","EventRecorderReporter when constructed with empty options and cleanFolder resolves correctly onConfigRead event when writeFile is successful should writeFile","EventRecorderReporter when constructed with empty options and cleanFolder results in a rejection and `wrapUp()` is called should reject","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","SandboxCoordinator on initialRun should create a sandbox with correct arguments","SandboxCoordinator on initialRun should initialize the sandbox","SandboxCoordinator on initialRun should have ran with 5 minute timeout","SandboxCoordinator on initialRun should have disposed the sandbox","SandboxCoordinator on initialRun should resolve in expected result","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have created 2 sandboxes","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the first sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have ran 2 mutants on the second sandbox","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onMutantTested on all mutants","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have reported onAllMutantsTested","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should eventually resolve the correct mutant results","SandboxCoordinator on runMutants() with 2 cpus and 5 mutants should have disposed all sandboxes","Sandbox when constructed with a CoverageInstrumenter when initialize() should have instrumented the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter should have created a workingFolder","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have copied the input files","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() should have created the isolated test runner inc framework hook","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when run should run the testRunner","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should save the mutant to disk","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should filter the scoped tests","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should write the filter code fragment to hooks file","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have ran testRunner with correct timeout","Sandbox when constructed with a testFramework but without a CoverageInstrumenter when initialized() when runMutant() when mutant has scopedTestIds should have resetted the source file","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized should have created the isolated test runner","Sandbox when constructed without a testFramework or CoverageInstrumenter and initialized when runMutant() should not filter any tests","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should exit the process","Stryker when constructed with coverageAnalysis \"perTest\" without a testFramework should log a fatal error","Stryker when constructed should use the config writer to override config","Stryker when constructed should freeze the config","Stryker when constructed should load plugins","Stryker when constructed should determine the testFramework","Stryker runMutationTest() when input file globbing results in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initialRun() resulted in a rejection should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should create the testRunnerOrchestrator","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should have logged the errors","Stryker runMutationTest() with correct input file globbing when initial test run completes but contains an error and failed tests should result in a rejection","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests should determine the testFramework","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should log to have quite early","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests but the mutator does not create any mutants should not have ran mutations","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants should not directly resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should have logged the amount of tests ran","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in void should clean the stryker temp folder","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should let the reporters wrapUp any async tasks","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise should not yet have resolved the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should resolve the stryker promise","Stryker runMutationTest() with correct input file globbing when initial test run completes without errors or failed tests and the mutator creates mutants and running of mutators was successfull while reporter.wrapUp() results in a promise and the reporter has wrapped up should clean the stryker temp folder","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options contains a testFramework \"awesomeFramework\" and coverageAnalysis is explicitly \"off\" should log on debug that coverageAnalysis was \"off\"","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is not \"off\" should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not log a warning for the missing setting","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should not retrieve a testFramework","TestFrameworkOrchestrator when options does not contain a testFramework and coverageAnalysis is `off` should log on debug that coverageAnalysis was \"off\"","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should throw an error if no code is provided when parsing","Timer after 59 seconds should show \"59 seconds\" when humanReadableElapsed()"],"originalLines":"    Timer.humanReadableElapsedMinutes = function (elapsedSeconds) {\r\n        var elapsedMinutes = Math.floor(elapsedSeconds / 60);\r\n        if (elapsedMinutes > 1) {\r\n            return elapsedMinutes + \" minutes \";\r\n        }\r\n        else if (elapsedMinutes > 0) {\r\n            return elapsedMinutes + \" minute \";\r\n        }\r\n        else {\r\n            return '';\r\n        }\r\n    };","mutatedLines":"    Timer.humanReadableElapsedMinutes = function (elapsedSeconds) {\n};"}]