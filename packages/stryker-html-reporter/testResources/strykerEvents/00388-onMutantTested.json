{"sourceFilePath":"c:\\z\\github\\stryker-mutator\\stryker\\src\\Stryker.js","mutatorName":"BlockStatement","status":1,"replacement":"{\n}","location":{"start":{"line":17,"column":27},"end":{"line":136,"column":1}},"range":[853,7037],"testsRan":[" Uncaught error outside test suite","InputFileResolver with mutant file expressions which result in files which are included in result of all globbing files and resolve is called should result in the expected input files","InputFileResolver with file expressions that resolve in different order should retain original glob order","InputFileResolver with mutant file expressions which result in files which are not included in result of all globbing files and resolve is called should reject the result","InputFileResolver when a globbing expression does not result in a result and resolve is called should log a warning","InputFileResolver when a globbing expression results in a reject should reject the promise","IsolatedTestRunnerAdapter when constructed should spawn a child process","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout should send run-message to worker","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should resolve the promise in a Timeout","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a timeout occurred should kill the child process and start a new one","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms should pass along the result","IsolatedTestRunnerAdapter when constructed and \"run\" is called with 2000ms timeout and a result message occurred after 1900 ms when we run a second time, wait 500ms and then receive the second result should not have resolved in a timeout","JasmineTestSelector should register it under \"jasmine\" in the TestSelectorFactory","JasmineTestSelector when constructed when select() is called with an array should give the correct file content","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without code coverage info should add both tests to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults without the tests having covered the mutants should not have added the run results to the mutants","MutantRunResultMatcher matchWithMutants() with 2 mutants and 2 runResults with tests having covered the mutants should have added the run results to the mutants","Mutant with single line code should set the filename","Mutant with single line code should set the mutator","Mutant with multi-line substitude should generate the correct mutated code","Mutant with multi-line substitude should set the correct originalLines","Mutant with multi-line substitude should set the correct mutatedLines","MutatorOrchestrator should throw an error if no source files are provided","MutatorOrchestrator should return an empty array if nothing could be mutated","MutatorOrchestrator should not stop executing when a file does not exist","MutatorOrchestrator with single input file with a one possible mutation should return an array with a single mutant","MutatorOrchestrator with single input file with a one possible mutation should be able to mutate code","MutatorOrchestrator with single input file with a one possible mutation should set the mutated line number","MutatorOrchestrator with single input file with a one possible mutation should report onSourceFileRead","MutatorOrchestrator with single input file with a one possible mutation should report onAllSourceFilesRead","MutatorOrchestrator should be able to handle a Mutator that returns the same nodeID","MutatorOrchestrator should be able to handle a Mutator that returns a different nodeID","OperatorMutator should mutate a valid Node","OperatorMutator should not mutate an invalid Node","RemoveConditionalsMutator should not generate an infinite loop when given a do-while loop","RemoveConditionalsMutator should not generate an infinite loop when given a while loop","RemoveConditionalsMutator should not generate an infinite loop when given a for loop","RemoveConditionalsMutator should generate a single mutant when given a do-while loop","RemoveConditionalsMutator should generate a single mutant when given a while loop","RemoveConditionalsMutator should generate a single mutant when given a for loop","RemoveConditionalsMutator should generate multiple mutants when given an if-statement","PluginLoader without wildcards load() without errors should have imported the given modules","PluginLoader without wildcards load() when module could not be found or loaded should have logged warnings","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should read from a `node_modules` folder","PluginLoader with wildcard rolving to \"stryker-cli\", \"stryker-jasmine\" and \"stryker-karma\" load() should load \"stryker-jasmine\" and \"stryker-karma\"","BroadcastReporter should forward all events","BroadcastReporter when \"wrapUp\" returns promises should forward a combined promise","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should not result in a rejection","BroadcastReporter when \"wrapUp\" returns promises and one of the promises results in a rejection should log the error","BroadcastReporter with one faulty reporter should still broadcast to other reporters","BroadcastReporter with one faulty reporter should log each error","ClearTextReporter onAllMutantsTested() should report on the survived mutant","ClearTextReporter onAllMutantsTested() should make a correct calculation","ProgressReporter onMutantTested() when status is KILLED should log \".\"","ProgressReporter onMutantTested() when status is TIMEDOUT should log \"T\"","ProgressReporter onMutantTested() when status is SURVIVED should log \"S\"","Stryker constructor \"before each\" hook for \"should use the config writer to override config\"","Stryker runMutationTest() when input file globbing results in a rejection \"before each\" hook for \"should result in a rejection\"","Stryker runMutationTest() with correct input file globbing \"before each\" hook for \"should result in a rejection\"","TestRunnerOrchestrator without test selector initialRun() should run all tests without selecting specific ones and report one runResult","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should not select test files","TestRunnerOrchestrator without test selector runMutations() with 2 mutants should report 2 results","TestRunnerOrchestrator with test selector initialRun() should have created an isolated test runner","TestRunnerOrchestrator with test selector initialRun() .then() should have selected 3 tests in total","TestRunnerOrchestrator with test selector initialRun() .then() should have reported the correct results","TestRunnerOrchestrator with test selector initialRun() .then() should have disposed the test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 4 mutants should have created 2 test runners","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 4 mutants should have ran mutant 1 and 3 on the first test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 4 mutants should have ran mutant 2 on the second test runner","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 4 mutants should have reported onMutantTested on all mutants","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 4 mutants should have reported onAllMutantsTested","TestRunnerOrchestrator with test selector runMutations() with 2 cpus and 4 mutants should eventually resolve the correct mutant results","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is not defined should use the value of \"awesomeFramework\"","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly null should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should not retrieve a testSelector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is explicitly \"null\" should log on debug that testSelector was null","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options contains a testFramework \"awesomeFramework\" and testSelector is \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is not set should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not log a warning for the missing setting","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should not retrieve a testSelector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is `null` should log on debug that testSelector was null","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should use the value of \"overrideTestSelector\"","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"overrideTestSelector\" should retrieve the test selector","TestSelectorOrchestrator when options does not contain a testFramework and testSelector is set to \"thisTestSelectorDoesNotExist\" should log a warning and retrieve `null`","TestSelectorOrchestrator when options does not contain a testFramework testFramework is set to \"testFrameworkWithoutSelector\" should log a warning and retrieve `null`","parserUtils collectFrozenNodes when provided a try catch block","parserUtils parse should return an empty object if an empty string is parsed","parserUtils parse should throw an error if no code is provided when parsing"],"originalLines":"var Stryker = (function () {\r\n    /**\r\n     * The Stryker mutation tester.\r\n     * @constructor\r\n     * @param {String[]} mutateFilePatterns - A comma seperated list of globbing expression used for selecting the files that should be mutated\r\n     * @param {String[]} allFilePatterns - A comma seperated list of globbing expression used for selecting all files needed to run the tests. These include library files, test files and files to mutate, but should NOT include test framework files (for example jasmine)\r\n     * @param {Object} [options] - Optional options.\r\n     */\r\n    function Stryker(options) {\r\n        var configReader = new ConfigReader_1.default(options);\r\n        this.config = configReader.readConfig();\r\n        this.setGlobalLogLevel(); // loglevel could be changed\r\n        this.loadPlugins();\r\n        this.applyConfigWriters();\r\n        this.setGlobalLogLevel(); // loglevel could be changed\r\n        this.freezeConfig();\r\n    }\r\n    /**\r\n     * Runs mutation testing. This may take a while.\r\n     * @function\r\n     */\r\n    Stryker.prototype.runMutationTest = function () {\r\n        var _this = this;\r\n        var reporter = new ReporterOrchestrator_1.default(this.config).createBroadcastReporter();\r\n        var testSelector = new TestSelectorOrchestrator_1.default(this.config).determineTestSelector();\r\n        return new InputFileResolver_1.default(this.config.mutate, this.config.files).resolve()\r\n            .then(function (inputFiles) {\r\n            var testRunnerOrchestrator = new TestRunnerOrchestrator_1.default(_this.config, inputFiles, testSelector, reporter);\r\n            return testRunnerOrchestrator.initialRun().then(function (runResults) { return ({ runResults: runResults, inputFiles: inputFiles, testRunnerOrchestrator: testRunnerOrchestrator }); });\r\n        })\r\n            .then(function (tuple) {\r\n            var runResults = tuple.runResults;\r\n            var inputFiles = tuple.inputFiles;\r\n            var testRunnerOrchestrator = tuple.testRunnerOrchestrator;\r\n            var unsuccessfulTests = _this.filterOutUnsuccesfulResults(runResults);\r\n            if (unsuccessfulTests.length === 0) {\r\n                _this.logInitialTestRunSucceeded(runResults);\r\n                var mutatorOrchestrator = new MutatorOrchestrator_1.default(reporter);\r\n                var mutants = mutatorOrchestrator.generateMutants(inputFiles\r\n                    .filter(function (inputFile) { return inputFile.shouldMutate; })\r\n                    .map(function (file) { return file.path; }));\r\n                log.info(mutants.length + \" Mutant(s) generated\");\r\n                var mutantRunResultMatcher = new MutantRunResultMatcher_1.default(mutants, runResults);\r\n                mutantRunResultMatcher.matchWithMutants();\r\n                return testRunnerOrchestrator.runMutations(mutants);\r\n            }\r\n            else {\r\n                _this.logFailedTests(unsuccessfulTests);\r\n                throw new Error('There were failed tests in the initial test run');\r\n            }\r\n        }).then(function (mutantResults) {\r\n            var maybePromise = reporter.wrapUp();\r\n            if (objectUtils_1.isPromise(maybePromise)) {\r\n                return maybePromise.then(function () { return mutantResults; });\r\n            }\r\n            else {\r\n                return mutantResults;\r\n            }\r\n        });\r\n    };\r\n    Stryker.prototype.filterOutUnsuccesfulResults = function (runResults) {\r\n        return runResults.filter(function (runResult) { return !(!runResult.failed && runResult.result === test_runner_1.TestResult.Complete); });\r\n    };\r\n    Stryker.prototype.loadPlugins = function () {\r\n        if (this.config.plugins) {\r\n            new PluginLoader_1.default(this.config.plugins).load();\r\n        }\r\n    };\r\n    Stryker.prototype.applyConfigWriters = function () {\r\n        var _this = this;\r\n        config_1.ConfigWriterFactory.instance().knownNames().forEach(function (configWriterName) {\r\n            config_1.ConfigWriterFactory.instance().create(configWriterName, undefined).write(_this.config);\r\n        });\r\n    };\r\n    Stryker.prototype.freezeConfig = function () {\r\n        objectUtils_1.freezeRecursively(this.config);\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(\"Using config: \" + JSON.stringify(this.config));\r\n        }\r\n    };\r\n    Stryker.prototype.logInitialTestRunSucceeded = function (runResults) {\r\n        var totalAmountOfTests = 0;\r\n        runResults.forEach(function (result) {\r\n            if (result.succeeded) {\r\n                totalAmountOfTests += result.succeeded;\r\n            }\r\n        });\r\n        log.info('Initial test run succeeded. Ran %s tests.', totalAmountOfTests);\r\n    };\r\n    Stryker.prototype.setGlobalLogLevel = function () {\r\n        log4js.setGlobalLogLevel(this.config.logLevel);\r\n    };\r\n    /**\r\n     * Looks through a list of RunResults to see if all tests have passed.\r\n     * @function\r\n     * @param {RunResult[]} runResults - The list of RunResults.\r\n     * @returns {Boolean} True if all tests passed.\r\n     */\r\n    Stryker.prototype.logFailedTests = function (unsuccessfulTests) {\r\n        var failedSpecNames = _.uniq(_.flatten(unsuccessfulTests\r\n            .filter(function (runResult) { return runResult.result === test_runner_1.TestResult.Complete; })\r\n            .map(function (runResult) { return runResult.testNames; })))\r\n            .sort();\r\n        if (failedSpecNames.length > 0) {\r\n            var message_1 = 'One or more tests failed in the inial test run:';\r\n            failedSpecNames.forEach(function (filename) { return message_1 += \"\\n\\t\" + filename; });\r\n            log.error(message_1);\r\n        }\r\n        var errors = _.flatten(unsuccessfulTests\r\n            .filter(function (runResult) { return runResult.result === test_runner_1.TestResult.Error; })\r\n            .map(function (runResult) { return runResult.errorMessages; }))\r\n            .sort();\r\n        if (errors.length > 0) {\r\n            var message_2 = 'One or more tests errored in the initial test run:';\r\n            errors.forEach(function (error) { return message_2 += \"\\n\\t\" + error; });\r\n            log.error(message_2);\r\n        }\r\n    };\r\n    return Stryker;\r\n}());","mutatedLines":"var Stryker = (function () {\n}());"}