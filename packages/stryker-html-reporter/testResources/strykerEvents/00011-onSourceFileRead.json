{"path":"c:\\z\\github\\stryker-mutator\\stryker\\src\\MutantRunResultMatcher.js","content":"\"use strict\";\r\nvar MutantRunResultMatcher = (function () {\r\n    function MutantRunResultMatcher(mutants, runResultsByTestId) {\r\n        this.mutants = mutants;\r\n        this.runResultsByTestId = runResultsByTestId;\r\n    }\r\n    MutantRunResultMatcher.prototype.matchWithMutants = function () {\r\n        var _this = this;\r\n        this.mutants.forEach(function (mutant) {\r\n            var smallestStatement;\r\n            _this.runResultsByTestId.forEach(function (testResult, id) {\r\n                var covered = false;\r\n                if (testResult.coverage) {\r\n                    var coveredFile = testResult.coverage[mutant.filename];\r\n                    if (coveredFile) {\r\n                        // Statement map should change between test run results.\r\n                        // We should be able to safely reuse the smallest statement found in first run.\r\n                        if (!smallestStatement) {\r\n                            smallestStatement = _this.findSmallestCoveringStatement(mutant, coveredFile);\r\n                        }\r\n                        covered = coveredFile.s[smallestStatement] > 0;\r\n                    }\r\n                }\r\n                else {\r\n                    // If there is no coverage result we have to assume the source code is covered\r\n                    covered = true;\r\n                }\r\n                if (covered) {\r\n                    mutant.addRunResultForTest(id, testResult);\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Finds the smallest statement that covers a mutant.\r\n     * @param mutant The mutant.\r\n     * @param coveredFile The CoverageResult.\r\n     * @returns The index of the coveredFile which contains the smallest statement surrounding the mutant.\r\n     */\r\n    MutantRunResultMatcher.prototype.findSmallestCoveringStatement = function (mutant, coveredFile) {\r\n        var _this = this;\r\n        var smallestStatement;\r\n        Object.keys(coveredFile.statementMap).forEach(function (statementId) {\r\n            var location = coveredFile.statementMap[statementId];\r\n            if (_this.statementCoversMutant(mutant, location) && _this.isNewSmallestStatement(coveredFile.statementMap[smallestStatement], location)) {\r\n                smallestStatement = statementId;\r\n            }\r\n        });\r\n        return smallestStatement;\r\n    };\r\n    /**\r\n     * Indicates whether a statement is the smallest statement of the two statements provided.\r\n     * @param originalLocation The area which may cover a bigger area than the newLocation.\r\n     * @param newLocation The area which may cover a smaller area than the originalLocation.\r\n     * @returns true if the newLocation covers a smaller area than the originalLocation, making it the smaller statement.\r\n     */\r\n    MutantRunResultMatcher.prototype.isNewSmallestStatement = function (originalLocation, newLocation) {\r\n        var statementIsSmallestStatement = false;\r\n        if (!originalLocation) {\r\n            statementIsSmallestStatement = true;\r\n        }\r\n        else {\r\n            var lineDifference = (originalLocation.end.line - originalLocation.start.line) - (newLocation.end.line - newLocation.start.line);\r\n            var coversLessLines = lineDifference > 0;\r\n            var coversLessColumns = lineDifference === 0 && (newLocation.start.column - originalLocation.start.column) + (originalLocation.end.column - newLocation.end.column) > 0;\r\n            if (coversLessLines || coversLessColumns) {\r\n                statementIsSmallestStatement = true;\r\n            }\r\n        }\r\n        return statementIsSmallestStatement;\r\n    };\r\n    /**\r\n     * Indicates whether a statement covers a mutant.\r\n     * @param mutant The mutant.\r\n     * @param location The location which may cover the mutant.\r\n     * @returns true if the statment covers the mutant.\r\n     */\r\n    MutantRunResultMatcher.prototype.statementCoversMutant = function (mutant, location) {\r\n        var mutantIsAfterStart = mutant.location.end.line > location.start.line ||\r\n            (mutant.location.end.line === location.start.line && mutant.location.end.column >= location.start.column);\r\n        var mutantIsBeforeEnd = mutant.location.start.line < location.end.line ||\r\n            (mutant.location.start.line === location.end.line && mutant.location.start.column <= location.end.column);\r\n        return mutantIsAfterStart && mutantIsBeforeEnd;\r\n    };\r\n    return MutantRunResultMatcher;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = MutantRunResultMatcher;\r\n//# sourceMappingURL=MutantRunResultMatcher.js.map"}